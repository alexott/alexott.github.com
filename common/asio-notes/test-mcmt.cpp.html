<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.27 in css mode. -->
<html>
  <head>
    <title>test-mcmt.cpp</title>
    <style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #cccccc;
      }
      .comment {
        /* font-lock-comment-face */
        color: #666666;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #666666;
      }
      .constant {
        /* font-lock-constant-face */
        color: #00008b;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .negation-char {
      }
      .preprocessor {
        /* font-lock-preprocessor-face */
        color: #006400;
      }
      .string {
        /* font-lock-string-face */
        color: #008b00;
      }
      .type {
        /* font-lock-type-face */
        color: #0000ff;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #8b0000;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="comment-delimiter">/**</span><span class="comment">
 * </span><span class="comment"><span class="keyword">@file</span></span><span class="comment">   test-mcmt.cpp
 * </span><span class="comment"><span class="keyword">@author</span></span><span class="comment"> Alex Ott &lt;<a href="mailto:alexott&#64;gmail.com">alexott&#64;gmail.com</a>&gt;
 * 
 * </span><span class="comment"><span class="keyword">@brief</span></span><span class="comment">  Impelements many threads - many connections strategy of connections handling.
 * All input/output is async. Server use several io_service objects to scale to work on
 * multiprocessor/multicore systems
 * 
 * 
 */</span>

<span class="preprocessor">#include</span> <span class="string">"common.h"</span>
<span class="preprocessor">#include</span> <span class="string">&lt;deque&gt;</span>

<span class="keyword">typedef</span> <span class="constant">std</span>::<span class="type">deque</span>&lt;io_service_ptr&gt; <span class="type">ios_deque</span>;

<span class="comment-delimiter">/**</span><span class="comment">
 * Connection class, implementing async input/output
 * 
 */</span>
<span class="keyword">class</span> <span class="type">connection</span> : <span class="keyword">public</span> <span class="constant">boost</span>::<span class="type">enable_shared_from_this</span>&lt;<span class="type">connection</span>&gt; {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> <span class="constant">boost</span>::<span class="type">shared_ptr</span>&lt;<span class="type">connection</span>&gt; <span class="type">pointer</span>;

    <span class="comment-delimiter">/** </span><span class="comment">
     * Create new connection 
     * 
     * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">io_service</span></span><span class="comment"> io_service in which this connection will work
     * 
     * </span><span class="comment"><span class="keyword">@return</span></span><span class="comment"> pointer to newly allocated object
     */</span>
    <span class="keyword">static</span> <span class="type">pointer</span> <span class="function-name">create</span>(<span class="constant">ba</span>::<span class="type">io_service</span>&amp; <span class="variable-name">io_service</span>) {
        <span class="keyword">return</span> pointer(<span class="keyword">new</span> <span class="type">connection</span>(io_service));
    }

    <span class="comment-delimiter">/** </span><span class="comment">
     * Return socket, associated with this connection. This socket used in accept operation
     * 
     * 
     * </span><span class="comment"><span class="keyword">@return</span></span><span class="comment"> reference to socket
     */</span>
    <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="type">socket</span>&amp; <span class="function-name">socket</span>() {
        <span class="keyword">return</span> socket_;
    }

    <span class="comment-delimiter">/** </span><span class="comment">
     * Start input/output chain with reading of headers from browser
     * 
     */</span>
    <span class="type">void</span> <span class="function-name">start</span>() {
        <span class="comment-delimiter">// </span><span class="comment">start reading of headers from browser
</span>        <span class="constant">boost</span>::<span class="constant">asio</span>::async_read_until(socket_, buf, <span class="constant">boost</span>::regex(<span class="string">"\r\n\r\n"</span>),
            <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_read, shared_from_this(),
                        <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                        <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
    }

<span class="keyword">private</span>:
    <span class="comment-delimiter">/** </span><span class="comment">
     * Initialize connection
     * 
     * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">io_service</span></span><span class="comment"> 
     * 
     * </span><span class="comment"><span class="keyword">@return</span></span><span class="comment"> 
     */</span>
    <span class="function-name">connection</span>(<span class="constant">ba</span>::<span class="type">io_service</span>&amp; <span class="variable-name">io_service</span>) : socket_(io_service) {
    }

    <span class="comment-delimiter">/** </span><span class="comment">
     * Called when data written to browser
     * 
     * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">error</span></span><span class="comment"> object, containing information about errors
     * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">bytes_transferred</span></span><span class="comment"> number of transferred bytes
     */</span>
    <span class="type">void</span> <span class="function-name">handle_write</span>(<span class="keyword">const</span> <span class="constant">boost</span>::<span class="constant">system</span>::<span class="type">error_code</span>&amp; <span class="variable-name">error</span>,
                      <span class="type">size_t</span> <span class="variable-name">bytes_transferred</span>) {
    }

    <span class="comment-delimiter">/** </span><span class="comment">
     * Called when data readed from browser
     * 
     * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">error</span></span><span class="comment"> object, containing information about errors
     * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">bytes_transferred</span></span><span class="comment"> number of transferred bytes
     */</span>
    <span class="type">void</span> <span class="function-name">handle_read</span>(<span class="keyword">const</span> <span class="constant">boost</span>::<span class="constant">system</span>::<span class="type">error_code</span>&amp; <span class="variable-name">error</span>,
                     <span class="type">size_t</span> <span class="variable-name">bytes_transferred</span>) {
        <span class="constant">ba</span>::async_write(socket_, <span class="constant">ba</span>::buffer(message_),
                        <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_write, shared_from_this(),
                                    <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                                    <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
    }
    
    <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="type">socket</span> <span class="variable-name">socket_</span>; <span class="comment-delimiter">/**</span><span class="comment">&lt; socket, associated with browser */</span>
    <span class="constant">boost</span>::<span class="constant">asio</span>::<span class="type">streambuf</span> <span class="variable-name">buf</span>;  <span class="comment-delimiter">/**</span><span class="comment">&lt; buffer for request data */</span>
    <span class="keyword">static</span> <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">message_</span>; <span class="comment-delimiter">/**</span><span class="comment">&lt; data, that we'll return to browser */</span>
};

<span class="constant">std</span>::<span class="type">string</span> <span class="constant">connection</span>::<span class="variable-name">message_</span>=<span class="string">"HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n"</span>
    <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;"</span>
    <span class="string">"&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;p&gt;This is a test!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>;


<span class="comment-delimiter">/**</span><span class="comment">
 * Server class
 * 
 */</span>
<span class="keyword">class</span> <span class="type">server</span> {
<span class="keyword">public</span>:
<span class="comment-delimiter">/** </span><span class="comment">
 * Initialize all needed data
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">io_service</span></span><span class="comment"> reference to io_service
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">port</span></span><span class="comment"> port to listen on, by default - 10001
 */</span>
    <span class="function-name">server</span>(<span class="keyword">const</span> <span class="type">ios_deque</span>&amp; <span class="variable-name">io_services</span>, <span class="type">int</span> <span class="variable-name">port</span>=10001)
        : io_services_(io_services),
          acceptor_(*io_services.front(),
                    <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::endpoint(<span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::v4(), port)) {
        start_accept();
    }

<span class="keyword">private</span>:
    <span class="comment-delimiter">/** </span><span class="comment">
     * start connection accepting in async mode
     * 
     */</span>
    <span class="type">void</span> <span class="function-name">start_accept</span>() {
        <span class="comment-delimiter">// </span><span class="comment">select next io_service object
</span>        io_services_.push_back(io_services_.front());
        io_services_.pop_front();
        <span class="comment-delimiter">// </span><span class="comment">create new connection
</span>        <span class="constant">connection</span>::<span class="type">pointer</span> <span class="variable-name">new_connection</span> = <span class="constant">connection</span>::create(*io_services_.front());
        <span class="comment-delimiter">// </span><span class="comment">start acceptor in async mode
</span>        acceptor_.async_accept(new_connection-&gt;socket(),
                               <span class="constant">boost</span>::bind(&amp;<span class="constant">server</span>::handle_accept, <span class="keyword">this</span>, new_connection,
                                           <span class="constant">ba</span>::<span class="constant">placeholders</span>::error));
    }

    <span class="comment-delimiter">/** </span><span class="comment">
     * Run when new connection is accepted
     * 
     * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">new_connection</span></span><span class="comment"> accepted connection
     * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">error</span></span><span class="comment"> reference to error object
     */</span>
    <span class="type">void</span> <span class="function-name">handle_accept</span>(<span class="constant">connection</span>::<span class="type">pointer</span> <span class="variable-name">new_connection</span>,
                       <span class="keyword">const</span> <span class="constant">boost</span>::<span class="constant">system</span>::<span class="type">error_code</span>&amp; <span class="variable-name">error</span>)  {
        <span class="keyword">if</span> (<span class="negation-char">!</span>error) {
            new_connection-&gt;start();
            start_accept();
        }
    }

    <span class="type">ios_deque</span> <span class="variable-name">io_services_</span>;          <span class="comment-delimiter">/**</span><span class="comment">&lt; deque of pointers to io_services */</span>
    <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="type">acceptor</span> <span class="variable-name">acceptor_</span>; <span class="comment-delimiter">/**</span><span class="comment">&lt; object, that accepts new connections */</span>
};

<span class="comment-delimiter">/** </span><span class="comment">
 * Main routine
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">argc</span></span><span class="comment"> number of arguments
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">argv</span></span><span class="comment"> pointers to arguments
 * 
 * </span><span class="comment"><span class="keyword">@return</span></span><span class="comment"> error code
 */</span>
<span class="type">int</span> <span class="function-name">main</span>(<span class="type">int</span> <span class="variable-name">argc</span>, <span class="type">char</span>** <span class="variable-name">argv</span>) {
    <span class="keyword">try</span> {
        <span class="type">int</span> <span class="variable-name">thread_num</span>=10;
        <span class="comment-delimiter">// </span><span class="comment">read number of threads with io_services from command line, if provided
</span>        <span class="keyword">if</span>(argc &gt; 1)
            thread_num=<span class="constant">boost</span>::<span class="type">lexical_cast</span>&lt;<span class="type">int</span>&gt;(argv[1]);
        <span class="type">ios_deque</span> <span class="variable-name">io_services</span>;
        <span class="constant">std</span>::<span class="type">deque</span>&lt;<span class="constant">ba</span>::<span class="constant">io_service</span>::work&gt; <span class="variable-name">io_service_work</span>;
        
        <span class="constant">boost</span>::<span class="type">thread_group</span> <span class="variable-name">thr_grp</span>;
        <span class="comment-delimiter">// </span><span class="comment">create threads for each io_service
</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable-name">i</span> = 0; i &lt; thread_num; ++i) {
            <span class="type">io_service_ptr</span> <span class="variable-name">ios</span>(<span class="keyword">new</span> <span class="constant">ba</span>::<span class="type">io_service</span>);
            io_services.push_back(ios);
            io_service_work.push_back(<span class="constant">ba</span>::<span class="constant">io_service</span>::work(*ios));
            <span class="comment-delimiter">// </span><span class="comment">run io_service in their own thread
</span>            thr_grp.create_thread(<span class="constant">boost</span>::bind(&amp;<span class="constant">ba</span>::<span class="constant">io_service</span>::run, ios));
        }
        <span class="comment-delimiter">// </span><span class="comment">create server
</span>        <span class="type">server</span> <span class="variable-name">server</span>(io_services);
        <span class="comment-delimiter">// </span><span class="comment">wait until all thread will finished
</span>        thr_grp.join_all();
    } <span class="keyword">catch</span> (<span class="constant">std</span>::exception&amp; e) {
        <span class="constant">std</span>::cerr &lt;&lt; e.what() &lt;&lt; <span class="constant">std</span>::endl;
    }


    <span class="keyword">return</span> 0;
}

     
</pre>
  </body>
</html>
