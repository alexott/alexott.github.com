<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.34 in css mode. -->
<html>
  <head>
    <title>proxy-conn.cpp</title>
    <style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ebebeb;
      }
      .comment {
        /* font-lock-comment-face */
        color: #666666;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #666666;
      }
      .constant {
        /* font-lock-constant-face */
        color: #00008b;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .negation-char {
      }
      .preprocessor {
        /* font-lock-preprocessor-face */
        color: #006400;
      }
      .string {
        /* font-lock-string-face */
        color: #008b00;
      }
      .type {
        /* font-lock-type-face */
        color: #0000ff;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #8b0000;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="comment-delimiter">/**</span><span class="comment">
 * </span><span class="comment"><span class="keyword">@file</span></span><span class="comment">   proxy-conn.cpp
 * </span><span class="comment"><span class="keyword">@author</span></span><span class="comment"> Alex Ott &lt;<a href="mailto:alexott&#64;gmail.com">alexott&#64;gmail.com</a>&gt;
 * 
 * </span><span class="comment"><span class="keyword">@brief</span></span><span class="comment">  
 * 
 * 
 */</span>

<span class="preprocessor">#include</span> <span class="string">"proxy-conn.hpp"</span>

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">io_service</span></span><span class="comment"> 
 */</span>
<span class="constant">connection</span>::<span class="function-name">connection</span>(<span class="constant">ba</span>::<span class="type">io_service</span>&amp; <span class="variable-name">io_service</span>) : io_service_(io_service),
                                                     bsocket_(io_service),
                                                     ssocket_(io_service),
                                                     resolver_(io_service),
                                                     proxy_closed(<span class="constant">false</span>),
                                                     isPersistent(<span class="constant">false</span>),
                                                     isOpened(<span class="constant">false</span>) {
}

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">start</span>() {
    fHeaders.clear();
    reqHeaders.clear();
    respHeaders.clear();
    
    async_read(bsocket_, <span class="constant">ba</span>::buffer(bbuffer), <span class="constant">ba</span>::transfer_at_least(1),
               <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_browser_read_headers,
                           shared_from_this(),
                           <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                           <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
}

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">err</span></span><span class="comment"> 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">len</span></span><span class="comment"> 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">handle_browser_read_headers</span>(<span class="keyword">const</span> <span class="constant">bs</span>::<span class="type">error_code</span>&amp; <span class="variable-name">err</span>, <span class="type">size_t</span> <span class="variable-name">len</span>) {
    <span class="keyword">if</span>(<span class="negation-char">!</span>err) {
        <span class="keyword">if</span>(fHeaders.empty())
            fHeaders=<span class="constant">std</span>::string(bbuffer.data(),len);
        <span class="keyword">else</span>
            fHeaders+=<span class="constant">std</span>::string(bbuffer.data(),len);
        <span class="keyword">if</span>(fHeaders.find(<span class="string">"\r\n\r\n"</span>) == <span class="constant">std</span>::<span class="constant">string</span>::npos) { <span class="comment-delimiter">// </span><span class="comment">going to read rest of headers
</span>            async_read(bsocket_, <span class="constant">ba</span>::buffer(bbuffer), <span class="constant">ba</span>::transfer_at_least(1),
                       <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_browser_read_headers,
                                   shared_from_this(),
                                   <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                                   <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
        } <span class="keyword">else</span> { <span class="comment-delimiter">// </span><span class="comment">analyze headers
</span>            <span class="constant">std</span>::<span class="constant">string</span>::<span class="type">size_type</span> <span class="variable-name">idx</span>=fHeaders.find(<span class="string">"\r\n"</span>);
            <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">reqString</span>=fHeaders.substr(0,idx);
            fHeaders.erase(0,idx+2);

            idx=reqString.find(<span class="string">" "</span>);
            <span class="keyword">if</span>(idx == <span class="constant">std</span>::<span class="constant">string</span>::npos) {
                <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Bad first line: "</span> &lt;&lt; reqString &lt;&lt; <span class="constant">std</span>::endl;
                <span class="keyword">return</span>;
            }
            
            fMethod=reqString.substr(0,idx);
            reqString=reqString.substr(idx+1);
            idx=reqString.find(<span class="string">" "</span>);
            <span class="keyword">if</span>(idx == <span class="constant">std</span>::<span class="constant">string</span>::npos) {
                <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Bad first line of request: "</span> &lt;&lt; reqString &lt;&lt; <span class="constant">std</span>::endl;
                <span class="keyword">return</span>;
            }
            fURL=reqString.substr(0,idx);
            fReqVersion=reqString.substr(idx+1);
            idx=fReqVersion.find(<span class="string">"/"</span>);
            <span class="keyword">if</span>(idx == <span class="constant">std</span>::<span class="constant">string</span>::npos) {
                <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Bad first line of request: "</span> &lt;&lt; reqString &lt;&lt; <span class="constant">std</span>::endl;
                <span class="keyword">return</span>;
            }
            fReqVersion=fReqVersion.substr(idx+1);
            
            <span class="comment-delimiter">// </span><span class="comment">analyze headers, etc
</span>            parseHeaders(fHeaders,reqHeaders);
            <span class="comment-delimiter">// </span><span class="comment">pass control
</span>            start_connect();
        }
    } <span class="keyword">else</span> {
        shutdown();
    }
}

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">err</span></span><span class="comment"> 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">len</span></span><span class="comment"> 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">handle_server_write</span>(<span class="keyword">const</span> <span class="constant">bs</span>::<span class="type">error_code</span>&amp; <span class="variable-name">err</span>, <span class="type">size_t</span> <span class="variable-name">len</span>) {
    <span class="keyword">if</span>(<span class="negation-char">!</span>err) {
        async_read(ssocket_, <span class="constant">ba</span>::buffer(sbuffer), <span class="constant">ba</span>::transfer_at_least(1),
                   <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_server_read_headers,
                               shared_from_this(),
                               <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                               <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
    }<span class="keyword">else</span> {
        shutdown();
    }
}

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">err</span></span><span class="comment"> 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">len</span></span><span class="comment"> 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">handle_server_read_headers</span>(<span class="keyword">const</span> <span class="constant">bs</span>::<span class="type">error_code</span>&amp; <span class="variable-name">err</span>, <span class="type">size_t</span> <span class="variable-name">len</span>) {
    <span class="keyword">if</span>(<span class="negation-char">!</span>err) {
        <span class="constant">std</span>::<span class="constant">string</span>::<span class="type">size_type</span> <span class="variable-name">idx</span>;
        <span class="keyword">if</span>(fHeaders.empty())
            fHeaders=<span class="constant">std</span>::string(sbuffer.data(),len);
        <span class="keyword">else</span>
            fHeaders+=<span class="constant">std</span>::string(sbuffer.data(),len);
        idx=fHeaders.find(<span class="string">"\r\n\r\n"</span>);
        <span class="keyword">if</span>(idx == <span class="constant">std</span>::<span class="constant">string</span>::npos) { <span class="comment-delimiter">// </span><span class="comment">going to read rest of headers
</span>            async_read(ssocket_, <span class="constant">ba</span>::buffer(sbuffer), <span class="constant">ba</span>::transfer_at_least(1),
                       <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_browser_read_headers,
                                   shared_from_this(),
                                   <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                                   <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
        } <span class="keyword">else</span> { <span class="comment-delimiter">// </span><span class="comment">analyze headers
</span>            RespReaded=len-idx-4;
            idx=fHeaders.find(<span class="string">"\r\n"</span>);
            <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">respString</span>=fHeaders.substr(0,idx);
            RespLen = -1;
            parseHeaders(fHeaders.substr(idx+2),respHeaders);
            <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">reqConnString</span>=<span class="string">""</span>,<span class="variable-name">respConnString</span>=<span class="string">""</span>;

            <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">respVersion</span>=respString.substr(respString.find(<span class="string">"HTTP/"</span>)+5,3);
            
            <span class="constant">headersMap</span>::<span class="type">iterator</span> <span class="variable-name">it</span>=respHeaders.find(<span class="string">"Content-Length"</span>);
            <span class="keyword">if</span>(it != respHeaders.end())
                RespLen=<span class="constant">boost</span>::<span class="type">lexical_cast</span>&lt;<span class="type">int</span>&gt;(it-&gt;second);
            it=respHeaders.find(<span class="string">"Connection"</span>);
            <span class="keyword">if</span>(it != respHeaders.end())
                respConnString=it-&gt;second;
            it=reqHeaders.find(<span class="string">"Connection"</span>);
            <span class="keyword">if</span>(it != reqHeaders.end())
                reqConnString=it-&gt;second;
            
            isPersistent=(
                ((fReqVersion == <span class="string">"1.1"</span> &amp;&amp; reqConnString != <span class="string">"close"</span>) ||
                 (fReqVersion == <span class="string">"1.0"</span> &amp;&amp; reqConnString == <span class="string">"keep-alive"</span>)) &amp;&amp;
                ((respVersion == <span class="string">"1.1"</span> &amp;&amp; respConnString != <span class="string">"close"</span>) ||
                 (respVersion == <span class="string">"1.0"</span> &amp;&amp; respConnString == <span class="string">"keep-alive"</span>)) &amp;&amp;
                RespLen != -1);
            <span class="comment-delimiter">// </span><span class="comment">send data
</span>            <span class="constant">ba</span>::async_write(bsocket_, <span class="constant">ba</span>::buffer(fHeaders),
                            <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_browser_write,
                                        shared_from_this(),
                                        <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                                        <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
        }
    } <span class="keyword">else</span> {
        shutdown();
    }
}


<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">err</span></span><span class="comment"> 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">len</span></span><span class="comment"> 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">handle_server_read_body</span>(<span class="keyword">const</span> <span class="constant">bs</span>::<span class="type">error_code</span>&amp; <span class="variable-name">err</span>, <span class="type">size_t</span> <span class="variable-name">len</span>) {
    <span class="keyword">if</span>(<span class="negation-char">!</span>err || err == <span class="constant">ba</span>::<span class="constant">error</span>::eof) {
        RespReaded+=len;
        <span class="keyword">if</span>(err == <span class="constant">ba</span>::<span class="constant">error</span>::eof)
            proxy_closed=<span class="constant">true</span>;
        <span class="constant">ba</span>::async_write(bsocket_, <span class="constant">ba</span>::buffer(sbuffer,len),
                        <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_browser_write,
                                    shared_from_this(),
                                    <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                                    <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
    } <span class="keyword">else</span> {
        shutdown();
    }
}

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">err</span></span><span class="comment"> 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">len</span></span><span class="comment"> 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">handle_browser_write</span>(<span class="keyword">const</span> <span class="constant">bs</span>::<span class="type">error_code</span>&amp; <span class="variable-name">err</span>, <span class="type">size_t</span> <span class="variable-name">len</span>) {
    <span class="keyword">if</span>(<span class="negation-char">!</span>err) {
        <span class="keyword">if</span>(<span class="negation-char">!</span>proxy_closed &amp;&amp; (RespLen == -1 || RespReaded &lt; RespLen))
            async_read(ssocket_, <span class="constant">ba</span>::buffer(sbuffer,len), <span class="constant">ba</span>::transfer_at_least(1),
                       <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_server_read_body,
                                   shared_from_this(),
                                   <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                                   <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));
        <span class="keyword">else</span> {
<span class="comment-delimiter">//          </span><span class="comment">shutdown();
</span>            <span class="keyword">if</span>(isPersistent &amp;&amp; <span class="negation-char">!</span>proxy_closed) {
                <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Starting read headers from browser, as connection is persistent"</span> &lt;&lt; <span class="constant">std</span>::endl;
                start();
            }
        }
    } <span class="keyword">else</span> {
        shutdown();
    }
}

<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">shutdown</span>() {
    ssocket_.close();
    bsocket_.close();
}

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">start_connect</span>() {
    <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">server</span>=<span class="string">""</span>;
    <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">port</span>=<span class="string">"80"</span>;
    <span class="constant">boost</span>::<span class="type">regex</span> <span class="variable-name">rHTTP</span>(<span class="string">"http://(.*?)(:(\\d+))?(/.*)"</span>);
    <span class="constant">boost</span>::<span class="type">smatch</span> <span class="variable-name">m</span>;
    
    <span class="keyword">if</span>(<span class="constant">boost</span>::regex_search(fURL, m, rHTTP, <span class="constant">boost</span>::match_extra)) {
        server=m[1].str();
        <span class="keyword">if</span>(m[2].str() != <span class="string">""</span>) {
            port=m[3].str();
        }
        fNewURL=m[4].str();
    }
    <span class="keyword">if</span>(server.empty()) {
        <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Can't parse URL "</span>&lt;&lt; <span class="constant">std</span>::endl;
        <span class="keyword">return</span>;
    }
    <span class="keyword">if</span>(<span class="negation-char">!</span>isOpened || server != fServer || port != fPort) {
        fServer=server;
        fPort=port;
        <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="constant">resolver</span>::<span class="type">query</span> <span class="variable-name">query</span>(server, port);
        resolver_.async_resolve(query,
                                <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_resolve, shared_from_this(),
                                            <span class="constant">boost</span>::<span class="constant">asio</span>::<span class="constant">placeholders</span>::error,
                                            <span class="constant">boost</span>::<span class="constant">asio</span>::<span class="constant">placeholders</span>::iterator));
    } <span class="keyword">else</span> {
        start_write_to_server();
    }
}

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">start_write_to_server</span>() {
    <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">Req</span>=fMethod;
    Req+=<span class="string">" "</span>;
    Req+=fNewURL;
    Req+=<span class="string">" HTTP/"</span>;
    Req+=<span class="string">"1.0"</span>;
    Req+=<span class="string">"\r\n"</span>;
    Req+=fHeaders;
    <span class="constant">ba</span>::async_write(ssocket_, <span class="constant">ba</span>::buffer(Req),
                    <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_server_write, shared_from_this(),
                                <span class="constant">ba</span>::<span class="constant">placeholders</span>::error,
                                <span class="constant">ba</span>::<span class="constant">placeholders</span>::bytes_transferred));

    fHeaders.clear();
}


<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">err</span></span><span class="comment"> 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">endpoint_iterator</span></span><span class="comment"> 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">handle_resolve</span>(<span class="keyword">const</span> <span class="constant">boost</span>::<span class="constant">system</span>::<span class="type">error_code</span>&amp; <span class="variable-name">err</span>,
                                <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="constant">resolver</span>::<span class="type">iterator</span> <span class="variable-name">endpoint_iterator</span>) {
    <span class="keyword">if</span> (<span class="negation-char">!</span>err) {
        <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="type">endpoint</span> <span class="variable-name">endpoint</span> = *endpoint_iterator;
        ssocket_.async_connect(endpoint,
                              <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_connect, shared_from_this(),
                                          <span class="constant">boost</span>::<span class="constant">asio</span>::<span class="constant">placeholders</span>::error,
                                          ++endpoint_iterator));
    }<span class="keyword">else</span> {
        shutdown();
    }
}

<span class="comment-delimiter">/** </span><span class="comment">
 * 
 * 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">err</span></span><span class="comment"> 
 * </span><span class="comment"><span class="keyword">@param</span></span><span class="comment"> </span><span class="comment"><span class="variable-name">endpoint_iterator</span></span><span class="comment"> 
 */</span>
<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">handle_connect</span>(<span class="keyword">const</span> <span class="constant">boost</span>::<span class="constant">system</span>::<span class="type">error_code</span>&amp; <span class="variable-name">err</span>,
                                <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="constant">resolver</span>::<span class="type">iterator</span> <span class="variable-name">endpoint_iterator</span>) {
    <span class="keyword">if</span> (<span class="negation-char">!</span>err) {
        isOpened=<span class="constant">true</span>;
        start_write_to_server();
    } <span class="keyword">else</span> <span class="keyword">if</span> (endpoint_iterator != <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="constant">resolver</span>::iterator()) {
        ssocket_.close();
        <span class="constant">ba</span>::<span class="constant">ip</span>::<span class="constant">tcp</span>::<span class="type">endpoint</span> <span class="variable-name">endpoint</span> = *endpoint_iterator;
        ssocket_.async_connect(endpoint,
                               <span class="constant">boost</span>::bind(&amp;<span class="constant">connection</span>::handle_connect, shared_from_this(),
                                           <span class="constant">boost</span>::<span class="constant">asio</span>::<span class="constant">placeholders</span>::error,
                                           ++endpoint_iterator));
    } <span class="keyword">else</span> {
        shutdown();
    }
}

<span class="type">void</span> <span class="constant">connection</span>::<span class="function-name">parseHeaders</span>(<span class="keyword">const</span> <span class="constant">std</span>::<span class="type">string</span>&amp; <span class="variable-name">h</span>, <span class="type">headersMap</span>&amp; <span class="variable-name">hm</span>) {
    <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">str</span>(h);
    <span class="constant">std</span>::<span class="constant">string</span>::<span class="type">size_type</span> <span class="variable-name">idx</span>;
    <span class="constant">std</span>::<span class="type">string</span> <span class="variable-name">t</span>;
    <span class="keyword">while</span>((idx=str.find(<span class="string">"\r\n"</span>)) != <span class="constant">std</span>::<span class="constant">string</span>::npos) {
        t=str.substr(0,idx);
        str.erase(0,idx+2);
        <span class="keyword">if</span>(t == <span class="string">""</span>)
            <span class="keyword">break</span>;
        idx=t.find(<span class="string">": "</span>);
        <span class="keyword">if</span>(idx == <span class="constant">std</span>::<span class="constant">string</span>::npos) {
            <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Bad header line: "</span> &lt;&lt; t &lt;&lt; <span class="constant">std</span>::endl;
            <span class="keyword">break</span>;
        }
        hm.insert(<span class="constant">std</span>::make_pair(t.substr(0,idx),t.substr(idx+2)));
    }
}
</pre>
  </body>
</html>
