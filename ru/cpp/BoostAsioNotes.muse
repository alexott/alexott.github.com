#title Что такое Boost.Asio и зачем он нужен
#keywords boost, asio, boost::asio

Проблема написания на С++ кросс-платформенного кода для работы с сетью существует
достаточно давно, и для решения этой проблемы было создано некоторое количество библиотек.
Но [[http://asio.sf.net][Boost.Asio]] можно назвать лучшей реализацией среди существующих.  На базе Boost.Asio уже
построено несколько библиотек ([[http://www.pion.org/projects/pion-network-library][libpion]], [[http://cpp-netlib.sf.net][cpp-netlib]]), и кроме того, ведется разработка
новых.  Кроме того, на базе Boost.Asio я спроектировал и разработал подсистему фильтрации
для системы фильтрации веб-трафика [[http://jetsoft.ru/product/dozorskvt/purpose.html][СКВТ "Дозор-Джет"]].

К основным возможностям Boost.Asio можно отнести следующие:

 - возможность написания кросс-платформенного сетевого кода, работающего на большом
   количестве платформ - Windows, практически все Unix-подобные ОС, Tru64
 - поддержка как IPv4, так и IPv6
 - работа с TCP & UDP
 - поддержка выполнения асинхронных операций
 - возможность использования интерфейсов, совместимых с std::iostream 
 - поддержка SSL
 - поддержка отложенных операций (таймеры)

Для меня, самым главным преимуществом Boost.Asio (не считая высокой переносимости кода)
является то, что на каждой платформе реализуется наиболее эффективная стратегия работы
(=epoll= на Linux 2.6, =kqueue= на FreeBSD/MacOSX, Overlapped IO на MS Windows), и то, что
библиотека позволяет использовать разные стратегии -- синхронная и асинхронная работа с
сокетами, использование потокового ввода-вывода, совместимого с =std::iostream=.  И эти
стратегии можно смешивать, например, принимать соединения используя асинхронную обработку
событий, а затем, запускать нить, которая будет использовать синхронный ввод-вывод данных
(пример [[https://github.com/alexott/boost-asio-examples/blob/master/test-otpc.cpp][test-otpc.cpp]]).

Для демонстрации возможностей Boost.Asio я написал (частично адаптировав примеры из
поставки) несколько примеров, реализующих разные стратегии обработки данных (большее
количество примеров, можно найти на домашней странице Boost.Asio).  Я использовал эти
примеры для оценки применимости разных стратегий в своих разработках.  Все эти примеры
реализуют "тупой" веб-сервер -- он принимает запрос, и отдает одну и ту же страницу,
независимо от указанного URL.  Сейчас выложены следующие примеры (все исходные тексты
включают в себя файл [[https://github.com/alexott/boost-asio-examples/blob/master/common.h][common.h]]):

 - [[https://github.com/alexott/boost-asio-examples/blob/master/test-mcmt.cpp][test-mcmt.cpp]] -- реализует обработку данных в соответствии со стратегией Many
   Connections/Many Threads: запускается несколько нитей выполнения, которые по очереди
   принимают соединение и обрабатывают запросы в асинхронном режиме;
 - [[https://github.com/alexott/boost-asio-examples/blob/master/test-otpc.cpp][test-otpc.cpp]] -- реализует обработку данных в соответствии со стратегией One Thread per
   Connection: одна нить выполнения асинхронно принимает соединения (файлы
   [[https://github.com/alexott/boost-asio-examples/blob/master/test-otpc-conn.cpp][test-otpc-conn.cpp]] & [[https://github.com/alexott/boost-asio-examples/blob/master/test-otpc-conn.hpp][test-otpc-conn.hpp]]), а затем запускает новую нить, в пределах
   которой используется синхронный ввод-вывод;
 - [[https://github.com/alexott/boost-asio-examples/blob/master/test-otpc-tp.cpp][test-otpc-tp.cpp]] -- аналогично [[https://github.com/alexott/boost-asio-examples/blob/master/test-otpc.cpp][test-otpc.cpp]], но новая нить не создается каждый раз, а
   используется пул нитей, реализуемый библиотекой [[http://threadpool.sf.net][threadpool]].

Для сборки примеров (исходники лежат [[https://github.com/alexott/boost-asio-examples][на github]]) нужен boost версии 1.35 или выше.

Я думаю, что на основе данной заметки может получится написать более подробную статью, но
это задел на будущее, а пока можно задавать мне вопросы :-)


