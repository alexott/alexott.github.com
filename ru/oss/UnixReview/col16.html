<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 16 -- Рекурсивная работа с каталогами</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 16 -- Рекурсивная работа с каталогами</H1>

<H2>Randal Schwartz</H2>Сентябрь 1997<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Perl выделяется на маленьких, раздражающих задачках -- тех, которые
не имеют ``готовых'' решений или утилит, но которые время от
времени возникают при сопровождении ваших данных, или выполнении
некоторых работ по администрированию систем.
<P>
<P>Например, возьмем типичную задачу: удаление ненужных пустых
каталогов. Предположим, что у вас имеется WWW- или FTP-сервер для
распространения пакетов программного обеспечения, и некоторые пакеты
время от времени добавляются в, и удаляются из области доступа (скажем,
<CODE>/archive</CODE>). Утилиты для ``публикации'' конкретного пакета
знают достаточно для создания подкаталогов при необходимости, но по
некоторым причинам утилиты, которые выполняют ``удаление'' пакета не
удаляют родительский каталог пакета.
<P>
<P>Через некоторое время дерево каталогов окажется частично
заполненным, а некоторые каталоги будут пустыми. Вы вы решаете, что
наступило время для очистки дерева каталогов, возможно в ночных
заданиях cron. Вы захотите удалить все пустые каталоги, но оставить все
каталоги, которые выполняют какую-либо работу.
<P>
<P>Давайте будем обрабатывать их с помощью рекурсивной подпрограммы. Мы
будем использовать дескриптор каталога ждя считывания его содержимого
каждого из каталогов, и если мы найдем в нем подкаталог, то мы перейдем
в него и затем попытаемся его удалить, если он является пустым.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    &amp;smash(&quot;/archive&quot;);
    sub smash {
      my $dir = shift;
      opendir DIR, $dir or return;
      my @contents =
        map &quot;$dir/$_&quot;,
        sort grep !/^\.\.?$/,
        readdir DIR;
      closedir DIR;
      foreach (@contents) {
        next unless !-l &amp;&amp; -d;
        &amp;smash($_);
        rmdir $_;
      }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>В начале, подпрограмма <CODE>&amp;smash</CODE> запускается с полным
путевым именем каталога верхнего уровня нашего архива. Этот путь
сохраняется в переменной <CODE>$dir</CODE> внутри подпрограммы, которая
открывает заданный каталог. (Hеправильные каталоги автоматически
пропускаются при сбое <CODE>opendir</CODE>). 
<P>
<P>Содержимое каталога затем очищается и обрабатывается. Читая 4-х
строковое выражение с конца к началу, мы считываем каталог, отбрасывая
``.'' and ``..'', сортируем его в алфавитном порядке и помещаем имя
каталога в начало каждого имени.
<P>
<P>После этого, цикл <CODE>foreach</CODE> продвигает <CODE>$_</CODE> по всему
списку имен, находя возможные кандидаты в каталоги (не символьные
ссылки, но каталоги). Для каждого из подкаталогов мы вызываем
подпрограмму &amp;smash и затем пытаемся удалить его в надежде, что он
является пустым каталогом. Если <CODE>rmdir()</CODE> не выполняется, то это
не является большой проблемой: это значит, что каталог все еще активен
и служит реальным целям.
<P>
<P>Поскольку этот код работает великолепно, проходя по подкаталогам и
является общей операцией, что было бы стыдно снова и снова переписывать код, который
выглядит примерно также. Для таких вещей очень легко сделать небольшую
ошибку, (например не проверять символьные на ссылки при просмотре
каталогов). К счастью, стандартная библиотека <CODE>File::Find</CODE>,
предоставляет правильный код для выполнения таких операций.
<P>
<P>Вот тот же код, переписанный с использованием стандартной библиотеки:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    use File::Find;
    finddepth (\&amp;wanted, &quot;/archive&quot;);
    sub wanted {
      rmdir $_;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, <CODE>File::Find</CODE> устанавливает подпрограмму с именем
<CODE>finddepth</CODE>. Эта программа принимает ссылку на подпрограмму
(здесь это <CODE>\&amp;wanted</CODE>) как первый параметр, и список
каталогов, как следующие параметры. <CODE>finddepth</CODE> рекурсивно
проходит через всю файловую систему, начиная с указанных каталогов и
вызывая <CODE>&amp;wanted</CODE> для каждого из найденных имен, с установкой
некоторых переменных, чтобы сделать работу более легкой. Hапример,
<CODE>$_</CODE> устанавливается равной базовому имени файла (без имени
каталога, но здесь все нормально, поскольку <CODE>finddepth</CODE>
автоматически выполняет <CODE>chdir()</CODE> в родительский каталог). Так
что мы можем попытаться выполнить команду <CODE>rmdir()</CODE> для этого
имени, которая не будет выполняться, если это имя не является каталогом
или не пусто!
<P>
<P>Даже сейчас в этом коде немного больше текста чем возможно. Мы можем
использовать <EM>анонимные подпрограммы</EM> вместо создания
именованной подпрограммы:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    use File::Find;
    finddepth (sub {
                 rmdir $_;
               }, &quot;/archive&quot;);
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, конструкции <CODE>sub { }</CODE> достаточно для создания
подпрограммы без имени и передачи ее <EM>coderef</EM> (ссылки на код)
как первого параметра.
<P>
<P>Вы даже может сделать все это из командной строки Unix:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    perl -MFile::Find \
        -e 'finddepth(sub {rmdir $_}, @ARGV)' \
        /archive
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, <CODE>-M</CODE> выполняет тоже самое, что и директива <CODE>use</CODE> 
и мы будем брать аргументы из <CODE>@ARGV</CODE>, делая таким образом команду,
которая легко превращается в алиас. 
<P>
<P>Если это кажется слишком сложным для запоминания, то вы также можете
использовать великолепную утилиту <EM>find2perl</EM> для генерации кода,
который выглядит примерно также. Эта утилита принимает расширенный
синтаксис команды <EM>find</EM>, и создает скрипт для Perl: 
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
                find2perl /archive -depth -eval 'rmdir $_' |
        perl
</PRE>
</CODE></BLOCKQUOTE>
<P>Заметьте, что здесь я сразу передаю скрипт Perl. (Для дополнительной
информации смотрите справочную страницу для <EM>find2perl</EM>). 
<P>
<P>Но давайте вернемся назад к более интенсивному использованию 
<CODE>File::Find</CODE> в программах и покажем как сделать возможными 
сложные вещи. Например, я иногда любопытствую о том, куда расходуется
мое дисковое пространство, так что было бы великолепно получить отчет о
20 самых больших файлах. Вот небольшой скрипт, который выполняет это:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    use File::Find;
    find (sub {
            $size{$File::Find::name} =
              -s if -f;
          }, @ARGV);
    @sorted = sort {
      $size{$b} &lt;=&gt; $size{$a}
    } keys %size;
    splice @sorted, 20 if @sorted &gt; 20;
    foreach (@sorted) {
      printf &quot;%10d %s\n&quot;, $size{$_}, $_;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь я снова использую <CODE>File::Find</CODE>, который также
определяет процедуру <CODE>find</CODE> вместе с <CODE>finddepth</CODE>, с
аналогичными параметрами. (Различие между этими двумя процедурами
является небольшим, отличаясь тем, получаем ли мы уведомление о
конкретном каталоге до или после его содержимого). Внутри анонимной
процедуры кроме получения <CODE>$_</CODE> равной базовому имени файла,
мы также получаем переменную <CODE>$File::Find::name</CODE> равную
полному имени файла, что удобно здесь.
<P>
<P>Для каждого из имен <CODE>$_</CODE>, которое является файлом (определяется
с помощью <CODE>-f</CODE>), мы сохраняем его размер (полученный с помощью
<CODE>-s</CODE>) в хэш, ключом которого является полное путевое имя
(<CODE>$File::Find::name</CODE>). Когда данные получены полностью, мы
получаем список файлов, отсортированный по их размерам, используя
блок сортировки. Затем мы отбрасываем все записи после первых 20 и
печатаем результат.
<P>
<P>Маленький, элегантный, простой скрипт. <CODE>File::Find</CODE> позволил
нам атаковать проблемы рекурсии намного проще, чем соответствующий
скрипт командного процессора.
<P>
<P>Давайте рассмотрим один более сложный пример. Предположим, что у нас
есть исходные тексты утилиты <EM>zark</EM> (фиктивная утилита), которые 
распакованы в каталог <CODE>/usr/local/src/zark</CODE>, и мы хотим собрать 
эту утилиту машин <EM>supercycle</EM> и <EM>ultracycle</EM>, в отдельных
каталогах, но совместно используя дерево исходных текстов насколько это
возможно. Одним из способов является создание <EM>дерева символьных
ссылок</EM>, которое отражает структуру дерева исходных текстов и
содержит символьные ссылки на соответствующий файлы.
<P>
<P>В частности, выполнение этих действий вручную будет выглядеть 
следующим образом:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    
        ## Bourne shell: создание переменных
    source=/usr/local/src/zark
    build=/usr/local/build/supercycle/zark
    mkdir $build
    ln -s $source/Makefile $build/Makefile
    ln -s $source/zark.c $build/zark.c
    ## и так далее...
    ## создание подкаталогов:
    mkdir $build/zifflelib
    ln -s $source/zifflelib/Makefile $build/zifflelib/Makefile
    ln -s $source/zifflelib/zif.c $build/zifflelib/zif.c
    ## и так далее...
    mkdir $build/zufflib
    ln -s $source/zufflib/Makefile $build/zufflib/Makefile
    ln -s $source/zufflib/zuf.c $build/zufflib/zuf.c
    ## и так далее...
</PRE>
</CODE></BLOCKQUOTE>
<P>Как вы можете видеть, это достаточно утомительно. Так, что 
выполним это простым способом... с помощью Perl:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    use File::Find;
    $src = shift; # первый аргумент -- исходные тексты
    $dst = shift; # второй аргумент -- целевой каталог
    find(sub {
           (my $rel_name = $File::Find::name)
             =~ s!.*/\./!!s;
           my $src_name = &quot;$src/$rel_name&quot;;
           my $dst_name = &quot;$dst/$rel_name&quot;;
           if (-d) {
             print &quot;mkdir $dst_name\n&quot;;
             mkdir $dst_name, 0777
               or warn &quot;mkdir $dst_name: $!&quot;;
           } else {
             print &quot;ln -s $src_name $dst_name\n&quot;;
             symlink $src_name, $dst_name
               or warn &quot;symlink $src_name $dst_name: $!&quot;;
           }
         }, &quot;$src/./&quot;);
</PRE>
</CODE></BLOCKQUOTE>
<P>Самой сложной частью подпрограммы для <EM>find</EM> является
определение общей части путевых имен исходных файлов и файлов, которые
надо создать, что я делаю включая фиктивный путь 
<CODE>&quot;/./&quot;</CODE> в середину пути к исходным текстам. Это не
затрагивает эффективного пути, но удобно для сканирования с помощью
регулярного выражения (показано здесь в вычислении <CODE>$rel_name</CODE>).
<P>
<P>Я надеюсь, что вы получите удовлетворение от этого маленького
введения в иерархические файловые системы, и от приведенных примеров,
которые в будущем сэкономят вам времени. 
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
