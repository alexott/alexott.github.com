<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 18 -- Битовые операции</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 18 -- Битовые операции</H1>

<H2>Randal Schwartz</H2>Январь 1998<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Perl имеет много операций вне его назначения, которые делают
выполнение многих задач более легким. В этой колонке, мы покажем как
операции манипуляции с битами (``bitops'') могут помочь вам в связи с
правами доступа к файлам.
<P>Сначала, небольшое введение. Право доступа к файлу (или режим)
интерпретируется как 12-битное значение, объединенное в четыре группы
по три бита в каждой. Первыми тремя битами являются биты setuid, setgid
и sticky, о которых мы не будем здесь говорить. Три другие группы
соответственно контролируют права доступа для владельца файла
(``пользователь, user''), членов группы-владельца файла (``группа,
group'') и всех остальных (``другие, other''). Каждая группа битов
контролирует права доступа на запись, чтение и выполнение файла для
каждой из групп пользователей.
<P>Мы можем получить число, обозначающее права доступа к конкретному
файлу, используя оператор <CODE>stat</CODE>, например таким образом:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    $mode = (stat &quot;/etc/motd&quot;)[2];
    print $mode;
</PRE>
</CODE></BLOCKQUOTE>
<P>Но этот код на моей машине печатает непонятное число 33188. Как я
могу превратить это число в что-то понятное? Во первых, самым простым
способом будет заставить Perl напечатать число в восьмеричном виде, так
что группы по три бита появятся как восьмеричные значения 0-7:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    $mode = (stat &quot;/etc/motd&quot;)[2];
    printf &quot;%o\n&quot;, $mode;
</PRE>
</CODE></BLOCKQUOTE>
<P>На моей машине этот код выдает значение ``100644''. Чем здесь
является дополнительная цифра 1? Этот код показывает, что
<CODE>/etc/motd</CODE> является файлом, ен похожем на устройство или
каталог. Мы не хотим видеть его, так что здесь должны использоваться
битовые операторы. Давайте выполним побитовую операцию "И" нашего
значения с числом 07777, показывая только права доступа, а не
закодированный тип:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    $mode = (stat &quot;/etc/motd&quot;)[2];
    printf &quot;%o\n&quot;, $mode &amp; 07777;
</PRE>
</CODE></BLOCKQUOTE>
<P>Это является хорошо знакомым значением ``644'', которое мы передаем
команде <EM>chmod</EM>. Теперь как я могу сделать, чтобы файл был
доступен для записи для всех? (Не рекомендуется... просто для
примера...) Нам необходимо выполнить операцию <EM>or (или)</EM> над
битами, которые представляют право записи для пользователя, группы и
остальных, и которые записываются как 0222 (другое восьмеричное
значение):
<P>
<BLOCKQUOTE><CODE>
<PRE>
    $mode = (stat &quot;/etc/motd&quot;)[2];
    $newmode = $mode | 0222;
    chmod $newmode, &quot;/etc/motd&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь использование ``|'' заставляет выполнить операцию ``или'' с
заданными битами, и мы получаем доступный для записи всеми
пользователями файл сообщений (если вы конечно администратор).
<P>Как мы можем просто выделить группу битов? Для этого нам необходимо
выполнить операцию сдвига, вместе с выполнением операции ``и'',
например так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    $mode = (stat &quot;/etc/motd&quot;)[2];
    $groupmode = ($mode &amp; 070) &gt;&gt; 3;
    print &quot;$groupmode\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Этот код на моей машине выдает ``4''. Заметьте, что я не использую
функцию <CODE>printf</CODE>, поскольку восьмеричные 0-7 выдаются также как
и десятичные числа, в том же самом диапазоне.
<P>Так, что вместо продолжения показа частичных примеров, давайте
применим это новое значение в конкретном куске кода. Эта программа
бедет проходить по вашим путям поиска, в поиске каталогов, которые
могут быть изменены пользователями, к которым нет доверия. Этот код
начинается с чего-то подобного этому коду:
<P>
<BLOCKQUOTE><CODE>
<PRE>
   #!/usr/bin/perl
   use File::stat;
</PRE>
</CODE></BLOCKQUOTE>
<P>Модуль <CODE>File::stat</CODE> позволяет нам получить именованный доступ
к некоторым полям <CODE>stat</CODE>. Смотрите применение этого в дальнейшем
коде. Далее у нас имеется код:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    sub trust_user { $_[0] &lt; 100 }
    sub trust_group { $_[0] &lt; 100 }
</PRE>
</CODE></BLOCKQUOTE>
<P>Эти подпрограммы определяют номера пользователей и групп, которым
имеют нужные права. Предполагается, что каталог доступный для записи
таким пользователям, является безопасным. Далее, разделим пути поиска
на понятные компоненты с помощью кода:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    my @path = split /:/, $ENV{PATH};
</PRE>
</CODE></BLOCKQUOTE>
<P>И затем нам необходимо пройти по путям поиска, по каждому из
элементов:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    for (@path) {
      (my $statinfo = stat $_) or
        (warn &quot;cannot stat $_: $!&quot;), next;
</PRE>
</CODE></BLOCKQUOTE>
<P>Заметьте, что мы сначала помещаем каждое из имен в переменную
<CODE>$_</CODE>, а затем пытаемся определить ее параметры. Вышеприведенный
оператор <CODE>use</CODE> переопределяет функцию <CODE>stat</CODE>, так что она
будет возвращать объект, который отвечает на вызов функций, названных
как имена полей функции <CODE>stat</CODE>. Так, что возвращаемое значение
является скаляром, а не списком.
<P>Далее мы устанавливаем некоторые переменные:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      my @reasons;
      my $uid = $statinfo-&gt;uid;
      my $gid = $statinfo-&gt;gid;
      my $mode = $statinfo-&gt;mode;
</PRE>
</CODE></BLOCKQUOTE>
<P>Переменная <CODE>@reasons</CODE> содержит причины, по которым каталог
считается плохим. В начале, это список пуст. Другие три переменные
содержат номер владельца, группы-владельца и значение прав доступа и
типа, как это описано выше. Далее давайте проверим права доступа
владельца:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      if ($uid != $&lt;
          and not trust_user($uid)
          and $mode &amp; 0200) {
        push @reasons, &quot;non-owned, write by owner &quot;.
          getpwuid($uid);
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, если владелец каталога не является человеком, запустившем
скрипт, и если владелец каталога не входит в список доверенных
пользователей, то содержимое каталога может быть изменено кем-то, если
он также имеет права записи в этот каталог. Так, что мы проверим это
путем выполнения операции ``и'' между <CODE>$mode</CODE> и числом 0200,
результат которой будет ненулевым, если установлен бит доступа на
запись для пользователя.
<P>Если это так, то мы добавляем человека, к которому нет доверия к
списку причин, используя операцию <CODE>push</CODE> для текстового
сообщения. Вызов <CODE>getpwuid</CODE> возвращает нам имя пользователя
вместо его номера.
<P>Далее, выполняется тоже самое (приблизительно) с учетом бита права
доступа на запись для пользователя:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      if (not trust_group($gid)
          and $mode &amp; 020) {
        push @reasons, &quot;write by group &quot;.
          getgrgid($gid);
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>И затем для бита записи для остальных пользователей:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      if ($mode &amp; 02) {
        push @reasons, &quot;write by world&quot;;
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>В заключение, после всех причин, которые могут быть неправильными,
настало время показать найденные ошибки:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      if (@reasons) {
        print
          &quot;danger: $_ is dangerous because &quot;,
          &quot;of the following reasons:\n&quot;,
          map &quot;  $_\n&quot;, @reasons;
      }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>В этом эпизоде, если <CODE>@reasons</CODE> является не пустым, то пришло
время протеста. Оператор <CODE>map</CODE> превращает каждую из причин в
сообщение с отступом, которые затем предваряются общим сообщением об
ошибке. А также приведена дополнительная закрывающая скобка для
соответствия оператору цикла <CODE>foreach</CODE>, который начат ранее.
<P>Так, что если вы поместите этот код в файл и запустите его, то вы
увидите все места, в которых вам могут нанести ущерб. Убедите, что вы
правильно настроили список доверенных пользователей и групп для
соответствия вашей настройке.
<P>А сейчас, давайте рассмотрим еще одну небольшую программу. Я
попытался сделать из нее эквивалент команде:
<P>
<BLOCKQUOTE><CODE>
<PRE>
     chmod -R go=u-w /some/dir /other/dir
</PRE>
</CODE></BLOCKQUOTE>
<P>которую я выполняю очень часто, поскольку она устанавливает все
права доступа в правильные значения для ``опубликованного'' дерева
каталогов, независимо от того, являются ли они исполнимыми файлами, или
чем-то другим.
<P>Но меня раздражало то, что команда <EM>chmod</EM> не имеет ключа для
``многословного'' режима, который позволил бы не узнать о том, что идет
неправильно, и что должно быть исправлено. Я также хотел отметить
некоторые каталоги как ``не затрагиваемые'', что является ключом,
которого также не имеет стандартная команда <EM>chmod</EM>.
<P>Но никогда не бойтесь... прием (hack) на языке Perl спасет вас! Эта
маленькая программа начинается со строк:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    #!/usr/bin/perl
    $| = 1;
    use File::Find;
</PRE>
</CODE></BLOCKQUOTE>
<P>Эти строки отключают буферизацию <CODE>STDOUT</CODE> и подключают модуль
<CODE>File::Find</CODE>. Далее мы используем код верхнего уровня. Просто
одна строка:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    find \&amp;wanted, @ARGV;
</PRE>
</CODE></BLOCKQUOTE>
<P>Эта строка вызывает функцию <CODE>find</CODE>, определенную в модуле
<CODE>File::Find</CODE>, передавая ей подпрограмму, определенную ниже и
аргументы командной строки. Я описывал <CODE>File::Find</CODE> в предыдущих
выпусках. Подпрограмма <CODE>&amp;wanted</CODE> будет вызываться для
каждого из путевых имен, и начинается со следующего кода:
<P>
<BLOCKQUOTE><CODE>
<PRE>
     sub wanted {
      if (-d &amp;&amp; -e &quot;$_/.PRIVATE&quot;) {
        print &quot;## skipping contents of $File::Find::name\n&quot;;
        return $File::Find::prune = 1;
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>Сначала мы определяем каждый каталог, который содержит каталог с
именем <CODE>.PRIVATE</CODE>. Так я называю собственные ``не
затрагиваемые'' области. Установка переменной
<CODE>$File::Find::prune</CODE> в значение 1 заставляет
<CODE>File::Find::find</CODE> прекратить нисходящий переход в эту
область. Далее мы пропускаем, символические ссылки и все не являющееся
файлами или каталогами:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      return if -l;
      return unless -f or -d;
</PRE>
</CODE></BLOCKQUOTE>
<P>И также определяем то, для чего не можем выполнить функцию
<CODE>stat</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    my @stat = stat or return;
</PRE>
</CODE></BLOCKQUOTE>
<P>Далее мы получаем различные биты режима:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      my $mode = $stat[2] &amp; 07777;
      my $user_rwx = ($mode &amp; 00700) &gt;&gt; 6;
      my $target_bits = $user_rwx &amp; 05;
      my $group_rwx = ($mode &amp; 00070) &gt;&gt; 3;
      my $other_rwx = ($mode &amp; 00007);
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь... <CODE>$user_rwx</CODE> является правами пользователя, в то
время как <CODE>$target_bits</CODE> являются тем, чем должны быть права
доступа для группы и остальных пользователей. Давайте посмотрим, если
они являются:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
     if ($target_bits != $group_rwx
          or $target_bits != $other_rwx) {
</PRE>
</CODE></BLOCKQUOTE>
<P>Далее, если эта проверка не проходит, то нам необходимо вычислить
новый режим:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
     my $new_mode = (($mode &amp; 07700) |
                        ($target_bits &lt;&lt; 3) |
                        ($target_bits));
</PRE>
</CODE></BLOCKQUOTE>
<P>Заметьте использование здесь побитовой операции ``или'' для создания
нового режима из частей. В заключение, давайте сообщим о том, что мы
делаем и сделаем это:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        printf
          &quot;chmod %o %s # was %o\n&quot;,
          $new_mode, $File::Find::name, $mode;
        chmod $new_mode, $_;
      }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>И заключительный скобки закрывают определение подпрограммы.
<P>Таким образом вы можете подружиться с битовыми операциями. Узнайте и
используйте их. И возможно в следующий раз, когда вы будете проклинать
стандартные утилиты Unix за то, что они не имеют ключа
``многословного'' режима, то вы сможете заменить эти утилиты
10-строковой программой на Perl, которая выполняет ту же самую работу,
с практически той же скоростью. Наслаждайтесь!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
