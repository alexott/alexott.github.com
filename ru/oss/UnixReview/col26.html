<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 26 -- Вычисление простых чисел</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 26 -- Вычисление простых чисел</H1>

<H2>Randal Schwartz</H2>Июнь 1999<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Нет никаких сомнений в том, что Perl великолепен в склеивании
вместе внешних программ и данных, но Perl также является хорошим
средством для проблем чистого программирования, которые вы можете найти
в начале курсов по программированию. Например, давайте взглянем на
общую задачу вашего первого года обучения, нахождение простых чисел.
<P>
<P>Как я вспоминаю из своих ранних занятий математикой, простым числом
является любое целое число больше единицы, которое делится только на
единицу и само себя, но не на другие целые
числа. <EM>Предупреждение:</EM> я не математик-идиот, так что это
определение не является точным, я надеюсь, что кто-то поправит меня.
<P>
<P>Так что, давайте выдадим простые числа пользуясь данным
определением:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    GUESS: for (my $guess = 2; $guess &lt;= 10000; $guess++) {
      for (my $divisor = 2; $divisor &lt; $guess; $divisor++) {
        next GUESS unless $guess % $divisor;
      }
      print &quot;$guess\n&quot;;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Внешний цикл, названный <CODE>GUESS</CODE>, нужен для того, чтобы мы
могли делать переходы вперед со связью этого цикла, даже изнутри
внутреннего цикла. Переменная <CODE>$guess</CODE> содержит число, которое
мы проверяем ы каждом из циклов. Я определяю для этого цикла
лексическую локальную переменную, задавая ей значений равное 2 и
увеличивая ее на 1 до тех пор, пока она не достигнет значения 10,000.
<P>
<P>Внутренний цикл старается найти все возможные делители начиная с 2 и
до того числа, которое мы проверяем. Выражение <CODE>$guess %
$divisor</CODE> является истинным в том случае, когда имеется остаток от
деления, означая, что <CODE>$guess</CODE> не делится на <CODE>$divisor</CODE>.
<P>
<P>На моей машине эта программа выполняется примерно 13 секунд только
для того, чтобы получить все простые числа меньшие 10000. Очевидно, что
получение 100,000 простых чисел с помощью этой программы будет очень
дорогостоящим.
<P>
<P>Но давайте применим немного математики к процессу выбора чисел, для
того чтобы ускорить его. С одной стороны, глупо пытаться использовать
любой делитель, который больше чем квадратный корень искомого
числа. (Hаибольший делитель должен иметь другой множитель, который
меньше чем квадратный корень, для того, чтобы их произведение было
меньше чем искомое число). Так, что давайте немного изменим внутренний
цикл:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    GUESS: for (my $guess = 2; $guess &lt;= 10000; $guess++) {
      for (my $divisor = 2; $divisor * $divisor &lt;= $guess; $divisor++) {
        next GUESS unless $guess % $divisor;
      }
      print &quot;$guess\n&quot;;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>В этом примере заметьте, что было изменено заключительное условие
внутреннего цикла. так что мы отбрасываем проверку <CODE>$divisor</CODE>,
когда делитель имеет значение большее квадратного корня потенциального
простого числа, находящегося в переменной <CODE>$guess</CODE>.
<P>
<P>Hа моей машине этот прием уменьшает время выполнения примерно на пол
секунды. Если я увеличу верхний предел до 100000 то я получу выигрыш в 8
секунд. Давайте попробуем выполнить другую оптимизацию кода. После
простого числа равного 2 нет простых четных чисел, так что не зачем
пытаться использовать четные делители. (Как сказано в моей книге по
математике ``доказательство этого оставим читателю''). Так что давайте
немного изменим цикл:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    print &quot;2\n&quot;;
    GUESS: for (my $guess = 3; $guess &lt;= 100_000; $guess += 2) {
      for (my $divisor = 3; $divisor * $divisor &lt;= $guess; $divisor += 2) {
        next GUESS unless $guess % $divisor;
      }
      print &quot;$guess\n&quot;;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь я явно выдаю число <CODE>2</CODE>, поскольку это сделает алгоритм
более простым, чем при включении этого числа внутрь цикла. Затем я
пробую каждое <EM>нечетное</EM>  число, начиная с 3. Аналогичным
образом внутренний цикл пробует использовать в качестве возможного
делителя нечетные числа начиная с 3, но все равно останавливается когда
квадрат делителя превышает возможное простое число.
<P>
<P>И как я предполагал, этот прием уменьшил время выполнения почти
вдвое, уменьшившись примерно до 5 секунд. Он все еще не хорошо
масштабируется при получении простых чисел меньших миллиона или 10
миллионов. Для того, чтобы сделать это, нам нужно использовать что-то
вместо грубой силы.
<P>
<P>Следующим крупным исправлением будет введение классического ``Решета
Эратосфена'' для нахождения простых чисел. Для того, чтобы сделать это,
мы сначала создадим массив, заполненный нулями, размером равным
максимальному числу, которое мы хотим найти. Затем, начиная с числа 2,
мы присвоим ненулевое значение всем индексам массив кратным 2,
показывая, что соответствующее число не является простым. Переходя
далее, мы можем выполнить то же самое для числа 3, устанавливая все
индексы массива кратные 3 в ненулевое значение. Это выглядит вот так:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    my $UPPER = 100_000;
    my @sieve = (0) x ($UPPER + 1);
    GUESS: for (my $guess = 2; $guess &lt;= $UPPER; $guess++) {
      next GUESS if $sieve[$guess];
      print &quot;$guess\n&quot;;
      for (my $mults = $guess * 2; $mults &lt;= $UPPER; $mults += $guess) {
        $sieve[$mults] = 1;
      }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Верхняя граница возможных простых чисел нужны в нескольких местах,
так что я поместил это значение в переменную <CODE>$UPPER</CODE>. имя этой
переменной набрано прописными буквами, что традиционно означает, что мы
используем постоянную переменную, установленную как константу для всей
программы. Далее, массив <CODE>@sieve</CODE> инициализируется нулями
начиная с <CODE>$sieve[0]</CODE> и до <CODE>$sieve[$UPPER]</CODE>. Поскольку
размер этого списка на единицу больше значения <CODE>$UPPER</CODE>, то мне
необходимо добавить 1. Оператор <CODE>x</CODE> воспроизводит заданный
слева список (просто <CODE>0</CODE>) столько раз, чтобы сделать
<CODE>@sieve</CODE> достаточно длинным.
<P>
<P>Цикл <CODE>GUESS</CODE> снова проверяет возможные значения начиная с
<CODE>2</CODE> и до верхнего предела. Если <CODE>$sieve[$guess]</CODE> уже
установлен, то он уже был установлен предыдущим кандидатом и мы
используем умножение целого числа на простое число, найденное раннее,
так что мы просто перескакиваем к следующему варианту. В противном
случае наш вариант печатается и производится заполнение массива.
<P>
<P>Для всех чисел кратных найденному простому числу выполняется проход
по массиву, устанавливая индексы с кратными значениями в значение
1. Заметьте, что сдесь нет умножений <EM>или</EM> делений (если вы не
обращаете внимание на <CODE>$guess * 2</CODE>, который я мог бы записать
как <CODE>$guess + $guess</CODE>. Это делает это алгоритм чрезвычайно
удобным для процессора.
<P>
<P>Как я и предполагал, мы уменьшили время работы до 2 х секунд. При
увеличении верхней границы расчетов <EM>в этой</EM> программе до
миллиона, время работы увеличилось до 15 секунд. У меня начался процесс
свопинга, поскольку мы создаем в памяти миллион скаляров. В
действительности нам нужен только один бит. К счастью, мы
<EM>можем</EM> прямо представить битовый вектор, используя оператор
<CODE>vec</CODE>:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    my $UPPER = 1_000_000;
    my $sieve = &quot;&quot;;
    GUESS: for (my $guess = 2; $guess &lt;= $UPPER; $guess++) {
      next GUESS if vec($sieve,$guess,1);
      print &quot;$guess\n&quot;;
      for (my $mults = $guess * 2; $mults &lt;= $UPPER; $mults += $guess) {
        vec($sieve,$mults,1) = 1;
      }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь переменная <CODE>$UPPER</CODE> используется для тех же целей, как
и в предыдущей программе, но мы теперь используем одиночный скаляр
<CODE>$sieve</CODE> для хранения группы битов, первоначально равной нулю.
<P>
<P>Остаток программы остается неизменным, но мы теперь мы заменили
действия с массивом на операции с
<CODE>vec</CODE>. <CODE>vec($sieve,$guess,1)</CODE> имеет истинное значение,
когда соответствующий бит в позиции <CODE>$guess</CODE> равен 1. И мы можем
использовать ту же самую конструкцию в левой части присваивания, для
того, чтобы устанавливать значения бита. Достаточно хитро и компактно.
<P>
<P>Достаточно странно, но программа все равно выполняется 15 секунд, но
свопирование сильно уменьшилось. Оно все равно кажется высоким, но
затем я осознал, что я устанавливаю много уже установленных битов. Hам
не нужно затрагивать все кратные <CODE>$guess</CODE> числа, поскольку все
кратные числа меньшие квадрата <CODE>$guess</CODE> уже были установлены
ранее!
<P>
<P>Исправив это, мы получим
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    my $UPPER = 1_000_000;
    my $sieve = &quot;&quot;;
    GUESS: for (my $guess = 2; $guess &lt;= $UPPER; $guess++) {
      next GUESS if vec($sieve,$guess,1);
      print &quot;$guess\n&quot;;
      for (my $mults = $guess * $guess; $mults &lt;= $UPPER; $mults += $guess) {
        vec($sieve,$mults,1) = 1;
      }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>что уменьшает время выполнения программы примерно до 13 секунд. Hе
такое уж и большое достижение, но каждый бит помогает нам при
увеличении объемов. Все таки мы нашли 78,498 простых чисел!
<P>
<P>Если вы хотите узнать о простых числах немного больше (возможно
больше, чем вы хотите), то я случайно натолкнулся на страницы по адресу
<CODE>http://www.utm.edu/research/primes/</CODE>, которая является очень
хорошим ресурсом.
<P>
<P>Так, что вы можете сейчас увидеть, что проблемы первых годов
компьютерной науки могут быть легко решены с помощью Perl, показывая,
что Perl является хорошим средством и для теоретических и для
практических задач. наслаждайтесь.
<P>
<HR>
Next
Previous
Contents
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">_uacct = "UA-78697-3"; urchinTracker(); </script></body>
</HTML>
