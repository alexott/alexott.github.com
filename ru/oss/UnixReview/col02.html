<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 2 -- Подсчет слов</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 2 -- Подсчет слов</H1>

<H2>Randal Schwartz</H2>Май 1995<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Изначально, Perl получил известность как удобное средство обработки
текстов. И даже развившись за полдюжины лет своего существования,
обработка текстов остается главным применением Perl.
<P>
<P>Например, давайте реализуем на Perl подсчет числа строк в каждом файле,
заданном в командной строке. Я сделаю это с использованием специального
оператор чтения ``&lt;&gt;'', который автоматически открывает каждый файл
из командной строки.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/usr/bin/perl
        while (&lt;>) {
                $count{$ARGV}++;
        }
        foreach $file (sort keys %count) {
                print "$file has $count{$file} lines\n";
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Цикл <CODE>while</CODE> проходит по каждой строчке каждого файла,
заданного в командной строке или стандартного потока ввода, если не заданы
имена файлов. Для каждой строки в ассоциативном массиве <CODE>%count</CODE>
увеличиваем значение элемента на единицу. Элемент массива выбирается ключом
<CODE>$ARGV</CODE>, который является именем файла, открытого в
``&lt;&gt;''. Если не задано имен файлов, имя файла равно ``-'', что,
следуя принятому в UNIX соглашению, означает стандартный ввод.
<P>
<P>После завершения цикла <CODE>while</CODE>, все счетчики посчитаны, цикл
<CODE>foreach</CODE> перебирает все ключи из ассоциативного массива
<CODE>%count</CODE> и выводит имена файлов, которые я обрабатываю, (они
являются ключами) и значения соответствующих счетчиков. Для красоты я
отсортировал имена файлов в алфавитном порядке с помощью
<CODE>sort</CODE>. На каждом шаге цикла <CODE>foreach</CODE> имя файла
попадает в переменную <CODE>$file</CODE>, которая используется для печати
счетчика строк в операторе <CODE>print</CODE>.
<P>
<P>Предположим, что я решил отсортировать в порядке возрастания числа
подсчитанных строчек (скажем, я ищу самый длинный файл из заданного списка
файлов). Нет проблем, мне надо лишь немного рассказать <CODE>sort</CODE> о
том, как ему изменить поведение.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/usr/bin/perl
        while (&lt;>) {
                $count{$ARGV}++;
        }
        foreach $file (sort by_count keys %count) {
                print "$file has $count{$file} lines\n";
        }
        sub by_count {
                $count{$b} &lt;=> $count{$a};
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь я добавил функцию сравнения элементов, которая задает новое
правило сортировки для <CODE>sort</CODE>. В моем случае, у меня есть список
ключей ассоциативного массива <CODE>%count</CODE> и мне хочется сортировать
не ключи, а значения из ассоциативного массива. Когда вызывается функция
сортировки <CODE>by_count</CODE>, она получает два элемента (два ключа из
<CODE>%count</CODE>) в <CODE>$a</CODE> и <CODE>$b</CODE>. Задача
<CODE>by_count</CODE> вернуть значение <CODE>(-1,0,+1)</CODE>, в
зависимости от того, как мы рассматриваем <CODE>$a</CODE>, меньшим, равным
или большим, чем <CODE>$b</CODE>, соответственно. Бинарная операция
<CODE>&lt;=&gt;</CODE> делает именно то, что нам надо. Она возвращает знак
разницы <CODE>(-1,0,+1)</CODE> между своими операндами, что и требуется от
функции сравнения. Изменив порядок операндов мы получим другой порядок
сортировки.
<P>Я поменял <CODE>$a</CODE> и <CODE>$b</CODE> местами в
<CODE>by_count</CODE> и, таким образом, получил сортировку по
убыванию. Таким образом, длиннейшие файлы будут идти первыми.
<P>
<P>Количество строк, это, конечно, интересно, но что нам делать если я
вдруг захотел посчитать количество слов? Давайте определим слово как
последовательность букв и цифр. (Да, большинство людей не используют цифры
в словах, но это ведь только пример).
<P>
<P>Чтобы посчитать строчки, мне нужно разбить строку на слова и добавлять в
счетчик количество слов, а не количество строк. Небольшие изменения сделают
это.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/usr/bin/perl
        while (&lt;>) {
                @words = split(/\W+/);
                $count{$ARGV} += @words;
        }
        foreach $file (sort by_count keys %count) {
                print "$file has $count{$file} words\n";
        }
        sub by_count {
                $count{$b} &lt;=> $count{$a};
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Список <CODE>@words</CODE> создается для каждой строчки файла и содержит
вырезанные <CODE>split</CODE> слова, которые разделялись регулярным
выражением <CODE>/\W+/</CODE>. Это регулярное выражение совпадает с
последовательностями, которые не могут быть буквенно-цифровыми. Оператор
<CODE>split</CODE> ``протягивает'' это регулярное выражение по строке (в
этом случае по строке <CODE>$_</CODE>, поскольку я не указал ничего
другого). Оператор <CODE>split</CODE> не заносит в список выражения,
подходящие под маску разделителя, все остальное становится элементами
списка.
<P>
<P>Получив список <CODE>@words</CODE>, я могу добавить длину этого списка
к счетчику. В скалярном контексте переменная <CODE>@words</CODE> равна
длине массива <CODE>@words</CODE>. В результате, в нашем массиве
<CODE>%counts</CODE> мы посчитаем не строчки, а слова.
<P>
<P>Теперь, посчитав слова, мне может быть даже более интересно посчитать,
какие слова встречаются чаще, не только какие файлы имеют больше
слов. Давайте перевернем наш счетчик.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       #!/usr/bin/perl
        while (&lt;>) {
                @words = split(/\W+/);
                foreach $word (@words) {
                        $count{$word}++;
                }
        }
        foreach $word (sort by_count keys %count) {
                print "$word occurs $count{$word} times\n";
        }
        sub by_count {
                $count{$b} &lt;=> $count{$a};
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Вместо того, чтобы просто считать количество слов на строчку, я прохожу
по каждому слову в цикле <CODE>foreach</CODE> внутри первого цикла
<CODE>while</CODE>. Тело цикла <CODE>foreach</CODE> выполняется на каждое
слово и увеличивает счетчик <CODE>%counts{$word}</CODE> в ассоциативном
массиве <CODE>%counts</CODE>. Ключ <CODE>$word</CODE> этого ассоциативного
массива теперь не имя файла, как это было в предыдущем случае, а само
слово. (Я потерял все ссылки на файл, но они скоро вернутся).
<P>
<P>После завершения цикла <CODE>while</CODE>, я прохожу по ключам
ассоциативного массива <CODE>%counts</CODE>, но в этот раз, ключами
являются слова, чем и отличается наше сообщение в <CODE>print</CODE>. Хотя,
функция сравнения элементов осталась та же.
<P>
<P>Выводом этой программы является список слов, отсортированный в порядке
убывания частоты встречаемости слова.
<P>
<P>Как я уже говорил, я потерял имя файла, где встретилось слово.
Предположим, что я хочу учесть соответствие слова и файла, где оно
встречается, вместо простого количества встреченных слов. Мне пришлось бы
где-то сохранить имя файла. Ладно, это всего лишь несколько нажатий на
клавиши и я получу это.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/usr/bin/perl
        while (&lt;>) {
                @words = split(/\W+/);
                foreach $word (@words) {
                        $count{$word}{$ARGV}++;
                }
        }
        foreach $word (sort keys %count) {
                foreach $file (sort keys %{$count{$word}}) {
                        print "$word occurs $count{$word}{$file}",
                                " times in $file\n";
                }
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Уф. Да, получилось несколько больше, чем просто несколько нажатий на
клавиши. Что же произошло? Теперь я превратил <CODE>%counts</CODE> в
двумерный ассоциативный массив. Такая конструкция не поддерживалась в Perl
до версии 5.0, так что убедитесь, что у вас свежая версия Perl (не
волнуйтесь, Perl распространяется бесплатно). Ключи <CODE>%counts</CODE>
все еще слова, но значения уже анонимные ассоциативные массивы. Ключами у
этого массива второго уровня являются имена файлов, в которых встречалось
слово. Например, <CODE>$count{``fred''}{``hello.c''}</CODE> содержит число,
сколько раз слово ``fred'' встретилось в ``hello.c''.
<P>
<P>Печатающий цикл тоже немного изменился, ведь мне теперь надо пройтись по
всем именам файлов, в которых встретилось слово (теперь в алфавитном
порядке), и для каждого слова посмотреть, сколько раз оно встретилось в
каждом файле. Этот жуткий синтаксис <CODE>%{$counts{$word}}</CODE>
необходим, чтобы ссылаться на анонимный ассоциативный массив в
<CODE>$counts{$word}</CODE>. (Это занимает какое-то время, но может
выглядеть вполне естественно, после приобретения некоторого опыта.)
Заметьте, что даже внутри двойных кавычек я могу использовать синтаксис
вложенного ассоциативного массива для доступа к счетчику.
<P>
<P>Хмм. Этот результат работы этой программы выглядит жутковато. Что мне
действительно бы хотелось, так чтобы слово было слева, а имена файлов и
счетчики справа. Нет проблем&nbsp;--- сейчас подчистим.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/usr/bin/perl
        while (&lt;>) {
                @words = split(/\W+/);
                foreach $word (@words) {
                        $count{$word}{$ARGV}++;
                }
        }
        foreach $word (sort keys %count) {
                print "$word:",
                        join(", ",
                                map "$_: $count{$word}{$_}",
                                sort keys %{$count{$word}}),
                        "\n";
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Теперь это выглядит так: 
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        bedrock: barney.c: 10, betty.c: 5, fred.c: 15
        flintstone: barney.c: 3
        rubble: barney.c: 5, betty.c: 2
</PRE>
</CODE></BLOCKQUOTE>
<P>Это работа по превращению ключей из внутреннего ассоциативного массива
(имена файлов, где встретилось слово) в строчку, содержащую ключевое имя
вместе со значением. Такой эффект достигается использованием мощного
оператора <CODE>map</CODE>, который устанавливает <CODE>$_</CODE> на каждый
элемент данного списка, затем возвращает результат из этого в новый
список. После этого, оператор <CODE>join</CODE> вставляет запятую с
пробелом между элементами и склеивает в строчку, которая печатается
<CODE>print</CODE>.
<P>
<P>Ух. Сколько работы в таком маленьком кусочке. Хотя, это все еще не очень
опрятно выглядит. Давайте подчистим, используя <CODE>format</CODE>.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/usr/bin/perl
        while (&lt;>) {
                @words = split(/\W+/);
                foreach $word (@words) {
                        $count{$word}{$ARGV}++;
                }
        }
        foreach $word (sort keys %count) {
                $left = "$word:";
                $right = join(", ",
                        map "$_: $count{$word}{$_}",
                        sort keys %{$count{$word}});
                write;
        }

        format STDOUT =
        @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        $left,          $right
          ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~~
          $right
        .
</PRE>
</CODE></BLOCKQUOTE>
<P>Я поместил печатаемое слово с следующим за ним двоеточием в
<CODE>$left</CODE>, а список счетчиков для каждого файла в
<CODE>$right</CODE>. <CODE>format</CODE> используется с оператором
<CODE>write</CODE>, используя формат, определенный в программе позже. Этот
формат ставит отмеченное слово в поле с левым выравниванием. Счетчики будут
дополнены пробелами справа. Если будет ссылок, чем может поместиться в
строку, то оставшиеся ссылки будут разбросаны по последующим строкам (без
отступов, что слегка отличается от предыдущего варианта), спасибо
встроенному переносчику слов оператора <CODE>format</CODE>. (Две тильды в
конце строки означают, что формат требует повторения строчки до тех пор,
пока строчка не будет напечатана пустой).
<P>
<P>Как вы могли заметить, это длинный путь от счетчика строк до симпатично
выглядящего соответствия слов, и счетчиков по файлам, но программирование
никогда не занимает так много времени (хотя результат выглядит немного
хуже). Особенности обработки текстов в Perl позволяет легко справляться с
такими общими, но нужными задачами.
<HR>
Next
Previous
Contents
</BODY>
</HTML>
