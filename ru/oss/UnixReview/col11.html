<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 11 -- Работа со списками</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 11 -- Работа со списками</H1>

<H2>Randal Schwartz</H2>Ноябрь 1996<P>Одной из самых сильных сторон Perl является работа со списками данных. В
действительности, с введением ссылок в Perl версии 5.0, работа со списками
стала даже еще легче. В этом разделе я покажу вам некоторые простые способы
работы со списками, которые вы можете счесть полезными. Кроме того, нет
необходимости заново изобретать колесо&nbsp;&mdash; кто-то иной, скорее
всего уже выполнил этот тяжкий труд. (И чаще всего, когда вы заново
изобретаете колесо, вы закончите работу браком).
<P>Одной из самых частых задач при работе со списками является удаление
повторяющихся элементов. Этот вопрос часто задается в группе новостей
``comp.lang.perl.misc''. Hаиболее эффективным (и даже наиболее простым для
записи, смотрите пример), является использование хеша (ранее называвшегося
``ассоциативным массивом'') для отслеживания элементов списка, и удаления
дополнительных копий этих элементов. Это может выглядеть примерно так:
<P>
<HR>
<PRE>
        %temp = ();
        @list = grep ++$temp{$_} &lt; 2, @list;
</PRE>
<HR>
<P>В этом примере, я очищаю хеш <CODE>%temp</CODE> присваивая ему пустой
список. Следующее выражение выполняет всю тяжелую работу, и здесь делается
много работы, так что рассмотрим это выражение по частям.
<P>Сначала, я предполагаю, что данные которые я хочу уменьшить только до
уникальных элементов, содержатся в массиве <CODE>@list</CODE>. Далее я выполняю
операцию ``grep'' над текущим значением этого списка. Аналогично команде
Unix, оператор <CODE>grep</CODE> выбирает и отклоняет элементы списка,
основываясь на результате оценки выражения, возвращающего истинное или
ложно значение. Однако в нашем случае, оцениваемым выражением является
доступ к элементу хеша, используя в качестве ключа значение переменной
<CODE>$_</CODE>. Оператор <CODE>grep</CODE> по одному присваивает переменной <CODE>$_</CODE>
значение каждого из элементов списка, и оценка ведется
последовательно. Таким образом, первый раз, если значением <CODE>$_</CODE>
является, например строка ``fred'', то после выражения
<CODE>++$temp{``fred''}</CODE> значение увеличивается от неопределенного
(поскольку элемент не может быть найден в хеше) до ``1''. Теперь, поскольку
это значение меньше чем 2, то полное выражение возвращает истину и элемент
включается в результат.
<P>При следующих вхождениях строки ``fred'', при выполнении
<CODE>++$temp{``fred''}</CODE> значение равно 2 или больше. Поскольку это
выражение затем возвращает ложное значение, то элемент
отвергается. Результат выполнения оператора <CODE>grep</CODE> затем
присваивается переменной <CODE>@list</CODE>, и у нас на руках выполненная
задача.
<P>Кто-то недавно спрашивал в группе новостей <CODE>comp.unix.shell</CODE> о
том, как удалить дублирующиеся имена из списка почтовых адресов. Хотя в
настоящее время, поскольку это может быть выполнено простой командой
<CODE>sort</CODE> с ключом ``-u'', я решил попытаться решить эту проблему с
помощью скрипта на Perl. А именно, проверка уникальности почтовых адресов
должны быть ``регистро-независимой'', поскольку  <CODE>fred@BIG.COM</CODE>
является тем же самым адресом, что и  <CODE>fred@big.com.</CODE>. Используя
чуть большую программу, чем в предыдущем примере, мы можем решить эту
задачу. Вот пример этого решения:
<P>
<HR>
<PRE>
        @list = split /\n/, &lt;&lt;END;
        fred@big.com
        barney@little.com
        fred@BIG.COM
        barney@ivy.edu
        END
        # ... later in the program ...
        {
                my %temp;
                foreach (@list) {
                        $temp{lc} = $_;
                }
                @list = sort values %temp;
        }
</PRE>
<HR>
<P>В этом примере, первые несколько строк заполняют переменную
<CODE>@list</CODE>. Блок из семи последних строк формирует временную область, в
которой я создаю переменную <CODE>%temp</CODE>. Эта переменная гарантированно
пустая, аналогично предыдущему примеру. Однако, выполняя объявление
переменной внутри блока, переменная автоматически удалится при завершение
блока, освобождая выделенную память, и если существует конфликт имен с
существующей переменной, то новая переменная будет иметь
превосходство. Красивый прием для временных переменных.
<P>После того, как мы создали пустую локальную переменную <CODE>%temp</CODE>,
выполняется цикл по значениям содержащимся в переменной
<CODE>@list</CODE>. Каждая итерация цикла задает разное значение локальной
переменной <CODE>$_</CODE>. Внутри цикла, выполняется простая установка
значения элементов хеша, в качестве ключа которого используется значение
<CODE>$_</CODE> переведенное в нижний регистр (используя функцию <CODE>lc</CODE>),
и значением элемента становится содержимое переменной <CODE>$_</CODE>
(оригинальный почтовый адрес). Выполняя это я делаю два почтовых адреса
одинаковыми (за исключением разницы в регистрах) и они занимают один и тот
же элемент ассоциативного списка. Поскольку это невозможно, то второй адрес
становится на место первого и я получаю одно значение.
<P>После выполнения цикла, я выделяю значения, отсортированные по
алфавиту. Почему значения? Хорошо, ключи все были приведены к нижнему
регистру, но значения будут сохранять по крайней мере <EM>одно</EM>
значение с предпочтительным выделением букв в почтовом адресе. Достаточно
удобно?
<P>Теперь, немного отличная задача. Другой частой задачей является удаление
списка объектов из другого списка объектов. Это может быть названо
``вычитанием множеств'' или получением ``разницы между множествами'', если
вы предпочитаете этот тип названий. Хорошо, нам снова на помощь приходит
ассоциативный список. В действительность, когда вы думаете о наборе
``каких-то вещей'', то вы почти всегда можете сразу думать о том, что
``множество является ключами ассоциативного массива'' и это близко к
истине. Так что перед вами код для проведения вычитания между списками
<CODE>@list</CODE> и @stoplist<CODE></CODE>:
<P>
<HR>
<PRE>
        %temp = ();
        @temp{@list} = ();
        foreach (@stoplist) {
                delete $temp{$_};
        }
        @list = sort keys %temp;
</PRE>
<HR>
<P>Снова у меня есть временный ассоциативный массив <CODE>%temp</CODE>, я
очищаю его, так что я могу работать с ним с нуля. Следующий шаг создает
элементы внутри <CODE>%temp</CODE> для всех ключей <CODE>@list</CODE>, используя
оператор среза (slice) для ассоциативного массива. Значения для данных
ключей будут не определены, но это неважно для данного решения. Цикл
<CODE>foreach</CODE> удаляет каждый элемент находящийся в массиве
<CODE>@stoplist</CODE> из ассоциативного массива <CODE>%temp</CODE>. Все нормально,
даже если некоторые элементы не присутствуют в ассоциативном массив&nbsp;--
оператор <CODE>delete</CODE> просто игнорирует их.
<P>Одно время среди разработчиков Perl обсуждался  синтаксис:
<P>
<HR>
<PRE>
        delete @temp{@stoplist};
</PRE>
<HR>
<P>что позволило бы исключить цикл, но это не было реализовано. Возможно
это будет сделано в Perl 6.0?
<P>В заключение, новый список собирается из оставшихся ключей
<CODE>%temp</CODE>, сортируемых в алфавитном порядке. В результате мы получаем
содержимое <CODE>@list</CODE>, без элементов <CODE>@stoplist</CODE>. Побочным
эффектом будет то, что также будут удалены дублированные элементы 
<CODE>@list</CODE>.
<P>Мы можем оформить  данный код в виде подпрограммы, например вот так:
<P>
<HR>
<PRE>
        sub remove {
                my($listref,$stopref) = @_;
                my(%temp);
                
                @temp{@$listref} = ();
                foreach (@$stopref) {
                        delete $temp{$_};
                }
                sort keys %temp;
        }
</PRE>
<HR>
<P>Заметьте, что первые два параметра являются <B>ссылками</B> на списки,
а не просто списками. Это позволяет использовать более эффективную передачу
списков в подпрограмму. Первый параметр сохраняется в переменной
<CODE>$listref</CODE>, а второй в <CODE>$stopref</CODE> и <CODE>%temp</CODE> создается
как пустой, локальный ассоциативный массив.
<P>В следующем выражении производится обращение к содержимому
<CODE>$listref</CODE>, используя запись <CODE>@$listref</CODE>, что позволяет
обратиться к списку, ссылка на который хранится в переменной
<CODE>$listref</CODE>. Аналогичным образом производится обращение к содержимому
массива, ссылка на который хранится в <CODE>$stopref</CODE>. Последнее
выражение, вычисляемое в этой подпрограмме (<CODE>sort keys %temp</CODE>)
становится возвращаемым значением подпрограммы.
<P>Вот простой пример обращения к данной подпрограмме:
<P>
<HR>
<PRE>
        @input = qw(fred barney betty);
        @guys = remove(
                \@input,
                [qw(betty wilma pebbles)]
        );
</PRE>
<HR>
<P>В массиве <CODE>@input</CODE> хранится несколько разных имен, и мы запускам
подпрограмму ``remove'', передавая в нее ссылку (созданную оператором
обратный слэш) на переменную <CODE>@input</CODE> и создается анонимный список
из трех имен. Результат, сохраняемый в массиве <CODE>@guys</CODE> будет
содержать разницу между массивами.
<P>Как мы можем выполнить пересечение множеств, где каждый элемент
находится в обоих списках? Это будет выглядеть примерно так:
<P>
<HR>
<PRE>
        %temp = ();
        @temp{@list_one} = (1) x @list_one;
        @result = grep $temp{$_}, @list_two;
</PRE>
<HR>
<P>Hа первом шаге создается хорошо известный нам хеш <CODE>%temp</CODE>. (Или,
если бы это была по настоящему временная переменная, то мы не нуждались бы в
этом коде). Следующий шаг создает срез хеша <CODE>%temp</CODE>, с одним
интересным свойством. Левая часть является списком относящимся к
<CODE>@list_one</CODE>&nbsp;-- правая часть является списком из единиц, который
повторяется (с помощью оператора <CODE>x</CODE>) настолько, чтобы его длина
была точно равна длине списка на левой стороне. В результате этого, все
элементы <CODE>%temp</CODE> с ключами из списка <CODE>@list_one</CODE> получают
значение равное 1.
<P>Результат вычисляется поиском тех элементов списка <CODE>@list_two</CODE>,
которые имеют соответствующие элементы из списка <CODE>@list_one</CODE>,
используя элементы из <CODE>%temp</CODE>, которые были установлены в предыдущем
выражении.
<P>Я надеюсь, что данный обзор даст вам некоторый набор идей о работе со
списками. Между прочим, данная статься, вместе с остальными статьями о Perl
доступна по адресу 
<A HREF="http://www.teleport.com/~merlyn/UnixReview/">http://www.teleport.com/~merlyn/UnixReview/</A>. Регистр букв в адресе
важен. Hаслаждайтесь!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
