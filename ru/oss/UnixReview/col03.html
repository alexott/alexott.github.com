<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 3 -- Регулярные выражения</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 3 -- Регулярные выражения</H1>

<H2>Randal Schwartz</H2>Июль 1995<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Одной из многих сильных сторон Perl является возможность легкого
манипулирования текстовыми строками. Это особенно полезно, так как
манипуляции со строками являются ядром большинства писанных на
коленке программ в типичной среде UNIX-инструментария.
<P>
<P>В Perl многие операции с текстовыми строками построены на
использовании ``регулярных выражений''. Многие люди, с которыми я
разговаривал, считают, регулярные выражения пугающими&nbsp;--- тёмным,
колдовским языком на котором говорят наиболее посвящённые адепты и то, 
только шёпотом. К счастью, в следующих нескольких параграфах я вынесу
искусство регулярных выражений на свет. (Конечно, после этого моя
карточка посвящённого будет аннулирована, но я должен рискнуть.)
<P>
<P>Регулярное выражение есть ни что иное, как шаблон, который выбирает
класс подходящих под него строек, отличая их от строек, которые не подходят
под этот шаблон. Например, регулярное выражение <CODE>/abc/</CODE>
соответствует всем строкам, в которых есть подряд буквы ``a'', ``b'' и
``c'' именно в этом порядке. (Видите, это не так уж страшно). Указание
последовательности из букв для поиска подстроки довольно обычно в
программах на Perl:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        foreach $i (@somelist) {
                if ($i =~ /abc/) {
                        print "$i contains abc\n";
                }
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь каждый элемент <CODE>@somelist</CODE> проверяется один раз. Для
каждого элемента, который соответствует регулярному выражению ``abc'' 
печатается, что он содержит подстроку ``abc'' где-то внутри строки.
<P>
<P>Регулярные выражения могут делать больше, чем просто проверять на
точное совпадение подстроки. Зачастую, они содержат метасимволы,
которые позволяют регулярным выражениям подходить к любому из
возможного списка символов в определённой позиции. Например, символ
``.'' в регулярном выражении соответствует любому строковому символу,
исключая символ новой строки. То есть, регулярное выражение ``a.c''
соответствует не только abc, но и acc, adc, afc, azc, a+c, ... вот
такая картина.
<P>
<P>Если вы хотите быть более разборчивым, вы можете использовать ``класс
символов''. Класс символов заключается в квадратные скобки. Класс
``[a-z]'' в регулярном выражении соответствует любой строчной букве
латинского алфавита. То есть, ``[b-f].d'' соответствует bed, fed, cad, 
но не kid. Класс ``[aeiou]'' соответствует всем строчным гласным
латинским буквам.
<P>
<P>Класс символов может так же описывать, что вы не хотели бы видеть в
соответствии, просто включите знак ``стрелка вверх''&nbsp;--&nbsp;``^'' первым
символом внутри скобок. Например, класс ``[\^a-z]'' говорит, что
приемлимо всё, кроме строчных символов латинского алфавита. Таким
образом, ``a[^a-z]'' соответствует a+c, a*c, a=c, но не abc или agc. 
<P>
<P>Но, даже с символами и классами символов вы всё ещё не можете
описывать соответствия с изменяющейся длиной. Если вы хотите, чтобы
между ``a'' и ``c'' могло быть любое количество символов, то вы должны 
использовать квантификаторы. Квантификатор пишется после регулярного
выражения (или его части) и позволяет выражению повторяться так много
раз, как позволяет квантификатор.
<P>
<P>Один из самых часто используемых квантификаторов, это
``звёздочка''&nbsp;--&nbsp;``*''. Этот квантификатор (используемый почти во всех
утилитах UNIX, которые используют регулярные выражения) означает,
``непосредственно предшествующее выражение может встретиться ноль или
больше раз''. Так, ``fre*d'' соответствует frd, fred, freed, freeed,
.... Заметьте, что это отличается от того shell делает с ``*'', shell
подразумевает, в терминах регулярных выражений, ``.*''.
<P>
<P>Немного менее частый, но не менее полезный квантификатор, это
``плюс''&nbsp;--&nbsp;``+'', который означает ``непосредственно предшествующее
выражение может встретиться один или больше раз'' . Так, ``fre+d''
соответствует fred, freed, freeed, ..., но не frd.
<P>
<P>Существует ещё ``знак вопроса''&nbsp;--&nbsp;``?'', означающий ``непосредственно
предшествующее выражение может встретиться ноль или один раз''. Так,
``ab?c'' соответствует ac или abc, но не abbc. (И Ab?a никогда не
будет соответствовать старой шведской группе ``Abba''.) Обратите
внимание, что знак вопроса в регулярном выражении означает совершенно
не то, как его интерпретирует shell. Знак вопроса в shell эквивалентен 
``.'' в регулярном выражении.
<P>
<P>Уже даже с такими возможностями регулярных выражений мы могли бы
делать очень много работы, выбирая одни строки и игнорируя другие. Но
даже более мощные операции становятся возможными, когда мы можем
запомнить ту часть строки, которая соответствует части регулярного
выражения. Эта часть заключается в круглые скобки и помещается в
память. Вы можете поместить любое количество правильно
сбалансированных скобок в регулярном выражении. Когда строка подходит
под регулярное выражение, части строки, соответствующие частям
регулярного выражения, заключённых в пары круглых скобок, запоминаются 
в ``памяти''. Эта память доступна двумя способами: через такое же
регулярное выражение используя нотацию обратной косой черты, или
позже в программе (до следующего регулярного выражения), используя
нумерованные скалярные переменные, доступные только для чтения.
<P>
<P>Для примера, скажем, мы разбираем вывод UNIX команды <CODE>who</CODE>:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        merlyn   tty14   May 01 14:42 (netserver5.omni.net)
</PRE>
</CODE></BLOCKQUOTE>
<P>Мы хотим выделить имя пользователя (первая колонка) и имя терминала
(вторая колонка), но нас не интересует остаток строки. Если данные в
переменной <CODE>$wholeline</CODE>, у нас получается что-то вроде:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
   
        if ($wholine =~ /([a-z]+) +([a-z0-9]+)/) {
                $user = $1;
                $tty = $2;
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Первая пара скобок выделяет имя пользователя (соответствует
<CODE>[a-z]+</CODE>), которое будет сохранено в <CODE>$1</CODE>, в случае
соответствия строки регулярному выражению. Это значение впоследствии
сохраняется в переменной <CODE>$user</CODE>. Таким же образом, имя терминала,
сохранённое в <CODE>$2</CODE>, запоминается в <CODE>$tty</CODE>.
<P>
<P>Эти символьные классы выглядят жутковато и, на самом деле, сломаются на
именах пользователей, содержащих цифры. Perl предоставляет несколько общих
аббревиатур классов символов, чтобы помочь уменьшить уровень
шума. <CODE>\s</CODE> соответствует любому пробельному символу (пробел,
табуляция, перевод строки), а <CODE>\S</CODE> соответствует любому
непробельному символу (всё, что не соответствует <CODE>\s</CODE>).
<P>
<P>В общем, можно написать так:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        if ($wholine =~ /(\S+)\s+(\S+)/) {
                $user = $1;
                $tty = $2;
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Таким образом, мы достигли обобщённости и улучшили читабельность
одновременно. Можно даже проще, <CODE>$1</CODE> и <CODE>$2</CODE> могут составить
список, и быть присвоенными напрямую <CODE>$user</CODE> и <CODE>$tty</CODE> как
список:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        if ($wholine =~ /(\S+)\s+(\S+)/) {
                ($user,$tty) = ($1,$2);
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Для дальнейшей оптимизации, мы положим данные в <CODE>$</CODE>_ и используем
тот факт, что оператор соответствия работает по умолчанию с <CODE>$_</CODE>, и
получаем:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  
        if (/(\S+)\s+(\S+)/) {
                ($user,$tty) = ($1,$2);
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Это немного укоротило программу. Но подождите ещё! Результатом оператора
соответствия в списковом контексте является список как у нас
<CODE>($1,$2)</CODE>. Таким образом, мы можем поставить присвоение как часть
выражения соответствия:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  
        if (($user,$tty) = /(\S+)\s+(\S+)/) {
                # (it matched)
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Теперь у нас ничего не осталось даже в теле <CODE>if</CODE>! Мы готовы
использовать <CODE>$user</CODE> и <CODE>$tty</CODE>!
<P>
<P>Давайте возьмём вывод <CODE>who</CODE>, по строке за раз, и посчитаем
количество, сколько каждый пользователь вошёл в систему, и покажем,
кто вошёл в систему больше одного раза.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  
        foreach $_ (`who`) { # one line each
                ($user,$tty) = /(\S+)\s+(\S+)/;
                $count{$user}++; # note count
                $where{$user}{$tty}++; # note ttys
        }
        foreach (sort keys %count) {
                if ($count{$_} > 1) {
                        print "user $_ is logged in at: ";
                        @where = sort keys %{$where{$_}};
                        print "@where\n";
                }
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Первый цикл собирает данные. Каждая строка, выводимая <CODE>who</CODE>
(представляет одну сессию), разбирается на имя пользователя и имя
терминала. Имена пользователей считаются в ассоциативном массиве
<CODE>%count</CODE>, чтобы мы могли учесть пользователей, имеющих больше
одной сессии. Также, <CODE>$user</CODE> и <CODE>$tty</CODE> сохраняются в
ассоциативном массиве ассоциативных массивов, называемом
<CODE>%where</CODE>. (Такая возможность недоступна в старых версиях Perl,
так что, если вы попробовали и у вас не заработало, обновите версию
Perl!) 
<P>
<P>После того, как первый цикл закончится, у нас будет счётчик сессий в
<CODE>%count</CODE> и подробная информация в <CODE>%where</CODE>. Второй цикл
сканирует массив <CODE>%count</CODE> используя сортированые ключи из
<CODE>%count</CODE> (имена пользователей). Если значение счётчика сессий
пользователя больше, чем один, значит пользователь вошёл в систему
больше, чем один раз. В этом случае, имя пользователя печатается
вместе со всеми именами терминалов, где он вошёл в систему. (Запись
<CODE>%{$where{$_}}</CODE> означает ассоциативный массив, на который
ссылается элемент ассоциативного массива <CODE>$where{$_}</CODE>&nbsp;---
да, это жуткий синтаксис, но не хуже, чем всё остальное в Perl.)
<P>
<P>В следующих выпусках я продолжу рассказ о интересных использованиях и
особенностях регулярных выражений. Следите за рекламой!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
