<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 17 -- Нахождение скрытых исполняемых файлов</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 17 -- Нахождение скрытых исполняемых файлов</H1>

<H2>Randal Schwartz</H2>Ноябрь 1997<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>В последние несколько месяцев я с возбуждением наблюдал за
великолепными изображениями, которые нам давал проект Mars
Pathfinder. Даже более интересным является связь Perl с этим проектом:
Larry Wall провел несколько лет в JPL (координаторы проекта
Pathfinder), и много начальной работы над Perl было проведено там. Вы
вероятно даже можете заключить пари о том, что часть этих изображений
была обработана и опубликована программами на Perl.
<P>В честь этого случая, я начал думать ``pathfinder'', ``pathfinder'',
и обнаружил типичную задачу, которая относится к другом типу пути, пути
к вашим командам командного процессора (В действительности, в течении
тестирования этой программы, я называл ее ``pathfinder'', что вполне
подходит).
<P>Если вы такой же как я, то вы делаете добавления в ваши пути поиска
каждый раз когда кто-нибудь говорит вам, что ``добавьте этот каталог в
ваш путь, чтобы воспользоваться этими утилитамиs''. Трудность
заключается в том, что путь поиска является линейным. Если программа с
именем ``clipper'' существует в каталоге, расположенном ранее в списке
поиска, то ``clipper'', расположенных в следующих в списке каталогах,
не будет виден, поскольку командный процессор использует принцип
``первым найден, первым запущен''.
<P>Но как вы можете узнать, что программа спрятана таким
способом. Командный процессор не может сообщить об этом. Но программа
на Perl может сделать это!
<P>Давайте глянем на задачу нахождения дубликатов в <CODE>PATH</CODE>.
Сначала нам необходимо получить элементы пути поиска:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my @path = split /:/, $ENV{PATH};
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, <CODE>PATH</CODE> является переменной среды, которая доступна
через специальный хэш <CODE>%ENV</CODE>, и которая затем разделяется по
символам двоеточия. Результатом этого является список
<CODE>@path</CODE>. Если существовали пустые элементы в <CODE>PATH</CODE>
(означая, что необходим поиск в текущем каталоге), то они будут
существовать как пустые строки.
<P>Затем мы должны удалить все повторяющиеся каталоги из ваших
путей. Как дубликаты оказываются там? Наиболее частым случаем является
то, что у вас есть что-то подобное:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    set path = (/strange/tool/bin $path);
</PRE>
</CODE></BLOCKQUOTE>
<P>в некотором файле настройки. Но вы также можете получить дубликаты
когда вы копируете один хороший файл .cshrc или
.profile на другую систему. Например, мой любимый файл
.cshrc содержит в путях поиска и /bin и
/usr/bin, но на некоторых системах, эти каталоги являются
одним и тем же каталогом (спасибо символическим ссылкам).
<P>Так, что мы не можем просто смотреть на имя каталога -- нам
необходимо рассматривать настоящий каталог. К счастью, вызов
<CODE>stat()</CODE> может дать нам значение устройства/узла, которое может
уникально идентифицировать каждую запись. Вот начало этого:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
    for (@path) {
      ...
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Теперь, внутри тела этого цикла, <CODE>$_</CODE> является одним из
каталогов из оригинального пути поиска. Мы сначала должны удалить любые
записи, которые не являются абсолютным путем. Это легко:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      next unless m#^/#;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, регулярное выражение <CODE>^/</CODE> запрашивает каждый элемент
(в <CODE>$_</CODE>) для того, чтобы убедиться, что он начинается с
<CODE>/</CODE>. Если вы чувствуете себя более уверено при использовании
<CODE>substr()</CODE>, то вы можете сделать что-то подобное этому
отрывку:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       next unless substr($_,0,1) eq &quot;/&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Но для меня это означает набор большего количества текста. Я
предпочитаю версию с использованием регулярного выражения.
<P>Далее, номер устройства и узла получаются с помощью вызова
<CODE>stat()</CODE>. Нам необходимо это для того, чтобы узнать, что два
имени указывают на один и тот же каталог. Номер устройства и узла
уникально идентифицируют каждую запись в файловой системе Unix. Если
<CODE>stat()</CODE> показывает, что значения одинаковы, то они
действительно одинаковы. Это выглядит так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      my ($dev,$ino) = stat;
      next unless defined $dev;
</PRE>
</CODE></BLOCKQUOTE>
<P>Если <CODE>stat</CODE> возвращает пустой список, то оригинальная запись
в <CODE>$_</CODE> не существует (или ее нельзя достичь). В этом случае
значение <CODE>$dev</CODE> равно <CODE>undef</CODE>. Вызов <CODE>stat</CODE>
возвращает список из 13 элементов, и мы игнорируем всё кроме двух
первых элементов.
<P>Отсюда мы конструируем строку <CODE>$key</CODE>, с пробелом между двумя
числами. Настоящий формат не является важным... нам просто нужна любая
пара числе, которая бы отличалась от любой другой пары чисел:
<P>
<BLOCKQUOTE><CODE>
<PRE>
     my $key = &quot;$dev $ino&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Это ключ далее используется как ключ к хэшу <CODE>%path_inodes</CODE>, в
поисках дубликатов. Если ключ уже существует, то мы увидим конкретный
каталог в этом пути и сообщим об этом. Это обрабатывается с помощью
функции <CODE>exists()</CODE>, которая возвращает истинное значение, если
указанный ключ найден в хэше.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      if (exists $path_inodes{$key}) {
        print &quot;warning: $_ is linked to $path_inodes{$key}\n&quot;;
        next;
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, <CODE>next</CODE> вызывает окончание оставшейся обработки
конкретного каталога, поскольку мы уже знаем, что он является
дубликатом.
<P>Если мы не нашли дубликатов, то мы просто добавляем данный каталог в
список <CODE>@clean_path</CODE>, и также помещаем его в хэш
<CODE>%path_inodes</CODE>. Ключом этого хэша является сконструированная
нами переменная <CODE>$key</CODE>, а значением хэша -- оригинальный путь к
каталогу. Мы не будем использовать его, но он был нужен во время
отладки.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      $path_inodes{$key} = $_;
      push @clean_path, $_;
</PRE>
</CODE></BLOCKQUOTE>
<P>В результате этого в <CODE>@clean_path</CODE> будут содержать пути без
дубликатов. Это важно, поскольку если есть дубликаты в путях, то мы на
следующем этапе получим огромное количество неправильных данных. Теперь
приступим к поиску повторяющихся имен в путях поиска.
<P>Одним из способов является проход по путям с помощью цикла
<CODE>foreach</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    for my $dir (@clean_path) {
      ...
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Внутри цикла нам необходимо получить содержимое указанного каталога,
<CODE>$dir</CODE>. Существует несколько способов сделать это, но давайте
будем использовать <CODE>DirHandle</CODE>. Для его использования, нам
необходимо загрузить правильный модуль.
<P>
<BLOCKQUOTE><CODE>
<PRE>
        use DirHandle;
</PRE>
</CODE></BLOCKQUOTE>
<P>Далее, для нужного каталога создается <CODE>DirHandle</CODE>, и читается
как список, вот каа здесь:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
        my @files =
        DirHandle-&gt;new($dir)-&gt;read;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, результат вызова  <CODE>new</CODE> для <CODE>DirHandle</CODE>
немедленно вызывает функцию <CODE>read</CODE>, что приводит к выдаче
полного списка имен в данном каталоге. Хорошим свойством этого кода
является то, что <CODE>DirHandle</CODE> автоматически закрывается в конце
этого выражения, поскольку мы не сохраняем его!
<P>Hо это не совсем правильно... нам не нужны файлы ``.'' or ``..'', и
для того, чтобы сделать отчет более красивым, нам надо отсортировать
его. Это легко -- просто добавьте в выражение операции <CODE>sort</CODE> и
<CODE>grep</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my @files =
        sort grep !/^\.\.?$/,
        DirHandle-&gt;new($dir)-&gt;read;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь функции <CODE>sort</CODE> передаются только те элементы которые не
соответствуют регулярному выражению (которое затрагивает только ``.'' и
``..'').
<P>Теперь, настало время пройти по списку <CODE>@files</CODE> и выбрать
файлы, которые мы уже видели в других каталогах. Этот кусок кода
подобен определению дубликатов в коде для заполнения
<CODE>@clean_path</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        for my $file (@files) {
        if (exists $progs{$file}) {
          print &quot;$file in $dir is shadowed by $progs{$file}\n&quot;;
          next;
        }
        $progs{$file} = $dir;
      }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь каждое из имен файлов помещается в переменную
<CODE>$file</CODE>. Если это имя уже существует в хэше <CODE>%progs</CODE>, то
мы увидим его в предыдущем каталоге и сообщим об этом. Если ключ не
существует, то мы запомним имя программы и каталог.
<P>Так что вот все куски кода. Однако нам еще надо склеить их в общую
программу, которая бы работала с использованием директивы <CODE>use
strict</CODE>, и в результате получим следующий код:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    #!/usr/bin/perl -w
    use strict;

        my @path = split /:/, $ENV{PATH};
    my %path_inodes;
    my @clean_path;
        
        for (@path) {
      next unless m#^/#;
      my ($dev,$ino) = stat;
      next unless defined $dev;
      my $key = &quot;$dev $ino&quot;;
      if (exists $path_inodes{$key}) {
        print &quot;warning: $_ is linked to $path_inodes{$key}\n&quot;;
        next;
      }
      $path_inodes{$key} = $_;
      push @clean_path, $_;
    }

        my %progs;

        ## print &quot;clean path is @clean_path\n&quot;;

        for my $dir (@clean_path) {
      use DirHandle;
      my @files =
        sort grep !/^\.\.?$/,
        DirHandle-&gt;new($dir)-&gt;read;
      ## print &quot;$dir: @files\n&quot;;
      for my $file (@files) {
        if (exists $progs{$file}) {
          print &quot;$file in $dir is shadowed by $progs{$file}\n&quot;;
          next;
        }
        $progs{$file} = $dir;
      }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Поместите его в каталог, находящийся в путях поиска (Если хотите,
назовите его ``pathfinder''), и запустите его, и вы увидите, все
программы, которые вы никогда не сможете запустить, поскольку они
скрыты. Hаслаждайтесь!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
