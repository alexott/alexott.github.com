<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 31 -- Развлечения с шаблонами для дождливых</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 31 -- Развлечения с шаблонами для дождливых</H1>

      дней
<H2>Randal Schwartz</H2>Апрель 2000<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Я вырос (и все еще живу) в Орегоне, о котором известно, что дожди там
идут почти во все времена года. Однако несколько месяцев весной
особенно влажно, и будучи ребенком, я часто был вынужден сидеть дома
во время особенно дождливых дней.
<P>
<P>Одной из вещей которыми я занимался сидя дома, была игра, чье
название я не хочу упоминать, поскольку она не нарушает ничьи торговые
марки, но в ней участвует два человека, спрашивающих друг друга о
различных вещах, подобных ``существительное'' или ``глагол,
оканчивающийся на -ed''. Кроме обучения нас частям речи, эта игра также
доставляла нам удовольствие, осознавая, что мы создаем рассказ заполняя
пробелы полного рассказа самыми неожиданными способами. Конечно,
творчески подходя к вопросам, мы получали намного лучшие рассказы.
<P>
<P>Какое отношение это имеет к Perl? Хорошо, я часто вижу вопросы ``как
я могу создать шаблон, который можно заполнить''? Для основных
применений ответом является ``посмотрите одно из решений работы с
шаблонами, которые можно найти на CPAN''. Так что, перейдите на
<A HREF="http://search.cpan.org">http://search.cpan.org</A> и введите слово
<CODE>template</CODE> в строке поиска, находящейся слева. Вы увидите
несколько способов применения существующего кода.
<P>
<P>Хотя для простых проблем, лучшим способом может быть
специализированный код. Программа, которая является основой нашей
колонки, является достаточно простой, так что мы можем
запрограммировать ее с самого начала, показывая что в таком подходе нет
ничего магического. Давайте начнем работу с простого шаблона:
<P>
<P>
<HR>
<PRE>
  The [человек] went to the [place].
</PRE>
<HR>
<P>Как мы можем превратить <CODE>[человек]</CODE> в вопрос ``дайте человек''
и поместить ответ обратно в строку? Нечто подобное данному коду будет
работать:
<P>
<P>
<HR>
<PRE>
  $_ = &quot;The [человек] went to the [place].&quot;;
  s/\[(.*?)\]/&amp;process($1)/eg;
  sub process {
    print &quot;дайте мне $_[0]: &quot;;
    chomp(my $response = &lt;STDIN&gt;);
    $response;
  }
  print;
</PRE>
<HR>
<P>Все что мы делаем здесь&nbsp;-- мы проходим по значению переменной
<CODE>$_</CODE> с выполнением глобальной подстановки. Каждый раз, когда вы
встречаем объект заключенный в кавычки, мы оцениваем правую часть
подстановки <EM>как код Perl</EM>. В этом случае, действие заключается
в запуске подпрограммы <CODE>process</CODE> с передачей ей переменной
<CODE>$1</CODE> в качестве параметра. Переменная получает входной параметр
для того, чтобы создать запрос к пользователю, а затем считывает мой
ответ. Возвращаемое процедурой значение становится заменяющим значением
для объекта заключенного в кавычки. Обратите внимание на <CODE>/eg</CODE> в
конце оператора подстановки: в этом случае мы получаем правую часть
оператора как <EM>выполненный</EM> код, с выполнением
<EM>глобальной</EM> подстановки.
<P>
<P>Для того, чтобы достигнуть большей гибкости кода, мы также можем
разрешить использование внутри скобок нескольких слов, включая переводы
строки. Код будет выглядеть следующим образом:
<P>
<P>
<HR>
<PRE>
  { local $/; $_ = &lt;DATA&gt; }
  s/\[(.*?)\]/&amp;process($1)/egs;
  sub process {
    my $prompt = shift;
    $prompt =~ s/\s+/ /g;
    print &quot;give me a $prompt: &quot;;
    chomp(my $response = &lt;STDIN&gt;);
    $response;
  }
  print;
  __END__
  The [sad человек] went to the [fun
  place to go].
</PRE>
<HR>
<P>Теперь мы получим запрос, похожий на следующее:
<P>
<P>
<HR>
<PRE>
  give me a sad человек: ____
  give me a fun place to go: ____
</PRE>
<HR>
<P>И значение в правой части будет заполнено соответствующим
образом. Добавление суффикса <CODE>s</CODE> к оператору подстановки
разрешает <CODE>.</CODE> соответствовать переводам строк. Внутри
подпрограммы мы превращаем все переводы строк в одиночные
пробелы. Также заметьте, что мы получаем шаблон из дескриптора файла
<CODE>DATA</CODE>, который начинается в конце программы, сразу после
отметки <CODE>__END__</CODE>.
<P>
<P>Теперь, давайте взглянем на будущие трудности. Предположим, что я
хочу задавать вопросы в порядке, отличающемся от того, как они будут
использоваться в истории. Это придает больше веселья, поскольку 
неожиданный ответ часто приводит к интересным сюрпризам.
<P>
<P>Для того чтобы сделать это, мне необходимо выполнять запросы, но
вместо немедленной подстановки сохранять ответы. Давайте введем
переменные, например так:
<P>
<P>
<HR>
<PRE>
  [person=человек]
  [place1=nearby place]
  [place2=far away place]
  [$person] went to [$place1], and then to [$place2].
  [$person] was [emotion after a long trip].
</PRE>
<HR>
<P>Здесь я ожидаю, что мы запросим о человеке, двух местах, а затем
выполним подстановку, а затем выполним запрос о эмоции и выполним
подстановку ответа сразу на место. Заметьте, что <CODE>person</CODE>
используется дважды.
<P>
<P>Мы скажем, что переменная должна быть идентификатором Perl (буквы,
цифры и знаки подчеркивания), в регулярном выражении соответствующие
<CODE>\w</CODE>. Таким образом, теперь скобки могут содержать три вещи и
подпрограмма обработки должна различать три разных случая: (1) простой
запрос, который необходимо заменить значением, (2) переменная, для
которой необходимо выполнить запрос и (3) ссылка на переменную, для
которой запрос уже выполнен.
<P>
<P>Мы будеи хранить значения переменных в хеше с именем
<CODE>%value</CODE>. Таким образом, подпрограмма <CODE>process</CODE> будеи
выглядеть так:
<P>
<P>
<HR>
<PRE>
  sub process {
    my $thing = shift;
    if ($thing =~ /^\$(\w+)$/) { # variable reference
      return $value{$1};
    }
</PRE>
<HR>
<P>До настоящего времени, мы получали значение между квадратными
скобками (получаемую как <CODE>$thing</CODE>), и если она равна знаку
доллара, за которым следует имя переменной, то мы будем возвращать
текущее значение данной переменной. Далее мы будем заменять переводы
строк, для тех случаев, когда начальная скобка находится на
отличающейся от строки на которой находится завершающая скобка:
<P>
<P>
<HR>
<PRE>
    $thing =~ s/\s+/ /g;  # handle wrapping
</PRE>
<HR>
<P>И затем мы будем обрабатывать случай ``определения'':
<P>
<P>
<HR>
<PRE>
    my $variable;
    $variable = $1 if $thing =~ s/^(\w+)=//; # может иметь значение undef
</PRE>
<HR>
<P>В этом месте, переменная <CODE>$variable</CODE> равна либо undef либо
имени переменной, которую надо определить и запомнить. Так что, левая
часть <CODE>$thing</CODE> является основой для запроса и затем получают
значение:
<P>
<P>
<HR>
<PRE>
    print &quot;Give me a&quot;, $thing =~ /^[aeiou]/i ? &quot;n &quot; : &quot; &quot;, $thing, &quot;: &quot;;
</PRE>
<HR>
<P>Заметьте, что здесь есть дополнительная обработка, для того чтобы
использовать в запросе ``an apple'' или ``a carrot'' при задании
``apple'' и ``carrot''. В заключении, давайте выполним запрос:
<P>
<P>
<HR>
<PRE>
    chomp(my $response = &lt;STDIN&gt;);
    if (defined $variable) {
      $value{$variable} = $response;
      return &quot;&quot;;
    }
    return $response;
  }
</PRE>
<HR>
<P>Заметьте, что если в скобках определяется переменная, то не
возвращается никакого значения. Если вы хотите, чтобы определение
автоматически запускалось, то вы можете опустить <CODE>return
&quot;&quot;</CODE>. Любой из способов является хорошим.
<P>
<P>Так что мы теперь получили некоторый хороший код и он работает для
приведенного ранее примера. Однако, если вы запустили этот код, то вы
смогли заметить в выводе лишние переводы строк. Почему это происходит?
Строки определения:
<P>
<P>
<HR>
<PRE>
  [person=человек]
  [place1=nearby place]
  [place2=far away place]
</PRE>
<HR>
<P>заменяются ``ничем'', за которым следует перевод строки, и это
происходит три раза. (Если вы до этого работали с <EM>m4</EM>, то вы
можете посчитать это как необходимость использования в вашем вводе
частых конструкций <CODE>dnl()</CODE>). Это немного неудобно, так что
давайте будет отдельно обрабатывать такие случаи. Если строка полностью
состоит из объекта заключенного в кавычки, то перевод строки
автоматически удаляется. 
<P>
<P>
<HR>
<PRE>
  s&lt;^\[([^]]+)\]\s*\n|\[([^]]+)\]&gt;
   {&amp;process(defined $1 ? $1 : $2)}meg;
</PRE>
<HR>
<P>Здесь я вновь использую операцию <CODE>s/old/new/eg</CODE>, разделяя две
строки используя альтернативные разделители. Заметьте, что образец
поиска состоит из двух отдельных регулярных выражений, которые
объединены вертикальной линией:
<P>
<P>
<HR>
<PRE>
  ^\[([^]]+)\]\s*\n
</PRE>
<HR>
<P>и
<P>
<P>
<HR>
<PRE>
  \[([^]]+)\]
</PRE>
<HR>
<P>Последняя часть должна быть аналогичной... она подобна той, которую
мы использовали. Первая часть соответствует полной строке, которая
состоит только из объекта заключенного в скобки, так что мы можем
удалить перевод строки.
<P>
<P>Правая часть оператора замены стала более сложной, поскольку нам
надо использовать либо <CODE>$1</CODE> либо <CODE>$2</CODE>, в зависимости от
того, какой из шаблонов поиска был выбран. Для этого используется
оператор <CODE>defined()</CODE>. И в заключение, оператор подстановки
использует дополнительный суффикс <CODE>m</CODE>, означая, что символ
<CODE>^</CODE> в регулярном выражении соответствует любому переводу строки,
и соответственно суффикс произносится как <CODE>meg</CODE>, поскольку
прошлой ночью смотрел фильм Meg Ryan на DVD.
<P>
<P>И еще одно: у нас нет способа включения в текст символов левых и
правых квадратных кавычек, так что давайте для этого будем использовать
<CODE>[LEFT]</CODE> и <CODE>[RIGHT]</CODE>. Это можно сделать включив следующие
строки в начало подпрограммы <CODE>process</CODE>:
<P>
<P>
<HR>
<PRE>
    return &quot;[&quot; if $thing eq &quot;LEFT&quot;;
    return &quot;]&quot; if $thing eq &quot;RIGHT&quot;;
</PRE>
<HR>
<P>Давайте теперь совместим все кусочки кода. И для того, чтобы
продемонстрировать как легко может быть использована эта программа, я
нашел архив с разными историями ``для заполнения'' по адресу 
<A HREF="http://www.mit.edu/storyfun/">http://www.mit.edu/storyfun/</A>, и помещу следующую историю в конец
программы:
<P>
<P>
<HR>
<PRE>
  { local $/; $_ = &lt;DATA&gt; }
  s/^\[([^]]+)\]\s*\n|\[([^]]+)\]/&amp;process(defined $1 ? $1 : $2)/meg;
  sub process {
    my $thing = shift;
    return &quot;[&quot; if $thing eq &quot;LEFT&quot;;
    return &quot;]&quot; if $thing eq &quot;RIGHT&quot;;
    if ($thing =~ /^\$(\w+)$/) { # variable reference
      return $value{$1};
    }
    $thing =~ s/\s+/ /g;  # handle wrapping
    my $variable;
    $variable = $1 if $thing =~ s/^(\w+)=//; # may be undef
    print &quot;Give me a&quot;, $thing =~ /^[aeiou]/i ? &quot;n &quot; : &quot; &quot;, $thing, &quot;: &quot;;
    chomp(my $response = &lt;STDIN&gt;);
    if (defined $variable) {
      $value{$variable} = $response;
      return &quot;&quot;;
    }
    return $response;
  }
  print;

  __END__
  [LEFT]... from &lt;htmlurl url="http://www.mit.edu/storyfun/I_went_for_a_walk">[RIGHT]
  [adj1=adjective]
  [place=place]
  [verbed=verb (ending in -ed)]
  [adj2=adjective]
  [nouns=plural noun]
  [plants=plural plant]
  [adj3=adjective]
  [adj4=adjective]
  [adj5=adjective]
  [noun=noun]
  [verbing=verb (ending in -ing)]
  [verb_past=verb (past tense)]
  [animals=plural animal]

  [your name] went for a walk

  Yesterday, I went out walking, and somehow ended up in [$place]. I saw
  [$plants] and [$animals] -- it was [$adj2]! But I started getting
  [$adj5] hungry, and needed to find my way home. But no matter where I
  [$verb_past], I couldn't see the path. I decided to go around the
  [$adj1] [$noun] up ahead, and discovered that it led back home! I was
  [$verbed]. At dinner, when I told my [$adj3] story, my [$nouns] looked
  at me with [$adj4] expressions. Then they forbade me from ever
  [$verbing] again.
</PRE>
<HR>
<P>Так что вам никогда не нужно будет беспокоиться в эти дождливые дни
или тогда, когда вам нужно будет ``заполнять'' шаблоны. Perl может
помочь вам провести время, и выполнить эту задачу более
эффективно. Встретимся в следующий раз, наслаждайтесь!
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
