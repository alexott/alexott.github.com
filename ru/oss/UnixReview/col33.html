<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 33 -- Режим Taint</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 33 -- Режим Taint</H1>

<H2>Randal Schwartz</H2>Июнь 2000<P>[Предполагаемый заголовок: Испортить так просто, не так ли?]
<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>Если вы читали мою колонку в течении некоторого времени, то вы
вероятно заметили, что я упоминаю о ``taint-режиме'', обычно коротко,
при описании строки такого типа:
<P>
<HR>
<PRE>
        #!/usr/bin/perl -Tw
</PRE>
<HR>
<P>что включает выдачу предупреждений (ключ <CODE>-w</CODE>) и ``режим
taint'' (ключ <CODE>-T</CODE>). Но что такое режим taint?
<P>Taint режим является свойством безопасности для Perl, и включает в
себя два уровня выполнения. В первую очередь, при включенном taint
режиме, выполнение некоторых операций запрещено. Одной из них является
то, что <CODE>$ENV{PATH}</CODE> не может содержать каталоги доступные для
записи всеми пользователями при запуске дочернего процесса (например с
помощью обратных кавычек или функции <CODE>system</CODE>). Когда ваша
программа предпринимает небезопасное действие, то программа сразу же
прерывается (через вызов <CODE>die</CODE>), до того, как действие получит
возможность выполнить возможное нарушение безопасности.  Вы можете
включить код, который сам будет проверять все действия, но вы можете
заставить Perl выполнять проверки для обеспечения устойчивости и уровня
``наилучшего выполнения'', который вы можете не создать или явно
включить.
<P>
<P>Второй уровень взаимодействия является более интересным и уникальным
для Perl (среди всех популярных языков программирования, которые я
знаюa), на котором Perl отслеживает ``ненадежность'' каждого скалярного
значения программы. Любой объект полученный из внешних источников
(аргументы командной строки, переменные среды, информация о
локализации, некоторые системные вызовы и все операции ввода из файлов)
отмечается как ``испорченный''.
<P>
<P>Например, следующие операции создают испорченные данные:
<P>
<P>
<HR>
<PRE>
  $t1 = &lt;STDIN&gt;;
  $t2 = $ENV{USER};
  $t3 = $ARGV[2];
  @t4 = &lt;*.txt&gt;;
</PRE>
<HR>
<P>В каждом из этих примеров, данные получаются ``из внешнего мира'', и
поэтому трактуются как потенциальное опасные. После того, как данные
отмечены как испорченные, порча распространяется на любые данные
<EM>полученные</EM> из испорченных данных:
<P>
<P>
<HR>
<PRE>
  $t5 = $t4[0];
  $t6 = &quot;/home/$t2&quot;;
  chomp($t1);
  @x = (&quot;help&quot;, &quot;me&quot;, $t3, &quot;please&quot;);
</PRE>
<HR>
<P>Заметьте, что порча осуществляется на уровне скаляров. Так, что
испорченным является только элемент <CODE>$x[2]</CODE>, а не весь массив
<CODE>@x</CODE>.
<P>
<P>После того, как данные помечена как ``грязные'', то будет
блокирована любая попытка использования данных подверженных внешнему
воздействию, вызывая немедленное завершение процесса через оператор
<CODE>die</CODE> с нарушением режима taint. Например, запуск команды
<CODE>rename</CODE>, когда либо имя исходного файла, либо имя файла
назначения является ``загрязненным'', рассматривается угрожающим. Однако
разрешается нормальное использование команды:
<P>
<P>
<HR>
<PRE>
  rename $x[0], $x[1];
</PRE>
<HR>
<P>Но не операция, которые используют ``испорченные'' данные (вспоминая
о том, что <CODE>$x[2]</CODE> была испорчена ранее):
<P>
<P>
<HR>
<PRE>
  rename $x[0], $x[2];
</PRE>
<HR>
<P>Это значит, что данные, которые были получены из внешнего мира,
также не могут тривиально воздействовать на внешний мир. Почему это так
важно?
<P>
<P>Хорошо, обычным использованием режима taint является безопасное
выполнение программ, которые действуют от лица других
пользователей. Например. программы с установленным битом пользователя
или группы на время выполнения берут привелегии владельца программы,
позволяя обычным пользователям для определенного набора задач роли
работать в роли администратора (или  другого пользователя). Или при
выполнении программ CGI, выполняющихся под правами web-сервера (обычно
это права пользователя <CODE>nobody</CODE>), позволяя работать с правами
пользователя используя запрос любого пользователя и обычно без прямого
доступа к серверу, а только через web-сервер.
<P>
<P>В обоих случаях, важным является то, что проверяются входные данные,
так что пользователю, запускающему программу, не позволяется нарушить
привелегии пользователя, под которым запускается программа, для
выполнения неразрешенных действий.
<P>
<P>Например, может быть очень опасным переименование файла, основываясь
на данных, полученных из формы CGI:
<P>
<P>
<HR>
<PRE>
  use CGI qw(param);
  ...
  my $source = param('source');
  my $dest = param('destination');
  rename $source, $dest;
</PRE>
<HR>
<P>Возможно, что автор этого скрипта CGI верит, что поскольку форма
содержит только радио-кнопки или всплывающее меню, которые снов
определяют данные, то у него будет безопасная программа. В
действительности, человек со склонностью к разрушению, может легко
запустить этот скрипт с произвольными данными в качестве
<CODE>source</CODE> и <CODE>destination</CODE>, и возможно переименовать любой
файл, к которому имеет доступ пользователь, под которым запущен скрипт!
<P>
<P>При включенном режиме taint, параметры CGI (полученные при чтении
стандартного потока ввода или через переменные среды) помечаются как
``грязные'' и поэтому операция <CODE>rename</CODE> даст сбой до нанесения
потенциального ущерба. (Для включения режима taint для скриптов
CGI, просто включите ключ <CODE>-T</CODE> в строку <CODE>#!</CODE>, как это
показывалось ранее). И это точно будут самые безопасные вещи, которые
будут делать здесь.
<P>
<P>но иногда существуют ситуации, когда входные данные легально должны
воздействовать на внешний мир. Вот следующее свойство, с которым режим
taint приходит. Как некоторое исключение, результат запоминания в
регулярном выражении (доступ к которому обычно происходит через
нумерованую переменную, такие как <CODE>$1</CODE> и <CODE>$2</CODE> и так
далее) никогда не отмечается как ``грязный'', даже если сравнение
производится с ``загрязненными данными. При правильном использовании
это дает нам ``хорошо защищенные ворота в заборе''. Например:
<P>
<P>
<HR>
<PRE>
  my $source = param('source');
  unless ($source =~ /^(gilligan|skipper|professor)$/) {
    die &quot;unexpected source $source\n&quot;;
  }
  $safe_source = $1;
</PRE>
<HR>
<P>Здесь ожидается, что значение <CODE>$source</CODE> будет одним из набора
<CODE>gilligan</CODE>, <CODE>skipper</CODE> или <CODE>professor</CODE>. Если это не
так, то программа завершит выполнение до копирования данных в
переменную <CODE>$safe_source</CODE>. (Заметьте, что скобки в регулярном
выражении выполняют двойную работу, обеспечивая правильное
предшевтсвование относительно вертикальных линий и значениями начала и
конца строки, а также в качестве побочного явления определяют первую
переменную на которую производится ссылка.Иногда вы становитесь
счастливыми).
<P>
<P>Теперь значение переменной <CODE>$safe_source</CODE> является допустимым
для использования в вышеприведенной операции <CODE>rename</CODE>, поскольку
оно получается из регулярного выражения, а не напрямую из входных
данных. В действительности, мы даже можем снова присвоить ее переменной
<CODE>$source</CODE> (что является часто применяемым действием):
<P>
<P>
<HR>
<PRE>
  $source = $1; # source now untainted
</PRE>
<HR>
<P>Конечно, мы должны выполнить аналогичную операцию над переменной
<CODE>$destination</CODE>, для того, чтобы завершить работу.
<P>
<P>Так, что если кто-то попытается задать неправильное значение для
исходного параметра, например такое как <CODE>ginger</CODE>, то программа
прекратит свое выполнение, и при включенном и при выключенном режиме
taint, но в режиме taint программа работает, поскольку мы
добавили дополнительный код для выполнения сравнения с регулярным
выражением, для чего нам нужно было выяснить какие могут быть возможные
значения строки.
<P>
<P>И теперь мы переходим к следующей точке: обычно мы не можем выполнять
явную проверку относительно известного списка значений. Очень часто,
данные являются значением указанным пользователем, и которые необходимо
подвести под общее описание, но также снова, регулярные выражения
являются достаточно хорошими для соответствия многим вещам.
<P>
<P>Например, допустим, что <CODE>$source</CODE> получаем из текстового
поля, а не из списка выбора, разрешая таким образом ввод привольных
данных. Как мы теперь можем передать ее оператору <CODE>rename</CODE>?
Хорошо, сначала мы решим, какой должна быть нормальная
строка. Например, давайте введем ограничение, чтобы имена файлов
содержали только символы попадающие соответствующие классу символов
<CODE>\w</CODE>, включая символ точки (также разрешая использование точки в
качестве первого символа имени файла). Это будет выглядеть вот так:
<P>
<P>
<HR>
<PRE>
  $source = param('source');
  $source =~ /^(\w[\w.]*)$/ or die;
  $source = $1;
</PRE>
<HR>
<P>Так что снова, если строка не соответствует образцу, то программа
прекращает выполнение. И только в том случае, если мы не прекратили
работу, мы продолжим использование переменной <CODE>$1</CODE>, которая была
проверена на соответствие ожидаемой формы имени.
<P>
<P>Заметьте, что <EM>очень</EM> важно проверить результат соответствия
регулярному выражению, поскольку переменная <CODE>$1</CODE> (а также
остальные переменные) получает значение, только когда произошло
соответствие регулярному выражению. В противном случае мы получим
результат предшествующего сравнения, и это будет действительно плохой
новостью для нас:
<P>
<P>
<HR>
<PRE>
  ## bad code do not use ##
  $param('source') =~ /^(\w[\w.]*)$/;
  $source = $1;
  ## bad code do not use ##
</PRE>
<HR>
<P>Немного более компактным способом записи вышеприведенного кода может
быть следующий код:
<P>
<P>
<HR>
<PRE>
  my ($source) = param('source') =~ /^(\w[\w.]*)$/
    or die &quot;bad source&quot;;
</PRE>
<HR>
<P>Здесь, я неявно использую переменную <CODE>$1</CODE> как список,
возвращенный соответствием регулярному выражению, объявляю переменную
для хранения результата и выполняю проверку ошибок, все это в одном
компактном выражении.
<P>
<P>Шаблон регулярного выражения должен быть таким, каким вы захотите,
Например, если вы используете шаблон <CODE>/(.*)/s</CODE>, то вы эффектно
удалитесь из под действия режима taint, для отдельных данных,
оставляя потенциальную возможность для взламывания вашей программы с
помощью непредусмотренных вами способов.
<P>
<P>Так, что я надеюсь, что это дало вам немного понимания того, как
использовать режим taint, а также объяснение того, почему это
полезно. Если эта статья 'taint достаточно для вас, то я
предполагаю. что вы прочитаете справочную страницу <CODE>perlsec</CODE>
(возможно используя команду <CODE>perldoc perlsec</CODE>). Встретимся в
следующий раз, наслаждайтесь вашим новыми знаниями о безопасности.
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
