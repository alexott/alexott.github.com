<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 6 -- Сортировка</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 6 -- Сортировка</H1>

<H2>Randal Schwartz</H2>Январь 1996<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt;, Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt;, Grigoriy Strokin
&gt;grg@isabase.philol.msu.ru&lt;
<P>Одна из наиболее важных задач по управлению данными&nbsp;--- это
приведение их в какой-нибудь осмысленный порядок. Perl предоставляет
довольно мощную операцию <CODE>sort</CODE>, которая обладает огромной
гибкостью. Я собираюсь поговорить о некоторых способах сортировки, и,
надеюсь, вы сможете сортировать что угодно, когда закончите чтение. (Нет,
несмотря на моё имя, я не буду говорить о ``случайной сортировке'').
<BLOCKQUOTE>Randal похоже на random -- произвольный, случайный
(англ.).&nbsp;--- Прим. переводчика.</BLOCKQUOTE>
<P>Давайте возьмём простой случай. Где-то в программе на Perl у меня есть
список слов, и я хочу отсортировать их в алфавитном порядке (технически, в
возрастающем порядке кодов ASCII
<BLOCKQUOTE>Случай не-латинского алфавита
здесь не рассматривается. Он вообще редко рассматривается в англоязычной
литературе. Смотрите документацию на locale.&nbsp;---
Прим. переводчика.</BLOCKQUOTE>
).  Это достаточно легко.
<P>
<HR>
<PRE>
        @somelist = ("Fred","Barney","Betty","Wilma");
        @sortedlist = sort @somelist;
</PRE>
<HR>
<P>Здесь мы помещаем значение <CODE>(``Barney'',``Betty'',``Fred'',
``Wilma'')</CODE> в <CODE>@sortedlist</CODE>. Если бы эти имена были в файле, я
мог бы прочитать их оттуда:
<P>
<HR>
<PRE>
   
        #!/usr/bin/perl
        @somelist = &lt;>; # read everything
        @sortedlist = sort @somelist;
        print @sortedlist;
</PRE>
<HR>
<P>В этом случае <CODE>@somelist</CODE> (и <CODE>@sortedlist</CODE> тоже) также
будут иметь символы новой строки в конце каждого имени. Это нормально,
поскольку никак не влияет на порядок сортировки, и делает печать намного
легче.
<P>Конечно, это можно немного сократить:
<P>
<HR>
<PRE>
   
        #!/usr/bin/perl
        @somelist = &lt;>;
        print sort @somelist;
</PRE>
<HR>
<P>И даже больше:
<P>
<HR>
<PRE>
   
        #!/usr/bin/perl
        print sort &lt;>;
</PRE>
<HR>
<P>(Я полагаю, это как раз то, что придаёт Perl репутацию нечитабельного
языка). Как вы видите, здесь я вообще не использую переменных. Тем не
менее, это на самом деле делает сортировку того, что читается, и печатает
результат.
<P>Такие виды сортировки хороши для текстовых данных. Однако если данные
цифровые, мы получим неправильный порядок: сравнение чисел 15 и 3 как строк
поставит 3 после 15, а не наоборот. Поскольку по умолчанию <CODE>sort</CODE>
сравнивает строки как текстовые, нам необходимо каким-либо образом сказать
<CODE>sort</CODE> делать вместо текстовой сортировки числовую.
<P>Для всех видов данных, кроме текстовых, необходимо использовать
``подпрограмму сортировки''. Это работает просто&nbsp;--- в момент, когда
Perl смотрит на два элемента из списка, пытаясь выяснить как упорядочить
элементы, ему необходимо выполнить некоторого рода сравнение. По умолчанию,
это обычное сравнение строк ASCII. Однако вы можете задать свою функцию
сравнения элементов, используя подпрограмму сортировки, при выполнении
которой будут действовать следующие соглашения:
<P>
<OL>
<LI>Ваша подпрограмма сортировки будет многократно вызываться для
двух элементов из списка.</LI>
<LI> Эти два элемента будут помещаться в переменные <CODE>$a</CODE> и
<CODE>$b</CODE>.  (Нет нужды делать их локальными или смотреть на
<CODE>@_</CODE>).</LI>
<LI> Вам необходимо ``сравнить'' <CODE>$a</CODE> и <CODE>$b</CODE> в
подпрограмме сортировки, и решить, которое из них больше.</LI>
<LI> Вам необходимо вернуть -1, 0, +1, в зависимости от того,
<CODE>$a</CODE> ``меньше чем'', ``равно'' или ``больше чем''
<CODE>$b</CODE>, используя свою операцию сравнения.</LI>
</OL>
<P>Те, кто знаком с функцией <CODE>qsort</CODE> из библиотеки языка C, должны
быть знакомы с такой подпрограммой. На самом деле, Perl использует именно
функцию <CODE>qsort</CODE>, так что ничего удивительного.
<P>Таким образом, подпрограмма сортировки, которая делает числовое, а не
текстовое сравнение, выглядит так:
<P>
<HR>
<PRE>
        sub numerically {
                if ($a &lt; $b) { -1; }
                elsif ($a == $b) { 0; }
                else { +1; }
        }
</PRE>
<HR>
<P>Теперь всё, что мы должны сделать&nbsp;--- это сказать Perl использовать
как функцию сравнения эту подпрограмму сортировки, а не встроенную
сортировку в ASCII-порядке. Это делается помещением имени подпрограммы (без
стоящего впереди амперсанда) между ключевым словом ``<CODE>sort</CODE>'' и
сортируемым списком. Например:
<P>
<HR>
<PRE>
   
        @newlist = sort numerically 32,1,4,8,16,2;
</PRE>
<HR>
<P>Так вместо списка, отсортированного в порядке ASCII (как это было бы,
если бы я не поставил слово ``numerically'') я получаю правильную числовую
последовательность степеней двойки в <CODE>@newlist</CODE>.
<P>Численное сравнение <CODE>$a</CODE> и <CODE>$b</CODE> возвращающее в результате
-1, 0, или +1, выполняется так часто, что Ларри Уол (Larry Wall) решил, что
оно заслуживает своего собственного оператора ``&lt;=>'', который стал
известен как ``космический корабль'' по причинам, которые я не стал бы
обсуждать. Таким образом, я могу сократить ``numeracally'' следующим
образом:
<P>
<HR>
<PRE>
   
        sub numerically {
                $a &lt;=> $b;
        }
</PRE>
<HR>
<P>Теперь это настолько коротко, что кажется лишним определять отдельную
процедуру, и на самом деле, Perl позволяет ещё более компактную запись:
подставить фрагмент кода, ответственный за сортировку, в вызов функции
<CODE>sort</CODE>, подобно такому:
<P>
<HR>
<PRE>
   
        @newlist = sort { $a &lt;=> $b; } @oldlist;
</PRE>
<HR>
<P>Взаимодействие с этим сортирующим блоком в точности такое же, как я
описал с подпрограммой раньше. Просто такая запись немного
компактнее. Лично я использую этот стиль для сортировочных подпрограмм не
длиннее 40 символов и создаю нормальную подпрограмму для больших.
<P>Давайте снова посмотрим на чтение списка чисел со стандартного ввода:
<P>
<HR>
<PRE>
   
        #!/usr/bin/perl
        print sort numerically &lt;>;
        sub numerically { $a &lt;=> $b; }
</PRE>
<HR>
<P>Теперь, если я передам этой программе список чисел, то я получу
отсортированный список чисел. Эта функциональность эквивалентна команде
UNIX ``sort'' с ключом ``-n''.
<P>Рассмотрим более интересный пример. Предположим, что у меня есть файл с
именами в первой колонке и количеством очков, набранных при игре в боулинг,
во второй:
<P>
<HR>
<PRE>
   
        Fred 210
        Barney 195
        Betty 200
        Wilma 170
        Dino 30
</PRE>
<HR>
<P>и я хочу отсортировать этот список по количеству очков. Получить данные
в программе довольно просто:
<P>
<HR>
<PRE>
   
        #!/usr/bin/perl
        @data = &lt;>;
</PRE>
<HR>
<P>но каждый элемент <CODE>@data</CODE> выглядит как ``Fred 210\n'', и тому
подобное. Как мне отсортировать список <CODE>@data</CODE>, но глядя только на
число, а не на имя?
<P>Пожалуй, я бы выделил число из строки. Как я это сделаю? Один из
способов&nbsp;--- разбить строку с помощью ``split'':
<P>
<HR>
<PRE>
   
        $a = "Fred 210\n";
        ($name,$score) = split /\s+/, $a;
</PRE>
<HR>
<P>Здесь я разбиваю <CODE>$a</CODE> по пробелам, получая список список из двух
элементов. Первый элемент попадает в <CODE>$name</CODE> (который нас не
интересует, на самом деле), второй элемент попадает в <CODE>$score</CODE>. Вот
теперь всё, что мне надо,&nbsp;--- это сказать Perl смотреть только на
количество очков:
<P>
<HR>
<PRE>
   
        sub scores {
                ($name_a,$score_a) = split /\s+/, $a;
                ($name_b,$score_b) = split /\s+/, $b;
                $score_a &lt;=> $score_b;
        }
</PRE>
<HR>
<P>и, на самом деле, это именно так и работает!
<P>
<HR>
<PRE>
   
        #!/usr/bin/perl
        sub scores { ... } # as above
        print sort scores &lt;>;
</PRE>
<HR>
<P>Так, что неправильно в этой картине? Было бы здорово, если бы мы
смотрели на каждый элемент списка только один раз. Тем более, после того,
как мы сравним счёт Fred'а и счёт Barney (и решим, что Fred лучше), нам так
же придётся сравнивать счёт Fred'а со счётом Betty. Это значит, что данные
о Fred'e нам придётся разбивать дважды. А для огромного списка нам придётся
выполнять одно и то же разбиение снова и снова.
<P>Есть несколько способов этого избежать. Один из них, это создать
отдельный массив, который содержит только количество очков, и затем
сортировать этот массив. Давайте посмотрим сначала на этот способ.
<P>Наша цель сначала прочитать данные, затем создать ассоциативный массив,
чьи ключи представляют отдельный элемент массива, а значения представляют
количество очков. Затем мы упростим задачу до поиска в ассоциативном
массиве вместо (возможного) лишнего разбиения строки.
<P>
<HR>
<PRE>
   
        @data = &lt;>; # read data
        foreach (@data) {
                ($name,$score) = split; # get score
                $score{$_} = $score; # record it
        }
</PRE>
<HR>
<P>Теперь значением <CODE>$score{``Fred 210\n''}</CODE> будет 210, и так далее,
для каждого элемента массива <CODE>@data</CODE>.
<P>Далее мы должны использовать эту информацию. Для этого нам нужна
подпрограмма, которой будут передаваться два элемента из <CODE>@data</CODE> в
переменных <CODE>$a</CODE> и <CODE>$b</CODE>. Подпрограмма находит соответствующие
значения в <CODE>\%score</CODE> и численно их сравнивает:
<P>
<HR>
<PRE>
   
        sub score {
                $score{$a} &lt;=> $score{$b};
        }
</PRE>
<HR>
<P>и она на самом деле делает это. Давайте сложим эти кусочки вместе:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        @data = &lt;>; # read data
        foreach (@data) {
                ($name,$score) = split; # get score
                $score{$_} = $score; # record it
        }
        print sort {
                $score{$a} &lt;=> $score{$b};
        } @data;
</PRE>
<HR>
<P>Заметьте, что в этой версии я вписал подпрограмму сортировки как блок в
строке sort. (Я просто пытался дать вам побольше альтернативных форм
записи).
<P>Другой способ подойти к проблеме&nbsp;--- это сжать список в список
пар. Второй элемент каждой пары (в действительности, анонимный список из
двух элементов) будет ключом сортировки, а первый будет оригинальным
значением (так мы всегда сможем вернуться к оригинальным данным). Это лучше
всего делается с помощью оператора ``map'' (в старых версиях Perl
отсутствует).
<P>
<HR>
<PRE>
        @pairs = map {
                ($name, $score) = split;
                [ $_, $score ];
        } @data;
</PRE>
<HR>
<P>Здесь блок программы выполняется для каждого элемента массива
<CODE>@data</CODE> с <CODE>$_</CODE>, установленным на элемент. Это приводит к
тому, что элемент разбивается на <CODE>$name</CODE> и <CODE>$score</CODE>, и затем
я строю двух-элементный анонимный список из <CODE>$score</CODE> и оригинального
значения <CODE>$_</CODE>. Эти анонимные массивы собираются в новый список. Если
<CODE>@data</CODE> имеет пять элементов, тогда <CODE>@pairs</CODE> имеет тоже пять
элементов, каждый из которых является ссылкой на двух-элементный анонимный
список. Ох!
<P>Следующим шагом отсортируем список <CODE>@pairs</CODE>. Внутри подпрограммы
сортировки <CODE>$a</CODE> и <CODE>$b</CODE> будут ссылками на двух-элементные
списки. Второй элемент каждого списка&nbsp;--- это ключ для сортировки, и
адресуется как <CODE>$a->[1]</CODE>. Таким образом, мы получаем подпрограмму
сортировки:
<P>
<HR>
<PRE>
        sub mangle {
                $a->[1] &lt;=> $b->[1];
        }
</PRE>
<HR>
<P>и сортировка выглядит так:
<P>
<HR>
<PRE>
        @sorted = sort mangle @pairs;
</PRE>
<HR>
<P>Теперь <CODE>@sorted</CODE> является таким же списком пар данных, как
<CODE>@pairs</CODE>, но отсортированных по количеству очков (вы ещё не забыли,
что мы работаем с очками?). Мне придётся убрать анонимный список, чтобы
получить назад оригинальные данные, но сохраняя порядок. Это легко,
<CODE>map</CODE> спасёт нас снова:
<P>
<HR>
<PRE>
        @finally = map {
                $_->[0];
        } @sorted;
</PRE>
<HR>
<P>Это потому, что <CODE>$_</CODE> будет равен каждому элементу
<CODE>@sorted</CODE>&nbsp;--- ссылке на анонимный список, и поэтому,
<CODE>$->[0]</CODE> будет доставать первый элемент анонимного списка,
указанного в <CODE>$_</CODE>, который является оригинальными данными. Вот так
вот!
<P>Конечно, если использовать традиционный для Perl стиль, то я могу
склеить это вместе таким образом, что все будет очень похоже
на<CODE>LISP</CODE>.  Чтобы понять, что происходит, вам нужно будет прочитать
этот фрагмент задом наперед:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        print
                map { $_->[0] }
                sort { $a->[1] &lt;=> $b->[1] }
                map {
                        ($name,$score) = split;
                        [$_,$score];
                } &lt;>;
</PRE>
<HR>
<P>Ого. Однако это работает!
<P>И последняя оптимизация: Я могу поставить разбиение строки прямо внутри
создания списка:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        print
                map { $_->[0] }
                sort { $a->[1] &lt;=> $b->[1] }
                map { [$_, (split)[1] ] }
                &lt;>;
</PRE>
<HR>
<P>это работает потому, что <CODE>split</CODE> делит строку <CODE>$_</CODE> на
``текстовые части''&nbsp;--- только второй элемент списка остаётся после
того, как мы его вырежем.
<P>Perl предоставляет несколько мощных методов сортировки, которые могут
быть действительно удобны после того, как вы хорошо их освоите. Я надеюсь,
что я вас больше вдохновил, чем смутил. В следующий раз я расскажу про
что-нибудь другое.
<HR>
Next
Previous
Contents
</BODY>
</HTML>
