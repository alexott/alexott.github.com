<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 12 -- Внутpенние документы (Here documents)</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 12 -- Внутpенние документы (Here documents)</H1>

<H2>Randal Schwartz</H2>Январь 1997<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
lt;ott@phtd.tpu.edu.ru&gt;
<P>Одним из отточенных свойств Perl является возможность обеспечения данных
внутри программы, представляя данные в различных формах, вместо того, чтобы
хранить эти данные во временных файлах или в файлах настройки. Одним из
часто используемых способов являются ``here document (внутренний документ)''
(также называемые ``here-doc''). Давайте посмотрим что это такое.
<P>В первую очередь, ``внутренний документ'' это ничто иное, как длинное
(обычно многостроковое) строковое значение, но объявленное особым
образом. Вот простой пример:
<P>
<HR>
<PRE>
        $a = &lt;&lt;END;
        Some stuff
        goes here.
        END
</PRE>
<HR>
<P>Это аналог записи:
<P>
<HR>
<PRE>
        $a = &quot;Some stuff\ngoes here.\n&quot;;
</PRE>
<HR>
<P>Hо заметьте, что мы расположили строку на двух отдельных строках. Ключем
к такому поведению является последовательность
&lt;&lt;END. Последовательность &lt;&lt; говорит ``это строковое значение,
которое начинается со следующей строки и продолжается до тех пор, пока мы
не найдем указанный маркер''. В нашем случае, концом строки является строка
``END'', которая должна располагаться на отдельной строке. Все символы
между началом строки и до маркера (включая последний перевод строки)
считается частью значения.
<P>Заметьте, что за выражением &lt;&lt;END следует точка с запятой. Это
ничто иное, как маскированная строка, чтобы сделать синтаксис выражения
корректным. Я всегда буду помещать точку с запятой в этом выражении. 
<P>Вот другой пример, показывающий как может быть произведено умножением
``встроенных документов'' в одной и той же исходной строке:
<P>
<HR>
<PRE>
        print &lt;&lt;HELLO, &lt;&lt;WORLD;
        hi
        HELLO
        there
        WORLD
</PRE>
<HR>
<P>Заметьте, что в самом деле это выражение аналогично строке:
<P>
<HR>
<PRE>
        print &quot;hi\n&quot;,&quot;there\n&quot;;
</PRE>
<HR>
<P>хотя и красиво маскировано.
<P>А что если мы не хотим иметь переводы строки? Хорошо, это достаточно
просто. Одним из простых способов является искажение результата с помощью
функции <CODE>substr</CODE>:
<P>
<P>
<HR>
<PRE>
        $data = substr(&lt;&lt;THING,0,-1);
        This is a long quoted line.
        THING
</PRE>
<HR>
<P>и теперь <CODE>$data</CODE> будет содержать строку, без завершающего символа
новой строки, благодаря функции <CODE>substr</CODE>, выбирающей все символы
кроме последнего. Другим способом является использование регулярного
выражения, но тут я немного заскочу вперед:
<P>
<HR>
<PRE>
        $stuff = join(&quot;:&quot;, &lt;&lt;END =~ /(.+)/g);
        hi
        there
        this\tis\ta\ttest
        of the best!
        END
</PRE>
<HR>
<P>Здесь приведено много разных вещей, так что позвольте мне внести
ясность. Значение <CODE>$stuff</CODE> получается из объединения элементов
списка через символ ``:''. Список получается при выполнении операции поиска
по регулярному выражению <CODE>m//g</CODE> в списочном контексте, выполняемой
для всех соответствий выражению ``.+'' внутри строки. Эта строка получается
из ``внутреннего документа'', ограниченного словом <CODE>END</CODE>. Результат
данного регулярного выражения является списком, который выглядит примерно
так:
<P>
<HR>
<PRE>
        &quot;hi&quot;, &quot;there&quot;,
        &quot;this\tis\ta\test&quot;,
        &quot;of the best!&quot;
</PRE>
<HR>
<P>Который при соединении будет выглядеть так:
<P>
<HR>
<PRE>
        &quot;hi:there:this\tis\ta\test:of the best!&quot;
</PRE>
<HR>
<P>Вот вам задачка (не такая сложная, если вы знаете!)... заключается в
том, являются ли последовательности <CODE>\t</CODE> символами табуляции или
просто последовательностью из символа обратный слэш, за которым следует
буква <CODE>t</CODE>? Хорошо. по умолчанию ``внутренние документы'' работают
как строки, заключенные в двойные кавычки, в которых происходит подстановка
переменных, а символы подобные <CODE>\t</CODE> получают свои значения.
<P>Так что в этом случае строка будет содержать три символа табуляции. Что
делать в том случае, если мы не хотим этого... мы просто хотим получить то,
что мы видим, также как и в случае строк, заключенных в одинарные кавычки?
Хорошо, мы можем задать это для ``внутреннего документа'' заключив конечный
таг в одинарные кавычки:
<P>
<HR>
<PRE>
        $stuff = &lt;&lt;'END';
        This\thas\tno\ttabs!
        END
</PRE>
<HR>
<P>что приведет к получению следующей строки:
<P>
<HR>
<PRE>
        $stuff = 'This\thas\tno\ttabs!' . &quot;\n&quot;;
</PRE>
<HR>
<P>Заметьте, что мы все равно получаем перевод строки в конце документа.
Я могу также явно указать использование интерполяции переменных:
<P>
<HR>
<PRE>
        $stuff = &lt;&lt;&quot;END&quot;;
        This\thas\ttabs\tnow!
        END
</PRE>
<HR>
<P>Похоже, что мне необходимо набирать больше текста. Hо мы должны использовать
кавычки в тех случаях, когда разделитель содержит пробелы:
<P>
<HR>
<PRE>
        $stuff = &lt;&lt;&quot;END OF DATA&quot;;
        This is my home: $ENV{HOME}
        And this is my shell: $ENV{SHELL}
        END OF DATA
</PRE>
<HR>
<P>Заметьте, что я здесь также использовал переменные (значения переменных
среды <CODE>$HOME</CODE> и <CODE>$SHELL</CODE>). Очень важно соблюдать правильное
количество пробельных символов. Лишние пробелы в начале или в конце маркера
приведут к тому, что Perl пропустит эту строки и будет продолжать поиск
настоящей отметки.
<P>Технология сканирования ``внутреннего документа'' с помощью регулярного
выражения может быть расширена в будущем. Hапример, представьте, что нам
необходим ассоциативный массив, загружаемый парами ключ-значение:
<P>
<HR>
<PRE>
        %data = &lt;&lt;END =~ /(\w+): (.*)/g;
        fred: Fred Flintstone
        barney: Barney Rubble
        betty: Betty Rubble
        wilma: Wilma Flintstone
        END

        for (sort keys %data) {
                print &quot;$_ =&gt; $data{$_}\n&quot;;
        }

        print &lt;&lt;QUOTE;
        This is to inform you that $data{&quot;fred&quot;} and
        $data{&quot;wilma&quot;} are married.
        QUOTE
</PRE>
<HR>
<P>В этом коде <CODE>%data</CODE> заполняется парами элементов, которые
получаются из каждого соответствия регулярному выражению. Это регулярное
выражение соотвествует ключу (такому как fred или barney) и необходимому
значению (такому как ``Fred Flintstone''). Цикл <CODE>foreach</CODE> в конце
кода выдает на печать полученный ассоциативный массив. А второй
``внутренний документ'' показывает нам возможность доступа к данному
ассоциативному массиву как части другого ``внутреннего документа''.
<P>Что приводит нас к следующей идее: использование ``внутреннего
документа'' как ``генератора форм писем''. Вот как это может выглядеть:
<P>
<HR>
<PRE>
        for (&lt;&lt;'EOF' =~ /(.+)/g) {
        fredf:Fred Flintstone:$25
        barneyb:Barney Rubble:$100
        bettyb:Betty Rubble:$0.05
        EOF
                ($email, $person, $owe) = split /:/;
                print &lt;&lt;EOM;
        ## mail for $person
        mail -s &quot;$person, you deadbeat!&quot; $email &lt;&lt;INPUT
        Hey, $person, you owe us $owe!
        Pay up, or else!
        INPUT
        ## end of mail for $person
        EOM
        }
</PRE>
<HR>
<P>Прошу извинить за такие странные отступы, но ``внутренние документы''
имеют дополнительные пробелы в начале. В этом коде делается несколько
вещей, так что позвольте мне описать их. В начале , цикл <CODE>foreach</CODE>
проходит по списку полученному из просмотра всех строк во ``внутреннем
документе''. Внутри цикла <CODE>foreach loop</CODE>, строка (в <CODE>$_</CODE>)
разбивается по символу двоеточие, и в результате мы получаем три
переменных&mdash; <CODE>$email</CODE>, <CODE>$person</CODE> и <CODE>$owe</CODE>.
<P>Следующим шагом является выдача другого ``внутреннего документа'',
ссылаясь на три переменных (иногда несколько раз). Этот документ является
скриптом командного процессора, который вы наверное будете выполнять.
Заметьте, что этот скрипт также содержит ``внутренний документ''
командного процессора (из которого Perl позаимствовал эту идею),
обозначенный меткой ``INPUT''. Смотрите, сколько уровней связано
здесь. Запустите эту программу и вы получите нечто похожее на следующий
код:
<P>
<HR>
<PRE>
        ...
        ## mail for Barney Rubble
        mail -s &quot;Barney Rubble, you deadbeat!&quot; barneyb &lt;&lt;INPUT
        Hey, Barney Rubble, you owe us $100!
        Pay up, or else!
        INPUT
        ## end of mail for Barney Rubble
        ...
</PRE>
<HR>
<P>Заметьте, что в последней программе имеются некрасивые отступы. Хорошо,
сделав небольшую работу, мы сможем избежать их, используя хитрое регулярное
выражение:
<P>
<HR>
<PRE>
        for (1..10) {
                @data = &lt;&lt;END =~ /\t\t(.*)\n/g;
                        Data one $_
                        Data two $_
        END
                print &quot;$_: @data\n&quot;;
        }
</PRE>
<HR>
<P>Заметьте, что регулярное выражение отбрасывает два символа табуляции,
которые я использовал для создания отступов в этой части
программы. Классно. Hо к сожалению, метка конца все равно должна иметь
правильный отступ слева.
<P>И в завершение, последний набор приемов. Внутренние документы могут быть
заключены в обратные кавычки, а не только в двойные или одинарный
кавычки. Это выполняется помещением метки конца в обратные кавычки:
<P>
<HR>
<PRE>
        $shell_out = &lt;&lt;`SHELL`;
        for i in *
        do
                echo -n \$i:
                sum \$i
        done
        SHELL
        print &quot;shell said: $shell_out\n&quot;;
</PRE>
<HR>
<P>В этом примере, маркер конца ``SHELL'' помещен в обратные кавычки,
заставляя все строки до маркера считаться командами для командного
процессора. В этом примере командами является цикл командного процессора,
проходящим по всем именам в текущем каталоге, присваивая переменной
командного процессора <CODE>$i</CODE> имя каждого из файлов. Для каждого файла
выдается имя, за которым следует контрольная сумма этого файла.
<P>Заметьте, что мы замаскировали знак доллара с помощью символа обратный
слэш. Это необходимо, поскольку во внутренних документах, заключенных в
обратные кавычки производится подстановка переменных и специальных знаков,
также как и в строках, заключенных в обратные кавычки. Однако выполнив
небольшую работу мы можем получить документ, который не испытывает таких
проблем:
<P>
<HR>
<PRE>
        $shell_in = &lt;&lt;'IN';
        for i in *
        do
                echo -n $i:
                sum $i
        done
        IN
        $shell_out = `$shell_in`;
        print &quot;shell said: $shell_out\n&quot;;
</PRE>
<HR>
<P>В этом примере, я сначала создаю строку из внутреннего документа
заключенного в одинарные кавычки (без подстановки переменных, так что
<CODE>$i</CODE> останется просто <CODE>$i</CODE>). А затем, я вставляю эту строку в
обыкновенную строку, заключенную в обратные кавычки, что приводит к
выполнению правильной команды командного процессора.
<P>Как вы смогли увидеть, внутренние документы позволяют сделать легким
включение в вашу программу больших частей постоянного текста. Другим
способом выполнить это является использование файлового дескриптора
<CODE>DATA</CODE>, но мы оставим это до будущих времен. Hаслаждайтесь!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
