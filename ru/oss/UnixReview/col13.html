<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 13 -- Введение в объекты</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 13 -- Введение в объекты</H1>

<H2>Randal Schwartz</H2>Март 1997<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt;
<P>Объекты, объекты, объекты! Мир программирования становится
``объектно-ориентированным''. И Perl не является исключением&nbsp;-- в нем
тоже имеются объекты, уже в течении последних 30% его жизни. Однако, в
отличии от других языков программирования, вы можете писать код на Perl
используя объекты, или полностью избегать их использования. Давайте
взглянем на систему объектов в Perl.
<P>В Perl ``объект'' это просто ссылка на структуру данных. (Если вы хотите
обновить свои знания, то посмотрите как я использовал ссылки в нескольких
предыдущих выпусках, или посмотрите документацию получаемую с помощью
команды ``man perlref''). Однако, ссылки могут быть ``связаны'' с
определенными пакетами, представляя данный пакет в виде ``класса''
объекта.
<P>Назначение связывания состоит в том, чтобы разрешить вызов ``методов''
для данного объекта. Метод в этом случае&nbsp;-- простая подпрограмма, но
но подпрограмма, находящаяся в пакете, с которым связывается объект.
<P>Давайте взглянем на простой пример. Я хочу создать класс с именем Car
(Машина). Внутри этого класса я помещаю метод, который создает новые
машины, которые я могу использовать. Этот метод называется ``new''. Вызов
метода выглядит примерно так:
<P>
<HR>
<PRE>
        $myCar = new Car;
</PRE>
<HR>
<P>Теперь, для того чтобы этот код работал, нам в пакете Car необходимо
иметь подпрограмму с именем ``new''. Это будет выглядеть примерно так:
<P>
<HR>
<PRE>
        sub Car::new {
                my $class = shift;
                my $self = {};
                bless $self, $class;
                $self-&gt;{passengers} = {};
                $self;
        }
</PRE>
<HR>
<P>Здесь делается много действий. Вот их построчное описание.
<P>
<UL>
<LI>Подпрограмма в пакете Car с именем ``new''. Нет ничего
особенного в имени ``new'', но это позволяет пользователям C++ и
Smalltalk работать более комфортно.</LI>
<LI>Первым параметром, передаваемым в подпрограмму является имя
класса (имя пакета). Эта подпрограмма сохраняет параметр в
локальной переменной с именем <CODE>$class</CODE>. Это одно из отличий
между вызовом метода и вызовом простой подпрограммы: всегда есть
дополнительный первый параметр.</LI>
<LI>``Объект'' создается, используя локальную переменную
<CODE>$self</CODE>. Этой переменной присваивается пустой анонимный
хеш. Это достаточно распространенная практика, поскольку переменные
класса (переменные: которые уникальны для каждого из объектов)
являются просто элементами этого хеша.</LI>
<LI>Объект ``связывается'' с пакетом. Это не изменяет значения
<CODE>$self</CODE>, но анонимный хеш ``запоминает'', что он пришел из
данного пакета. Эта ``память'' позволяет найти методы в нужном
пакете, при последующих вызовах.</LI>
<LI>Внутри <CODE>$self</CODE> создается переменная класса с именем
``passengers (пассажиры)'' в виде анонимного хеша (ссылки).</LI>
<LI>В заключение, возвращается значение переменной
<CODE>$self</CODE>.</LI>
</UL>
<P>Заметьте, что в этом случае возвращаемым значением является ссылка на
анонимный хеш, но  также этот хеш был связан с пакетом Car. Вы могли бы
использовать переменную <CODE>$myCar</CODE> (определенную ранее) просто как
ссылку на анонимный хеш. Однако, объекты лучше работают, в тех случаях,
когда мы рассматриваем их как ``черные ящики'', вместо того, чтобы
взаимодействовать с объектами через ``методы объектов (instance)''.
<P>Давайте взглянем на методы работающие с данным классом. Давайте посадим
``Fred'' и ``Wilma'' в машину:
<P>
<HR>
<PRE>
        enter $myCar qw(Fred Wilma);
</PRE>
<HR>
<P>Это код отличается тем, что вместо имени класса после имени метода, у
нас имеется имя объекта. Также заметьте, что у нас имеются параметр,
переданный методу, который следует за именем объекта. Давайте взглянем на
то, как это обрабатывается внутри подпрограммы: 
<P>
<P>
<HR>
<PRE>
        sub Car::enter {
                my $self = shift;
                foreach $_ (@_) {
                        $self-&gt;{passengers}-&gt;{$_} = &quot;seat&quot;;
                }
                $self;
        }
</PRE>
<HR>
<P>Также, здесь происходит несколько действий. Давайте разберем их по
отдельности:
<P>
<OL>
<LI>Как и в случае вызова метода класса ``new'', также существует
дополнительный параметр. В данном случае -- это объект (например
<CODE>$myCar</CODE>). Первым действием подпрограммы является помещение этого
объекта в переменную <CODE>$self</CODE>. Она будет той же самой переменной
<CODE>$self</CODE>, как и было определено в подпрограмме ``new''.</LI>
<LI>После того, как значение <CODE>$self</CODE> будет удалено из списка
параметров, оставшиеся значения в массиве <CODE>@_</CODE> будут являться
людьми, которые сейчас находятся в машине. Цикл  <CODE>foreach</CODE>
устанавливает элементы внутри переменной объекта с именем ``passengers'' (на
которую ссылаются как на элемент в хеше <CODE>$self</CODE>). Ключом хеша
будет имя пассажира, а соответствующим значением будет номер места,
показывающее, что пассажир имеет место (более поздняя версия данной
подпрограммы, возможно будет записывать выбор места, но сейчас просто будем
сохранять данное значение).</LI>
<LI>Хотя значение возвращаемое данным методом, в действительности является
побочным эффектом изменения <CODE>$self</CODE>, но мы все равно возвращаем
<CODE>$self</CODE>, по причинам, которые станут очевидными далее.</LI>
</OL>
<P>
<P>Так, что этот метод заставляет включить людей, перечисленных в качестве
аргументов подпрограммы, в переменную ``passengers''.
<P>
<P>Иногда, вызов лучше записывается используя стрелочную нотацию, которая
выглядит примерно так:
<P>
<HR>
<PRE>
        $myCar = Car-&gt;new;
        $myCar-&gt;enter(qw(Fred Barney));
</PRE>
<HR>
<P>В действительности, поскольку возвращаемым значением метода
<HR>
<PRE>
enter
</PRE>
<HR>
 является объект, то мы можем объединить обе
строки:
<P>
<HR>
<PRE>
        $myCar = Car-&gt;new-&gt;enter(qw(Fred Barney));
</PRE>
<HR>
<P>Это является преимуществом стрелочной нотации. Мы также можем переписать
этот код, используя другую нотацию (``косвенный объект'') notation as:
<P>
<P>
<HR>
<PRE>
        $myCar = enter {new Car} qw(Fred Barney);
</PRE>
<HR>
<P>но как вы можете заметить, параметры все больше и больше отдаляются от
имени метода.
<P>
<P>После того, как пассажиры были добавлены, нам нужно посмотреть кем они
являются. Это обрабатывается с помощью дополнительного метода:
<P>
<HR>
<PRE>
        @passengers = passengers $myCar;
        print &quot;passengers for $myCar is @passengers\n&quot;;
</PRE>
<HR>
<P>что приводит к выдаче следующего результата:
<P>
<HR>
<PRE>
        passengers for Car=HASH(0xb126c) is Barney Fred
</PRE>
<HR>
<P>Посмотрите на значение <CODE>$myCar</CODE>, когда оно интерпретируется как
строка. В действительности, это просто отладочный символ, в форме:
<P>
<HR>
<PRE>
        Class=UNDERLYINGTYPE(0xHexAddress)
</PRE>
<HR>
<P>Также заметьте, что пользователю класса Car нет необходимости знать то,
что список пассажиров хранится в хеше (ассоциативном списке)...если далее
мы обнаружим, что эффективней будет использования двоичного дерева или
сортированого списка, то мы сможем перейти к использованию этих
алгоритмов, поскольку интерфейс останется тем же самым. Вот почему важно
рассматривать объект как черный ящик.
<P>Вот одно из возможных определений метода ``passengers'':
<P>
<HR>
<PRE>
        sub Car::passengers {
                my $self = shift;
                sort keys %{$self-&gt;{passengers}};
        }
</PRE>
<HR>
<P>Здесь как и в предыдущих примерах первым параметром является сам объект
(например <CODE>$myCar</CODE>). Это значение затем используется для доступа к
переменной ``passengers''. Затем для этого хеша вызывается оператор
<CODE>keys()</CODE>, и результат функции сортируется в АЛФАВИТHОМ порядке.
<P>
<P>Для полноты примера, давайте добавим еще один метод&nbsp;--- удаление
добавленных пассажиров. Это будет выглядеть примерно следующим образом:
<P>
<HR>
<PRE>
        sub Car::leave {
                my $self = shift;
                for (@_) {
                        delete $self-&gt;{passengers}-&gt;{$_};
                }
                $self;
        }
</PRE>
<HR>
<P>Давайте теперь соединим все примеры вместе:
<P>
<HR>
<PRE>
        %cars = (
                Flintstone =&gt;
                        Car-&gt;new-&gt;enter(qw(Fred Wilma)),
                Rubble =&gt;
                        Car-&gt;new-&gt;enter(qw(Barney Betty)),
        );
        ## show who is where
        foreach $family (sort keys %cars) {
                my @passengers = $cars{$family}-&gt;passengers;
                print &quot;the $family car contains @passengers\n&quot;;
        }
</PRE>
<HR>
<P>Здесь мы используем два семейных автомобиля, хранящихся в хеше с именем
<CODE>%cars</CODE>. Ключом хеша является фамилия семейства, а соответствующим
значением будет экземпляр класса Car. Затем следует простой код, который
выдает списки пассажиров в машинах.
<P>Это позволяет нам выполнять типичные действия, такие как пересадка Wilma из
одной машины в другую:
<P>
<HR>
<PRE>
        ## wilma decides it is better to ride with betty
        $cars{Flintstone}-&gt;leave(&quot;Wilma&quot;);
        $cars{Rubble}-&gt;enter(&quot;Wilma&quot;);
</PRE>
<HR>
<P>Давайте выполним это типичное действие в виде метода класса, и
проиллюстрируем именованные параметры.
<P>
<HR>
<PRE>
        sub Car::jump {
                my $self = shift;
                my %parms = @_;
                my $dest_car = $parms{TO} || Car-&gt;new;
                my $people = $parms{PEOPLE} || [$self-&gt;passengers];
                $people = [$people] unless ref $people;
                $self-&gt;leave(@$people);
                $dest_car-&gt;enter(@$people);
        }
</PRE>
<HR>
<P>Это позволит нам выполнять что-то подобное следующему коду:
<P>
<HR>
<PRE>
        ## wilma goes to the rubble car
        $cars{Flintstone}-&gt;jump(
                PEOPLE =&gt; qw(Wilma),
                TO =&gt; $cars{Rubble},
        );
        ## but it breaks down, so they all go to the other car
        $cars{Rubble}-&gt;jump(
                TO =&gt; $cars{Flintstone},
        );
        ## and then that breaks down, so they all get in a new car
        $newCar = $cars{Flintstone}-&gt;jump;
        @passengers = $newCar-&gt;passengers;
        print &quot;new car contains @passengers\n&quot;;
</PRE>
<HR>
<P>Попробуйте выполнить эти примеры. Они открывают большое поле для
экспериментов.
<P>Как вы увидели, объект позволяют нам определить новые типы данных
(машина) и операции выполняемые над этими типами. В будущем выпуске я
проиллюстрирую другие действия с объектами, такие как
наследование. Hаслаждайтесь!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
