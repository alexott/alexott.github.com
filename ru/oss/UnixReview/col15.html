<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 15 -- Анализ файлов протокола</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 15 -- Анализ файлов протокола</H1>

<H2>Randal Schwartz</H2>Июль 1997<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt;
<P>Сокращение ``PERL'' оригинально замышлялось для обозначения
``Practical Extraction and Report Language (язык практических
извлечений и отчетов)''. Хотя Perl расширил свою сферу применения и
возможности за последние 10 лет своего существования, но все равно
основы получения отчетов созданных из извлеченных данных являются
основой большинства проблем программирования на Perl.
<P>
<P>Давайте взглянем на типичную проблему: анализ файлов
протокола. В наши дни файлы протокола создаются во всех
местах. Например, записи входа/выхода в систему, запуск команд,
перекачка файлов, почтовые системы, сервера gopher и даже увеличившееся
использование серверов web, всё это создает строки и строки и страницы
кажется бесконечных потоков данных. Каждая отдельная транзакция не
заслуживает исследования (до тех пор, пока вы ищите недавние нарушения
безопасности), но сведение этих данных в отчеты является частой задачей.
<P>
<P>Давайте взглянем на гипотетический ``файл протокола передачи
файлов'', который выглядит примерно так:
<P>
<P>
<HR>
<PRE>
    fred wilma 08:50 730
    barney betty 06:15 190
    betty barney 22:27 993
    barney wilma 23:47 504
    fred wilma 04:29 836
    betty betty 14:37 738
    wilma barney 18:47 825
</PRE>
<HR>
<P>и состоит из четырех разделенных пробелами колонок, содержащих
исходный сервер, сервер назначения, время в 24-часовом формате и число
переданных байт.
<P>
<P>Я создаю некоторые данные с помощью небольшой тестовой программы:
<P>
<P>
<HR>
<PRE>
    my @hosts = qw(fred barney betty wilma);
    srand;
    sub randhost { $hosts[rand @hosts]; }
    for (my $n = 0; $n &lt;= 999; $n++) {
      printf
        &quot;%s %s %02d:%02d %d\n&quot;,
        randhost, randhost, rand(24), rand(60), rand(1000);
    }
</PRE>
<HR>
<P>которая выдает соответствующие поля. Выравнивается ``999'' для
выравнивания размера вывода* (Эта программа использует синтаксис версии
5.004 с очень гибким расположением объявления <CODE>my()</CODE>... если 
при использовании более старых версий Perl 5 вы получаете сообщения об
ошибках, то удалите объявления <CODE>my()</CODE>).
<P>
<P>Так что у нас теперь есть относительно неинтересные данные. Давайте
посмотрим как создается типичный отчет. Все отчеты будут требовать,
чтобы данные были обработаны по колонка, что будет общей частью для
каждой из программ обработки данные. Так что давайте решим эту
проблему. 
<P>
<P>Основа программы обработки выглядит примерно так:
<P>
<P>
<HR>
<PRE>
    while (&lt;&gt;) {
      my ($from, $to, $hh, $mm, $bytes) =
        /^(\S+) (\S+) (\d+):(\d+) (\d+)$/
          or (warn &quot;bad format on line $.: $_&quot;), next;
      # accumulate
    }
    # print the result here
</PRE>
<HR>
<P>Если в файле существует несколько форматов записей, то для
регулярных выражений для которых произошел сбой, можно было бы
попытаться применить другие сочетания. Это полезно в тех случаях, когда
существуют разные варианты данных.
<P>
<P>Программа лишь забирает данные, но не аккумулирует числа и не выдает
результаты. Давайте начнем с чего-нибудь простого: подсчет общего
количества переданных байтов и количества заданий передачи данных:
<P>
<P>
<HR>
<PRE>
      # for accumulate:
      $total_bytes += $bytes;
      $jobs++;
</PRE>
<HR>
<P>что выполняется внутри цикла, а затем вне цикла происходит выдача
результатов:
<P>
<P>
<HR>
<PRE>
    # for print:
    print &quot;total bytes = $total_bytes, jobs = $jobs\n&quot;;
</PRE>
<HR>
<P>Хорошо, это было не слишком трудно. Давайте попытаемся сделать нечто
более интересное. Давайте посмотрим сколько байтов было передано с
каждой машины. Мы сделаем это с помощью ассоциативного массива, в котором ключом будет
являться имя машины, а соответствующим значением будет общее количество
(а также сохраним количества заданий в отдельном ассоциативном массиве):
<P>
<P>
<HR>
<PRE>
      # for accumulate:
      $from_bytes{$from} += $bytes;
      $from_jobs{$from}++;
</PRE>
<HR>
<P>Теперь для выдачи результатов, нам необходимо пройти по ассоциативному массиву:
<P>
<P>
<HR>
<PRE>
    # for print:
    for my $from (sort keys %from_bytes) {
      my $bytes = $from_bytes{$from};
      my $jobs = $from_jobs{$from};
      print &quot;$from sent $bytes bytes on $jobs jobs\n&quot;;
    }
</PRE>
<HR>
<P>В этом коде получаются ключи <CODE>%from_bytes</CODE>, потом они
сортируются и используются для получения соответствующих значений из
двух ассоциативных массивов. 
<P>
<P>Что делать, если мы хотим получить общее количество переданных байт
и не хотим заботиться о том, в каком направлении они переданы. Для
того, чтобы сделать это, я использую хитрый прием добавляя число в два
разных места в ассоциативном массиве:
<P>
<P>
<HR>
<PRE>
      # for accumulate:
      $total_bytes{$from} += $bytes;
      $total_bytes{$to} += $bytes;
</PRE>
<HR>
<P>и теперь проход по ассоциативному массиву <CODE>%total_bytes</CODE>
аналогичен вышеприведенному коду:
<P>
<P>
<HR>
<PRE>
    # for print:
    for my $host (sort keys %total_bytes) {
      my $bytes = $total_bytes{$host};
      print &quot;$host did $bytes\n&quot;;
    }
</PRE>
<HR>
<P>Заметьте, что если мы вычисляем ``общую сумму'' байтов, то
значение должно дублироваться, так что в этом случае будьте
осторожны. Если вы хотите иметь возможность вычисления ``общей суммы''
этих чисел, то одним из способов решения может быть выделение по
половине трафика для каждой из машин:
<P>
<P>
<HR>
<PRE>
      # for accumulate:
      $bytes /= 2; # allocation correction
      $total_bytes{$from} += $bytes;
      $total_bytes{$to} += $bytes;
</PRE>
<HR>
<P>В этом случае суммарные данные этой таблицы будут показывать то же,
что и суммарные данные других таблиц. ``Как можно обмануть с помощью
статистики''.
<P>
<P>До настоящего времени, мы выполняли накопление данных основанных на
пустых объектах (суммарное количество) и основанных на одном объекте
данных (таком как исходный сервер). Можем мы выполнять накопление
данных, основываясь на двух или нескольких объектах данных? Конечно,
благодаря имеющейся в Perl возможности использования вложенных
ассоциативных массивов. Давайте взглянем на двумерную таблицу,
показывающую все передачи данных между передающими и получающими данные
машинами. Это будет выглядеть примерно так:
<P>
<P>
<HR>
<PRE>
      # for accumulate:
      $from_to_bytes{$from}{$to} += $bytes;
</PRE>
<HR>
<P>Теперь мы отслеживаем передающие и принимающие машины. Хотя выдача
данных будет достаточно хитрой. Вот построчная выдача результатов для
всех сочетаний передающих и принимающих машин:
<P>
<P>
<HR>
<PRE>
    # for print:
    for my $from (sort keys %from_to_bytes) {
      my $second = $from_to_bytes{$from};
      for my $to (sort keys %$second) {
        my $bytes = $second-&gt;{$to};
        print &quot;$from to $to did $bytes\n&quot;;
      }
    }
</PRE>
<HR>
<P>Это немного сложно, поскольку мы проходим по всей матрице. Внешний
цикл выполняет проход по всем передающим машинам, помещая ссылки на
внутренние ассоциативные массивы в переменную <CODE>$second</CODE>. Затем с
помощью внутреннего цикла выполняется проход по внутреннему
ассоциативному массиву, выдавая хранящиеся в нем данные.
<P>
<P>Вывод этой программы выглядит немного безобразно:
<P>
<P>
<HR>
<PRE>
    [...]
    barney to fred did 2792
    barney to wilma did 4683
    betty to barney did 2333
    betty to betty did 2568
    [...]
</PRE>
<HR>
<P>так, что давайте немного улучшим его, выдавая прямоугольную
таблицу. Сначала нам необходимо вычислить все возможные названия
принимающих машин, для того чтобы создать заголовки колонок:
<P>
<P>
<HR>
<PRE>
    my %to_hosts = ();
    for my $from (sort keys %from_to_bytes) {
      my $second = $from_to_bytes{$from};
      my @keys = keys %$second;
      @to_hosts{@keys} = ();
    }
    my @to_hosts = sort keys %to_hosts;
</PRE>
<HR>
<P>Здесь я создаю временный ассоциативный массив с именем
<CODE>%to_hosts</CODE>, который служит в качестве ``множества''. Для
каждой из передающих машин, я получаю список принимающих машин и
помещаю его в массив <CODE>@keys</CODE> (внутри цикла), а затем добавляю
элементы этого массива в ``множество''. Последнее выражение выделяет
данные из множества и помещает их в массив <CODE>@to_hosts</CODE>, который
я затем использую для выдачи заголовков колонок. Заголовки колонок
выдаются с помощью кода:
<P>
<P>
<HR>
<PRE>
    printf &quot;%10s:&quot;, &quot;bytes to&quot;;
    for (@to_hosts) {
      printf &quot; %10s&quot;, $_;
    }
    print &quot;\n&quot;;
</PRE>
<HR>
<P>а затем выполняется проход по матрице, который немного проще чем в
предыдущем примере:
<P>
<P>
<HR>
<PRE>
    for my $from (sort keys %from_to_bytes) {
      printf &quot;%10s:&quot;, $from;
      for my $to (@to_hosts) {
        my $bytes = $from_to_bytes{$from}{$to} || &quot;- none -&quot;;
        printf &quot; %10s&quot;, $bytes;
      }
      print &quot;\n&quot;;
    }
</PRE>
<HR>
<P>поскольку нам не нужно получать ключи второго ассоциативного
массива... они уже являются частью массива <CODE>@to_hosts</CODE>. Вывод
программы выглядит примерно так:
<P>
<P>
<HR>
<PRE>
  bytes to:     barney      betty       fred      wilma
    barney:       3303       4429       2792       4683
     betty:       2333       2568       3928       1813
      fred:       2416       3542        226       5293
     wilma:       5267       1196       2706       4580
</PRE>
<HR>
<P>Вот у вас и имеется программа сокращения некоторые простых
данных. Развлекайтесь сокращением данных!
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
