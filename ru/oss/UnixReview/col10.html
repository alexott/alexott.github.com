<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 10</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 10</H1>

<H2>Randal Schwartz</H2>Сентябрь 1996<P>В своем предыдущем выпуске я воссоздал часть обычной утилиты Unix под
названием  grep, при этом добавив к ней дополнительную функциональность ---
возможность игнорирования не-текстовых файлов. Сейчас я постараюсь показать
как использовать существующую ``обвязку'' для использования существующей
команды для выполнения самого поиска, но оставляя свойство поиска только в
текстовых файлах.
<P>Обвязка заменяет запуск отдельной программы: в моих скриптах я запускаю
``textgrep'' вместо ``grep'', например, если я хочу быть более ясным, то я
могу назвать свою обвязку ``grep'', а затем поместить настоящий ``grep''
туда, где он не будет найден с помощью путей поиска, и известное только
моей обвязке.
<P>В этом случае, обвязка запускается с теми же аргументами что и
стандартная программа grep. Обвязка будет проверять только имена файлов
(игнорируя остальные аргументы) и будет удалять имена двоичных файлов. Все
оставшиеся имена и ключи для команды будут прозрачно переданы настоящей
команде grep.
<P>Первая часть программы используется для отделения имен файлов от ключей
программы. Давайте глянем на этот код:
<P>
<HR>
<PRE>
        while ($ARGV[0] =~ /^-[a-z]$/) {
                push @OPTS, shift;
        }
</PRE>
<HR>
<P>Здесь, мы сначала смотрим на первый элемент <CODE>@ARGV</CODE> (обозначенный
как <CODE>$ARGV[0]</CODE>), и если он выглядит как ключ команды (минус за
которым следует одиночная буква), то мы переносим этот элемент из массива
<CODE>@ARGV</CODE> в массив <CODE>@OPTS</CODE>. По умолчанию оператор ``shift''
удаляет первый элемент массива <CODE>@ARGV</CODE>.
<P>Hо этот метод не работает при использовании ключей ``-e'' и ``-f'',
которые получают дополнительный параметр. Скорее всего этот параметр не
будет выглядеть как ключ, так что мы должны сделать дополнительный шаг:
<P>
<HR>
<PRE>
        while ($ARGV[0] =~ /^-[a-z]$/) {
                if ($ARGV[0] =~ /^-[ef]$/) {
                        push @OPTS, shift;
                }
                push @OPTS, shift;
        }
</PRE>
<HR>
<P>Теперь, если встречается ключ <CODE>-e</CODE> или <CODE>-f</CODE>, то
переносятся два аргумента, а не один. Как вы можете видеть, написание
обвязки требует достаточно полного понимания аргументов программы для
которой создается обвязка.
<P>Далее, нам необходимо обработать то, что осталось в <CODE>@ARGV</CODE>,
отбрасывая имена нетекстовых файлов. Это тот же код, что был использован в
предыдущей заметке:
<P>
<HR>
<PRE>
        @ARGV = &quot;-&quot; unless @ARGV;
        @ARGV = grep { -T or $_ eq &quot;-&quot; } @ARGV;
        exit 0 unless @ARGV;
</PRE>
<HR>
<P>Первый шаг вставляет  ``-'' если массив пуст. Это не изменяет значения 
<CODE>@ARGV</CODE>, но дает нам возможность правильной обработки в
дальнейшем. Второй шаг удаляет из <CODE>@ARGV</CODE> любые имена файлов,
которые не являются текстовыми (что определяется оператором <CODE>-T</CODE>)
или не равны ``-'' (означая стандартный ввод). Стандартный ввод всегда
рассматривается как текстовый файл. Третья строка заставляет прекратить
работу с нулевым значением, если у нас нет имен обрабатываемых файлов.
<P>В заключение, нам необходимо запустить grep с измененной командной
строкой:
<P>
<HR>
<PRE>
        exec &quot;grep&quot;, @OPTS, @ARGV;
</PRE>
<HR>
<P>Оператор ``exec'' запускает команду ``grep'' (которая находится в
текущих путях поиска), и передает ей ключи (из массива <CODE>@OPTS</CODE>),
если они есть и затем список имен обрабатываемых файлов (из массива
<CODE>@ARGV</CODE>).
<P>Это выполняет большинство действий. Я мог бы назвать эту программу 
``textgrep'', и она бы работала. Однако давайте глянем на обвязку, подобную
описанной выше: что-то для замены команды  ``grep'', чтобы я все равно мог
запускать ее как ``grep''. Сначала, мне необходимо переименовать команду
grep в что-то другое (например, в ``/usr/bin/realgrep''), и объяснить
обвязке где ее найти:
<P>
<HR>
<PRE>
        $real_grep = &quot;/usr/bin/realgrep&quot;;
</PRE>
<HR>
<P>Далее, я хочу запускать этот realgrep, но уверять, что он запущен как
``grep'' (в тех случаях, когда это его беспокоит). Это делается обманом о
его имени и расположении. Я хочу, чтобы настоящий grep верил, что он имеет
тоже название что и мой скрипт textgrep (который будет назван grep). К
счастью этот путь доступен в переменной <CODE>$0</CODE>, и может быть передан в
новую программу как ``argv[0]'', используя интересное свойство
<CODE>exec</CODE>:
<P>
<HR>
<PRE>
        exec $0 $real_grep, @OPTS, @ARGV;
</PRE>
<HR>
<P>Заметьте, что <CODE>$0</CODE> вставлена между оператором <CODE>exec</CODE> и
именем запускаемой программы.
<P>Hе так уж и много надо сделать, чтобы настоящая команда grep не смогла
найти свое расположение. Помещая все кусочки вместе мы получаем:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        $real_grep = &quot;/usr/bin/realgrep&quot;;
        while ($ARGV[0] =~ /^-[a-z]$/) {
                if ($ARGV[0] =~ /^-[ef]$/) {
                        push @OPTS, shift;
                }
                push @OPTS, shift;
        }
        @ARGV = &quot;-&quot; unless @ARGV;
        @ARGV = grep { -T or $_ eq &quot;-&quot; } @ARGV;
        exit 0 unless @ARGV;
        exec $0 $real_grep, @OPTS, @ARGV;
        die &quot;cannot exec $real_grep: $!&quot;;
</PRE>
<HR>
<P>Я добавил оператор  ``die'' для обработки ошибок запуска программы
<CODE>$real_grep</CODE>.
<P>Почему используется ``exec'', а не  ``system''? Использование
<CODE>exec</CODE> заставляет скрипт на Perl вызвать ``exec'' для программы
grep, вместо того, чтобы запускать  grep как дочерний процесс. Если этот
шаг завершился удачно (как скорее всего и будет, если у нас используется
правильное имя файла), то интерпретатор  Perl заменяется на программу
grep. Код после <CODE>exec</CODE> должен обработать сбойный <CODE>exec</CODE>
(например оператором ``die'').
<P>Существуют другие применения скриптов-обвязок. Hапример, предположим,
что у меня имеется пакет для работы с базой данных, который должен иметь
определенные значения umask, определенный текущий каталог и несколько
важных для него переменных среды. Хотя вы можете написать его и на языке
командного процессора, давайте все равно взглянем как это будет выглядеть
на  Perl:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        my $DB_HOME = &quot;/home/merlyn/database&quot;;
        chdir $DB_HOME
                or die &quot;cannot get to db dir: $!&quot;;
        umask 2;
        $ENV{'DB_HOME'} = $DB_HOME;
        $ENV{'PATH'} .= &quot;:$DB_HOME&quot;;
        exec &quot;accounting&quot;, @ARGV;
        die &quot;Cannot exec accounting: $!&quot;;
</PRE>
<HR>
<P>Здесь я устанавливаю переменную  Perl  <CODE>$DB_HOME</CODE>, задающую
каталог моего пакета. Затем я выполняю переход в этот каталог, и
устанавливаю значение <CODE>umask</CODE> равным ``002'' (при этом снимается
доступ на запись для остальных пользователей). Затем, я устанавливаю
значение переменной среды <CODE>DB_HOME</CODE> равным значению переменной Perl
с тем же именем. Заметьте, что переменные Perl не экспортируются
автоматически, так что этот код аналогичен:
<P>
<HR>
<PRE>
        setenv DB_HOME $DB_HOME
</PRE>
<HR>
<P>в C-shell, или:
<P>
<HR>
<PRE>
        export DB_HOME
</PRE>
<HR>
<P>в Bourne shell. Также я обновляю переменную среды <CODE>PATH</CODE>,
добавляя туда каталог <CODE>DB_HOME</CODE>, как один из каталогов содержащих
программы. Заметьте, что я добавляю новый каталог в конец списка, а не в
начало. Если бы я хотел добавить его в начало, я должен был бы записать это
выражение вот так:
<P>
<HR>
<PRE>
        $ENV{'PATH'} = &quot;$DB_HOME:$ENV{'PATH'}&quot;;
</PRE>
<HR>
<P>И затем происходит запуск программы из моего пакета, за которым следует
диагностическое сообщение, в том случае если выполнение <CODE>exec</CODE>
прошло неудачно. Заметьте, что я передаю своей программе массив
<CODE>@ARGV</CODE> без всякой обработки. Если бы были некоторые общие
аргументы, такие как ``-d $DB_HOME'', то эта строка выглядела бы вот
так:
<P>
<HR>
<PRE>
        exec &quot;accounting&quot;, &quot;-d&quot;,
                $DB_HOME, @ARGV;
</PRE>
<HR>
<P>(Это вероятно достаточно тупой пакет, который требует так много действий
по установке <CODE>DB_HOME</CODE>, но к счастью вы смогли увидеть как я обошел
это ограничение).
<P>Другим типом обвязок являются те, которые вносят беспорядок в
стандартные файловые дескрипторы, для того, чтобы немного изменить
поведение. Hапример, стандартная команда ``find'' имеет достаточно полезное
свойство сообщать о каталогах, которые невозможно просканировать в
стандартный поток сообщений об ошибках. Однако, когда нас не интересуют
сообщения о том, что  find не может сделать, то эти сообщения только
раздражают нас.
<P>Конечно, используя правильное перенаправление ввода-вывода, я могу
убрать сообщения стандартного вывода сообщений об ошибках
(<CODE>stderr</CODE>). Однако, давайте создадим обвязку, вместо того, чтобы
полностью отбрасывать сообщения для <CODE>STDERR</CODE>:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        open STDERR, &quot;&gt;/dev/null&quot;;
        exec &quot;find&quot;, @ARGV;
        die &quot;Cannot exec find: $!&quot;;
</PRE>
<HR>
<P>Вот, достаточно просто. я мог бы поместить этот код в файл с именем
``qfind'' (сокращение для ``quiet find'', и затем запускать следующим
образом:
<P>
<HR>
<PRE>
        qfind / -name '*perl*' -ls
</PRE>
<HR>
<P>и теперь я не буду получать сообщения, говорящие мне о каталогах в
которые невозможен вход.
<P>Я также мог бы сделать это для обвязки программы доступа к базе данных,
для того, чтобы сохранять все сообщения в файле протокола (прямо перед
запуском ``exec''):
<P>
<HR>
<PRE>
        open STDERR, &quot;&gt;&gt;log&quot;;
</PRE>
<HR>
<P>Хорошо, это заканчивает мое обсуждение обвязок. Я надеюсь, что вы
насладились им.
<HR>
Next
Previous
Contents
</BODY>
</HTML>
