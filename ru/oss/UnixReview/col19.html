<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 19 -- Подключение файлов</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 19 -- Подключение файлов</H1>

<H2>Randal Schwartz</H2>Март 1998<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Perl великолепно работает с текстом. В этом нет никаких
сомнений. Perl является отличным инструментом для для одноразовых
задач, что позволяет нам выполнить нашу работу быстрее, легче и
надежно. Нол иногда нам необходимо написать утилиты, которые являются
более гибкими и таким образом имеют объем больше чем несколько строк,
или используют более одного приложения.
<P>
<P>В этом обзоре я остановлюсь на типичном приложении для обработки
текста, с наиболее общей характеристикой -- обработкой файла строка за
строкой, но позволяя ``включать файлы''. Эти подключаемые файлы будут
содержать дополнительную информации для обработки, но в оригинальном
файле будут указываться только имя файла.
<P>
<P>Таким образом, у нас есть файл, который мы хотим обработать
построчно. Это достаточно неинтересно, но давайте глянем на что-то
подобное следующему коду:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    while (&lt;&gt;) {
        &amp;process($_);
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>где <CODE>process</CODE> является подпрограммой, определенной где-то в
другом месте. Это базовый цикл ``считать за раз одну строку в
$_''. Если вы попытаетесь запустить этот код, то вам надо будет
определить данную подпрограмму, так что просто используем следующий
код:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    sub process {
        my $line = shift;
        print &quot;processed: $line&quot;;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Давайте, теперь скажем, что некоторые строки в текстовом файле
являются строками ``подключающими файлы''. Если строка имеет вид:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    #include fred
</PRE>
</CODE></BLOCKQUOTE>
<P>то содержимое, файла <CODE>fred</CODE> автоматически обрабатывается так,
как будто он является содержимым оригинального файла. Для этого, нам
надо распознать эту строку и выделить имя файла -- это не так сложно
при использовании регулярных выражений:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    if (/^#include (\S+)/) {
        $name = $1;
        ...;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>И теперь мы должны решить, что необходимо поместить в
``...''. Конечно, нам необходимо открыть файл, построчно считать его
содержимое и закрыть файл. Это не так сложно -- у нас уже имеется имя
файла:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    if (/^#include (\S+)/) {
        $name = $1;
        open F, $name or die
            &quot;Cannot open $name: $!&quot;;
        while (&lt;F&gt;) {
            &amp;process($_);
        }
        close F;
    } else { # wasn't include
        &amp;process($_);
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>И это работает внутри внешнего цикла <CODE>while</CODE>. Великолепно,
теперь мы можем обрабатывать подключаемые файлы.
<P>
<P>Хорошо, по крайней мере это работает на один уровень подключения
файлов. Hо что будет, если подключаемый файл также захочет подключить
другой файл? Это не будет работать при использовании нашего кода. Во
внутреннем цикле ``чтения F'' нет ничего, что выглядело бы как код для
включения файлов. Hо оба цикла вызывают подпрограмму
<CODE>&amp;process</CODE>, так, что это дает нам некоторые
возможности. Давайте немного изменим логику программы:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    while (&lt;&gt;) {
        &amp;process_or_include($_);
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    sub process_or_include {
        local $_ = shift;
        if (/^#include (\S+)/) {
            &amp;include($1);
        } else {
            &amp;process($_);
        }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь мы изменили внешний цикл так, чтобы он для каждой строки
вызывал подпрограмму <CODE>&amp;process_or_include</CODE>. Эта подпрограмма
получает строку и помещает ее в новую локальную переменную <CODE>$_</CODE>
(для того, чтобы облегчить выполнение регулярного выражения).
<P>
<P>Далее, если строка начинается с директивы ``include'' и содержит
непустое имя файла, то мы вызываем подпрограмму <CODE>&amp;include</CODE>
(определена ниже), а если нет, то мы вызываем оригинальную подпрограмму
<CODE>&amp;process</CODE> с аргументом равным переданной строке.
<P>
<P>Теперь мы должны определить подпрограмму <CODE>&amp;include</CODE>,
которой передается имя файла, и предположительно будем вызывать
подпрограмму <CODE>&amp;process_or_include</CODE> для каждой строки. Это не
должно быть тяжело... просто напишите, как в предыдущем коде:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    sub include {
        my $name = shift;
        open F, $name or die
            &quot;Cannot open $name: $!&quot;;
        while (&lt;F&gt;) {
            &amp;process_or_include($_);
        }
        close F;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Как и в предыдущем случае, переданное имя файла помещается в
переменную <CODE>$name</CODE>, которая затем используется для открытия
файлового дескриптора <CODE>F</CODE> (прекращая работу, если нет
данных). Затем из файлового дескриптора построчно считываются данные в
переменную  <CODE>$_</CODE>, и затем для этих данных вызывается
подпрограмма <EM>&amp;process_or_include</EM> (определенная выше). Затем,
когда данные заканчиваются, мы закрываем файловый дескриптор.
<P>
<P>Так. Правильно. О, нет, не правильно. Почему неправильно? Hа первый
взгляд это выглядит правильным, каждая строка файла, открытого на
файловом дескрипторе F, обрабатывается или считается как директива
подключения. Hо <EM>это является</EM> проблемой. Существует только одно
имя файлового дескриптора и оно не является локальным для подпрограммы,
так что каждый рекурсивный <CODE>&amp;include</CODE> использует <EM>один и
тот же</EM> файловый дескриптор <CODE>F</CODE>.
<P>
<P>Все что нам надо -- это локальный дескриптор файла. В старых версиях
Perl, это было слегка беспорядочным, но современные версии обрабатывают
это достаточно хорошо. Сначала мы добавим строку
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    use IO::File;
</PRE>
</CODE></BLOCKQUOTE>
<P>в начало нашего скрипта. Эта директива ``расширяет'' Perl
подключением знания об объекте <CODE>IO::File</CODE>. не беспокойтесь: вам
не нужно знание объектно-ориентированного программирования для
использования возможностей этого модуля. Просто используйте несколько
простых синтаксических конструкций.
<P>
<P>Вместо открытия явного дескриптора файла, нам теперь необходимо
открывать локальный для подпрограммы объект <CODE>IO::File</CODE>:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    sub include {
        my $name = shift;
        my $F = IO::File-&gt;new($name)
            or die &quot;Cannot open $name: $!&quot;;
        while (&lt;$F&gt;) {
            &amp;process_or_include($_);
        }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Заметьте, что вместо вызова функции <CODE>open</CODE> для файлового
дескриптора &lt;F&gt;, мы теперь вызываем метод <CODE>new</CODE> для
возврата объекта <CODE>IO::File</CODE> в локальный скаляр
<CODE>$F</CODE>. Затем мы можем использовать этот скаляр везде, где мы
ранее использовали файловый дескриптор, и он работает как надо. Однако,
рекурсивный запуск этой подпрограммы будет создавать совершенно новые
объекты <CODE>IO::File</CODE>!
<P>
<P>Нижняя часть этой подпрограммы считывает по одной строке, но теперь
из объекта содержащегося в переменной <CODE>$F</CODE>. Данные все равно
считываются в переменную <CODE>$_</CODE>, но при этом они проверяются на
существование.
<P>
<P>Другим побочным эффектом является то, что нам больше не надо
закрывать дескриптор файла. Когда <CODE>$f</CODE> покидает область
видимости (в конце текущей подпрограммы), то соответствующий
``дескриптор файла'' автоматически закрывается. Это очень хорошо.
<P>
<P>OK, у нас теперь имеется превосходный процессор подключения файлов,
который обрабатывает включение файлов в самих включаемых файлах. Как мы
можем сделать его более полезным? Что если ввести ``пути поиска'',
задающие места в которых файл может быть найден, если его имя задано
относительным путем?
<P>
<P>Это не нат трудно. Вам нужно сделать некоторые изменения к процедуре
открытия файла. Давайте сделаем это в подпрограмме подключения файла.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    
    sub include {
        my $name = shift;
        my $F = &amp;find_file($name);
        while (&lt;$F&gt;) {
            &amp;process_or_include($_);
        }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Имя подключаемого файла сохраняется в переменной <CODE>$name</CODE>, как
и ранее. Затем вместо прямого открытия файла, мы вызываем процедуру
<CODE>&amp;find_file</CODE> (определенную ниже). Возвращаемое значение
является объектом <CODE>IO::File</CODE>, который точно также используется
как и ранее, включая его окончательное освобождение в конце
подпрограммы.
<P>
<P>Подпрограмма <CODE>&amp;find_file</CODE> определена следующим образом:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    sub find_file {
        local $_ = shift;
        if (/^\//) { # absolute
            return &amp;must_open($_);
        }
        # relative
        for $dir (@path) {
            my $full = &quot;$dir/$_&quot;;
            if (-e $full) {
                return &amp;must_open($_);
            }
        }
        die &quot;Cannot find $_ in @dirs&quot;;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Входящий параметр является именем файла, который необходимо найти в
каталогах, находящихся в путях поиска. Имя файла сохраняется в
локальной переменной <CODE>$_</CODE>. Если имя в <CODE>$_</CODE> начинается с
прямого слэша, то оно является абсолютным путевым именем и мы должны
использовать как есть. Так что мы вызываем подпрограмму
<EM>&amp;must_open</EM> (определенную ниже), передавая ей полной имя
файла и возвращая то, что она возвращает нам (если есть) и что должно
быть объектом <CODE>IO::File</CODE>.
<P>
<P>Если имя не начинается с символа слэш, то нам необходимо попытаться
найти файл в каждом из каталогов, определенных в путях
поиска. Переменная <CODE>$dir</CODE> устанавливается равной каждому из
элементов массива <CODE>@path</CODE>. Полное путевое имя помещается в
переменную <CODE>$full</CODE> (временную скалярную переменную). Если файл с
таким именем существует (тестируется с помощью <CODE>-e</CODE>), то мы
пытаемся открыть его вызывая ту же самую подпрограмму
<CODE>&amp;must_open</CODE>. Если файл не существует, то мы пробуем
использовать следующий путь из списка.
<P>
<P>Если все пути из массива <CODE>@path</CODE> были использованы и файл не
был найден, то эта подпрограмма выполняет <CODE>die</CODE> с
соответствующим сообщением об ошибке.
<P>
<P>Функция <CODE>&amp;must_open</CODE> определена следующим образом:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    sub must_open {
        my $name = shift;
        IO::File-&gt;new($name) or die
            &quot;Cannot open $name: $!&quot;;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>В подпрограмму передается имя файла <CODE>$name</CODE>, который будет
открыт, или мы выполним <CODE>die</CODE>. Если открытие файла прошло
успешно, то созданный объект становится возвращаемым значением. Мы
можем передавать объекты <CODE>IO::File</CODE> через стэк --это намного
удобней, чем файловые дескрипторы!
<P>
<P>Таким образом, этот пример показал некоторые основы обработки
текста, применение локальных файловых дескрипторов и рекурсивных
подпрограмм. Не так плохо для небольшой утилиты. Увидимся с вами
далее...
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
