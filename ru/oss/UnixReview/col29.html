<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 29</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 29</H1>

<H2>Randal Schwartz</H2>Декабрь 1999<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Каждый день мы встречаемся с телефонными номерами, которые
``произносятся'', например как ``please dial 1-ZZZ-HE-MUST-PAY to force
your older brother to pay for the call!''. Это происходит поскольку в
ранние дни телефонного сервиса с (когда были телефоны использующие
наборные диски), для каждой цифры сопоставлялась буква.
<P>
<P>В одном из списков рассылки, который я читаю, поступил вопрос:
кто-то хотел знать, существуют ли большие наборы слов, которые
вступают в противоречие с теми же номерами. Я подумал, что это было бы отличной
работой для Perl и через короткое время написал программу, которая
проходит по всем словам стандартного словаря  Unix, который расположен
в <CODE>/usr/dict/words</CODE>, для того, чтобы найти самый длинный список
сталкивающихся слов (или списки, если существует более
одного). Поскольку программа демонстрирует некоторую базовую технику
сокращения данных, то я решил продемонстрировать ее и вам.
<P>
<P>Сначала идет самая критическая часть. Задавая произвольную строку,
например ``merlyn'', какие цифры будут использоваться для ее создания?
Hам необходимо знать, что <CODE>m</CODE> равно 6, а <CODE>e</CODE> равно 3, и
так далее. Самым быстрам способом для выполнения этой операции является
оператор <CODE>tr</CODE>:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $_ = &quot;merlyn&quot;;
  tr[abcdefghijklmnoprstuvwxy]
    [222333444555666777888999];
  print;
</PRE>
</CODE></BLOCKQUOTE>
<P>что выдает 637596. Здесь я использовал свойство, которое разрешает
операндам <CODE>tr</CODE> быть разделенными произвольными,
сбалансированными знаками пунктуации, вместе с возможным пустым
пространством между двумя списками. Это дает нам великолепное
видимое расположение, что позволяет сне проверить, что я получаю
правильные символы с правильным переводом.
<P>
<P>Давайте оформим этот код как подпрограмму, добавив две
дополнительных возможности: (1) Прописные символы будут обрабатываться
как строчные, и (2) если в строке имеется что-то не входящее в этот
список (например символы Q или Z или знаки препинания), то будет
возвращаться значение <CODE>undef</CODE>:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  sub translate {
    local $_ = lc shift;
    return unless
      tr[abcdefghijklmnoprstuvwxy]
        [222333444555666777888999]
      == length;
    $_;
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>Превращение прописных букв в строчные выполняется очень легко, 
выполняя функцию <CODE>lc</CODE> над результатом полученным с помощью
оператора <CODE>shift</CODE> из массива аргументов <CODE>@_</CODE>.
<P>
<P>Передача ``плохих символов'' обрабатывается, путем отслеживания
чтобы число символов преобразованных с помощью оператора <CODE>tr</CODE>
(он возвращает значение) было равным длине переданной строки. В
противном случае возвращается значение <CODE>undef</CODE>.
<P>
<P>Теперь нам необходимо пройти по словарю, Это не очень сложно; нам
просто необходимо преобразовать каждое слово, а затем сохранить
результаты. Если мы используем хеш, ключом которого является
преобразованное число, то каждый элемент хеша может иметь значение
ссылки на массив всех слов, которым соответствует данный номер, Это
выглядит примерно так:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  my %num_to_words;
  @ARGV = &quot;/usr/dict/words&quot; unless @ARGV;
  while (&lt;&gt;) {
    chomp;
    next unless
      my $translate = translate($_);
    push @{$num_to_words{$translate}}, $_;
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>Мы используем аргументы командной строки, перечисленные в массиве
<CODE>@ARGV</CODE>, как список обрабатываемых файлов, используя
<CODE>/usr/dict/words</CODE> как значение по умолчанию, если аргументы не
заданы. И мы будем считать значение <CODE>$num_to_words{$translate}</CODE>
ссылкой на массив, помещая каждое новое слово в конец массива. Если
записей не существует (например в начале работы), то Perl помещает
ссылку на пустой массив в значение, позволяя выполнять операцию
<CODE>push</CODE>.
<P>
<P>Так, что если словарь состоит только из слов <CODE>merlyn</CODE>,
<CODE>Randal</CODE> и <CODE>pamfan</CODE>, то у нас будет следующая структура
данных:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  %num_to_words = (
    &quot;637596&quot; =&gt; [&quot;merlyn&quot;],
    &quot;725325&quot; =&gt; [&quot;Randal&quot;, &quot;pamfan&quot;],
  );
</PRE>
</CODE></BLOCKQUOTE>
<P>Каждый из ключей в хеше является преобразованным числом. Каждое
значение является ссылкой на массив, состоящий из слов, которые
имеют данное преобразованное число. Если у нас имеется более одной
записи, то у нас есть противоречия. Чем больше лист столкновений, тем
он интересней для нас.
<P>
<P>Например, заметьте, что выдуманное слово ``pamfan'' сталкивается со
словом ``Randal'', создавая список из двух объектов. Это более
интересно, чем слово <CODE>merlyn</CODE>, которое преобразуется в отдельное
число.
<P>
<P>Так что теперь, необходимо пройти по полученной структуре данных, и
найти самый длинный список столкновений. Для начала, нам необходимо
выполнить цикл и измерить длину каждого из списков:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  for my $number (keys %num_to_words) {
    my $length = @{$num_to_words{$number}};
    ...
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>Этот код использует ссылку на массив из значения хеша, выполняя
разыменование его в скалярном контексте, так что в результате мы
получаем количество значений в массиве. Если у нас имеется пять
значений, которые соответствуют числу <CODE>$number</CODE>, то результат
будет равен 5.
<P>
<P>И мы захотим сохранить информацию о самой длинной записи. Одним из
способов является хранение двух значений, первое из которых
инициализируется за пределами цикла:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  my $maxlength = 0;
  my @longest;
</PRE>
</CODE></BLOCKQUOTE>
<P>Мы будем использовать <CODE>$maxlength</CODE> для сохранения
максимальной длины списка и будем помещать значения в список
<CODE>@longest</CODE> для тех чисел6 чья длина совпадает с максимальной
длиной списка. Если новое значение <CODE>$length</CODE> больше текущего
максимального значения, то мы начинаем заново заполнять массив:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  ...
    if ($length &gt; $maxlength) {
      $maxlength = $length;
      @longest = $number;
    } elsif ($length == $maxlength) {
      push @longest, $number;
    }
  ...
</PRE>
</CODE></BLOCKQUOTE>
<P>Это значит, что если длина просматриваемой нами записи больше чем
максимальная длина предыдущих записей (в начале это условие равно
истине, поскольку переменная <CODE>$maxlength</CODE> в начале получает
значение 0), то мы устанавливаем максимальную длину записи равной длине
текущей записи, и запоминаем значение ключа в массиве самых длинных
ключей. Однако, следующие ключи, чьи значения имеют ту же длину будут
помещаться в конеч списка ключей.
<P>
<P>Теперь в массиве <CODE>@longest</CODE> у нас находятся все числа,
которые имеют самое большое столкновений. Как получается, в стандартном
словаре <CODE>/usr/dict/words</CODE> имеется только по одному значению, но
давайте притворимся, что значений может быть много и рассмотрим
оставшийся код.
<P>
<P>Теперь нам необходимо выдать данные:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  for my $number (sort @longest) {
    print
      &quot;$number: &quot;,
      join(&quot; &quot;, sort @{$num_to_words{$number}}),
      &quot;\n&quot;;
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>Для каждого из преобразованных чисел в массиве самых длинных
списков, мы выдаем само число и затем список всех слов, которые
соответствуют этому числу.
<P>
<P>И когда мы поместим все куски кода вместе, у нас получится готовая
программа:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  use strict;

  my %num_to_words;
  @ARGV = &quot;/usr/dict/words&quot; unless @ARGV;
  while (&lt;&gt;) {
    chomp;
    next unless
      my $translate = translate($_);
    push @{$num_to_words{$translate}}, $_;
  }

  my $maxlength = 0;
  my @longest;
  for my $number (keys %num_to_words) {
    my $length = @{$num_to_words{$number}};
    if ($length &gt; $maxlength) {
      $maxlength = $length;
      @longest = $number;
    } elsif ($length == $maxlength) {
      push @longest, $number;
    }
  }

  for my $number (sort @longest) {
    print
      &quot;$number: &quot;,
      join(&quot; &quot;, sort @{$num_to_words{$number}}),
      &quot;\n&quot;;
  }

  sub translate {
    local $_ = lc shift;
    return unless
      tr[abcdefghijklmnoprstuvwxy]
        [222333444555666777888999]
      == length;
    $_;
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>И теперь вот ответ на оригинальную головоломку. Наибольшее
количество слов в <CODE>/usr/dict/words</CODE>, которые соответствуют одним
и тем же телефонным цифрам, имеется в одном списке, который состоит из
слов:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  22737: acres bards barer bares baser bases caper capes cards cares cases
</PRE>
</CODE></BLOCKQUOTE>
<P>И больше нет фиктивных фраз! Встретимся в следующий раз,
наслаждайтесь!
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
