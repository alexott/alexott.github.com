<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 7 -- Простые ссылки</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 7 -- Простые ссылки</H1>

<H2>Randal Schwartz</H2>Март 1996<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt;
<P>Одна из наиболее мощных возможностей появившихся в последней версии Perl
(версия 5.0
<BLOCKQUOTE>Март 1996г. -- Прим. переводчика.</BLOCKQUOTE>
) это
``ссылка''. Ссылка подобна указателю в языке Си, предоставляя средство
ссылаться на структуры данных ``косвенно''. Эта косвенность может быть
использована двояко: вы можете иметь секцию кода действующую на различные
структуры данных в разное время, или вы можете иметь структуры данных,
косвенно содержащие другие структуры данных, предоставляя вам возможности
вложенных структур данных (списки списков, списки ассоциативных массивов, и
так далее).
<P>Ссылку можно сделать на скаляры, массивы (списки), ассоциативные массивы
(хеши), или подпрограммы. Эти ссылки подходят практически в любое место,
где подходят скалярные значения, таким образом, они могут содержатся в
скалярных переменных, быть значением списка или хеша, и могут быть переданы
в или из подпрограммы. (Почти единственное место, где может подойти скаляр и
не может ссылка, это ключ хеша).
<P>Ссылка на именованую переменную создаётся с помощью оператора
``\''.
<P>
<HR>
<PRE>
        $ref_to_a = \$a;
</PRE>
<HR>
<P>Значение в <CODE>$ref_to_a</CODE> теперь ссылка на переменную
<CODE>$a</CODE>. Мы можем использовать эту ссылку чтобы изменить значение
<CODE>$a</CODE> косвенно, используя раскрытие ссылки до скаляра:
<P>
<HR>
<PRE>
        ${ $ref_to_a } = 35;
</PRE>
<HR>
<P>Чтобы понять этот синтаксис, представьте замещение имени скалярной
переменной (вроде <CODE>b</CODE> в <CODE>$b</CODE>) блоком, возвращающим значение
ссылки на скалярную переменную (в этом случае <CODE>$ref_to_a</CODE>). Тогда
выражение выше становится таким же как:
<P>
<HR>
<PRE>
        $a = 35;
</PRE>
<HR>
<P>И следующие два выражения так же эквивалентны:
<P>
<HR>
<PRE>
        $a++;
        ${ $ref_to_a }++;
</PRE>
<HR>
<P>Я даже могу сократить эту запись немного, чтобы поменьше набирать. Если
единственное, что есть внутри блока, то это просто скалярная переменная, и
я могу опустить фигурные скобки, вот как здесь:
<P>
<HR>
<PRE>
        $$ref_to_a++; # increment $a
        $$ref_to_a = 35; # set $a = 35
</PRE>
<HR>
<P>Теперь это выглядит просто как более сложный путь написать <CODE>$a</CODE>,
но давайте посмотрим следующий текст:
<P>
<HR>
<PRE>
        $the_ref = \$a;
        $$the_ref = 35; # set $a to 35
        $the_ref = \$b;
        $$the_ref = 35; # set $b to 35
</PRE>
<HR>
<P>Заметьте, что тот же самый кусок текста (<CODE>$$the_ref = 35</CODE>)
изменил <CODE>$a</CODE> в первый раз и <CODE>$b</CODE> во второй
раз. Действительно, мы можем это немного автоматизировать используя цикл
<CODE>foreach</CODE>:
<P>
<HR>
<PRE>
        foreach $the_ref (\$a, \$b) {
                $$the_ref = 35;
        }
</PRE>
<HR>
<P>Возможно теперь вы начинаете видеть, что я могу использовать один и тот
же текст программы применительно к различным переменным, спасибо
добавочному уровню косвенности. Хорошо!
<P>Так же, как я могу создать ссылку на скаляр, я могу создать ссылку на
массив (список).
<P>
<HR>
<PRE>
        $list_ref = \@fred;
</PRE>
<HR>
<P>В этом случае, конструкция <CODE>{$list_ref}</CODE> (или эквивалентная
<CODE>$list_ref</CODE>) может быть использована везде, где я мог бы
использовать ``fred'' как списковую переменную:
<P>
<HR>
<PRE>
        @$list_ref = (3,4,5); # @fred = (3,4,5)
        $$list_ref[2] = 6; # $fred[2] = 6
        print $#$list_ref; # print $#fred;
        push(@$list_ref,8,9); # push(@fred, 8, 9)
</PRE>
<HR>
<P>И ещё раз, я могу использовать ссылки для исполнения действия
косвенно:
<P>
<HR>
<PRE>
        foreach $list_ref (\@fred, \@barney) {
                @$list_ref = (); # clear out the array
        }
</PRE>
<HR>
<P>которое устанавливает оба <CODE>@fred</CODE> и <CODE>@barney</CODE> в пустое
значение (присваивает пустой список весьма нелёгким образом).
<P>Всё это время я создавал ссылки на именованные списковые переменные, но
так же можно создавать список, который не соответствует ни одной списковой
переменной. Это называется ``анонимный список''. Анонимный список может
быть создан конструктором анонимных списков, который строит список и
возвращает ссылку на него:
<P>
<HR>
<PRE>
        $list_ref = [3, 4, 6, 8, 9];
</PRE>
<HR>
<P>Значение <CODE>$list_ref</CODE> может быть использовано точно так же, как я
использовал ссылку на именованный список. Единственная разница в том, что не
будет реального имени переменной&nbsp;--- только ссылка. Например, я могу
добавить в массив: 
<P>
<HR>
<PRE>
        push(@$list_ref, 10, 12);
</PRE>
<HR>
<P>и выяснить его размер:
<P>
<HR>
<PRE>
        $len = @$list_ref; # $len = 7
</PRE>
<HR>
<P>или увеличить его первый элемент:
<P>
<HR>
<PRE>
        $$list_ref[0]++; # first element is now 4
</PRE>
<HR>
<P>Ссылки на списки и ссылки на анонимные списки можно использовать для
передачи списка в подпрограмму без копирования целого списка в аргументы
подпрограммы.
<P>
<HR>
<PRE>
        @a = 1..1000; # create 1000 element list
        $ref_to_a = \@a; # reference to @a
        &amp;brack_it($ref_to_a); # pass reference to subroutine
        sub brack_it {
                my($list_ref) = @_; # name the first parameter
                foreach (@$list_ref) {
                        print "[$_]"; # print element in brackets
                }
                print "\n";
        }
</PRE>
<HR>
<P>Заметьте, что подпрограмма ожидает ссылку на список первым аргументом, и
затем раскрывает эту ссылку, чтобы получить настоящий список. В этом случае
только один скаляр был передан из главного текста в подпрограмму. Без
использования ссылки нам пришлось бы сделать копию всех 1000 элементов,
чтобы передать их в подпрограмму.
<P>На самом деле, мы можем пропустить шаг-другой:
<P>
<HR>
<PRE>
        &amp;brack_it(\@a); # call sub on @a
</PRE>
<HR>
<P>Нам нет необходимости хранить промежуточную ссылку в скалярной
переменной&nbsp;--- достаточно просто передать её первым аргументом.
<P>Так же, мы можем передать первым аргументом ссылку на анонимный
массив:
<P>
<HR>
<PRE>
        &amp;brack_it(
                [10, 20, 30]
        );
</PRE>
<HR>
<P>Здесь создаётся анонимный список из трёх значений 10, 20, 30, и ссылка
на этот список передаётся в подпрограмму.
<P>Что происходит с анонимным списком, когда подпрограмма завершается?
Анонимный список (подобно всем анонимным вещам) учитывается ``счётчиком
ссылок'', это означает, что Perl отслеживает количество ссылок на этот блок
данных. Когда данные передаются в подпрограмму, на блок появляется первая
ссылка, затем, появляется вторая (список аргументов и локальная копия
<CODE>``$list_ref''</CODE>). Когда подпрограмма завершается, обе ссылки
исчезают, оставляя блок, на который никто не ссылается. Когда это
происходит, Perl автоматически освобождает память, занимаемую списком,
точно так же, как будто подпрограмма завершалась и её локальные переменные
больше не были действительны.
<P>Так же, ссылки можно копировать:
<P>
<HR>
<PRE>
        $a = [ 20, 30, 40 ]; # $a is a listref
        $b = $a;
</PRE>
<HR>
<P>Теперь, обе переменные <CODE>$a</CODE> и <CODE>$b</CODE> указывают на одни и те
же данные. Если я добавлю элемент к <CODE>@$a</CODE>, я буду иметь доступ к тем
же данным через <CODE>@$b</CODE>. Я могу даже удалить <CODE>$a</CODE>.
<P>
<HR>
<PRE>
        undef $a;
</PRE>
<HR>
<P>и <CODE>$b</CODE> будет указывать на оригинальные данные! Хотя, когда я
окончательно удалю <CODE>$b</CODE>,
<P>
<HR>
<PRE>
        undef $b;
</PRE>
<HR>
<P>блок, содержащий анонимный список, будет возвращён обратно в пул
свободных блоков, так как на него никто не ссылается.
<P>Я могу создавать ссылки на ассоциативные массивы (хеши):
<P>
<HR>
<PRE>
        $hash_ref = \%score;
        ${ $hash_ref }{"fred"} = 205; # $score{"fred"} = 205
        $$hash_ref{"barney"} = 195; # $score{"barney"} = 195
        @$hash_ref{"wilma","betty"} = (170,180);
                # @score{"wilma","betty"} = (170,180);
        @the_keys = keys %$hash_ref; # keys %score
</PRE>
<HR>
<P>Опять, если я использую <CODE>{$hash_ref}</CODE> (или даже просто
<CODE>$hash_ref</CODE>) в любом месте, где я бы использовал имя ассоциативного
массива (<CODE>score</CODE> для <CODE>%score</CODE>), то я получаю свойственный
хешам синтаксис для получения косвенного доступа к <CODE>%score</CODE>.
<P>Я могу создать обобщённую подпрограмму для вывода ключей и
соответствующих значений (отсортированных по ключам), и передавать
ссылку на хеш.
<P>
<P>
<HR>
<PRE>
        sub show_hash {
                my($hash_ref) = @_;
                foreach (sort keys %$hash_ref) {
                        print "$_ => $$hash_ref{$_}\n";
                }
        }

        &amp;show_hash(\%score);
</PRE>
<HR>
<P>Преимущество снова в том, что здесь передаётся только один скаляр
(ссылка на хеш) в подпрограмму, а не полностью анонимный список (выложенный
в плоский список).
<P>Списки и хеши можно возвращать из подпрограммы используя похожий
синтаксис. Приведу пример подпрограммы, возвращающей ссылку на список:
<P>
<HR>
<PRE>
        sub return_it {
                my(@list) = 1..100;
                \@list;
        }

        $list_ref = &amp;return_it();
        print $$list_ref[4]; # prints 5, or $list[4]
</PRE>
<HR>
<P>Каждый раз, когда эта подпрограмма вызывается, создаётся новый список от
1 до 100. Подпрограмма, затем, возвращает ссылку на этот список. Даже хотя
список обычно был бы уничтожен на выходе из подпрограммы, (так как он
локальный для подпрограммы), Perl замечает, что есть ещё внешняя ссылка на
список (возвращаемое значение), и превращает его в анонимный список. Эта
ссылка затем копируется в переменную <CODE>$list_ref</CODE>, которая затем может
быть использована как любая ссылка на список. Пока хотя бы одна ссылка на
список существует, он будет храниться в памяти.
<P>Каждый вызов <CODE>\&amp;return_it()</CODE> будет создавать различные
<CODE>@list</CODE>, и поэтому возвращать ссылки на различные структуры
данных. Таким образом мы можем превращать именованные переменные
подпрограммы в неименованые переменные вне подпрограммы довольно
тривиально. Также, заметьте, что мы возвращаем не значения списка, а только
скаляр, ссылающийся на значения, и таким образом уменьшаем избыточность
передачи всех значений из функции на Perl ``стек''.
<P>Подобно анонимным спискам, я могу создавать анонимный ``хеш'':
<P>
<HR>
<PRE>
        $hash_ref = {
                "fred", 205,
                "barney", 195,
                "dino", 30,
        };

        print ${$hash_ref}{"fred"}; # prints 205
        print $$hash_ref{"dino"}; # prints 30
</PRE>
<HR>
<P>И снова, эта структура данных, которая действует как если бы я создал
переменную (ассоциативный массив) и затем получил ссылку на него, но
переменная не имеет реального имени. Эти данные доступны только косвенно
через <CODE>$hash_ref</CODE>. Я мог бы передать такую ссылку в
<CODE>\&amp;show_hash</CODE> (см. выше) вот так:
<P>
<HR>
<PRE>
        &amp;show_hash( {
                "fred", 205,
                "barney", 195,
                "dino", 30,
        } );
</PRE>
<HR>
<P>В этом случае, я даже не собираюсь сохранять ссылку на хеш в
переменной&nbsp;--- я сразу передаю ссылку в подпрограмму. Когда
подпрограмма завершается, ничто не содержит ссылку на эти данные, и данные
исчезают.
<P>Надеюсь, эта экскурсия в ссылочные переменные оказалась вам полезной. В
следующем выпуске, я постараюсь проиллюстрировать ссылки на подпрограммы, и
даже изменение ``таблицы символов'' Perl используя ссылки во время
исполнения программы.
<HR>
Next
Previous
Contents
</BODY>
</HTML>
