<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 34</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 34</H1>

<H2>Randal Schwartz</H2>Октябрь 2000<P>[предполагаемый заголовок: короткий сеанс магии]
<P>Давайте начнем с некоторых действий с текстом. У меня в файле
<CODE>peg_poem</CODE> есть поэма, написанная моим хорошим другом, Peg Edera,
которая выглядит так:
<P>
<HR>
<PRE>
    The Little Acts

    Maybe there is no magic.
    Maybe it is only faith.
    The lonely girl stuffs a letter
    In a bottle, casts it in the sea.
    It floats, it sinks.
    What counts is that it's cast.

    Those little intentions,
    The petals placed on the altar,
    The prayer whispered into air,
    The deep breath.
    The little acts,
    The candles lit,
    The incense burning
    And we remember what counts
    And we know what we need
    In the little acts.

    Then is when to listen.
    What is it that brought you
    To this?
    There's the magic.
    Right in hearing what
    Sends you to 
    Hope.

      Peg Edera
      February 8, 2000
</PRE>
<HR>
<P>Заголовок этой поэмы задал тему данной заметки, так что будет логично,
что мы используем этот текст как зерно для мельницы.
<P>Давайте начнем с открытия файла и считывания данных. Это будет выглядеть
примерно так:
<P>
<HR>
<PRE>
  open POEM, &quot;peg_poem&quot; or die &quot;Cannot open: $!&quot;;
  while (&lt;POEM&gt;) {
    ... do something here with each line
  }
</PRE>
<HR>
<P>Внутри тела данного цикла <CODE>while</CODE>, <CODE>$_</CODE> содержит каждую
строку поэмы. Так что на первом проходе мы получим строку <CODE>The Little
Acts</CODE> и символ новой строки, и так далее.
<P>Если мы просто хотим скопировать данные в <CODE>STDOUT</CODE>, это сделает
оператор <CODE>print</CODE>:
<P>
<HR>
<PRE>
  # open...
  while (&lt;POEM&gt;) {
    print;
  }
</PRE>
<HR>
<P>По умолчанию <CODE>print</CODE> производит вывод в <CODE>STDOUT</CODE>, так что
мы просто копируем ввод в вывод. А что если мы хотим пронумеровать строки?
Переменная <CODE>$.</CODE> содержит номер строки последнего файла из которого
производилось чтение:
<P>
<HR>
<PRE>
  # open...
  while (&lt;POEM&gt;) {
    print &quot;$.: $_&quot;;
  }
</PRE>
<HR>
<P>И теперь мы получим красивое отображение, помеченное номера
строк. давайте немного оптимизуем этот код... слишком много набирать для
того, чтобы так мало выполнить в теле цикла:
<P>
<HR>
<PRE>
  # open...
  print &quot;$.: $_&quot; while &lt;POEM&gt;;
</PRE>
<HR>
<P>Здесь используется форма модификатора <CODE>while</CODE>. Каждая строка все
равно считывается в <CODE>$_</CODE>, и таким образом  <CODE>print</CODE> получает
правильную информацию.
<P>Даже оператор  <CODE>open</CODE> может быть оптимизован используя
великолепный оператор ``diamond (&lt;&gt;)''. Этот оператор просматривает
текущее значение массива <CODE>@ARGV</CODE> в поисках списка имен файлов, так
что давайте зададим их:
<P>
<HR>
<PRE>
  @ARGV = qw(peg_poem);
  while (&lt;&gt;) {
    print;
  }
</PRE>
<HR>
<P>Заметьте, что нам нет необходимости в явном открытии файла, поскольку
это выполняется оператором <CODE>&lt;&gt;</CODE>. Конечно, копирование файла
лучше выполняется модулем специально созданным для копирования:
<P>
<HR>
<PRE>
  use File::Copy;
  copy &quot;peg_poem&quot;, \*STDOUT;
</PRE>
<HR>
<P>Hо это просто другой способ выполнить работу.
<P>Давайте пойдем в другом направлении: обработке информации до того, как
она будет послана в вывод. Как артист, я уверен что Peg ценит возможность
включения пустых строк между параграфами поэмы. Hо как мы могли бы удалить
пустые строки из вывода? Достаточно просто: используя регулярное
выражение:
<P>
<HR>
<PRE>
  while (&lt;&gt;) {
    print if /\S/;
  }
</PRE>
<HR>
<P>В этом коде регулярное выражение ищет любой одиночный непробельный
символ. Если такого нет, то строка выглядит как пустая и не достойна
печати.
<P>Кроме печати данных сразу после считывания, мы также можем просто
считать весь файл в память для проведения дополнительных действий:
<P>
<HR>
<PRE>
  while (&lt;&gt;) {
    push @data, $_;
  }
</PRE>
<HR>
<P>Каждая новая строка добавляется в конец массива <CODE>@data</CODE>, который
в начале является пустым. Теперь мы можем выдать строки в обратном
порядке:
<P>
<HR>
<PRE>
  for ($i = $#data; $i &gt;= 0; $i--) {
    print $data[$i];
  }
</PRE>
<HR>
<P>И поскольку это работает (это нормальный цикл <CODE>for</CODE>), то в
действительности будет меньше работы для программиста (и немного больше для
Perl) если записать это просто как:
<P>
<HR>
<PRE>
  print reverse @data;
</PRE>
<HR>
<P>что получает массив <CODE>@data</CODE> и создает копию массива,
переворачивая исходный массив, а затем эта копия передается оператору
<CODE>print</CODE>.
<P>А что если мы захотим перевернуть каждую строку? Хорошо, в скалярном
контексте оператор <CODE>reverse</CODE> переворачивает строку. Hо символ новой
строки появится не там где нужно. Так что для получения правильного
результата нам необходимо выполнить несколько действий:
<P>
<HR>
<PRE>
  foreach $line (@data) {
    chomp($copy = $line);
    print reverse($copy).&quot;\n&quot;;
  }
</PRE>
<HR>
<P>Здесь я беру строку, копирую ее в отдельную переменную, так что
<CODE>chomp</CODE> не затронет оригинальный элемент массива <CODE>@data</CODE>), и
затем в скалярном контексте переворачивает ее (поскольку он используется в
операторе соединения строк) и результат выдается на вывод.
<P>Другим способом получения части строки, не включающей символа новой
строки, является использование регулярного выражения:
<P>
<HR>
<PRE>
  foreach (@data) {
    print reverse($1).&quot;\n&quot; if /(.*)/;
  }
</PRE>
<HR>
<P>В этом случае я использую неявную переменную <CODE>$_</CODE> вместе с
регулярным выражением, которое находит все символы за исключением символа
новой строки (поскольку знак точка <CODE>.</CODE> не соответствует символу
новой строки) и затем использую результат соответствия в функции
<CODE>reverse</CODE>. Волшебство!
<P>Мы могли бы также прогнать этот массив через операцию мапирования, так
что давайте глянем как это сделать. Давайте напишем простую собирательную
строку:
<P>
<HR>
<PRE>
  @reversed = map {
    /(.*)/ &amp;&amp; reverse($1).&quot;\n&quot;;
  } @data;
  print @reversed;
</PRE>
<HR>
<P>Операция <CODE>map</CODE> берет каждый из элементов <CODE>@data</CODE> и
временно помещает его в переменную <CODE>$_</CODE>. Соответствие регулярного
выражения всегда происходит, и после этого переменная <CODE>$1</CODE> содержит
строку не включающую символ новой строки, которая затем инвертируется и
символ новой строки помещается в конец строки. Конечно, нам не нужна
промежуточная переменная:
<P>
<HR>
<PRE>
  print map {
    /(.*)/ &amp;&amp; reverse($1).&quot;\n&quot;;
  } @data;
</PRE>
<HR>
<P>Я думаю, что Peg смеялся бы над результатом применения программы к его
работе, так что давайте взглянем на другие маленькие волшебные вещи.
<P>Если мы хотим разбить строки на серии слов, то самым простым способом
будет применение для каждой из строк регулярного выражения с ``глобальным''
модификатором, например вот так:
<P>
<HR>
<PRE>
  while (&lt;&gt;) {
    push @words, /(\S+)/g;
  }
</PRE>
<HR>
<P>Здесь используется регулярное выражение <CODE>\S+</CODE>, соответствующее 
каждой из протяженной последовательности непробельных символов. Так что
после обработки первой строки, мы будем иметь следующий результат:
<P>
<HR>
<PRE>
  @words = (&quot;The&quot;, &quot;Little&quot;, &quot;Acts&quot;);
</PRE>
<HR>
<P>а вторая строка не вносит в массив ничего, поскольку в ней нет
совпадений с регулярным выражением. Мы можем сократить этот код снова
используя оператор <CODE>map</CODE>:
<P>
<HR>
<PRE>
  @words = map /(\S+)/g, &lt;&gt;;
</PRE>
<HR>
<P>Это достаточно мощно, так что позвольте мне неспеша пройтись по этому
коду. Сначала оператор чтения стоящий справа используется в списочном
контексте, означая что все строки всех файлов из массива  <CODE>@ARGV</CODE>
считываются в один прием. Затем оператор <CODE>map</CODE> берет из полученного
массива по одному элементу (строке) и помещает его в переменную
<CODE>$_</CODE>. Затем в списочном контексте оценивается регулярное выражение и
поскольку совпадение для одной может произойти несколько раз, то каждое
совпадение дает нам 0 или более элементов в массиве результатов. Затем
полученный массив присваивается массиву <CODE>@words</CODE>. Классно, все
выполняется одной строкой кода.
<P>Проблемой является то, что мы вытягиваем и знаки пунктуации. Так что в
массиве слово <CODE>magic</CODE> появится как <CODE>magic.</CODE>, и это будет не
тоже самое слово, особенно для тех случаев когда мы хотим провести подсчет
слов.
<P>Так что мы можем немного изменить данный код:
<P>
<HR>
<PRE>
  @words = map /(\w+)/g, &lt;&gt;;
</PRE>
<HR>
<P>и теперь мы отбираем все смежные буквы, цифры и знаки подчеркивания,
которые подпадают под шаблон <CODE>\w+</CODE>.
<P>Hо этот шаблон разбивает слово &lt;There's&gt; на две части. Я
участвовал во многих обсуждениях разработчиков, на которых я требовал,
чтобы в определение <CODE>\w</CODE> были включены апострофы и и удалены знаки
подчеркивания. Так что, вот более точное и явное регулярное выражение
используемое мной:
<P>
<HR>
<PRE>
  @words = map /([a-zA-Z']+)/g, &lt;&gt;;
</PRE>
<HR>
<P>Так. Это работает с данной поэмой. И пропускает отвратительные номера
дней.
<P>А сейчас заключительный фокус, давайте узнаем какое из слов является
самым часто используемым. Поскольку некоторые из них имеют буквы в верхнем
регистре, то нам необходим еще один цикл:
<P>
<HR>
<PRE>
  @words = map lc, map /([a-zA-Z']+)/g, &lt;&gt;;
</PRE>
<HR>
<P>Эта строка приводит все слова к нижнему регистру. Hамного лучше! Теперь
давайте подсчитаем слова:
<P>
<HR>
<PRE>
  $count{$_}++ for @words;
</PRE>
<HR>
<P>Hет..... это не может быть так просто? но это так. Каждое из слов
оказывается в переменной <CODE>$_</CODE>. Мы используем ее как ключ к хешу. В
начале значение пары имеет значение <CODE>undef</CODE>, и оно увеличивается
когда мы находим соответствующее слово.
<P>Теперь давайте взглянем следующий код:
<P>
<HR>
<PRE>
  @by_order = sort { $count{$b} &lt;=&gt; $count{$a} } keys %count;
  for (@by_order) {
    print &quot;$_ =&gt; $count{$_}\n&quot;;
  }
</PRE>
<HR>
<P>Этот код выдает слова в отсортированном порядке. Я использовал блок
сортировки для контроля порядка ключей, и затем выдаю ключи в этом
порядке.
<P>Хорошо, я надеюсь, что вы увидели, что  Perl может быть волшебен
всегда. До следующей встречи, наслаждайтесь!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
