<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 23 -- Редактирование файлов на месте</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 23 -- Редактирование файлов на месте</H1>

<H2>Randal Schwartz</H2>Декабрь 1998<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Perl является хорошим средством для обработки текстовых
файлов. Некоторые из наиболее общих файлов Perl обычно используются для
обработки файлов протокола, который создаются почти всеми утилитами,
которые выполняют интересные вещи на вашей системе. Некоторые из моих
последних выпусков были нацелены на выполнение анализа этих данных, но
давайте глянем на более земную проблему: простое приведение в порядок
этих файлов.
<P>
<P>Допустим, имеется утилита, которая создает увеличивающийся файл
протокола, добавляя новые сообщения в конец файла. Большая часть файла
интересует нас, но много строк содержат в начале <CODE>warning:</CODE>,
что не интересно для нас. Так, что нашей задачей является исключение
этих строк из конечного файла.
<P>
<P>Давайте начнем с самого простого подхода. Предположим, что файл
протокола уже был создан как <CODE>log</CODE>, так что преобразуем его в
<CODE>clean-log</CODE>, используя простой цикл чтения и выполнения печати в
зависимости от условия:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        open IN, &quot;log&quot;
          or die &quot;Cannot open: $!&quot;;
        open OUT, &quot;&gt;clean-log&quot;
          or die &quot;Cannot create: $!&quot;;
        while (&lt;IN&gt;) {
          print OUT $_ unless /^warning:/i;
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>В этом коде у нас имеется два вызова функции <CODE>open</CODE>, а затем
выполняется цикл. Каждый раз проходя через цикл <CODE>while</CODE>, новая
строка оказывается в переменной <CODE>$_</CODE>. Затем она проверяется с
помощью регулярного выражения, и если она не соответствует данному
выражению, то строка выдается в выходной файл.
<P>
<P>Хорошо, этот код работает хорошо, но мы дважды использовали дисковое
пространство. Давайте реши эту проблему добавлением оператора
переименования в конец блока. Мы можем также избежать использования
нового имени файла, используя соглашение, которое добавляет символ
(<CODE>~</CODE>) в конец имени файла, означая ``временный или резервный
файл''.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $name = &quot;log&quot;;
        open IN, &quot;&lt;$name&quot;
          or die &quot;Cannot open: $!&quot;;
        open OUT, &quot;&gt;$name~&quot;
          or die &quot;Cannot create: $!&quot;;
        while (&lt;IN&gt;) {
          print OUT $_ unless /^warning:/i;
        }
        close IN;
        close OUT;
        rename &quot;$name~&quot;, $name
          or die &quot;Cannot rename: $!&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь я использовал в качестве параметра имя в переменной
<CODE>$name</CODE> и выходной файл, чье имя равно имени основного файла с
добавлением символа тильда. Запомните последние шаги: мы
переименовываем временный файл в оригинальный файл, таким образом
удаляя оригинальный файл. Это получается лучше. Теперь у меня есть
скрипт, который я мог запускать для того, что бы сделать файл короче и
чтобы он содержал только то, что мне необходимо!
<P>
<P>Хммм. Что, если скрипт сделает ошибку? Было бы хорошо иметь
резервную копию исходных данных, на которые я мог бы взглянуть когда
необходимо. Чтобы выяснить что изменилось, я мог бы тогда запустить
программу <CODE>diff</CODE> для старого м нового файлов. Давайте выполним
действия в том же порядке: сначала переименуем файл, затем выдадим
выбранные строки в новый файл с исходным именем:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $name = &quot;log&quot;;
        rename $name, &quot;$name~&quot;
          or die &quot;Cannot rename: $!&quot;;
        open IN, &quot;&lt;$name~&quot;
          or die &quot;Cannot open: $!&quot;;
        open OUT, &quot;&gt;$name&quot;
          or die &quot;Cannot create: $!&quot;;
        while (&lt;IN&gt;) {
          print OUT $_ unless /^warning:/i;
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Хмм. Это выглядит хорошо. Теперь у меня есть резервный файл (с
символом тильда в имени) и новый файл с данными. Давайте сделаем скрипт
более удобным; нет никакой причины помещать имя файла в скрипт. Давайте
будем считывать имя файла с командной строки (<CODE>@ARGV</CODE>) и сделаем
возможным задание нескольких файлов из командной строки:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        foreach $name (@ARGV) {
          rename $name, &quot;$name~&quot;
            or die &quot;Cannot rename: $!&quot;;
          open IN, &quot;&lt;$name~&quot;
            or die &quot;Cannot open: $!&quot;;
          open OUT, &quot;&gt;$name&quot;
            or die &quot;Cannot create: $!&quot;;
          while (&lt;IN&gt;) {
            print OUT $_ unless /^warning:/i;
          }
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Мы получили даже более мощный скрипт, добавив несколько строк
кода. Но возможно я ввел вас в заблуждение. Larry Wall (создатель Perl)
вероятно делал эти операции работы с текстом достаточно раз, что он
научил Perl делать это сразу. <EM>Режим редактирования по месту</EM>
сразу обрабатывает такие случаи. Если установлена переменная
<CODE>$^I</CODE> (либо внутри программ, либо ключом командной строки
<CODE>-i</CODE>), то открытие файла с помощью оператора чтения (&lt;&gt;)
автоматически выполняет аналогичную операцию:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $^I = &quot;~&quot;;
        while (&lt;&gt;)
          print unless /^warning:/i;
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Намного легче. И небрежно выполняет теже операции, что и код
приведенные выше. Заметьте, что мне не нужно было выполнять цикл по
списку <CODE>@ARGV</CODE>; Это подразумевается оператором чтения. Значение
переменной <CODE>$^I</CODE> (обычно <EM>undef</EM>) добавляется к именам
файлов, заданным в <CODE>@ARGV</CODE>, для того, чтобы создать резервные
файлы. 
<P>
<P>Все переименования и изменения предполагают, что программа больше не
выводит в файл протокола и мы можем работать с оригинальными данными
так, как мы захотим.  Давайте вмешаемся в картину, для того, чтобы
показать менее общий, но очень важный случай: блокировку файлов.
<P>
<P>Файловая система UNIX позволяет нескольким процессам получить доступ
на запись в файл. Но до тех пор, пока у нас не будет способа
координации записи в файл, данные в файле будут разрушены.
<P>
<P>Наиболее общим способов предотвращения разрушения данных является
использование <EM>блокировку файла</EM>. В Perl, это легко достигается
используя оператор <CODE>flock</CODE>, названный по имени системного
вызова, введенного разработчиками UNIX BSD. Даже, хотя в вариантах
System V UNIX такой функции не существует, оператор Perl превращается в
соответствующие низкоуровневые операции для выполнения совместимых
действий, так что этот оператор достаточно переносим.
<P>
<P>Вот базовые правила:
<P>
<OL>
<LI>Программы, которые хотят читать из файла, должный открыть
файл, а затем использовать <CODE>flock HANDLE, 1</CODE>.
</LI>
<LI>Программы, которые хотят читать из файла и <EM>записывать в
файл</EM> должны открыть файл, а затем использовать <CODE>flock
HANDLE, 2</CODE>.
</LI>
<LI>Вызов <CODE>flock</CODE> будет блокировать файл до тех пор пока
он доступен, в это время требуемые операции могут быть выполнены с
некоторой степенью безопасности.
</LI>
<LI>После выполнения операций уберите блокировку путем закрытия
файлового дескриптора. (Вы также можете выполнить отмену блокировку
без закрытия файла, но вы должны точно знать, что вы делаете. Самым
простым способом является простое закрытие файла).
</LI>
</OL>
<P>
<P>Заметьте, что блокирование файла только взаимодействует с другими
процессами, которые также блокируют файл. Если процесс выбирает такое
действие, он может совместно открыть файл на чтение или запись, и таким
образом работать с файлом. Поэтому этот метод называется
<EM>консультативной (advisory)</EM> блокировкой. (Hекоторые варианты
UNIX реализуют <EM>обязательную (mandatory)</EM> блокировку, но это еще
не так распространено).
<P>
<P>Так, что предположим, что наша утилита, которая создает файл
<EM>протокола</EM> все еще производит запись в него и что эта утилита
выполняет <CODE>flock</CODE> для этого файла при записи. Как мы можем
удалить предупреждения без копирования данных в другое место?
<P>
<P>Первым и быстрым решением является загрузка всех данных в память и
запись их без ненужных нам предупреждение:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $name = &quot;log&quot;;
        open LOG, &quot;+&lt;$name&quot;
          or die &quot;Cannot open $name: $!&quot;;
        flock LOG, 2;
        @data = grep !/^warning:/i, &lt;LOG&gt;;
        seek LOG, 0, 0;
        trunc LOG, 0;
        print LOG @data;
        close LOG;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь мы добавили знак плюс к режиму открытия файла, для того, чтобы
показать, что один и тот же файловый дескриптор будет использоваться и
для чтения и для записи данных. (Я я не открываю файл на запись позже,
поскольку можно потерять блокировку данного файла).
<P>
<P>После получения блокировки, мы можем изменять файл как захотим. Мы
заполняем массив <CODE>@data</CODE> строками из файла, которые нас
интересуют, а затем переписываем файл перемещаясь в его начало, задавая
обрезая его и затем выдавая данные в файл. Завершающий оператор
<CODE>close</CODE> освобождает файл, так что другие утилиты могут получить
новую блокировку для файла и продолжать запись в файл.
<P>
<P>Хорошо, это было достаточно остроумно, но заметьте, что теперь мне
необходимо все (новые) данные хранить в памяти. Для достаточно большого
файла это становится проблемой. Так, что давайте будем редактировать
файл ``на месте''. Это немного хитроумно, так что я дам вам программу,
а потом объясню как она работает:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $name = &quot;log&quot;;
        open LOG, &quot;+&lt;$name&quot;
          or die &quot;Cannot open $name: $!&quot;;
        flock LOG, 2;
        my $write_pos = 0;
        while (&lt;LOG&gt;) {
          unless (/^warning:/i) {
            my $read_pos = tell LOG;
            seek LOG, $write_pos, 0;
            print LOG $_;
            $write_pos = tell LOG;
            seek LOG, $read_pos, 0;
          }
        }
        trunc LOG, $write_pos;
        close LOG;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь я сопровождаю два указателя на файл: один на позицию чтения и
на позицию записи. Позиция чтения отслеживается автоматически в цикле
<CODE>while</CODE>. Позиция записи в начале начинается с нулевого значения,
а затем запоминается в переменной <CODE>$write_pos</CODE>. Внутри цикла,
когда я вижу запись, которую я хочу сохранить, я вычисляю текущую
позицию чтения используя функцию <CODE>tell</CODE>, перемещаюсь в позицию
записи, сохраняю необходимую запись и затем возвращаюсь в позицию
чтения. Однажды пройдя по файлу, я могу сократить его размер до позиции
записи, что я и делаю.
<P>
<P>Этот код работает только потому, что я делаю файл короче, но он
будет работать на огромных файлах, поскольку нам требуется память для
хранения только одной строки.
<P>
<P>Так что у вас есть программа. Много способов уменьшения количества
данных встретятся вам далее. Наслаждайтесь.
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
