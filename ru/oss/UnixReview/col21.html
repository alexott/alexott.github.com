<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 21 -- Выбор среди операций выбора</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 21 -- Выбор среди операций выбора</H1>

<H2>Randal Schwartz</H2>Август 1998<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Большинство современных алгоритмических языков имеют разные способы
выполнения ``условий'' и ``итераций'', или они будут бесполезными (или
полезными только для простых программ). Perl имеет разные способы
выбора и оценки циклов. Давайте рассмотрим некоторые из этих способов.
<P>
<P>Базовым элементом для выполнения выбора является <CODE>if</CODE>:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    if ($somecondition) {
      true_branch;
      true_branch;
    } else {
      false_branch;
      false_branch;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>вместе с предложением <CODE>elsif</CODE>:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    if ($cond_1) {
      true_branch_for_1;
      true_branch_for_1;
    } elsif ($cond_2) {
      true_branch_for_2;
      true_branch_for_2;
    } elsif ($cond_3) {
      true_branch_for_3;
      true_branch_for_3;
    } else {
      all_false_branch;
      all_false_branch;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Каждое из условий приведенных условий выполняется последовательно и
первое из условий, результат которого будет истинным вызовет выполнение
соответствующей ветви, пропуская все остальные условия. Удобная
конструкция.
<P>
<P>Hо также существуют другие способы получения тех же
результатов. Многие из них перечислены ``<CODE>man perlsyn</CODE>'' (или
``<CODE>perldoc perlsyn</CODE>'' если у вас не установлены справочные
страницы). Hапример, условие <CODE>if</CODE> может быть переписано как:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    $cond &amp;&amp; do {
      true_branch;
      true_branch;
    };
</PRE>
</CODE></BLOCKQUOTE>
<P>или мы можем окружить его ``backwards-if'', как в коде:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    do {
      true_branch;
      true_branch;
    } if $cond;
</PRE>
</CODE></BLOCKQUOTE>
<P>Я сам лично не использую этот прием часто. Мне кажется, что он
выглядит <EM>слишком</EM> задом наперед. Однако он является более
простой формой:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    $action_expression if $cond;
</PRE>
</CODE></BLOCKQUOTE>
<P>которую я использую часто. Hапример:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    print &quot;a is $a, b is $b\n&quot;
    if $debug;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь я устанавливаю <CODE>$debug</CODE> в начале программы, и все эти
операторы начинают выполняться. 
<P>
<P>Для получения большего количества вариантов, давайте сначала глянем
на построение блоков циклов. Базовый цикл <CODE>while</CODE> дает нам
повторяемое выполнение блока кода до тех пор, пока условное выражение
не станет ложным:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    while ($cond) {
      body;
      body;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>мы можем прервать выполнение цикла используя команду <CODE>last</CODE>,
как в коде:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    while ($cond) {
      body;
      last if $cond_2;
      body;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь обратный-if прерывает цикл в том случае, когда
<CODE>$cond_2</CODE> становится равным истинному выражению. Поскольку
<CODE>last</CODE> рассчитывается как выражение, то мы можем использовать
его в выражении, разделенном запятыми, для выполнения сразу нескольких
операций:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
    while ($cond) {
      body;
      ($a = &quot;something&quot;),
      ($b = &quot;something else&quot;),
      last
        if $cond_2;
      body;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Начав однажды, я предпочитаю сохранять левую часть оператора
обратный-if достаточно простой, так, что я использую ее таким же
ограниченным способом. Но рассматривайте, что может быть что-то
подобное такому непростому варианту:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
    while ($cond) {
      body;
      if ($cond_2) {
        $a = &quot;something&quot;;
        $b = &quot;something else&quot;;
        last;
      }
      body;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>который работает, но занимает несколько видимых строк. Также имеется
оператор <CODE>next</CODE>, который прыгает вперед в том случае, когда мы
видим, что есть вещи, которые нам не хочется выполнять:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    foreach $item (split) {
      body_1;
      next if $item =~ /^a/;
      body_2;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>В этом случае объекты начинающиеся с ``a'' обрабатываются
операторами <CODE>body_1</CODE>, но не обрабатываются операторами
<CODE>body_2</CODE>. Оператор <CODE>next</CODE> автоматически выполняет
оператор <CODE>continue</CODE>, который мы можем иногда указать сами:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    foreach $item (split) {
      body_1;
      next if $item =~ /^a/;
      body_2;
      next if $item =~ /z$/;
      body_3;
    } continue {
      body_4;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>В этом случае объекты начинающиеся с``a'' выполняют только блоки
<CODE>body_1</CODE> и <CODE>body_4</CODE>, в то время, как начинающиеся с ``z''
выполняют <CODE>body_1</CODE>, <CODE>body_2</CODE> и <CODE>body_4</CODE>, а все
остальные объекты выполняют все 4 действия. Это достаточно
гибко. Практическим применением этого является получение правильной
переменной <CODE>$.</CODE> в течении обработки чтения файла используя
&lt;&gt;. Вам необходимо закрыть <CODE>ARGV</CODE> когда вы обнаруживаете
конец файла, но только <EM>после</EM> того как вы выполните всю
обработку строки. Так что простой надежный цикл выглядит примерно так:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    while (&lt;&gt;) {
      next unless /perl/i;
      print &quot;$ARGV:$.:$_&quot;;
    } continue {
      close(ARGV) if eof;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Располагая <CODE>close</CODE> внутри <CODE>continue</CODE>, мы получаем
гарантию, что эта функция будет выполнена даже в том случае, если мы
выполним оператор <CODE>next</CODE>.
<P>
<P>Также существует оператор <CODE>redo</CODE>, который перезапускает
текущую итерацию. Вот великолепный практический пример использования
<CODE>redo</CODE> --обработка продолжающихся строк в файле настройки:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    while (&lt;&gt;) {
      s/#.*//;
      next unless /\S/;
      if (s/\s*\\\s*\n//) {
        $_ .= &lt;&gt;;
        redo;
      }
      ...;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Мы считываем данные по одной строке за раз в переменную
<CODE>$_</CODE>. Если строка содержит комментарий, то они удаляются из
нее. Если строка полностью состоит из пробельных символов (не содержит
непробельных символов), то она игнорируется. Хитрой частью является
подстановка. Любой символ обратный слэш в конце строки (возможно
окруженный пробелами) будет удален и мы добавим к строке следующую
строку из потока ввода.
<P>
<P>Однако мы опять получаем строку, для которой надо выполнить удаление
комментариев, проверку на то, что строка не пустая и возможно выполнить
дальнейшую обработку символов обратный слэш, так что самым простым
способом будет выполнить оператор <CODE>redo</CODE>, который выполнит
переход в начало цикла. Красиво и компактно.
<P>
<P>Операторы <CODE>last</CODE>, <CODE>next</CODE>, and <CODE>redo</CODE> применяются
к ``явному блоку'', точно также как и итераторы (<CODE>while</CODE>,
<CODE>until</CODE>, <CODE>for</CODE> и <CODE>foreach</CODE>). Используя явные блоки
(такие, которые не являются частью более крупной конструкции) мы скорее
можем создать произвольные контрольные структуры. Например, давайте
будем складывать все числа, которые вводятся по одному, останавливаясь
только при вводе слова ``end''.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    {
      print &quot;number? &quot;;
      chomp($n = &lt;STDIN&gt;);
      last if $n eq &quot;end&quot;;
      $sum += $n;
      redo;
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь явный блок работает как граница для заключенных в него
операторов <CODE>last</CODE> и <CODE>redo</CODE>. Эта проблема может быть
решена, но мы по существу создаем цикл, в который входят в центре, или
из которого выходят в центре, а зависимости от того, как вы
рассматриваете его. Используя явные блоки мы также можем создать
многовариантные проверки <CODE>if</CODE>. Давайте рассмотрим некоторую
элементарную обработку <CODE>@ARGV</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
    last unless $ARGV[0] =~ /^-/;
    $_ = shift;
    last if /^--$/; $verbose++, redo if /^-v$/; $radians++, redo if /^-r$/;
    $expr = ($1 || shift), redo if /^-e(.*)$/;
    $file = ($1 || shift), redo if /^-f(.*)$/; die ``unknown arg: $_'';
}
</PRE>
</CODE></BLOCKQUOTE>
<P>В этом коде мы обрабатываем записи в <CODE>@ARGV</CODE> до тех пор, пока
в них не будет отсутствовать начальное тире.  Если первый элемент
начинается с тире, то мы помещаем его в переменную <CODE>$_</CODE>. Если мы
встречаем двойное тире, то мы прекращаем обработку аргументов. Однако,
если мы встречаем <CODE>-v</CODE> или <CODE>-r</CODE>, то мы устанавливаем
соответствующую переменную и опять переходим в начало цикла. Если мы
встречаем <CODE>-e</CODE> или <CODE>-f</CODE>, то как параметр мы берем остаток
аргумента (или следующий аргумент, если нет последующего текста). В
заключение, если мы прошли по всем вариантам и не обнаружили то, что мы
хотим увидеть, то мы можем прекратить работу.
<P>
<P>Вы можете выполнить это также с помощью операторов <CODE>and</CODE> и
<CODE>or</CODE> как в следующем коде:
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
     $ARGV[0] =~ /^-/ or last;
     $_ = shift;
     /^--$/ and last;
     /^-v$/ and $verbose++, redo;
     /^-r$/ and $radians++, redo;
     /^-e(.*)$/ and $expr = ($1 || shift), redo;
     /^-f(.*)$/ and $file = ($1 || shift), redo;
     die ``unknown arg: $_'';
}
</PRE>
</CODE></BLOCKQUOTE>
<P>Этот код выполняет тоже самое, что и предыдущий пример. Когда я
начал писать этот пример, я стал ``yuck'', поскольку иногда я до
некоторой степени был враждебно настроен против использования
операторов <CODE>and</CODE> и <CODE>or</CODE> в пустом (void) контексте (просто
из-за их постороннего эффекта выполнять правую часть оператора в
зависимости от условного выражения). Однако после тщательного
рассмотрения этого кода, я стал более благосклонным к таком коду,
поскольку он был для меня более ясным. Отрицательным эффектом может
быть то, что кто-то просматривающий код может не понимать как работают
операторы <CODE>and</CODE> и <CODE>or</CODE>, так что может быть полезным
комментирование кода.
<P>
<P>Итак, я надеюсь, что я дал вам дополнительные варианты создания
условных выражений и позволил вам увидеть дополнительные формы
операторов повторения. Всегда помните девиз Perl: <EM>Существует более
чем один способ решения!</EM> Увидимся в следующий раз.
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
