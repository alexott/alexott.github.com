<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 14 -- Еще раз об объектах</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 14 -- Еще раз об объектах</H1>

<H2>Randal Schwartz</H2>Май 1997<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt;
<P>В моем предыдущем выпуске я начал обзор Объектно-ориентированных
возможностей Perl. В качестве иллюстрации я создал класс, названный
``Car'', и дал этому классу ``методы'' позволяющие пассажирам входить,
выходить и учитываться. Хотя вы можете читать этот выпуск, не прочитав
предыдущий выпуск, но я вам настоятельно рекомендую сначала прочитать
прочитать его. (Если у вас есть доступ к internet, то вы можете прочитать
предыдущий выпуск по адресу 
<A HREF="http://www.stonehenge.com/merlyn/UnixReview/">http://www.stonehenge.com/merlyn/UnixReview/</A><P>Так, что продолжая с того, места там где я вас оставил в прошлый раз,
давайте возьмем набор транспортных средств:
<P>
<HR>
<PRE>
        my $myCar = new Car;
        my $myTruck = new Truck;
</PRE>
<HR>
<P>Теперь, это должно создать новые объекты Car и Truck. Теперь, эти
транспортные средства будут похожи во многих свойствах, но будут отличаться
в других свойствах. Мы представим это, используя ``наследование'' от общего
класса ``Vehicle'', например вот так:
<P>
<HR>
<PRE>
        BEGIN {
          @Car::ISA = &quot;Vehicle&quot;;
          @Truck::ISA = &quot;Vehicle&quot;;
        }
</PRE>
<HR>
<P>Причиной того, что я поместил этот код в блок <CODE>BEGIN</CODE>, поскольку
необходимо, чтобы этот код был выполнен <EM>до того</EM> как я вызову
оператор <CODE>new</CODE>, даже если, я помещу эти операторы в конце
программы. Обычно, все настройки <CODE>@ISA</CODE> должны происходить до
выполнения первых ``настоящих'' строк кода.
<P>Но что здесь делается? Как вы видите, нет метода
<CODE>Car::new</CODE>. Вместо этого Perl будет искать этот метод в классе
Vehicle. Аналогично, нет метода <CODE>Truck::new</CODE>. Вместо этого, у нас
имеется метод <CODE>&amp;Vehicle::new:</CODE>
<P>
<HR>
<PRE>
        sub Vehicle::new {
          bless my $self = {}, shift;
          my %parms = @_;
          $self-&gt;{Passengers} = $parms{Passengers} || {};
          $self;
        }
</PRE>
<HR>
<P>Заметьте, что это код очень похож на код <CODE>Car::new</CODE> из
предыдущего выпуска. Первая строка создает анонимный ассоциативный массив,
присваивая его переменной <CODE>$self</CODE>, и ассоциируя его с правильным
пакетом. Заметьте, что имя пакета получается как первый параметр, в этом
случае получаемом с помощью оператора <CODE>shift</CODE>. Вторая строка создает
именованный ассоциативный массив <CODE>%parms</CODE> из оставшихся аргументов
данного метода.
<P>Третья строка отличается от строки метода <CODE>Car::new</CODE>. Я позволяю
передавать список пассажиров, которые в начале будут посажены в машину,
например вот так:
<P>
<HR>
<PRE>
        $myCar = new Car Passengers =&gt; qw(Fred Dino);
</PRE>
<HR>
<P>Если такой список не был указан, то машина начинает свое движение
пустой. Последняя строка возвращает созданную машину. 
<P>Так, что этот метод может использоваться и  для класса Car и для класса
Truck, для создания соответственно Car и Truck. Однако существует различее
между Car и Truck, так, что мы получим немного проблем из-за
ничего. Давайте добавим дополнительное поведение к этим транспортным
средствам, и затем начнем различать их.
<P>Сначала, давайте снова добавим методы <CODE>enter</CODE>, <CODE>leave</CODE> и
<CODE>jump</CODE> из предыдущего выпуска:
<P>
<HR>
<PRE>
        $myCar-&gt;enter(qw(Fred Barney));
        $myTruck-&gt;enter(qw(Wilma Betty));
        $myTruck-&gt;jump(To =&gt; $myCar, People =&gt; qw(Wilma));
        $myCar-&gt;leave(qw(Fred Barney Wilma));
</PRE>
<HR>
<P>Обычно говоря, Fred и Barney едут в машине, а Wilma и Betty трясутся в
грузовике. Внезапно Wilma покидает грузовик и пересаживается в машину, а
затем уговаривает Fred и Barney вместе с ней покинуть машину. (Betty все
еще остается одна в грузовике). Давайте взглянем на то, как это будет
реализовываться:
<P>
<HR>
<PRE>
        sub Vehicle::enter {
          my $self = shift;
          for (@_) {
            $self-&gt;{Passengers}-&gt;{$_} = &quot;seat&quot;;
          }
          $self;
        }
</PRE>
<HR>
<P>В этом коде, объект сохраняется в переменной <CODE>$self</CODE>, а затем для
каждого из оставшихся аргументов, мы добавляем объект в хеш
<CODE>Passengers</CODE> с именем в качестве ключа и номером места в качестве
значения (также как и в прошлом выпуске). Заметьте, что этот метод
определяется в классе <CODE>Vehicle</CODE>, делая его доступным для классов Car
и Truck. Аналогичным образом определяется мето <CODE>leave</CODE>:
<P>
<HR>
<PRE>
        sub Vehicle::leave {
          my $self = shift;
          for (@_) {
            delete $self-&gt;{Passengers}-&gt;{$_};
          }
          $self;
        }
</PRE>
<HR>
<P>И в этом коде, отличие между методами <CODE>enter</CODE> и <CODE>leave</CODE>
заключается в том, что они делают с хешем <CODE>Passengers</CODE>. Метод
<CODE>jump</CODE> является немного пугающим, но все равно достаточно легким для
чтения:
<P>
<HR>
<PRE>
        sub Vehicle::jump {
          my $self = shift;
          my %parms = @_;
          my $dest_vehicle = $parms{To} ||
            new {ref $self};
          my $people = $parms{People} ||
            [keys %{$self-&gt;{Passengers}}];
          $people = [$people] unless ref $people;
          $self-&gt;leave(@$people);
          $dest_vehicle-&gt;enter(@$people);
          $dest_vehicle;
        }
</PRE>
<HR>
<P>Первым делом, объект сохраняется в переменной <CODE>$self</CODE>, а
оставшиеся аргументы формируют ассоциативный массив
<CODE>%parms</CODE>. Выбирается транспортное средство назначения. Если
существует запись в ассоциативном массиве для ключа <CODE>To</CODE>, то
выбирается это значение, в противном случае создается новое транспортное
средство.
<P>Но какого типа должно быть транспортное средство? Произвольное
допущение, соединенное с годами программирования, позволяет мне считать,
что новое транспортное средство должно быть того же размера и формы, что и
средство, которое покидает пассажир. Мы можем получить тип вызывая <CODE>ref
$self</CODE>, результат которого передается как ``объект'' для вызова
<CODE>new</CODE>. (Было бы неплохо так создавать объекты в реальном мире? Но я
отклонился от темы...)
<P>Далее следует назначенный пассажир, который переходит из машины в
машину. Это будет либо список, указанный параметром <CODE>People</CODE>, либо
все пассажиры, находящиеся в машине. Заметьте, что здесь ожидается, что
<CODE>$people</CODE> будет ссылкой на список, но если кто-то передаст скаляр,
то у нас позже будут проблемы, так что строка, которая начинается с
<CODE>$people =</CODE>, если необходимо, превращает простое имя в
одно-элементный анонимный список.
<P>После того, как определены исходное транспортное средство
(<CODE>$self</CODE>), люди (<CODE>@$people</CODE>) и устройство в которое будет
производится переход (<CODE>$dest_vehicle</CODE>) мы можем начать перемещение
людей. Сначала людей просят покинуть исходное транспортное средство, а
затем просят войти в требуемое транспортное средство. В заключение,
возвращается новое транспортное средство (которое может быть тем же самым,
что и переданное как параметр <CODE>To</CODE>, или совершенно новым объектом
Car или Truck).
<P>Хорошо, это реализует практически все, что необходимо для работы. Для
проверки работы, мне необходимо иметь некоторый способ для доступа к
текущему списку пассажиров:
<P>
<HR>
<PRE>
        sub Vehicle::passengers {
          my $self = shift;
          sort keys %{self-&gt;{Passengers}};
        }
</PRE>
<HR>
<P>Почему бы не дать пользователям классов Car и Truck знать, что
<CODE>$self-&gt;{Passengers}</CODE> является хешем, ключами которого являются
текущие пассажиры? Хорошо, я мог бы выбрать этот способ, если бы я был
ленив, или если бы производительность была бы критическим фактором. Однако,
я был привязан к этому интерфейсу навсегда, даже если бы позже я обнаружил,
что легче было бы список пассажиров реализовать в виде списка, а не
ассоциативного массива. Однако, лучше предоставить методы для доступа,
поддеpживающие pаботу пользователей не напpямую.
<P>Эти классы транспортных средств имеют вопиюще малую обработку
ошибок. Давайте добавим такую проверку, и покажем, почему классы Car и
Truck являются различными, в одно и тоже время:
<P>
<HR>
<PRE>
        sub Vehicle::enter {
          my $self = shift;
          if (@_ + keys %{$self-&gt;{Passengers}} &gt; $self-&gt;seats) {
            die &quot;Cannot add @_ to $self&quot;;
          }
          for (@_) {
            $self-&gt;{Passengers}-&gt;{$_} = &quot;seat&quot;;
          }
          $self;
        }
</PRE>
<HR>
<P>Давайте взглянем на то, что происходит здесь. Я добавляю длину списка
аргументов (в массиве <CODE>@_</CODE>) к количеству ключей, для того, чтобы
посмотреть, не больше ли это число числа, возвращаемого при вызову метода
<CODE>seats</CODE>. Если число больше, то в машину пытается сесть больше людей,
чем имеется мест, и происходит прекращение выполнения программы.
<P>Но что такое метод <CODE>seats</CODE>? Я его еще не определил, но он будет
выглядеть примерно так:
<P>
<HR>
<PRE>
        sub Vehicle::seats { 2 }
</PRE>
<HR>
<P>Это не слишком сложно. Теперь и грузовики и легковые машины, все имеют по
2 места, также как и все другие классы, унаследованный от Vehicle. Но
подождите&nbsp;--- легковые машины имеют по 4 места! Так, что просто
добавим этот факт:
<P>
<HR>
<PRE>
        sub Car::seats { 4 }
</PRE>
<HR>
<P>Когда вызывается метод <CODE>$myCar-&gt;seats</CODE>, то он возвращает
значение 4 (поскольку мы нашли <CODE>seats</CODE> прямо в <CODE>Car</CODE>). Но
когда вызывается <CODE>$myTruck-&gt;seats</CODE>, то метода
<CODE>Truck::seats</CODE> не существует, так что Perl произведет поиск в путях
наследования, для того, чтобы найти значение по умолчанию для количества
мест в <CODE>Vehicle</CODE>! Для отработки, мы могли бы определить еще
несколько типов:
<P>
<HR>
<PRE>
        BEGIN {
          @Motorcycle::ISA = &quot;Vehicle&quot;;
          @Van::ISA = &quot;Vehicle&quot;;
          @Unicycle::ISA = &quot;Vehicle&quot;;
        }
        sub Van::seats { 8 }
        sub Unicycle::seats { 1 }
</PRE>
<HR>
<P>И заметьте, что я не определил метод <CODE>seats</CODE> для класса
Motorcycle, поскольку значение по умолчанию (2) является правильным.
<P>
<P>То, что вы увидели здесь, является примером наследования и перегрузки
методов. Наследование выражается в том, что значение <CODE>seats</CODE> для
2-местных транспортных средств получается прямо из объекта
Vehicle. Перезагрузка выражается в том, что <CODE>seats</CODE> для транспортных
средств с другим количеством мест, перекрывает значение, определенное в
классе Vehicle.
<P>Я надеюсь, что вы насладились этой краткой прогулкой в страну объектов,
и вы смогли увидеть некоторые возможности. Наслаждайтесь!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
