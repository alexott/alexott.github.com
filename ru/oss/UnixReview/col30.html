<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 30 -- Глубокое копирование и рекурсия</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 30 -- Глубокое копирование и рекурсия</H1>

<H2>Randal Schwartz</H2>Февраль 2000<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Один из модулей, который я обнаружил на CPAN имел проблему с
созданием нескольких объектов. Отдельные объекты создавались нормально,
но при дальнейшем одновременном использовании объектов, некоторые
данные из одного объекта таинственным способом оказывались в другом
объекте, даже если первый объект был освобожден!
<P>
<P>При тщательном рассмотрении я обнаружил, что объект
инициализировался из <EM>поверхностной копии</EM> шаблона, и я сообщил
автору, то ему вместо этого необходимо выполнять <EM>глубокое
копирование</EM> шаблона. Он был озадачен этим предложением, и
если вы также не знакомы с этими двумя терминами, то  я думаю6 что вы
также озадачены.
<P>
<P>Что такое глубокое копирование и почему оно нужно нам? Давайте
начнем с простого примера и вернемся к задаче, с которой я столкнулся.
<P>
<P>Например, давайте соберем всю информацию о паролях в простой хеш,
ключом которого будет имя пользователя, а значением -- ссылка на массив
из девяти значений возвращаемых функцией <CODE>getpwent()</CODE>. В
первом приближении, мы быстро напишем что-то подобное этому:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  while (@x = getpwent()) {
    $info{$x[0]} = \@x;
  }
  for (sort keys %info) {
    print &quot;$_ =&gt; @{$info{$_}}\n&quot;
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>Что? Где будут находиться данные? Мы сохранили ссылку на данные в
значение хеша. Хорошо, может сделаем код более ясным:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  while (@x = getpwent()) {
    $info{$x[0]} = \@x;
    print &quot;$info{$x[0]}\n&quot;;
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>На моей машине, это несколько раз выдает <CODE>ARRAY(0x80ce7fc)</CODE>,
по одному разу для каждого из пользователей в системе. Так что это
значит? Это значит, что мы используем один и тот же массив, и таким
образом у нас нет различных ссылок, указывающих на разные массивы, у
нас есть один массив, с множеством ссылок, указывающих на одни и те же
данные. Таким образом, при последнем проходе цикла, массив <CODE>@x</CODE>
будет опустошен и все ссылки на массив будут указывать на одинаковые
пустые данные.
<P>
<P>Это происходит, поскольку мы выполнили <EM>поверхностное
копирование</EM> ссылки на массив <CODE>@x</CODE> в значение хеша, что
копирует только указатель, а не содержимое массива. Что нам нужно,
чтобы копировать не только ссылку, но и данные, на которые указывает
данная ссылка. В нашем случае, это достаточно просто:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  while (@x = getpwent()) {
    $info{$x[0]} = [@x];
  }
  for (sort keys %info) {
    print &quot;$_ =&gt; $info{$_} =&gt; @{$info{$_}}\n&quot;
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>И вы можете заметить, что мы для каждого из элементов хеша мы
получили разные ссылки на массивы, указывающие на независимые копии
9-элементного массива, вначале содержавшегося в массиве
<CODE>@x</CODE>. Этот код работе, поскольку мы создавали анонимные ссылки
на массивы с помощью выражения <CODE>[@x]</CODE>, что также дает анонимному
массиву начальное значение, копируя элементы из массива <CODE>@x</CODE>.
<P>
<P>Вот основной принцип <EM>глубокого копирования</EM>: для обеспечения
полной независимости необходимо выполнять копирование не только
указателя верхнего уровня, но и всех данных внутри структуры данных.
<P>
<P>В действительности был другой способ для обеспечения уникальных
операторов в данном примере, и я покажу его для чтобы неполным
изложением не вызывать раздражение моих друзей-знатоков Perl. Вам нет
необходимости копировать что-либо, если вы перед этим создали отдельный
массив:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  while (my @x = getpwent()) {
    $info{$x[0]} = \@x;
  }
  for (sort keys %info) {
    print &quot;$_ =&gt; $info{$_} =&gt; @{$info{$_}}\n&quot;
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь, каждый проход по циклу начинается с выделения совершенно
лексически нового  массива <CODE>@x</CODE>, вместо повторного использования
существующей переменной, Так что когда на нее берется ссылка, и когда
переменная выходит из области видимости в конце цикла, то переменная
автоматически остается, уже как анонимная переменная.
<P>
<P>Так что давайте вернемся к глубокому копированию. Вот другой
пример. Предположим, что Fred и Barney используют один дом:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $place = {
    Street =&gt; &quot;123 Shady Lane&quot;,
    City =&gt; &quot;Granite Junction&quot;,
  };
  $fred = {
    First_name =&gt; &quot;Fred&quot;,
    Last_name =&gt; &quot;Flintstone&quot;,
    Address =&gt; $place,
  };
  $barney = {
    First_name =&gt; &quot;Barney&quot;,
    Last_name =&gt; &quot;Rubble&quot;,
    Address =&gt; $place,
  };
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь заметьте, что <CODE>$fred-&amp;gt;{Address}{City}</CODE> равен
``Granite Junction'', как мы и ожидали, этому значению равен и
<CODE>$barney-&amp;gt;{Address}{City}</CODE>. Но мы выполнили поверхностное
копирование <CODE>$place</CODE> в значения обоих элементов
<CODE>Address</CODE>. Это значит, что у нас нет двух копий данных, а просто
один экземпляр данных. Мы можем убедиться в этом, когда мы изменим одно
из значений. Давайте позволим Fred переехать в другое место:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $fred-&gt;{Address}{Street} = &quot;456 Palm Drive&quot;;
  $fred-&gt;{Address}{City} = &quot;Bedrock&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Выглядит достаточно правильно. Но что случилось с Barney? Он
переехал вместо с Fred!
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
print &quot;@{$barney-&gt;{Address}}{qw(Street City)}\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Этот код выдает новый адрес Fred! Почему это случилось? Присвоение
<CODE>$place</CODE> как адреса, в обоих случаях выполнило поверхностное
копирование: обе структуры данных использовали общий указатель на общие
данные улицы и адреса. Далее нам могло бы помочь глубокое копирование:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $place = {
    Street =&gt; &quot;123 Shady Lane&quot;,
    City =&gt; &quot;Granite Junction&quot;,
  };
  $fred = {
    First_name =&gt; &quot;Fred&quot;,
    Last_name =&gt; &quot;Flintstone&quot;,
    Address =&gt; {%$place},
  };
  $barney = {
    First_name =&gt; &quot;Barney&quot;,
    Last_name =&gt; &quot;Rubble&quot;,
    Address =&gt; {%$place},
  };
  $fred-&gt;{Address}{Street} = &quot;456 Palm Drive&quot;;
  $fred-&gt;{Address}{City} = &quot;Bedrock&quot;;
  print &quot;@{$barney-&gt;{Address}}{qw(Street City)}\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь... теперь каждое поле <CODE>Address</CODE> является полностью
отдельной копией, так что при обновлении одной из копий, остальные
копии остаются без изменений. Это работает, поскольку как и в случае с
выражением <CODE>[@x]</CODE>, мы создаем новый анонимный хеш и берем ссылку
на него.
<P>
<P>Но что делать, если <CODE>$place</CODE> сам по себе является сложной
структурой? Например, предположим, что улица в адресе состоит из
названия и номера:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $place = {
    Street =&gt; {
      Number =&gt; 123,
      Name =&gt; &quot;Shady Lane&quot;,
    },
    City =&gt; &quot;Granite Junction&quot;,
  };
  $fred = {
    First_name =&gt; &quot;Fred&quot;,
    Last_name =&gt; &quot;Flintstone&quot;,
    Address =&gt; {%$place},
  };
  $barney = {
    First_name =&gt; &quot;Barney&quot;,
    Last_name =&gt; &quot;Rubble&quot;,
    Address =&gt; {%$place},
  };
</PRE>
</CODE></BLOCKQUOTE>
<P>Теперь мы делаем то, что не является ни глубоким копированием, ни
поверхностным копированием. Хеш <CODE>$fred-&amp;gt;{Address}</CODE>
отличается от хеша <CODE>$barney-&amp;gt;{Address}</CODE>. Но они оба
содержат значение, которое идентично ссылке на хеш
<CODE>$place-&amp;gt;{Street}</CODE>! Так, что если Fred просто переедет
дальше по улице:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $fred-&gt;{Address}{Street}{Number} = 456;
</PRE>
</CODE></BLOCKQUOTE>
<P>то Barney снова переедет вместе с ним! Теперь мы можем исправить
положение применяя логику к процессу копирования адреса, для того чтобы
скопировать и описание улицы:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $fred = {
    First_name =&gt; &quot;Fred&quot;,
    Last_name =&gt; &quot;Flintstone&quot;,
    Address =&gt; {
      Street =&gt; {%{$place-&gt;{Street}}},
      City =&gt; $place-&gt;{City},
    },
  };
</PRE>
</CODE></BLOCKQUOTE>
<P>Но как вы можете видеть, процесс становится более и более
извилистым. И что будет если мы заменим <CODE>City</CODE> на другую
структуру, или добавим другой уровень к структуре <CODE>Street</CODE>.
<P>
<P>К счастью, мы можем написать простую подпрограмму копирования,
применимую для общих задач, используя рекурсию. Вот пример подпрограммы
глубокого копирования:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  sub deep_copy {
    my $this = shift;
    if (not ref $this) {
      $this;
    } elsif (ref $this eq &quot;ARRAY&quot;) {
      [map deep_copy($_), @$this];
    } elsif (ref $this eq &quot;HASH&quot;) {
      +{map { $_ =&gt; deep_copy($this-&gt;{$_}) } keys %$this};
    } else { die &quot;what type is $_?&quot; }
  }
</PRE>
</CODE></BLOCKQUOTE>
<P>Эта подпрограмма получает один параметр: вершину дерева скалярных
переменных и указателей на хеши и массивы. Если объект является
скалярной переменной, то он просто возвращается в вызывающую программу,
поскольку поверхностное копирование скаляра является и глубоким
копированием. Если объект является ссылкой на массив, то мы из
данных создаем с новый анонимный массив. Однако каждый из элементов
массива также может являться структурой данных, так что нам необходимо
выполнить глубокое копирование этих данных. Решение является очень
простым: просто вызвать <CODE>deep_copy</CODE> для каждого из
элементов. Аналогичным образом новая ссылка на хеш создается
копированием каждого из элементов, включая глубокое копирование
значений хеша. (Ключ хеша всегда является простым скаляром, так что он
не нуждается в копировании, хотя это должно быть достаточно просто для
добавления). Для того, чтобы убедиться в работоспособности, давайте
передадим некоторые данные:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $place = {
    Street =&gt; {
      Number =&gt; 123,
      Name =&gt; [qw(Shady Lane)],
    },
    City =&gt; &quot;Granite Junction&quot;,
    Zip =&gt; [97007, 4456],
  };
  $place2 = $place;
  $place3 = {%$place};
  $place4 = deep_copy($place);
</PRE>
</CODE></BLOCKQUOTE>
<P>Хммм7 Как мы можем увидеть что мы сделали, и что было  использовано
совместно? Давайте добавим вызов стандартного библиотечного модуля,
названного <CODE>Data::Dumper</CODE>:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  use Data::Dumper;
  $Data::Dumper::Indent = 1;
  print Data::Dumper-&gt;Dump(
    [$place, $place2, $place3, $place4],
    [qw(place place2 place3 place4)]
  );
</PRE>
</CODE></BLOCKQUOTE>
<P>И вот что выдается на моей машине:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $place = {
    'City' =&gt; 'Granite Junction',
    'Zip' =&gt; [
      97007,
      4456
    ],
    'Street' =&gt; {
      'Name' =&gt; [
        'Shady',
        'Lane'
      ],
      'Number' =&gt; 123
    }
  };
  $place2 = $place;
  $place3 = {
    'City' =&gt; 'Granite Junction',
    'Zip' =&gt; $place-&gt;{'Zip'},
    'Street' =&gt; $place-&gt;{'Street'}
  };
  $place4 = {
    'City' =&gt; 'Granite Junction',
    'Zip' =&gt; [
      97007,
      4456
    ],
    'Street' =&gt; {
      'Number' =&gt; 123,
      'Name' =&gt; [
        'Shady',
        'Lane'
      ]
    }
  };
</PRE>
</CODE></BLOCKQUOTE>
<P>Давайте посмотрим на результаты. <CODE>Data::Dumper</CODE> позволяет мне
увидеть, что <CODE>$place2</CODE> является поверхностной копией
<CODE>$place</CODE>, тогда как <CODE>$place3</CODE> является промежуточной копией.
Обратите внимание на элементы <CODE>$place</CODE> внутри
<CODE>$place3</CODE>. И поскольку <CODE>$place4</CODE> не содержит
использованных до этого ссылок, то мы знаем, что эта переменная
является полностью независимой глубокой копией. Успех! (Порядок
элементов хеша является несовместимым, но при обычном использовании это
является неважным и неопределяемым).
<P>
<P>Теперь эта простая подпрограмма <CODE>deep_copy</CODE> будет давать
сбой, если будут использоваться рекурсивные ссылки на данные (ссылки,
которые указывают на данные выше по дереву). Для решения этой, вы
можете взглянуть на метод <CODE>dclone</CODE> модуля <CODE>Storable</CODE>,
который можно найти на CPAN.
<P>
<P>Так, что когда вы используете <CODE>=</CODE> для структуры, то
убедитесь, что вы знаете что делаете. Вместо поверхностного копирования
вам может понадобиться глубокое копирование. Для получения
дополнительной информации обратитесь к оперативной документации с
помощью команд <CODE>perldoc perldsc</CODE> и <CODE>perldoc perllol</CODE>, или
даже для описания основ, к документации выдаваемой командами
<CODE>perldoc perlref</CODE> и <CODE>perldoc perlreftut</CODE>. Встретимся в
следующий раз, наслаждайтесь!
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
