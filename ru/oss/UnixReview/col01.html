<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 1 -- Простой разбор данных</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 1 -- Простой разбор данных</H1>

<H2>Randal Schwartz</H2>март 1995<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Perl быстро стал ключевым инструментом в багаже типичного системного
администратора и системного программиста. 
<P>
<P>Тем не менее, легко испугаться при виде 211 страниц печатной
документации, которые идут с последней версией Perl (версия 5).  У вас
могут возникнуть вопросы: ``С чего начать?'' и ``Сколько из этого надо
знать, чтобы писать на Perl?''
<P>
<P>Один из самых простых способов научиться&nbsp;--- смотреть, как
кто-нибудь другой решает элементарную задачу. Например, возьмем типичную
задачу администрирования&nbsp;--- присвоение уникального номера (userID)
новому пользователю. Для этого, мы должны узнать текущий максимальный номер
пользователя(userID), и затем выбрать следующий максимальный номер.
<P>
<P>Мы разобьем задачу на мелкие подзадачи и будем их решать. 
<P>
<P>Сначала рассмотрим печать первой колонки данных, выдаваемых командой
<CODE>who</CODE>
<P>
<HR>
<PRE>
who | perl -ne '@F = split; print ''$F[0]\n'';'
</PRE>
<HR>
<P>
<P>Выходной поток <CODE>who</CODE> становится входным потоком для Perl. Ключ -n
заставляет Perl исполнять некоторый код строчка за строчкой. Каждая входная
строчка помещается в переменную <CODE>$_</CODE>. Ключ -e указывает код, который
будет исполнять Perl. Ключи можно комбинировать, как это сделали мы.
<P>
<P>В нашем случае есть два Perl выражения: операция <CODE>split</CODE>, и
<CODE>print</CODE>. Операция <CODE>split</CODE> разбивает содержимое <CODE>$_</CODE>,
создавая список слов (считаем пробелы разделителями слов). Список
помещается в массив <CODE>@F</CODE>. Затем операция <CODE>print</CODE> печатает
содержимое первого элемента массива <CODE> @F</CODE> и сразу перевод строки
(\n). Заметим, что первый элемент массива имеет номер 0, подобно массивам в
Си.
<P>
<P>Можно немного урезать код, удалив <CODE>split</CODE>:
<P>
<HR>
<PRE>
who | perl -ane 'print ''$F[0]\n'' '
</PRE>
<HR>
<P>
<P>Заметим добавление ключа -a, заставляющего Perl автоматически выполнить
<CODE>split</CODE> и поместить результат в массив <CODE>@F</CODE>.
<P>
<P>Чтобы укоротить строчку еще больше, добавим ещё ключ&nbsp;-l, который
делает две вещи сразу:
<P>
<UL>
<LI>Удаляет символ новой строки из <CODE>$_</CODE> перед тем, как наш
код просмотрит строку. </LI>
<LI>Приклеивает символ новой строки
обратно на выводимую строчку.</LI>
</UL>
<P>
<P>В результате получаем: 
<P>
<HR>
<PRE>
who | perl -lane 'print $F[0]'
</PRE>
<HR>
<P>
<P>Чтобы еще сократить код, заменим ключ -n на -p, который заставляет
Perl печатать содержимое, оставшееся в <CODE>$_</CODE>:
<P>
<HR>
<PRE>
who | perl -lape '$_ = $F[0]'
</PRE>
<HR>
<P>
<P>Аналогичный по функциональности Perl-скрипт выглядит так:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        $\ = $/;                # from -l
        while (&lt;>) {            # from -p
                chop;           # from -l
                @F = split;     # from -a
                $_ = $F[0];     # argument to -e
                print;          # from -p
        }
</PRE>
<HR>
<P>
<P>Здесь видно, какое количество текста сократили нам ключи в командной
строке Perl.
<P>
<P>Переменная <CODE>$\</CODE> задаёт терминатор-суффикс для каждой
операции <CODE>print</CODE>, подобно переменной ORS в Awk. По умолчанию эта
переменная пуста, что позволяет вам самостоятельно контролировать формат выводимой
<CODE>print</CODE> информации. 
<P>
<P>Здесь мы устанавливаем переменную <CODE>$\</CODE> равной значению переменной
<CODE>$/</CODE>, которая является разделителем полей ввода (подобно RS в
Awk). По умолчанию, её значение равно '\n'. Таким образом, мы
добиваемся перевода на новую строчку после каждой выведенной строки.
<P>
<P>Теперь от команды <CODE>who</CODE> перейдём к реальной задаче: разбор
файла паролей для поиска наибольшего номера пользователя (userID).
<P>
<P>Файл паролей отличается от того, что выдаёт <CODE>who</CODE> тем, что колонки
разделены не пробелами, а двоеточиями. Нет проблем&nbsp;--- сообщим об этом 
Perl:
<P>
<HR>
<PRE>
perl -F: -lane 'print $F[0]' /etc/passwd 
</PRE>
<HR>
<P>
<P>С помощью ключа -F мы задали новый разделитель колонок и в
результате получили список всех пользователей в нашей системе.
<P>
<P>Если у нас запущена служба ``Жёлтых Страниц'' (Yellow Pages), то
вам, возможно, надо будет другим образом получить информацию о
пользователях: 
<P>
<HR>
<PRE>
ypcat passwd | perl -F: -lane 'print $F[0]' 
</PRE>
<HR>
<P>
<P>Здесь команда ypcat выдает в поток стандартного вывода файл похожий
на passwd, который может быть обработан Perl так же как и локальный
/etc/passwd.
<P>
<P>Во всех наших упражнениях мы получали только имена пользователей, а
не их номера (userID). Номер пользователя (userID) находится в третьей 
колонке, или <CODE>$F[2]</CODE> в нашем скрипте. 
<P>
<HR>
<PRE>
perl -F: -lane 'print $F[2]' /etc/passwd 
</PRE>
<HR>
<P>
<P>Мы получили список номеров, теперь надо определить максимальный и
напечатать следующий максимальный номер. 
<P>
<P>Для этого заведём скалярную переменную <CODE>$max</CODE>. Изначально,
<CODE>$max</CODE> не определена, она будет равняться нулю в сравнениях с числами.
Наша работа состоит в сравнении каждого номера пользователя (userID) с
<CODE>$max</CODE> и установке <CODE>$max</CODE> в значение номера, если он больше.
<P>
<HR>
<PRE>
perl -F: -lane '$max = $F[2] if $max &lt; $F[2]; \
       print $max' /etc/passwd 
</PRE>
<HR>
<P>
<P>Здесь мы присваиваем <CODE>$max</CODE> значение <CODE>$F[2]</CODE>, как только
выполнилось условие
<P>
<HR>
<PRE>
$max &lt; $F[2]
</PRE>
<HR>
<P>
<P>Это происходит на каждом шаге цикла по строчкам файла
<HR>
<PRE>
/etc/passwd
</PRE>
<HR>
. Это одно из мест в Perl, где логическое
условие размещается слева, а не справа.
<P>
<P>Изобразим это равнозначным скриптом:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        $\ = $/;
        while (&lt;>) {
                chop;
                @F = split /:/;
                $max = $F[2] if $max &lt; $F[2];
                print $max;
        }
</PRE>
<HR>
<P>
<P>Это уже почти то, что нам надо. Однако нам все еще надо передавать
данные из /etc/passwd в скрипт, что не совсем удобно. Давайте
внесем открытие файла /etc/passwd внутрь скрипта.
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        open(PASSWD,"/etc/passwd");
        $\ = $/;
        while (&lt;PASSWD>) {
                chop;
                @F = split /:/;
                $max = $F[2] if $max &lt; $F[2];
                print $max;
        }
</PRE>
<HR>
<P>
<P>Директива <CODE>open </CODE> создаёт дескриптор файла, ассоциированный с
/etc/passwd для чтения.
<P>
<P>Если у вас используются Yellow Pages, то для этого случая решение
чуть-чуть длиннее:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        open(PASSWD,"ypcat passwd|");
        $\ = $/;
        while (&lt;PASSWD>) {
                chop;
                @F = split /:/;
                $max = $F[2] if $max &lt; $F[2];
                print $max;
        }
</PRE>
<HR>
<P>
<P>Здесь Perl использует вместо файла вывод команды. Признаком команды
является вертикальная черта в конце. Это напоминает оператор
перенаправления, который мы использовали при написании command-line
версии программы.
<P>
<P>Вывод наших последних нескольких программ представлял собой серию
чисел, представляющих максимальный userID, который мы находили на
каждом шаге. На самом же деле, нам нужно только последнее число.
Как это сделать в программе? Просто вынесем <CODE>print</CODE> из цикла.
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        open(PASSWD,"/etc/passwd"); # or YP equivalent
        $\ = $/;
        while (&lt;PASSWD>) {
                chop;
                @F = split /:/;
                $max = $F[2] if $max &lt; $F[2];
        }
        print $max + 1;
</PRE>
<HR>
<P>
<P>Не забудем прибавить 1, чтобы получить число большее, чем предыдущее
максимальное. 
<P>
<P>Теперь сохраним этот скрипт в файле, поставим на нём бит
исполнимости и поместим его куда-нибудь в <CODE>$PATH</CODE>. Потом, когда нам 
понадобится новый номер пользователя, просто вызовем этот скрипт,
заключив его имя в обратные кавычки, и получим правильный номер. 
<P>
<P>Или почти правильный номер. Некоторые системы (типа SunOS, на которых это
тестировалось), имеют пользователя <CODE>nobody</CODE>, который имеет максимально
возможный номер, например, 65535. Если мы запустим нашу программу, то
получим не то, что хотели.
<P>
<P>Поступим просто -- исключим большие номера, например, большие 30000,
т.е. <CODE>$max</CODE> будет изменяться только если <CODE>$F[2]</CODE> меньше
30000. Нам всего  лишь придётся усложнить правую часть <CODE>if</CODE>:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        open(PASSWD,"/etc/passwd"); # or YP equivalent
        $\ = $/;
        while (&lt;PASSWD>) {
                chop;
                @F = split /:/;
                $max = $F[2] if $F[2] &lt; 30000 and $max &lt; $F[2];
        }
        print $max + 1;
</PRE>
<HR>
<P>
<P>Вот, с этой задачей покончили. Как минимум, она работает на SunOS.
<P>
<P>Так что решение этой маленькой задачи получилось не таким уж маленьким,
но по крайней мере мы выполнили ее с помощью нескольких строк на Perl.
Теперь, если вы не боитесь длинных командных строк, то давайте переведём
эту программу в форму командной строки:
<P>
<HR>
<PRE>
perl -aF: -lne '$m=$F[2] if $F[2]&lt;30000 and $m&lt;$F[2];\
          END { print $m+1 }' /etc/passwd
</PRE>
<HR>
<P>
<P>
<P>Здесь интересным свойством является то, что блок <CODE>END</CODE>
автоматически перемещается за пределы неявного цикла, помещая его там, где
он находится в скрипте.
<P>
<P>Если вы новичок в Perl, то вы, вероятно, захотите найти хорошую
книгу. Есть две книги, которые я могу порекомендовать вам, хотя я иногда
некритичен к ним, поскольку участвовал в написании обеих.
<P>
<P>Learning Perl (O'Reilly and Associates, ISBN 1-56592-042-2) постепенное
введение в язык, вместе с упражнениями и прокомментированными
ответами. Рассчитана на людей ``знакомых с UNIX, но никоим образом не
Гуру'', хотя, определённо, у вас уже должны быть базовые знания по
программированию перед тем, как вы откроете эту книгу.
<P>
<P>Programming Perl (O'Reilly and Associates, ISBN 0-937175-64-1) это
большой всеобъемлющий справочник по всему языку, соавтором книги является
создатель Perl Ларри Уолл (Larry Wall). Там Вы встретите также некоторое
количество учебного материала и много длинных практических примеров. Тем не
менее, книга предназначена для Гуру, и если вы не программируете в UNIX с
1977 года, как я, она может просто влететь вам в одно ухо и вылететь из
другого. (c) LVK
<P>
<P>Кроме того, есть очень хорошая группа новостей в Usenet, называемая
comp.lang.per
<BLOCKQUOTE>lee7 говорит, что теперь уже
comp.lang.perl.misc</BLOCKQUOTE>
, которую читают очень высококлассные
специалисты в Perl, включая Ларри Уолла (и вашего покорного слугу). Если у
вас имеются сложности с доступом к Usenet, то вместо этого вы можете
послать письмо на адрес perl-users-request@virginia.edu и попросить, чтобы
вас подписали на список рассылки.
<HR>
Next
Previous
Contents
</BODY>
</HTML>
