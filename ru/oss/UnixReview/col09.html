<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 9</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 9</H1>

<H2>Randal Schwartz</H2>Июль 1996<P>Возможности Perl по обработке текстов предоставляют нам прямой доступ к
набору высокоуровневых возможностей по работе с текстами. Однако иногда
проблемой является, не что сделать с полученным текстом, а пропустить
вещи, которые выглядят не как текст. Давайте посмотрим как можно
использовать возможности Perl для распознавания текстовых файлов (как
противоположность двоичным файлам) и облегчения типичных задач обработки
данных.
<P>Сначала, давайте воссоздадим простейшую форму программы, которая
эмулирует стандартную команду grep из поставки Unix.
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        $search = shift;
        $showname = @ARGV &gt; 1;
        while (&lt;&gt;) {
                next unless /$search/o;
                print &quot;$ARGV: &quot; if $showname;
                print;
        }
</PRE>
<HR>
<P>Первая выполняемая  строка после заголовка <CODE>#!</CODE> получает первый
параметр командной строки (находящейся в массиве <CODE>@ARGV</CODE>), вырезает
его из массива и помещает в переменную <CODE>$search</CODE>. Здесь
используется свойство, что по умолчанию оператор <CODE>shift</CODE> применяется
к массиву <CODE>@ARGV</CODE>.
<P>Далее, если осталось более одного аргумента, то мне необходимо запомнить
его в переменной <CODE>$showname</CODE>, так что я могу отображать имя файла
вместе с найденными строками, точно также как это делает команда
grep. <CODE>$showname</CODE> будет иметь истинное значение, когда число
аргументов больше единицы, и ложное значение в противном случае.
<P>Затем идет типичный цикл (``diamond-loop''): каждая строка из файлов
указанных в командной строке считывается в переменную <CODE>$_</CODE>, и тело
цикла получает возможность работать со строкой.
<P>Первая строка в цикле производит поиск значения хранимого в
<CODE>$search</CODE> (оно интерпретируется как регулярное выражение Perl)
внутри содержимого переменной <CODE>$_</CODE>. Если ничего не найдено, то мы
переходим к следующей строке. Модификатор ``o'' в регулярном выражении
является ускорителем работы&nbsp;-- без него регулярное выражение
``компилировалось'' бы на каждом проходе цикла, без нужды замедляя работу,
поскольку наше регулярное выражение не меняется.
<P>Затем происходит обращение к переменной <CODE>$showname</CODE>: если она
имеет истинное значение, то нам необходимо вставить имя файла в выводимую
строку. С счастью Perl хранит имя файла в переменной <CODE>$ARGV</CODE> (только
случайно названной также как и дескриптор файла <CODE>ARGV</CODE> и массив
<CODE>@ARGV</CODE>).
<P>В заключение, независимо от того, выдается ли имя файла или нет,
происходит вывод текущей строки (из переменной <CODE>$_</CODE>, поскольку
оператор <CODE>print</CODE> без аргументов производит вывод переменной
<CODE>$_</CODE>).
<P>Так, что данная маленькая программа эмулирует простейшую форму команды
grep: а именно, ее запуск в виде:
<P>
<HR>
<PRE>
        grep регулярное_выражение [файл ... ]
</PRE>
<HR>
<P>Я также должен сказать, что эта программа для определенных регулярных
выражений выполняется быстрее чем соответствующие варианты grep
поставляемые производителями Unix: ядро работы с регулярными выраженими в
внутри Perl считаются одним из самых быстрых.
<P>Итак, зачем я переписываю grep? Затем, что я могу придать ему
дополнительную функциональность! Поставляемая с системой команда grep
рассматривает и текстовые и двоичные файлы. Много раз мне хотелось просто
выполнить что-то подобное:
<P>
<HR>
<PRE>
        textgrep regex *
</PRE>
<HR>
<P>и чтобы эта волшебная команда ``textgrep'' просматривала только
текстовые файлы, пропуская двоичные файлы соответствующие <CODE>*</CODE>. В
частности мой личный каталог ``binary'' (<CODE>$HOME/.bin</CODE>) имеет набор
двоичных программ, но в основном это исполнимые скрипты (в основном на Perl
:-), и мне хотелось бы иногда выполнить:
<P>
<P>
<HR>
<PRE>
        cd $HOME/.bin
        textgrep &quot;строка&quot; *
</PRE>
<HR>
<P>для выполнения поиска только в скриптах. Другим применением может быть
запуск внутри ``рабочего'' каталога с набором исходных текстов программы и
объектных файлов. Если вы ищете определенную строку в файле исходных
текстов, то вы не хотите просматривать двоичный файл который был
скомпилирован из файла исходных текстов!
<P>Так что давайте посмотрим, сможем ли мы сделать из нашего
``grep-на-perl'' команду ``textgrep''. Первым шагом должно быть отличие
текстовых файлов от двоичных. Perl выполняет это легко, используя
встроенный оператор <CODE>-T</CODE>. Этот оператор возвращает истинное
значение, если строка аргумента (имя файла) или файловый дескриптор
представляет ``текстовый файл''. Unix не имеет простого признака файла,
является ли он ``текстовым'' или ``двоичным'', так что вместо этого Perl
считывает кусок данных из файла и пытается угадать является ли этот файл
текстовым или двоичным. Обычно он угадывает правильно, но иногда может быть
ошибка.
<P>Поскольку массив <CODE>@ARGV</CODE> содержит имена файлов, то логично будет
протестировать каждый из них с помощью оператора <CODE>-T</CODE> для
определения к какому типу относится файл. Мы можем сделать это в
сокращенной форме, используя оператор <CODE>grep</CODE> (не путайте с командой
grep из Unix, хотя имя оператора было выбрано из-за похожего действия).
<P>Оператор <CODE>grep</CODE> оценивает блок кода для каждого из элементов
списка, временно помещая каждый из элементов в переменную <CODE>$_</CODE>. Для
тех элементов, для которых блок кода вернул истинное значение эти элементы
остаются в списке, так что на первый взгляд, мы можем просто записать:
<P>
<HR>
<PRE>
        @ARGV = grep { -T } @ARGV;
</PRE>
<HR>
<P>Однако это не работает в тех случаях, когда нам необходимо использовать
``-'' в списке  <CODE>@ARGV</CODE>. ``-'' обозначает ``считывание из
стандартного ввода'', что к счастью считается текстовым файлом. Однако
<CODE>-T</CODE> будет отбрасывать этот несуществующий файл, так что мы должны
учитывать этот специальный случай. Это не так тяжело, но теперь код
выглядит так:
<P>
<HR>
<PRE>
        @ARGV = grep { -T or $_ eq &quot;-&quot; } @ARGV;
</PRE>
<HR>
<P>Великолепно! <CODE>@ARGV</CODE> теперь содержит только текстовые файлы!
Только есть один раздражающий вариант. Когда оригинальный список файлов
содержит только двоичные файлы, то теперь <CODE>@ARGV</CODE> будет пуст. Это
неудобно, поскольку теперь программа будет производить считывание со
стандартного ввода, даже хотя пользователь задал в командной строке набор
имен файлов. Давайте взглянем как я обрабатываю данный случай в законченной
программе:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        $search = shift;
        $showname = @ARGV &gt; 1;
        @ARGV = &quot;-&quot; unless @ARGV;
        @ARGV = grep { -T or $_ eq &quot;-&quot; } @ARGV;
        exit 0 unless @ARGV;
        while (&lt;&gt;) {
                next unless /$search/o;
                print &quot;$ARGV: &quot; if $showname;
                print;
        }
</PRE>
<HR>
<P>Заметьте, что четвертая строка заменяет пустой массив  <CODE>@ARGV</CODE> на
массив <CODE>@ARGV</CODE> состоящий исключительно из ``-''. Это не не изменяет
поведения программы, но позволяет мне протестировать дальнейшее поведение
программы при использовании пустого массива.
<P>Следующая строка производит отбор только текстовых файлов, как это
описано выше. Следующая после нее строка заканчивает выполнение программы,
если список файлов является пустым, поскольку нам нечего сканировать!
Остальная часть программы аналогична предыдущим версиям.
<P>Теперь у нас есть программа, которую мы могли бы назвать
``textgrep''. Она не имеет аргументов, хотя и понимает ``-'' в списке
файлов, что значит ``стандартный ввод'', и предполагает, что стандартный
ввод всегда является текстовым файлом.
<P>Давайте пойдем далее. Стандартная команда grep имеет ключ ``-l''
(маленькая буква L), которая заставляет выводить только список
соответствующих файлов, без вывода совпавшей строки. Это полезно для
выполнения различных операций. Hапример, для редактирования всех файлов из
текущего каталога, которые содержат строку ``fred'', я мог бы сказать:
<P>
<HR>
<PRE>
        vi `grep -l fred *`
</PRE>
<HR>
<P>Или для перемещения всех этих файлов в каталог ../freds,
<P>
<HR>
<PRE>
        mv `grep -l fred *` ../freds
</PRE>
<HR>
<P>Так что давайте придадим ``textgrep'' такую же возможность. Это делается
таким кодом:
<P>
<HR>
<PRE>
        #!/usr/bin/perl
        $names++, shift if $ARGV[0] eq &quot;-l&quot;;
        $search = shift;
        $showname = @ARGV &gt; 1;
        @ARGV = &quot;-&quot; unless @ARGV;
        @ARGV = grep { -T or $_ eq &quot;-&quot; } @ARGV;
        exit 0 unless @ARGV;
        while (&lt;&gt;) {
                next unless /$search/o;
                if ($names) {
                        print &quot;$ARGV\n&quot;;
                        close ARGV;
                } else {
                        print &quot;$ARGV: &quot; if $showname;
                        print;
                }
        }
</PRE>
<HR>
<P>Давайте рассмотрим дополнительные строки: первая строка после
комментария изучает <CODE>$ARGV[0]</CODE> (первый аргумент). Если он равен
``-l'', то мы хотим работать в режиме ``только имена'', так что я
устанавливаю флаг <CODE>$names</CODE>, и удаляю ключ ``-l'' из массива. К
счастью, следующий элемент является регулярным выражением и оно сохраняется
в следующей строке.
<P>Другое изменение находится внутри тела цикла. Заметьте, что когда строка
найдена, то я проверяю флаг <CODE>$names</CODE>. Если он имеет истинное
значение, то программа выдает имя файла, за которым следует перевод строки,
а затем закрывается файл <CODE>ARGV</CODE>. Мы закрываем файл <CODE>ARGV</CODE>
поскольку оператор считывания автоматически перейдет к следующему файлу,
когда мы вернемся к началу цикла. После нахождения требуемой строки нет
необходимости в проверке остатка файла. Это также обеспечивает, что имя
файла будет показано только однажды, вне зависимости от количества
совпадений в файле.
<P>Если <CODE>$names</CODE> имеет ложное значение, т.е. не был задан ключ
``-l'', то выполняется код из предыдущих версий, заключенный в блок
``else''.
<P>Используя эту программу, я могу работать только с текстовыми файлами.
Hапример, редактировать текстовые файлы в которых есть строка ``fred'':
<P>
<HR>
<PRE>
        vi `textgrep -l fred *`
</PRE>
<HR>
<P>Или даже послать все текстовые файлы на устройство печати:
<P>
<HR>
<PRE>
        pr `textgrep -l '^' *` | lpr -Pslatewriter
</PRE>
<HR>
<P>Заметьте, что  ``^'' соответствует началу строки, что обычно является
истинным для любого из файлов в которых производится поиск, но запомните,
что  textgrep отбрасывает нетекстовые файлы!
<P>Как вы смогли увидеть, всего с помощью дюжины строк на Perl, я воссоздал
очень популярную утилиту Unix, и даже придал ей дополнительную
функциональность. Я надеюсь, что вы получили наслаждение от этого короткого
экскурса в работу с текстом. Увидимся в следующий раз!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
