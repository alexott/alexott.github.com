<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 32 -- Некоторые приемы работы c printf</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 32 -- Некоторые приемы работы c printf</H1>

<H2>Randal Schwartz</H2>Июнь 2000<P>[Предполагаемый заголовок: Пусть это выглядит так, как вы захотите]
<P>
<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>В большинстве случаев, программисты на Perl для вывода данных
стараются использовать великолепный <CODE>print</CODE> или время от времени
окунаются в мир форматов, для того, чтобы быстро сделать наброски
различных отчетов. Однако, оператор <CODE>printf</CODE>, на который часто
не обращают внимания, обеспечивает необходимое количество параметров
настройки, для того, чтобы строки выглядели так, как вы этого хотите.
<P>
<P>Оператор <CODE>printf</CODE> получает строку формата и ноль или
несколько значений. Строка формата управляет всем процессом. За
несколькими исключениями, каждое поле со знаком процента <CODE>%</CODE>
используемое в строке формата, соответствует одному из дополнительных
значений, определяя то, как значение будет выглядеть при
выводе. Например:
<P>
<P>
<HR>
<PRE>
  printf &quot;my string %s has %d characters.\n&quot;, $str, length($str);
</PRE>
<HR>
<P>Здесь поле <CODE>%s</CODE> выдает символьное значение, которое находится
в переменной <CODE>$str</CODE>. Аналогичным образом поле <CODE>%d</CODE> выдает
десятичное значение, вычисленное операцией
<CODE>length($str)</CODE>. Параметры оцениваются в списочном контексте, так
что мы могли бы использовать следующий код для достижения тех же
результатов: 
<P>
<P>
<HR>
<PRE>
  @output = ($str, length($str));
  printf &quot;my string %s has %d characters.\n&quot;, @output;
</PRE>
<HR>
<P>Задача становится интересной, если мы не знаем длину массива
<CODE>@output</CODE>, поскольку нам необходимо иметь поле <CODE>%</CODE> для
каждого из элементов массива <CODE>@output</CODE>, но поскольку мы сами
создали массив, то здесь нет никаких проблем.
<P>
<P>Кроме <CODE>%s</CODE> для строк и <CODE>%d</CODE> для десятичных целых
чисел, другим часто применяемым форматом является <CODE>%f</CODE> для чисел
с плавающей запятой:
<P>
<P>
<HR>
<PRE>
  printf &quot;he has $%f in his account\n&quot;, 3.50;
</PRE>
<HR>
<P>Здесь значение 3.5 выдается как число с плавающей точкой
<CODE>3.500000</CODE>. Но почему появились лишние нули? По умолчанию
точность для чисел с плавающей запятой равна 6 символам после
десятичной точки. Для уменьшения этого значения, мы можем управление
точностью в формат, поместив нужное число между <CODE>%</CODE> и
<CODE>f</CODE>.
<P>
<P>
<HR>
<PRE>
  printf &quot;he has $%.2f in his account\n&quot;, 3.50;
</PRE>
<HR>
<P>И это выдаст нам <CODE>3.50</CODE>, как мы и ожидали. Здесь <CODE>2</CODE>
означает, что будет выводиться дву цифры, что станет означать
центы. Для того, чтобы вместиться в заданный формат, число округляется,
так что <CODE>3.509</CODE> должно показываться как <CODE>3.51</CODE>, а
<CODE>3.502</CODE> будет выведено как <CODE>3.50</CODE>. В качестве крайнего
случая мы можем использовать <CODE>%.0f</CODE> для округления до ближайшего
целого числа, и десятичная точка не будет использоваться.
<P>
<P>Другим общим форматом в научной нотации является <CODE>%e</CODE>. Он
полезен того, когда число может быть слишком большим для представления
несколькими цифрами:
<P>
<P>
<HR>
<PRE>
  printf &quot;2 to the 100 power is approximately %e\n&quot;, 2 ** 100;
</PRE>
<HR>
<P>Это выдаст нам <CODE>1.267651e+30</CODE>, снова используя 6 цифр после
десятичной точки, до тех пор пока мы не будем явно задавать точность,
например как <CODE>%.10e</CODE>.
<P>
<P>Но <CODE>%e</CODE> редко используется (как я заметил). В общем случае,
когда выдается число неизвестной величины или точности, то большинство
программистов возвращаются к использованию <CODE>%g</CODE> ``общему формату
чисел''. В этом случае, число форматируется используя либо <CODE>%d</CODE>,
либо <CODE>%f</CODE>, либо <CODE>%e</CODE>, в зависимости от того, какой из
форматов дает ``лучший'' результат. Если число является целым, то будет
использован формат для целых чисел. Если число с плавающей точкой имеет
разумную величины, то используется обычный формат, а в противном случае
будет использоваться научный вид записи чисел.
<P>
<P>
<HR>
<PRE>
  printf &quot;Your number is %g\n&quot;, $number;
</PRE>
<HR>
<P>Снова может быть использовано указание точности, но в этом случае
это поле указывает максимальное количество значащих цифр, со значением
по умолчанию равным 6. Так что для <CODE>%.15g</CODE>, мы получим наилучшее
отображение 15 наиболее значащих цифр.
<P>
<P>Для строк, мы получаем аналогичный контроль ``точности''. Если мы
включаем точности для строки, а строка длинее заданного числа, то она
автоматически сокращается:
<P>
<P>
<HR>
<PRE>
  printf &quot;I said %.5s!\n&quot;, &quot;hello world&quot;;
</PRE>
<HR>
<P>что выдает <CODE>I said hello!</CODE>, обрезая строку.
<P>
<P>Другой возможностью <CODE>printf</CODE> является указание ширины
поля. После того, как будет определено значение для отдельного поля, то
может использоваться минимальная ширина поля, указанная десятичным
числом после знака процента:
<P>
<P>
<HR>
<PRE>
  printf &quot;=%10s=\n&quot;, &quot;hello&quot;;
</PRE>
<HR>
<P>Здесь строка из символов не заполняет все 10 символов, так что слева
будет добавлено 4 пробела. Здесь указывается минимальная, а не
максимальная ширина поля, так что если строка будет длинее, то она
будет выдана полностью. Мы можем объединить поле указания точности с
полем указания ширины, для того, чтобы получить строку, которая
дополнена до заданного размера, или обрезана, если строка превышает
заданный размер. Рассмотрим простой код:
<P>
<P>
<HR>
<PRE>
  printf &quot;=%5.5s=\n&quot;, substr(&quot;1234567890&quot;, 0, $_) for 0..10;
</PRE>
<HR>
<P>что выдает нам великолепную модель:
<P>
<P>
<HR>
<PRE>
    =     =
    =    1=
    =   12=
    =  123=
    = 1234=
    =12345=
    =12345=
    =12345=
    =12345=
    =12345=
    =12345=
</PRE>
<HR>
<P>Дополнение пробелами может происходить справа, а не слева, при
использовании отрицательного числа в качестве минимальной ширины:
<P>
<P>
<HR>
<PRE>
  printf &quot;=%-5.5s=\n&quot;, substr(&quot;1234567890&quot;, 0, $_) for 0..10;
</PRE>
<HR>
<P>
<HR>
<PRE>
    =     =
    =1    =
    =12   =
    =123  =
    =1234 =
    =12345=
    =12345=
    =12345=
    =12345=
    =12345=
    =12345=
</PRE>
<HR>
<P>Также числа могут дополняться нулями, а не пробелами, если
использовать знак <CODE>0</CODE> в начале ширины:
<P>
<P>
<HR>
<PRE>
  printf &quot;%02d:%02d:%02d %s&quot;, $h, $m, $s, $ampm;
</PRE>
<HR>
<P>Если число в <CODE>$m</CODE> меньше чем 10 (например 7), то мы получим в
выводе ведущий 0 (например <CODE>07</CODE>), что очень полезно для отображения
времени, как в нашем случае.
<P>
<P>Знак <CODE>%</CODE> может быть получен его дублированием, как в коде:
<P>
<P>
<HR>
<PRE>
  printf &quot;He scored %.0f%% of the goals&quot;, 100 * $him / $total;
</PRE>
<HR>
<P>Заметьте, что часто предпринимаемое маскирование <CODE>%</CODE> с помощью
символа обратный слэш, не будет работать. Это не проблема интерполяции
строк: это проблема интерпретации в <CODE>printf</CODE>.
<P>
<P>Одним, из менее часто используемых форматов является ``символьный''
формат:
<P>
<P>
<HR>
<PRE>
  printf &quot;the letter A is %c\n&quot;, 65;
</PRE>
<HR>
<P>Здесь, значение 65 рассматривается как код ASCII, и превращается в
символ ``A''. Этот формат не так часто используется в Perl, в отличии
от C, поскольку Perl связан со строками как типами данных первого
класса, редко раскрывая программисту численные значения индивидуальных
символов.
<P>
<P>И имеются форматы ``типов для программиста'' ... <CODE>%h</CODE> для
шестнадцатеричного вывода, <CODE>%o</CODE> для восьмеричного, и новый
формат в Perl 5.6, <CODE>%b</CODE> для двоичного вывода. Например, вот один
из способов для того, чтобы показать права доступа к файлу:
<P>
<P>
<HR>
<PRE>
        printf &quot;%s is mode %o\n&quot;, $_, 07777 &amp; (stat)[2] for @ARGV;
</PRE>
<HR>
<P>Но глядя на вывод, значения искажают все вокруг. Нужно использовать
поле минимальной длины:
<P>
<P>
<HR>
<PRE>
        printf &quot;%30s is mode %04o\n&quot;, $_, 07777 &amp; (stat)[2] for @ARGV;
</PRE>
<HR>
<P>Это основы, но давайте также взглянем на некоторый практический
код.Предположим, что у меня есть набор значений в массиве
<CODE>@numbers</CODE>, которые я хочу напечатать в виде вертикальной
колонки с форматом <CODE>%15g</CODE> для всех чисел. Вы можете подумать,
что я могу просто сделать следующее:
<P>
<P>
<HR>
<PRE>
        printf &quot;%15g\n&quot;, @numbers; # bad
</PRE>
<HR>
<P>Но этот код не будет работать, поскольку поле <CODE>%</CODE> необходимо
для каждого из значений списка (как мы увидели ранее). Хорошо, простым
способом исправления этой проблемы является использовании цикла:
<P>
<P>
<HR>
<PRE>
        printf &quot;%15g\n&quot;, $_ for @numbers;
</PRE>
<HR>
<P>Но другим способом является репликация строки формата. Если нам
необходимо выдать три записи, что нам нужна строка
<CODE>%15g\n%15g\n%15g\n</CODE>, которую мы можем получить с помощью
операции <CODE>&quot;%15g\n&quot; x 3</CODE>. Так что нам необходимо знать
число элементов в массиве <CODE>@numbers</CODE> для использования в правой
части оператора <CODE>x</CODE>. Это достаточно просто: просто используйте
имя массива в скалярном контексте (который здесь и используется!):
<P>
<P>
<HR>
<PRE>
        printf &quot;%15g\n&quot; x @numbers, @numbers;
</PRE>
<HR>
<P>Здесь массив <CODE>@numbers</CODE> используется и в скалярном и в
списочном контексте в одном выражении: один и тот же текст, но с разным
значением. 
<P>
<P>Время от времени, вам может понадобиться переменная дина
колонки. Например вам может понадобиться, чтобы число <CODE>15</CODE> из
предыдущего примера было настраиваемым:
<P>
<P>
<HR>
<PRE>
        $width = 15;
        printf &quot;%$widthg\n&quot;, $_ for @numbers; # bad
</PRE>
<HR>
<P>Этот код не работает, поскольку Perl ищет переменную с именем
<CODE>$widthg</CODE>, даже если вы использовали имя переменной
<CODE>$width</CODE> за которой следует <CODE>g</CODE>. Но вы также не можете
помести здесь пробел, поскольку формат для <CODE>printf</CODE> разборчив и
не понимает пробелов. Одним из решений является отделение имени
переменной:
<P>
<P>
<HR>
<PRE>
        $width = 15;
        printf &quot;%${width}g\n&quot;, $_ for @numbers;
</PRE>
<HR>
<P>Другим способом является использование в списке <CODE>*</CODE> для того,
чтобы определить число. Каждое появление <CODE>*</CODE> в формате поля
заставляет использовать один элемент из списка значений для численного
значения, которое обозначает <CODE>*</CODE>:
<P>
<P>
<HR>
<PRE>
        $width = 15;
        printf &quot;%*g\n&quot;, $width, $_ for @numbers;
</PRE>
<HR>
<P>И мы получили это. Много способов для выдачи ваших чисел, строк и
всего, что получается в ваших вычислениях. Встретимся в следующий раз,
наслаждайтесь!
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
