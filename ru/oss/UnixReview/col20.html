<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 20 -- Вычисление выражений в тексте</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 20 -- Вычисление выражений в тексте</H1>

<H2>Randal Schwartz</H2>Июнь 1998<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Среди многих способов работы с текстовыми строками, Perl является
``text wrangling'' языком. Perl делает легким процесс считывания
строк произвольной длины, выбора и извлечения интересующих данных,
выдачи результатов в файлы, сокеты или другие процессы.
<P>
<P>Одной из интересных проблем является возможность использования в
тексте произвольных выражений. Это очень удобно, когда  у вас имеется
файл-шаблон (скажем отчет или страница HTML), которые содержат в
основном постоянный текст, но должны включать в себя некоторые
переменные или только что вычисленные значения. Обычно Perl  не
распознает такие выражения внутри строки как что-то отличное от
символов, которые надо напечатать, но существуют обстоятельства, когда
текст изменяется.
<P>
<P>Hапример,
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $a = 3 + 4;
        print &quot;I have $a eggs\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>позволяет мне вычислить выражение 3 + 4 и затем пометить результат в
строку. Однако помещение того же самого выражения в строку не будет
работать:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        print &quot;I have 3 + 4 eggs\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>поскольку Perl  не может определить является ли <CODE>3 + 4</CODE>
текстом или выражением, которое необходимо вычислить. Некоторое время
назад я столкнулся с приемом получения вычисленного выражения
находящегося внутри строки в двойных кавычках и этот прием стал
простейшим путем решения проблемы получения выражения внутри строк.
Этот прием выглядит немного безобразным, но так делает остальная часть 
Perl, так что он сравнительно не плох.
<P>
<P>Прием заключается в простом предшевствовании выражения символами 
<CODE>@{[</CODE> и завершении его символами <CODE>]}</CODE>,  например вот так:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
      print &quot;I have @{[ 3 + 4 ]} eggs\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Если вы выполните этот код, то вы увидите, что он правильно печатает
слово ``7 eggs''! Как это работает? Внешний <CODE>@{ ... }</CODE> включает
режим интерполяции массива, требуя чтобы внутри скобок находилось 
либо имя массива, либо ссылка на список. Внутренние квадратные скобки
создают анонимный список, и возвращают ссылку на этот список. Этот
анонимный список вычисляется из списка выражений внутри скобок -- в
нашем случае есть только одно выражение, так что получается список из
одного элемента.
<P>
<P>Таким образом, выражение вычисляется, превращается в анонимный
список, а затем интерполируется триггером <CODE>@</CODE>, и все сделано!
<P>
<P>Мы даже можем использовать эту конструкцию в более крупных
документах (используя here-строки):
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        open SM, &quot;|/usr/lib/sendmail -t&quot;;
        print SM &lt;&lt;END;
        To: $destination
        From: @{[$source || &quot;root&quot;]}
        Subject: update at @{[scalar localtime]}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        Следующие люди зарегистрированы
        на @{[`hostname` =~ /(.*)/]}:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        @{
          my %foo = map /^(\S+)()/, `who`;
          [sort keys %foo];
        }
        END
        close SM;
</PRE>
</CODE></BLOCKQUOTE>
<P>Я привел несколько примеров... давайте разберем каждый по
отдельности. В первом примере, я открываю канал в <EM>sendmail</EM>,
для того, чтобы отослать электронное сообщение. Далее, я выдаю в этот
канал строку заключенную в двойные кавычки. Переменная
<CODE>$destination</CODE> является обычной скалярной переменной, которую я
устанавливаю где-то перед выполнением данного кода.
<P>
<P>Строка <CODE>from</CODE> сообщения использует конструкцию описанную
выше. Если переменная <CODE>$source</CODE> установлена, то она используется
-- в противном случае возвращается строка <CODE>root</CODE>.
<P>
<P>Строка <CODE>subject</CODE> сообщения также использует конструкцию,
описанную выше. В скалярном контексте оператор <EM>localtime</EM>
возвращает строку времени. Поскольку конструктор анонимного массива,
заключенный в квадратный скобки требует оценки элементов в списочном
контексте, то я привожу его в скалярный контекст с помощью оператора
<EM>scalar</EM>. Результирующие выражение переводится в строку
заголовка сообщения с относительной легкостью.
<P>
<P>Аналогичным образом, имя текущей машины вычисляется и вставляется в
текст. Заметьте, что я беру вывод команды <EM>hostname</EM>,
заключенной в обратные кавычки, и выделяю из него все символы,
находящиеся до символа новой строки. Таким образом, символ новой строки
<EM>не</EM> выделяется, и я могу использовать результат в середине
строки.
<P>
<P>Финальный кусок кода внутри строки, использует дополнительный прием,
Конструкция <CODE>@{...}</CODE> является любым блоком кола, также как и
последнее выражение, вычисленное в этом блоке является ссылкой на
список некоторого типа. Таким образом, для получения уникального списка
пользователей в системе, я могу использовать временный хэш как набор,
Вывод команды <EM>who</EM> разделяется на строки и сравнивается со
строкой регулярного выражения, выделяя два элемента из общего списка
для каждой из строк. Это является правильной формой для создания
хэша. В заключение ключи хэша сортируются и превращаются в анонимный
список.
<P>
<P>Другим способом получения текстовой строки являющейся ``в основном
константой, но иногда изменяющейся'' является выполнение глобальной
подстановки для строки. Хотя мы пока не можем получать произвольные
выражения, оно достаточно хорошо работает тогда, когда данные
получаются из структуры подобной хэшу:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        %data = (
                TO =&gt; 'fred@random.place',
                PRIZE =&gt; 'a pearl necklace',
                VALUE =&gt; '1000',
        );
        $_ = &lt;&lt;'EOF';
        To: %TO%
        From: merlyn@stonehenge.com
        Subject: Your lucky day
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        You are the winner of %PRIZE%,
        worth over $%VALUE%!  Congratulations.
        EOF
        s/%(\w+)%/$data{$1}/g;
        print;
</PRE>
</CODE></BLOCKQUOTE>
<P>Для каждого из слов, найденных между знаками процента, по ключу
ищется соответствующий элемент хэша, и заменяется этим значением. Это
является хорошим для проблем набора символов (form-letter type
problems). Если данные не могут быть сохранены в хэше, то мы можем
сделать дополнительный шаг и сделать замены текста полным выражением,
вместо простой, заключенной в двойные кавычки строки, используя
модификатор <CODE>/e</CODE> для оператора подстановок.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $_ = &lt;&lt;'EOF';
        To: %TO%
        From: merlyn@stonehenge.com
        Subject: Your lucky day
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        You are the winner of %PRIZE%,
        worth over $%VALUE%!  Congratulations.
        EOF
        s/%(\w+)%/&amp;getvaluefor($1)/eg;
        print;
        sub getvaluefor {
                my $key = shift;
                ...
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь подпрограмма <CODE>&amp;getvaluefor</CODE> будет вызываться для
каждого из ключевых слов, найденных в тексте. Возвращаемая
подпрограммой строка будет значением вставляемым в окончательный
текст. Таким образом подпрограмма может быть достаточно сложно, включая
использование значений по умолчанию или кэшированных вычислений.
<P>
<P>Но мы все еще находимся далеко от того, что я делал ранее --
использования выполнения кода используемого <EM>внутри</EM> шаблона. В
действительности это не так далеко от того, что нам надо, если мы
используем режим ``двойной оценки'' оператора подстановки. Давайте
рассмотрим следующий пример:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $_ = 'I have [ 3 + 4 ] eggs';
        s/\[(.*?)\]/$1/eegs;
        print;
</PRE>
</CODE></BLOCKQUOTE>
<P>Этот код выдает <CODE>I have 7 eggs</CODE>, но каким образом? Хорошо,
исключая то, что мы знаем... <CODE>/s</CODE> означает, что <CODE>.</CODE> может
соответствовать символу новой строки. А <CODE>/g</CODE> означает, что
выполняется более чем одна подстановка. А одиночное <CODE>/e</CODE>
означает, что правая часть оператора является выражением Perl, а не
заключенной в двойные кавычки строкой. И у нас здесь имеется переменная
<CODE>$1</CODE>, что очень хорошо. 
<P>
<P>Но наличие второго <CODE>/e</CODE> означает, что <EM>значение</EM>
выражения в правой части также должно рассматриваться как код на Perl,
и затем должно быть превращено в строковое значение! (В начале это
рассматривалось как ошибка, но затем это посчитано очень полезным и
осталось как свойство).
<P>
<P>Так что мы получаем <CODE>$1</CODE> равным <CODE>&quot; 3 + 4 &quot;</CODE>
и затем <CODE>7</CODE>, и 7 вставляется вместо заключенного в скобки
выражения. Мы можем вставить между скобками все что захотим, и это
будет выполнено как код Perl.
<P>
<P>Так, теперь у нас есть они... много способов использования текста
являющегося в ``в основном константой , но иногда переменной'' в наших
программах. Разрешите мне закончить это раздел кусочком истории. Я
заканчивал свои письма в <CODE>comp.lang.perl.misc</CODE> некоторым хитрым 
куском  кода  (часто неясным), который печатал фразу ``Just
another Perl hacker,''. Когда я обнаружил возможность двойной оценки
кода в процессе подстановки, я просто <EM>использовал</EM> его для
создания одной из этих фраз ``JAPH''. И вот что получилось в результате:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  $Old_MacDonald = q#print #; $had_a_farm = (q-q:Just another Perl hacker,:-);
  s/^/q[Sing it, boys and girls...],$Old_MacDonald.$had_a_farm/eieio;
</PRE>
</CODE></BLOCKQUOTE>
<P>Посмотрите что получится, если вы сможете определить как это работает!
<P>
<P>Особые благодарности ведущим разработчикам Perl, Chip Salzenberg, за
идею создания этой ежемесячной колонки. Спасибо Chip!
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
