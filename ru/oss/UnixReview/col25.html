<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 25 -- Получение даты с помощью Perl</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 25 -- Получение даты с помощью Perl</H1>

<H2>Randal Schwartz</H2>Апрель 1999<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>И компьютерная литература и популярная пресса наполнены множеством
статей о ``конце тысячелетия'' и ``Y2K'', некоторые из которых являются
позитивными, а некоторые пугающими. Много людей спрашивают ``готов ли
Perl к Y2K?'' Хорошо, вот то что говорит об этом документация на
Perl:
<P>
<BLOCKQUOTE>
Имеет ли Perl проблему 2000 года?  Готов ли Perl к
Y2K?
</BLOCKQUOTE>
<P><B>Короткий ответ</B>: Нет,  Perl не имеет проблемы 2000-го
года. Да, Perl готов к Y2K. Программистов наняли для его использования,
однако вы вероятно не используете его.
<P><B>Длинный ответ</B>: Perl готов к Y2K также как и ваш
карандаш&nbsp;-- не больше и не меньше. Функции работы с временем и
датами, входящие в библиотеку Perl (gmtime и localtime) предоставляют
адекватную информацию для правильного определения года большего 2000
(2038 будет являться проблемой для 32-битных машин). Год, возвращаемый
этими функциями при вызову в списочном контексте, равен текущему году
минус 1900. Для годов между 1910 и 1999 это значение равно двухзначному
десятичному числу. Для того, чтобы избежать проблемы 2000-года просто
не используйте занчение года как двухзначное число. Оно не является
таковым.
<P>При использовании функций <CODE>gmtime()</CODE> и <CODE>localtime()</CODE> в
строковом контексте, они возвращают строку времени, которая содержит
полное значение года. Например: <CODE>$timestamp =
gmtime(1005613200)</CODE> устанавливает <CODE>$timestamp</CODE> равной
<CODE>&quot;Tue Nov 13 01:00:00 2001&quot;</CODE>. Так что в этом случае
нет никакой проблемы 2000-года.
<P>Это не значит, что Perl не может быть использован для создания не
готовых к Y2K программ. Он может быть использован. Но точно также, как
и ваш карандаш. Это будет ошибкой пользователя, но не языка. С риском
вспыхивания NRA: ``Perl не ломает Y2K, это делают люди''. Для более
длинного объяснения смотрите 
<A HREF="http://language.perl.com/news/y2k.html">http://language.perl.com/news/y2k.html</A>.
<P>Так, мы получили ответ на вопрос. Но поскольку мы говорим о датах,
то давайте рассмотрим несколько вещей, которые Perl умеет делать с
датами.
<P>Во первых, имеется три встроенных оператора <CODE>времени</CODE>. Нет,
ни один из них не дает вам подписку на журнал Time&nbsp;--- просто
число (как беззнаковое 32-битное число) секунд с начала отсчета (1
Января 1970, 0000 GMT). В момент написания, оно достигло значения
примерно 900 миллионов и скоро пересечет отметку миллиард. Когда точно?
Мы можем использовать другую встроенную функцию Perl для перевода этого
времени в что-то такое, что может понять человек:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $when = gmtime 1000000000;
        print &quot;timestamp turns a billion at $when\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Выполнив этот код я получил:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        timestamp turns a billion at Sun Sep  9 01:46:40 2001
</PRE>
</CODE></BLOCKQUOTE>
<P>Ахх... так где-то в идее Артура Кларка о новом тысячелетии мы
получим новую цифру в значении возвращаемом <CODE>time</CODE>. Я удивлюсь,
что программы дадут сбой, когда <EM>это</EM> случится.
<P>Та строка, которая возвращается функцией <CODE>gmtime</CODE> является
временем по GMT. Если вы не живете в Лондоне или в Западной Африке, то
вам будет удобней получать время соответственно вашей временной
зоне. Это делается легко: просто используйте функцию
<CODE>localtime</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $now = localtime time;
        print &quot;It is now $now\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>И <CODE>gmtime</CODE> и <CODE>localtime</CODE> возвращают строку похожую на
результат команды UNIX <EM>date</EM>, в тех случаях, когда они
вызываются в скалярном контексте, так как я выполнил это. Вы можете
также получить части даты, используя эти две функции в списочном
контексте:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my ($sec,$min,$hour,$mday,$mon,$year,
          $wday,$yday,$isdst) = localtime time;
</PRE>
</CODE></BLOCKQUOTE>
<P>И это даст вам доступ к частям даты. Заметьте, что <CODE>$mon</CODE>
отсчитывается с 0 (вы наверное захотите добавить к ней 1), а
<CODE>$year</CODE> является смещением с 1900 года. Да, она будет равен 100 в
2000 году, так что просто исправим это с помощью команды <CODE>$year +=
1900</CODE>. Для дополнительной информации прочитайте <CODE>perldoc -f
localtime</CODE>.
<P>Для обратного преобразования есть другой способ, Perl поставляется
со стандартным модулем <CODE>Time::Local</CODE>. (Документация доступна с
помощью команды <CODE>perldoc Time::Local</CODE>, конечно если кто-то не
испортил ваш дистрибутив). Например, для получения значения с начала
отсчета для начала 2000 года в моей временной зоне, я могу использовать
следующий код:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        use Time::Local;
        my $time = timelocal(0,0,0,1,0,100);
        my $string = localtime $time;
        print &quot;the big ball falls at $time =&gt; $string\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь я печатаю заново преобразованную строку просто для того, чтобы
проверить, что я выполняю правильное действие. Мы можем использовать
этот код для получения обратного счетчика:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        use Time::Local;
        my $time = timelocal(0,0,0,1,0,100);
        my $diff = $time - time;
        $diff /= 86400; # seconds to days
        if ($diff &gt; 0) {
                printf &quot;we've got %.2f days to go\n&quot;, $diff;
        } else {
                print &quot;we made it!\n&quot;;
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Конечно, значение переменной <CODE>$time</CODE> не изменяется между
запусками программы, так что лучше всего вычислить его один раз и
записать в программу. Но это хорошо для демонстрационной программы. Для
того, чтобы увидеть более тщательно разработанный обратный счетчик,
посетите мою домашнюю страницу по адресу 
<A HREF="http://www.stonehenge.com/merlyn/">http://www.stonehenge.com/merlyn/</A>.
<P>Кроме встроенных функций и библиотек, также на CPAN существует
достаточное количество пакетов для работы с временем и датами. Наиболее
претенциозным из них является <CODE>Date::Manip</CODE>, который вы можете
установить на свою систему (если он у вам еще не установлен) используя
инструкции описанные в <CODE>perldoc perlmodinstall</CODE>. (Если у вас нет
<EM>perlmodinstall</EM>, то вы должны обновить свою версию Perl до
версии 5.005 или более поздней).
<P>Как говорится в первом параграфе документации модуль
<CODE>Date::Manip</CODE>:
<P>
<BLOCKQUOTE>
Это набор подпрограмм, спроектированный для облегчения общих
действий с датами и временем, Легко выполняются такие операции, как
сравнение двух дат, вычисления диапазона между двумя датами или разбор
дат записанных в национальном формате. С самого <CODE>Date::Manip</CODE>
был нацелен на легкое выполнение <EM>ЛЮБЫХ</EM> операций с датами и
временем, не обязательно быстро. Также, он ориентирован на выполнение
тех операций, в каких терминах думаем мы (как люди), а не на операции
выполняемые компьютерами. Также существуют другие модули, которые могут
выполнять небольшое подмножество операций выполняемых
<CODE>Date::Manip</CODE> более быстро, чем данный модуль, так что если
скорость выполнения играет важную роль, то вы должны использовать
что-то другое. Посмотрите на CPAN список модулей работы с датами и
временем. Но я верю, что для получения гибких решений
<CODE>Date::Manip</CODE> является лучшим выбором для вас.
</BLOCKQUOTE>
<P>Однако, как упомянуто в этом тексте, <CODE>Date::Manip</CODE> является
достаточно тяжелым, только для загрузки занимая примерно пол секунды
CPU на моей мощной машине. Вероятно это нормально для программ
выполняющихся длительное время, но это очень много для коротко-живущих
приложений CGI.
<P>Для многих приложений, когда не достаточно встроенных функций, вы
можете использовать достаточно быстрый модуль <CODE>Date::Calc</CODE>
(который также можно найти на the CPAN). Это модуль загружается (у
меня) примерно одну десятую секунды CPU, делая его удобным для
применения в коротко-живущих программах CGI или других часто
запускаемых утилитах.
<P>В качестве примера возможностей <CODE>Date::Calc</CODE>, я решил
эмулировать команду UNIX <CODE>cal</CODE>, которая может выдавать календарь
на месяц или год на любое время от 1-го года до далекого будущего. К
сожалению, поскольку <CODE>Date::Calc</CODE> не понимает Юлианский
календарь (адаптированный в 1752 в США),  то я ограничу свою программу
самым недавним временем, но сохраняя тот же интерфейс командной строки.
<P>В заключение моя программа стала выглядеть так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    #!/usr/bin/perl -w
    use strict;

    use Date::Calc qw(
      Today Day_of_Week Days_in_Month
      Month_to_Text Day_of_Week_Abbreviation
    );

    if (@ARGV) {
      my $year = shift;
      if (@ARGV) {
        my $month = $year;
        my $year = shift;
        die &quot;year $year must be &gt; 1752&quot;
          unless $year &gt; 1752;
        &amp;do_cal($year,$month);
      } else {
        die &quot;year $year must be &gt; 1752&quot;
          unless $year &gt; 1752;
        for my $month (1..12) {
          &amp;do_cal($year,$month);
          print &quot;\n&quot; unless $month == 12;
        }
      }
    } else {
      my ($today_year, $today_month, $today_day)
        = Today;
      &amp;do_cal($today_year, $today_month);
    }

    sub do_cal {
      my $cal_year = shift;
      my $cal_month = shift;

      my $month_name = Month_to_Text($cal_month);
      my $start_dow = Day_of_Week(
        $cal_year,$cal_month,1
      );
      my $end_day = Days_in_Month(
        $cal_year,$cal_month
      );

      my $curday = 1 - $start_dow % 7;

      print &quot;
      $month_name $cal_year\n&quot;;
      print map { sprintf &quot; %4.4s &quot;,
        Day_of_Week_Abbreviation($_) } 7,1..6;
      print &quot;\n&quot;;
      {
        for ($curday..($curday+6)) {
          if ($_ &lt; 1) {
            print &quot;&lt;&lt;&lt;&lt;&lt;&lt;&quot;;
          } elsif ($_ &lt;= $end_day) {
            printf &quot;[ %2d ]&quot;, $_;
          } else {
            print &quot;&gt;&gt;&gt;&gt;&gt;&gt;&quot;;
          }
        }
        print &quot;\n&quot;;
        $curday += 7;
        redo if $curday &lt;= $end_day;
      }
    }
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь самыми заметными вещами является то, что я использую
<CODE>Date::Calc</CODE> для получения сегодняшнего месяцы и года
(<CODE>Today</CODE>), получение текстового имени месяца
(<CODE>Month_to_Text</CODE>), нахождение дня недели (<CODE>Day_of_Week</CODE>),
нахождение последнего дня месяца (<CODE>Days_in_Month</CODE>) и даже
получение правильных имен для дней недели
(<CODE>Day_of_Week_Abbreviation</CODE>).
<P>Имея все эти подпрограммы очень легко написать программу. Что должно
бы сделать ее более легкой, если заметить, что почти все мои предыдущие
подпрограммы <CODE>&amp;do_cal</CODE> могли быть заменены подпрограммой
<CODE>Date::Calc</CODE> с именем <CODE>Calendar</CODE>, о которой я не знал,
пока почти не закончил программу.
<P>Так, что важным советом является ``Не изобретайте
колесо... прочитайте всю документацию''. В следующий раз я последую
своему собственному совету. И если вы все еще думаете, что Perl не
достаточно полезен, то теперь вы знаете как получить дату с помощью
Perl или по крайней мере правильное время. Наслаждайтесь.
<HR>
Next
Previous
Contents
</BODY>
</HTML>
