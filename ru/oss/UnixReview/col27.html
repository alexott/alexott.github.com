<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 27</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 27</H1>

<H2>Randal Schwartz</H2>Август 1999<P>Перевод Anton Petrusevich &lt;casus@mail.ru&gt; и Alex Ott
&lt;ott@phtd.tpu.edu.ru&gt; 
<P>
<P>Символических ссылок не было в первых версиях Unix с которыми я
работал. Это был Unix V6, в 1977 году, когда размер ядра Unix был
меньше 32K. Трудно представить что-нибудь меньшее 32K и связанное Unix
настоящих дней.
<P>
<P>Но где-то в недрах университета Калифорнии в Беркли, в начале 80-х
годом, люди работающие над BSD изобрели схему для исправления двух
самых крупных проблем связанных с жесткими ссылками: ссылки не могли
создаваться для каталогов и они не могли указывать на точку в другой
смонтированной файловой системе. Их решением были символьные ссылки,
которые сейчас являются распространенным свойством.
<P>
<P>По существу символьная ссылка являются текстовой строкой, которая
находится на месте файла. Когда происходит доступ к имени файла
являющегося символьной ссылкой, то ядро Unix заменяет имя файла его
текстовым значением, подобно расширению макроса. Все это происходит
прозрачно для выполняющейся программы (в отличии от некоторых других
популярных операционных систем).
<P>
<P>Символические ссылки достаточно легко создаются из командной строки:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        ln -s /usr/lib/perl5 ./Lib
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>что создает ссылку <CODE>Lib</CODE> указывающую на
<CODE>/usr/lib/perl5/</CODE>. Из Perl, тоже самое выполняется следующим
кодом: 
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        symlink(&quot;/usr/lib/perl5&quot;, &quot;./Lib&quot;) or die &quot;$!&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>И вы можете увидеть результат с помощью команды:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        ls -l
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>что вам покажет что-то похожее на:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        ..... Lib -&gt; /usr/lib/perl5
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>показывает что происходит перенаправление. И тот же факт можно
увидеть из Perl с помощью кода:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $where = readlink(&quot;Lib&quot;);
        print &quot;Lib =&gt; $where\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Но что делать, если <CODE>/usr/lib</CODE> сама является символической
ссылкой, указывающей например на <CODE>/lib</CODE>? Хорошо, система
правильно определит ее при выполнении спуску с <CODE>/usr</CODE> в
<CODE>/usr/lib</CODE> и перенаправит программу в <CODE>/lib</CODE> и там
продолжит поиск <CODE>perl5</CODE>.
<P>
<P>Таким образом, следование по символьной ссылке может вовлекать в
процесс многократное расширение. Для того чтобы предотвратить циклы
существует предел на число расширений в путевых именах, но в общем это
число достаточно большое, так что вы можете не волноваться.
<P>
<P>Каким же самым простым способом можно узнать на какой реальный файл
указывает символическая ссылка? Вы можете попытаться многократно
запускать  команду <CODE>ls -l</CODE> и запоминать пути или просто написать
программу на Perl, которая выполнит для вас все необходимые расширения.
<P>
<P>И давайте также сделаем эту работу рекурсивно, начиная с заданного
каталога в дереве файлов, выдавая все символические ссылки и их
завершающие расширения во всех нижележащих каталогах. Великолепно.
<P>
<P>Вот программа, которая просто делает это, представленная по
нескольку строк за раз.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    #!/usr/bin/perl -w
    use strict;
    $|++;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Эти первые три строки сообщают нам о том, где найти Perl и разрешают
выдачу сообщений, что обычно является хорошим ограничением
компилятора. Мы также запрещаем буферизацию потока <CODE>STDOUT</CODE>,
так что я в процессе выполнения могу увидеть насколько далеко забралась
программа.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    use File::Find;
    use Cwd;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Далее мы подгружаем модули из стандартной библиотеки поставляемой с
Perl. <CODE>File::Find</CODE> помогает нам рекурсивно пройти через иерархию
каталогов, не задумываясь над тем насколько это тяжело, а <CODE>Cwd</CODE>
возвращает имя текущего рабочего каталога, обычно без запуска дочернего
процесса.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    my $dir = cwd;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Теперь мы будем получать имя текущего каталога используя вызов
<CODE>cwd</CODE> (импортированный из модуля <CODE>Cwd</CODE>). Нам необходимо
это для правильного расширения относительных путевых имен в абсолютные
путевые имена.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    find sub {
      ##### содержимое этого куска представлено ниже
    }, @ARGV;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Далее следует внешняя часть тела программы. Мы вызовем функцию
<CODE>find</CODE> (импортированную из модуля <CODE>File::Find</CODE>),
передавая ей ссылку на анонимную подпрограмму, а также массив
аргументов командной строки в массиве <CODE>@ARGV</CODE>. Подпрограмма (чье
содержимое определено ниже) будет вызываться для каждого файла или
каталога найденного во всех каталогах и подкаталогах, начиная с
каталогов верхнего уровня указанных в <CODE>@ARGV</CODE>.
<P>
<P>Теперь перейдем к подпрограмме. В настоящей программе этот код
находится в вышеприведенном коде, в месте обозначенном <CODE>#####</CODE>.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      return unless -l;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Когда эта подпрограмма вызывается, то в переменную <CODE>$_</CODE>
помещается имя найденного файла или каталога, а рабочий каталог
становится равным каталогу в котором находится найденный объект. Здесь,
мы будем прекращать работу подпрограммы, если найденный файл не
является символьной ссылкой.
<P>
<P>Следующие два строки создают основу подпрограммы. Я получаю
переменные <CODE>@left</CODE> и <CODE>@right</CODE>. Думайте о <CODE>@left</CODE>
как ``как далеко я дереве файлов я нахожусь?'', а о <CODE>@right</CODE> как
``Куда еще я должен перейти?''. Основной задачей является
взять один элемент из начала <CODE>@right</CODE>, и попытаться приклеить
его в конец <CODE>@left</CODE>, до тех пор пока у нас не останется
элементов в <CODE>@right</CODE>. Если на любом из этапов, путь находящийся
в <CODE>@left</CODE> является символьной ссылкой, то мы должны расширить
его и начать сначала. Также, если исследуемый элемент из
<CODE>@right</CODE> является признаком текущего или родительского
каталогов, то мы вместо этого должны убрать элемент из <CODE>@left</CODE>.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      my @right = split /\//, $File::Find::name;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Переменная <CODE>$File::Find::name</CODE> содержит полное путевое имя,
начиная с имени которое мы задали в командной строке. Если это было
относительное путевое имя, то это также будет путевым именем
относительно первоначального рабочего каталога (теперь сохраненного в
переменной <CODE>$dir</CODE>). Вот как я разбиваю путевое имя на отдельные
элементы.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      my @left = do {
        @right &amp;&amp; ($right[0] eq &quot;&quot;) ?
          shift @right :            # быстрый способ
            split /\//, $dir;
      };    # первый элемент всегда равен null
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Это немного запутанно, так что я буду объяснить это медленно. Мы
устанавливаем <CODE>@left</CODE> равным значению этого выражения,
получаемого из блока <CODE>do</CODE>. Если первый элемент <CODE>@right</CODE>
является пустым, то оригинальная строка начинается с символа слэш и нам
необходимо производить 
отсчет относительно корневого каталога. Это обрабатывается перемещением
этого пустого элемента из начала <CODE>@right</CODE> для того, чтобы он
<EM>только</EM> он стал элементом <CODE>@left</CODE>. В противном случае у
нас имеется относительное путевое имя и мы будеи загружать переменную
<CODE>@left</CODE> значениями разбитого на части путевого имени начального
рабочего каталога.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      while (@right) {
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Теперь, поскольку у нас имеются объекты по которым необходимо
пройти, мы сделаем это...
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $item = shift @right;
        next if $item eq &quot;.&quot; or $item eq &quot;&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Это схватывает следующий шаг и отбрасывает его, если объект является
пустой строкой или точкой (символом текущего каталога), означая, что мы
должны оставаться в текущем каталоге.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        if ($item eq &quot;..&quot;) {
          pop @left if @left &gt; 1;
          next;
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>А если у нас имеется две точки (символ родительского каталога), то
мы будем удалять один уровень от нашей текущей позиции (пока не
достигнем корня).
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        my $link = readlink (join &quot;/&quot;, @left, $item);
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Теперь, если путь в <CODE>@left</CODE>, вместе со следующим шагом
является символьной ссылкой, то будет определено значение
<CODE>$link</CODE> равным тому значение, которым мы должны заменить
значение <CODE>$item</CODE>. В противном случае, мы просто переходим
дальше.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        if (defined $link) {
          my @parts = split /\//, $link;
          if (@parts &amp;&amp; ($parts[0] eq &quot;&quot;)) { # absolute
            @left = shift @parts;   # quick way
          }
          unshift @right, @parts;
          next;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Так, что если у нас имеет символьная ссылка, то мы снова разделим ее
на части. Если она является абсолютным путевым именем, то значение
<CODE>@left</CODE> будет равным корневому каталогу. В противном случае,
значение <CODE>@left</CODE> остается тем же самым. Мы также поместим, то
что нашли в начало оставшейся части <CODE>@right</CODE>, так что оно будет
воздействовать на оставшуюся часть пути.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        } else {
          push @left, $item;
          next;
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Если на данном этапе объект не был символической ссылкой, то все
просто; мы просто перемещаемся в эту точку в <CODE>@left</CODE>.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      }
      print &quot;$File::Find::name is &quot;, join(&quot;/&quot;, @left), &quot;\n&quot;;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Когда цикл заканчивается, мы просто выдаем окончательный путь
содержащийся в <CODE>@left</CODE>.
<P>
<P>И теперь вы имеете правильную ссылку. Это немного хитро, поскольку
расширение символических ссылок в чем то является рекурсивным, но
структуры данных Perl и полный доступ к нужным системным вызовам дает
нам простой способ интерпретации символьных ссылок.
<P>
<P>Теперь вы никогда не удивитесь тому, куда указывают
ссылки. Встретимся в следующий раз, наслаждайтесь!
<P>
<HR>
Next
Previous
Contents
</BODY>
</HTML>
