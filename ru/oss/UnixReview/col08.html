<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Unix Review Column 8</TITLE>


</HEAD>
<BODY>
Next
Previous
Contents
<HR>
<H1>Unix Review Column 8</H1>

<H2>Randal Schwartz</H2>Май 1996<P>В моей предыдущей заметке я ввел понятие ``ссылки'' в Perl, подобной
указателю в C. Я говорил о ссылках на скалярные значения, массивы и
ассоциативные массивы (хеши). В этой заметке мы поговорим о ссылках на
подпрограммы, и использовании ссылок для внесения изменений в таблицу
символов Perl во время выполнения, для создания алиасов.
<P>Ссылка на подпрограмму может быть создана с помощью оператора
``создать-ссылку-на'', обратный слеш (одно, из примерно 17 значений
обратного слеша):
<P>
<HR>
<PRE>
        sub wilma {
                print &quot;Hello, @_!&quot;;
        }
        $ref_to_wilma = \&amp;wilma;
</PRE>
<HR>
<P>В этом примере, определяется подпрограмма  <CODE>&amp;wilma</CODE>, а затем
создается ссылка на эту подпрограмму и сохраняется в переменной
<CODE>$ref_to_wilma</CODE>. Однако необязательно определять подпрограмму для
взятия ссылки на нее.
<P>Переменная <CODE>$ref_to_wilma</CODE> может быть использована там где
вызывается подпрограмма <CODE>wilma</CODE>, хотя мы должны ``разименовать
(dereference)'' ее тем же способом, как и остальные ссылки. Синтаксические
правила являются теми же&nbsp;-- заменить имя ``wilma'' в выражении
<CODE>&amp;wilma</CODE> на <CODE>{$ref_to_wilma}</CODE> (или
<CODE>$ref_to_wilma</CODE>, поскольку это скалярная переменная), как в данном
примере:
<P>
<HR>
<PRE>
        &amp;wilma(&quot;fred&quot;); # выдает "hello to fred"
        &amp;{ $ref_to_wilma }(&quot;fred&quot;); # тоже самое
        &amp;$ref_to_wilma(&quot;fred&quot;); # и здесь тоже самое
</PRE>
<HR>
<P>Теперь эти ссылки могут быть использованы для выбора разных операций над
одними и теми же данными. Рассмотрим набор подпрограмм, выполняющих базовые
математические операции над своими аргументами, возвращая результат:
<P>
<HR>
<PRE>
        sub add { $_[0]+$_[1]; }
        sub subtract { $_[0]-$_[1]; }
        sub multiply { $_[0]*$_[1]; }
        sub divide { $_[0]/$_[1]; }
</PRE>
<HR>
<P>Теперь давайте позволим пользователю ввести один из этих операторов, за
которым следуют два операнда (префиксная запись), а затем будем выбирать
одну из четырех подпрограмм используя код с условиями (без ссылок):
<P>
<HR>
<PRE>
        print &quot;enter operator op1 op2\n&quot;;
        $_ = &lt;STDIN&gt;;
        ## break the result on whitespace:
        ($op,$op1,$op2) = split;
        if ($op eq &quot;+&quot;) {
                $res = &amp;add($op1,$op2);
        } elsif ($op eq &quot;-&quot;) {
                $res = &amp;subtract($op1,$op2);
        } elsif ($op eq &quot;*&quot;) {
                $res = &amp;multiply($op1,$op2);
        } else { # divide, we hope
                $res = &amp;divide($op1,$op2);
        }
        print &quot;result is $res\n&quot;;
</PRE>
<HR>
<P>Теперь подумайте, как это усложниться, если у меня будет 15
операторов. Одинаковость шаблонов кода заставляет меня думать, что я могу
факторизовать этот код, и в действительности я могу это сделать используя
ссылки.
<P>
<HR>
<PRE>
        ## инициализация таблицы операторов
        %op_table = (
                &quot;+&quot; =&gt; \&amp;add,
                &quot;-&quot; =&gt; \&amp;subtract,
                &quot;*&quot; =&gt; \&amp;multiply,
                &quot;/&quot; =&gt; \&amp;divide,
        );
        print &quot;enter operator op1 op2\n&quot;;
        $_ = &lt;STDIN&gt;;
        ## break the result on whitespace:
        ($op,$op1,$op2) = split;
        ## get reference:
        $sub_ref = $op_table{$op};
        ## and now evaluate
        $res = &amp;{$sub_ref}($op1,$op2);
        print &quot;result is $res\n&quot;;
</PRE>
<HR>
<P>Сначала переменная <CODE>$op</CODE> используется как ключ в хеше
<CODE>%op_table</CODE>, выбирая одну из четырех ссылок на подпрограммы и
помещая ее в переменную <B>$sub_ref</B>. Затем эта ссылка
разименовывается с передачей двух операндов. Это возможно, поскольку все
четыре подпрограммы имеют одно количество операндов. Если бы у нас были
некоторые отклонения, то мы могли бы иметь проблемы.
<P>Однако мы можем сократить шаги по поиску и выполнению подпрограмм,
например написав такой код:
<P>
<HR>
<PRE>
        $res = &amp;{$op_table{$op}}($op1,$op2);
</PRE>
<HR>
<P>что просто выполняет поиск и разыменование одним действием. Ловко?
<P>Аналогично анонимным спискам и анонимным хешам, я могу создать анонимную
подпрограмму. Hапример, вернемся к чему-то подобному подпрограмме <CODE>&amp;wilma</CODE>,
<P>
<HR>
<PRE>
        $greet_ref = sub {
                print &quot;hello, @_!\n&quot;;
        };
</PRE>
<HR>
<P>Теперь у нас в переменной <CODE>$say_ref</CODE> будет храниться ссылка на
подпрограмму, но подпрограмма будет без имени. Эта подпрограмма запускается
при разименовании ссылки на подпрограмму, точно также как и остальные
ссылки на подпрограммы:
<P>
<HR>
<PRE>
        &amp;$greet_ref(&quot;barney&quot;); # hello, barney!
</PRE>
<HR>
<P>Одно из преимуществ анонимных подпрограмм заключается в том, что они
могут быть использованы в тех местах, где использование подпрограмм с
именами может казаться немного глупым. Hапример, в предыдущем примере имена
<CODE>&amp;add</CODE>, <CODE>&amp;subtract</CODE>, <CODE>&amp;multiply</CODE>,
<CODE>&amp;divide</CODE> были скорее капризом. При добавлении операторов, я
должен был сохранять именование подпрограмм, даже хотя имена были
использованы только в одном месте&nbsp;-- в таблице
<CODE>%op_table</CODE>. Таким образом, используя анонимные подпрограммы, я могу
полностью избежать использования имен:
<P>
<HR>
<PRE>
        ## инициализация таблицы операторов
        %op_table = (
                &quot;+&quot; =&gt; sub { $_[0]+$_[1] },
                &quot;-&quot; =&gt; sub { $_[0]-$_[1] },
                &quot;*&quot; =&gt; sub { $_[0]*$_[1] },
                &quot;/&quot; =&gt; sub { $_[0]/$_[1] },
        );
</PRE>
<HR>
<P>и в действительность. функции в <CODE>%op_table</CODE> работают также как и
раньше, только за тем исключением, что я не должен пытать себя
придумыванием имен четырем подпрограмм. Это очень помогает при
сопровождении&nbsp;-- например, для того, чтобы добавить возведение в
степень (используя <CODE>**</CODE>), все что я должен сделать&nbsp;-- добавить
запись в таблицу <CODE>%op_table</CODE>:
<P>
<HR>
<PRE>
                &quot;**&quot; =&gt; sub { $_[0]**$_[1] },
</PRE>
<HR>
<P>вместо того, чтобы сначала создать именованную процедуру, а затем
добавлять ссылку на нее в <CODE>%op_table</CODE>.
<P>Ссылки на подпрограммы также полезны при передаче данных в
подпрограммы. Hапример, предположим, что я написал подпрограмму, которая
отбрасывает пустые строки до тех пор, пока мы не получим что-нибудь
полезное, а затем возвращает полезную информацию. В качестве первого
аргумента я мог бы получать подпрограмму, которая определяла бы как
``получить следующий объект''. Иногда, это может быть ``считать из
файлового дескриптора'', а в другое время, это могло бы быть ``следующий
элемент массива''. Вот как это могло бы выглядеть:
<P>
<HR>
<PRE>
        $next = &amp;non_blank(
                sub { &lt;STDIN&gt;; }
        ); # read from stdin
        $next = &amp;non_blank(
                sub { shift @cache; }
        }; # grab from list @cache
</PRE>
<HR>
<P>Внутри подпрограммы <CODE>&amp;non_blank</CODE>, первым параметром является
ссылка на подпрограмму, которая будет ``вытягивать следующее
значение''. Вот одна из возможных реализаций данной подпрограммы:
<P>
<HR>
<PRE>
        sub non_blank {
                my($scanner) = @_;
                my($return);
                {
                        $return = &amp;{$scanner}();
                        redo until $return =~ /\S/;
                }
                $return;
        }
</PRE>
<HR>
<P>В этом примере, подпрограмма, ссылка на которую находится в переменной
<CODE>$scanner</CODE> вызывается до тех пор, пока ее возвращаемое значение
(сохраняемое в переменной <CODE>$return</CODE>) не будет непустым. Когда она
запускается с подпрограммой содержащей &lt;STDIN&gt;, то происходит
построковое считывание со стандартного ввода. Когда, она запускается с
сдвигом элементов в массиве <CODE>@cache</CODE>, то мы каждый раз будем
получать данные из массива <CODE>@cache</CODE>.
<P>К сожалению, в процессе тестирования этого кода, я обнаружил одну
проблему. Иногда, не существует непустых данных в потоке сканируемом
подпрограммой  <CODE>&amp;non_blank</CODE>, и таким образом эта подпрограмма
зацикливается. Ох! Подумав, мы приходим к логичной модификации и это решает
нашу проблему. Я буду возвращать неопределенное значение, если нет больше
сканируемых элементов, как в данном коде
<P>
<HR>
<PRE>
        sub non_blank {
                my($scanner) = @_;
                my($return);
                {
                        $return = &amp;{$scanner}();
                        last unless defined $return;
                        redo until $return =~ /\S/;
                }
                $return;
        }
</PRE>
<HR>
<P>Вот. Это работает! Теперь, если моей программе требуется  сканирование
&lt;STDIN&gt;, массива <CODE>@cache</CODE> или даже вызова другой подпрограммы
для получения следующей непустой строки, то не имеет значения как это
делается. И эта ошибка исправляется в одном месте, а не во всех участках
кода, которые реализуют аналогичные алгоритмы.
<P>Между прочим, я увлекся пунктуацией&nbsp;-- давайте упростим запись
до:
<P>
<HR>
<PRE>
        $return = &amp;$scanner();
</PRE>
<HR>
<P>Достаточно о подпрограммах. Давайте обратимся к другому использованию
ссылок&nbsp;-- как к способу модификации таблицы символов Perl. Почему нам
необходимо это? Одной из причин является создание алиасов для других
символов:
<P>
<HR>
<PRE>
        *fred = *barney;
</PRE>
<HR>
<P>Здесь мы сообщаем, что символ ``fred'' является алиасом для символа
``barney''. Мы называем это ``glob''-ссылкой, поскольку она модифицирует
глобальную таблицу символов.
<P>После того, как мы это сделаем, каждое использование <CODE>barney</CODE> как
переменной, может быть заменено на <CODE>fred</CODE>:
<P>
<HR>
<PRE>
        $barney = 3;
        $fred = 3; # тоже самое
        @barney = (1,2,4);
        print &quot;@fred&quot;; # выдает &quot;1 2 4&quot;
        %fred = (&quot;a&quot; =&gt; 1);
        print $barney{&quot;a&quot;}; # выдает 1
</PRE>
<HR>
<P>Таким же образом создаются алиасы для подпрограмм, файловых
дескрипторов, дескрипторов каталогов и имен форматов.
<P>Мы можем быть более избирательны, передавая glob-присвоению  данные о
типе ссылки:
<P>
<HR>
<PRE>
        *fred = \&amp;wilma;
</PRE>
<HR>
<P>Сейчас <CODE>$fred</CODE> также остается <CODE>$barney</CODE>, <CODE>@fred</CODE>
остается <CODE>@barney</CODE>, <CODE>%fred</CODE> остается <CODE>%barney</CODE>, но
<CODE>&amp;fred</CODE> является алиасом для <CODE>&amp;wilma</CODE>. Вы часто
можете увидеть такой код внутри блоков с локальной операцией glob:
<P>
<HR>
<PRE>
        *fred = *barney;
        {
                local(*fred) = \&amp;wilma;
                &amp;fred(3,4,5); # &amp;wilma(3,4,5)
        }
        &amp;fred(6,7,8); # &amp;barney(6,7,8)
</PRE>
<HR>
<P>Локализованное glob-присвоение эффективно только внутри блока кода,
когда мы выходим из области видимости блока, как по волшебству
восстанавливается предыдущее glob-присвоение.
<P>Мы можем переписать вышеприведенную подпрограмму <CODE>&amp;non_blank</CODE>
используя локальный алиас, вместо явного разименования ссылки:
<P>
<HR>
<PRE>
        sub non_blank {
                local(*scanner) = @_;
                my($return);
                {
                        $return = &amp;scanner();
                        last unless defined $return;
                        redo until $return =~ /\S/;
                }
                $return;
        }
</PRE>
<HR>
<P>Заметьте, что мы можем вызывать <CODE>&amp;scanner</CODE>, вместо неуклюжей
записи <CODE>&amp;$scanner</CODE>.
<P>Мы также можем использовать glob-ссылки приведения в порядок
подпрограммы <CODE>&amp;brack_it</CODE> из предыдущего выпуска. Вместо явного
разименования значения <CODE>$list_ref</CODE> в:
<P>
<HR>
<PRE>
        sub brack_it {
                my($list_ref) = @_;
                foreach (@$list_ref) {
                        print &quot;[$_]&quot;; # печать элементов в скобках
                }
                print &quot;\n&quot;;
        }
</PRE>
<HR>
<P>мы можем заменить его на glob-присвоение:
<P>
<HR>
<PRE>
        sub brack_it {
                local(*list) = @_; # надеемся, что ссылка на список
                foreach (@list) {
                        print &quot;[$_]&quot;; # печать элементов в скобках
                }
                print &quot;\n&quot;;
        }
</PRE>
<HR>
<P>Другим использованием glob-присвоений является возможность сделать
подпрограмму сортировки более родовой (общей). Hапример, классическая
``сортировка по значению'' для конкретного хеша записывается как:
<P>
<HR>
<PRE>
        sub by_numeric_value {
                $hash{$a} &lt;=&gt; $hash{$b}
        }
</PRE>
<HR>
<P>что работает хорошо, поскольку подпрограмма сортировки получает данные
из хеша <CODE>%hash</CODE>, как в этом примере:
<P>
<HR>
<PRE>
        sub sort_hash_by_value {
                sort by_numeric_value keys %hash;
        }
        @them = &amp;sort_hash_by_value;
</PRE>
<HR>
<P>Здесь, значения в массиве <CODE>@them</CODE> являются ключами <CODE>%hash</CODE>
сортироваными числовым значениям. Мы можем сделать данную подпрограмму
более общей:
<P>
<HR>
<PRE>
        sub sort_by_value {
                local(*hash) = @_; # ссылка на хеш
                sort by_numeric_value keys %hash;
        }
        @them_hash = &amp;sort_by_value(\%hash);
</PRE>
<HR>
<P>До настоящего времени это выполняет тоже самое, что и предыдущая
подпрограмма, но я передаю имя <CODE>%hash</CODE> в качестве первого
аргумента. Затем на него создается алиас и подпрограмма работает как и
прежде. Она становится лучше, поскольку я могу передать другие хеши:
<P>
<HR>
<PRE>
        @them_there = &amp;sort_by_value(\%there);
</PRE>
<HR>
<P>и что выполняет теже действия над хешем <CODE>%there</CODE>! В этом случае,
подпрограмма сортировки <CODE>&amp;sort_hash_by_value</CODE> думает, что она
имеет доступ к <CODE>%hash</CODE>, а в действительности она имеет доступ к
<CODE>%there</CODE>, поскольку используется алиас. Очень хорошо.
<P>Снова, я надеюсь, что эта экскурсия по возможностям  Perl (особенно по
наиболее мощным свойствам ссылок) была полезна для вас. Hаслаждайтесь!
<HR>
Next
Previous
Contents
</BODY>
</HTML>
