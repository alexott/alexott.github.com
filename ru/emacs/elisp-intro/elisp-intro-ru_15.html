<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on March, 10  2004 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Программирование на Emacs Lisp: Считаем слова</TITLE>

<META NAME="description" CONTENT="Программирование на Emacs Lisp: Считаем слова">
<META NAME="keywords" CONTENT="Программирование на Emacs Lisp: Считаем слова">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC165"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_14.html#SEC164"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC167"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_14.html#SEC148"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_16.html#SEC171"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 13. Подсчеты: Повторения и Регулярные выражения </H1>
<!--docid::SEC165::-->
<P>

Циклы, рекурсия и поиск по регулярным выражениям --- это очень
мощные и полезные инструменты, которые вы часто будете использовать при
написании своих программ.  В этой главе мы еще раз продемонстрируем
использование функции поиска по регулярному выражению на примере
создания функции, которая подсчитывает количество слов в области буфера.
Мы создадим две версии этой функции: первую с использованием цикла
<CODE>while</CODE>, вторую с использованием цикла <CODE>while</CODE> и рекурсии.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_15.html#SEC166">Считаем слова</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_15.html#SEC167">13.1 Функция <CODE>count-words-region</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Используем regexp, но появляется проблема.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_15.html#SEC169">13.2 Рекурсивный подсчет слов</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_15.html#SEC170">13.3 Упражнения: Сколько знаков пунктуации</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Зачем считать слова"></A>
<A NAME="SEC166"></A>
<H2> Считаем слова </H2>
<!--docid::SEC166::-->
<P>

В стандартном дистрибутиве Emacs имеется функция для подсчета числа
строк в области буфера.  Однако, соответствующей функции для посчета
слов нет.
</P><P>

Иногда в процессе работы требуется посчитать количество слов.  Например,
если вы пишете эссе, то вы можете поставить верхний предел в 800 слов;
если вы создаете роман, можно заставить себя писать в день не меньше
1000 слов.  Мне кажеться странным, что в Emacs нет такой функции.
Возможно большинство людей, которые используют редактор пишут программы
или создают документацию, в общем делают то, что не требует подсчета
слов; или может быть всех удовлетворяет существующая в операционной
системе команда <CODE>wc</CODE>, которая может подсчитать слова.  Кроме этого
возможно многие следуют соглашению издательств и находят число слов в
документе путем деления общего числа символов на пять.  В любом случае
мы все равно создадим команду для посчета слов.
</P><P>

<A NAME="count-words-region"></A>
<HR SIZE="6">
<A NAME="SEC167"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC165"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC168"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC166"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC165"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC169"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 13.1 Функция <CODE>count-words-region</CODE> </H2>
<!--docid::SEC167::-->
<P>

Функция считающая слова может находить число слов в строке, параграфе,
области или буфере.  Что нам подойдет больше всего?  Мы могли бы создать
функцию, которая считает слова во всем буфере.  Однако, в традициях
Emacs принято создавать многоцелевые функции --- вам может
потребоваться сосчитать слова не во всей книге, а только в одной главе.
Поэтому будет лучше, если наша функция будет находить число слов в
области.  Как только мы напишем функцию <CODE>count-words-region</CODE> мы
сможем при желании сосчитать количество слов во всем буфере, пометив его
как область, набрав <KBD>C-x h</KBD> (<CODE>mark-whole-buffer</CODE>).
</P><P>

Ясно, что подсчет слов это циклический процесс: сначала мы прибавляем
первое слово области, затем второе, потом третье, и так далее, до тех
пор, пока мы не достигнем конца области.  Это значит, что подсчет слов
идеально подходит для рекурсивного или циклического решения с
использованием <CODE>while</CODE>.
</P><P>

Для начала мы реализуем команду подсчета слов с помощью цикла
<CODE>while</CODE>, а затем перепишем функцию с использованием рекурсии.
Функция конечно должна быть интерактивной.
</P><P>

Как обычно шаблон для определения интерактивной функции следующий:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun <VAR>имя-функции</VAR> (<VAR>список-аргументов</VAR>)
  "<VAR>документация</VAR><small>...</small>"
  (<VAR>выражение-interactive</VAR><small>...</small>)
  <VAR>тело</VAR><small>...</small>)
</pre></td></tr></table></P><P>

Все что надо --- это заполнить соответствующие места.
</P><P>

Имя функции должно быть запоминающимся и лучше, если оно будет походить
на имя существующей функции <CODE>count-lines-region</CODE>.  Так пользователю
будет легче запомнить название функции.  Неплохой выбор ---
<CODE>count-words-region</CODE>.
</P><P>

Функция подсчитывает количество слов в области.  Это значит, что список
аргументов должен содержать символы, которые будут связаны с положением
двух позиций --- началом и концом области.  Эти символы можно
назвать соответственно <SAMP>`beginning'</SAMP> и <SAMP>`end'</SAMP>.  Также первая
строка документации должна быть завершенным предложением, поскольку
некоторые команды, такие как <CODE>apropos</CODE>, отображают только ее.
Выражение, делающее функцию интерактивной командой, это хорошо знакомое
нам выражение <SAMP>`(interactive "r")'</SAMP>, которое сообщает Emacs, что
начало и конец области надо связать с символами в списке аргументов
нашей функции.
</P><P>

В теле функции нам надо будет решить три задачи: сначала
проинициализировать необходимые переменные для того, чтобы цикл
<CODE>while</CODE> начал подсчет слов, второе --- запустить сам цикл
<CODE>while</CODE>, и третье --- отобразить информационное сообщение для
пользователя.
</P><P>

Когда пользователь вызывает функцию <CODE>count-words-region</CODE> курсор
может быть в начале или конце области.  Однако подсчет слов лучше
производить с начала области.  Это значит, что мы должны переместить
курсор в начало области, вдруг при вызове функции он был в конце или
середине области.  Для верности мы воспользуемся функцией
<CODE>(goto-char beginning)</CODE>.  Конечно же после того, как мы закончим
работу курсор необходимо вернуть на прежнюю позицию.  Поэтому, тело
функции должно быть вложено в особую форму <CODE>save-excursion</CODE>.
</P><P>

Основная часть функции состоит из цикла <CODE>while</CODE> в котором одно
выражение перемещает курсор вперед через слово, а другое выражение
подсчитывает эти перемещения.  Проверка-истина-ложь цикла <CODE>while</CODE>
должна возвращать истину до тех пор пока курсор находиться внутри
области и вернуть ложное значение, как только точка достигнет конца
области или выйдет за ее пределы.
</P><P>

Мы могли бы воспользоваться выражением <CODE>(forward-word 1)</CODE> для
перемещения курсора вперед слово за словом, но лучше понять, что же, в
редакторе GNU Emacs считается `словом' и воспользоваться функцией поиска
регулярных выражений.
</P><P>

Функция поиска регулярного выражения, при нахождении текста, который
сопоставим с заданным образцом, оставляет курсор сразу за последним
символом найденного текста.  Это означает, что последовательность
успешных вызовов функции поиска будет перемещать курсор вперед слово за
словом.
</P><P>

Практически нам потребуется чтобы функция поиска регулярного выражения
перемещала курсор также и через пробелы и символы пунктуации, которые
разделяют слова, а не только через само слово.  Регулярное выражение,
которое не позволит нам перепрыгнуть через разделяющие слова пробелы не
сможет перепрыгнуть даже через два слова!  Значит искомое регулярное
выражение должно включать пробелы и символы пунктуации, которые могут
следовать за словом, также как и само слово.  (Слово может находиться в
конце буфера и за ним уже не будет пробелов или знаков пунктуации,
поэтому эта часть регулярного выражения должна быть необязательной).
</P><P>

То есть нам понадобится регулярное выражение, которое будет совпадать с
текстом, когда за одним или более символами составляющими слово может
следовать один или несколько или ни одного символа не входящих в состав
слов.  Соответствующее регулярное выражение приведено ниже:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>\w+\W*
</pre></td></tr></table></P><P>

Таблица синтаксиса текущего буфера определяет, какие символы могут
входить в состав слова, а какие нет. (See section <A HREF="elisp-intro-ru_16.html#SEC174">Что входит в состав слова или символа?</A>, для получения дополнительной информации о
синтаксисе.  Также смотри section `The Syntax Table' in <CITE>The GNU Emacs Manual</CITE>, и, section `Syntax Tables' in <CITE>The GNU Emacs Lisp Reference Manual</CITE>.)
</P><P>

Выражение поиска в таком случает выглядит так:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(re-search-forward "\\w+\\W*")
</pre></td></tr></table></P><P>

(Обратите внимание на удвоенные обратные слэши перед <SAMP>`w'</SAMP> and
<SAMP>`W'</SAMP>.  Одиночный обратный слэш имеет специальное значение для
интерпретатора Лиспа.  Он означает, что следующий за ним символ должен
обрабатываться особым образом.  Например, два символа <SAMP>`\n'</SAMP> означают
символ <SAMP>`новой строки'</SAMP>, а не только обратный слэш за которым идет
<SAMP>`n'</SAMP>.  Для интерпретатора Lisp два обратных слэша подряд означают
один `не специальный' обратный слэш).
</P><P>

Также нам понадобится счетчик, в котором мы будет хранить количество
найденных слов; эту переменную мы вначале проинициализируем значением 0
а затем будем увеличивать каждый раз, когда Emacs вычисляет тело цикла
<CODE>while</CODE>.  Увеличивающее выражение очень простое:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq count (1+ count))
</pre></td></tr></table></P><P>

Наконец, мы должны будем сообщить пользователю сколько всего слов в
области.  Как раз для этой цели и предназначена функция <CODE>message</CODE>.
Но надо чтобы эта функция отображала правильно составленную фразу не
зависимо от того сколько в области слов: мы же не говорим "в области 1
слов".  Грамматику надо знать и единственное со множественным числом не
путать.  Эту проблему можно решить используя условное выражение, которое
будет возвращать при вычислении различные фразы в зависимости от того
сколько в области слов.  Существует четыре варианта: в области нет ни
одного слова, в области только одно слово, в области от двух до четырех
слов, и в области больше четырех слов.  Для этого хорошо подходит особая
форма <CODE>cond</CODE>.
</P><P>

Таким образом получается следующее определению функции:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>;;; Первая версия; с ошибками!
(defun count-words-region (beginning end)  
  "Сообщает число слов в области.
Словом считается текст в котором за хотя бы одним символом входящим в
состав слова следует хотя бы один символ не входящий в состав слова.
Таблица синтаксиса текущего буфера определяет, какими должны быть эти
символы."
  (interactive "r")
  (message "Подсчет слов в области ... ")

;;; 1. Соответствующая инициализация.
  (save-excursion
    (goto-char beginning)
    (let ((count 0))

;;; 2. Запуск цикла while.
      (while (&#60; (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))

;;; 3. Сообщаем о результатах пользователю.
      (cond ((zerop count)
             (message 
              "Область НЕ содержит слов."))
            ((= 1 count) 
             (message 
              "В области содержится 1 слово."))
       	    ((and (&#60; 1 count) (&#62; 5 count))
	     (message 
              "В области содержиться %d словa." count))
            (t 
             (message 
              "В области содержится %d слов." count))))))
</pre></td></tr></table></P><P>

Эта функция работает, но не всегда правильно.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_15.html#SEC168">13.1.1 Ошибка в <CODE>count-words-region</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Ошибка с пробелами"></A>
<HR SIZE="6">
<A NAME="SEC168"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC167"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC169"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC166"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC167"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC169"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 13.1.1 Ошибка в <CODE>count-words-region</CODE> </H3>
<!--docid::SEC168::-->
<P>

Команда <CODE>count-words-region</CODE> представленная в предыдущем разделе
содержит две ошибки, или точнее одну ошибку, которая проявляется два
раза.  Первое, если вы пометите область, которая содержит один пробел в
середине какого-нибудь текста, команда <CODE>count-words-region</CODE> скажет
вам что область содержит одно слово!  Второе, если вы пометите область
содержащую один пробел в конце буфера или в конце доступной области
буфера, если включено сужение, команда отобразит следующее сообщение об
ошибке:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>Search failed: "\\w+\\W*"
</pre></td></tr></table></P><P>

Если вы читаете это в Info, то вы сами можете убедиться в наличии этих
ошибок.
</P><P>

Вначале, как обычно вычислите саму функцию, для того чтобы установить
ее.
Ниже приведена копия определения.  Расположите курсор за последней
закрывающейся скобкой и нажмите <KBD>C-x C-e</KBD> для того чтобы установить
функцию.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>;;; Первая версия; с ошибками!
(defun count-words-region (beginning end)  
  "Сообщает число слов в области.
Словом считается текст в котором за хотя мы одним символом входящим в
состав слова следует хотя бы один символ не входящий в состав слов.
Таблица синтаксиса текущего буфера определяет, какими должны быть эти
символы."
  (interactive "r")
  (message "Подсчет слов в области ... ")

;;; 1. Соответствующая инициализация.
  (save-excursion
    (goto-char beginning)
    (let ((count 0))

;;; 2. Запуск цикла while.
      (while (&#60; (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))

;;; 3. Сообщаем о результатах пользователю.
      (cond ((zerop count)
             (message 
              "Область НЕ содержит слов."))
            ((= 1 count) 
             (message 
              "В области содержится 1 слово."))
       	    ((and (&#60; 1 count) (&#62; 5 count))
	     (message 
              "В области содержиться %d словa." count))
            (t 
             (message 
              "В области содержится %d слов." count))))))
</pre></td></tr></table></P><P>

Если хотите, то вы можете также для удобства связать эту функцию с
какой-нибудь клавишей:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(global-set-key "\C-c=" 'count-words-region)
</pre></td></tr></table></P><P>

Для первой проверки, поставьте метку в начале, а курсор в конце
следующей строки и наберите <KBD>C-c =</KBD> (или <KBD>M-x
count-words-region</KBD>, если вы не связали команду с клавишами <KBD>C-c =</KBD>)
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    раз   два  три
</pre></td></tr></table></P><P>

Emacs выдаст вам ожидаемое сообщение:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>В области содержиться 3 словa.
</pre></td></tr></table></P><P>

Повторим этот тест, но на этот раз поставьте метку в начале строки, а
курсор расположите как раз <EM>перед</EM> словом <SAMP>`раз'</SAMP>.  Снова
выполните команду <KBD>C-c =</KBD> (или <KBD>M-x count-words-region</KBD>).  Вроде
бы Emacs должен сообщить нам что в области не содержится слов ---
ведь там находятся только пробелы.  Но вместо этого Emacs скажет нам что
в области содержиться одно слово!
</P><P>

Перед третьей проверкой скопируйте тестируемую строку в конец буфера
<TT>`*scratch*'</TT> и после нее напечатайте несколько пробелов.  Поставьте
метку <EM>сразу</EM> за словом <SAMP>`три'</SAMP>, а точку в конце строки.  (Конец
строки должен быть и концом буфера).  И снова наберите <KBD>C-c =</KBD> (или
<KBD>M-x count-words-region</KBD>).  Мы опять ожидаем, что Emacs сообщит нам
об отсутствии слов в области, поскольку она содержит только пробелы.
Вместо этого в эхо-области появляется сообщение <SAMP>`Search failed'</SAMP>.
</P><P>

Эти две ошибки следствие одной и той же проблемы.
</P><P>

Рассмотрим первое проявление ошибки, когда область содержит только
пробелы, а затем идет какой-то текст.  Происходит следующее: команда
<CODE>M-x count-words-region</CODE> перемещает точку в начало области.  В
цикле <CODE>while</CODE> проверяется меньше ли значение точки, чем значение
<CODE>end</CODE>, сначала это верно.  Теперь функция поиска по регулярному
выражению ищет и находит первое слово.  Она оставляет курсор после
найденного слова. Переменной <CODE>count</CODE> присваивается значение 1.
Цикл <CODE>while</CODE> повторяется; но теперь значение точки больше чем
значение <CODE>end</CODE> и поэтому цикл завершается, функция отображает
сообщение, где говорится что область содержит одно слово, ведь значение
<CODE>count</CODE> равно 1.  Короче говоря, функция поиска регулярного
выражения ищет и находит слово даже если оно находится вне помеченной
области.
</P><P>

При втором проявлении ошибки, область состоит из одних пробелов в конце
буфера.  Emacs сообщает, что <SAMP>`Search failed'</SAMP>.  Это происходит в
результате выполненения все той же функции поиска.  Поскольку теперь в
буфере нет слов, то поиск завершается неудачей.
</P><P>

Обе эти ошибки, обьясняются тем, что функция поиска выходит или пытается
выйти за пределы области.
</P><P>

Решение напрашивается само собой --- ограничить поиск заданой
областью, но если немного подумать, то все получается не совсем так
просто.
</P><P>

Как мы знаем функция <CODE>re-search-forward</CODE> принимает первый аргумент,
в виде шаблона текста, который необходимо найти.  Но кроме первого
обязательного аргумента, функция может принимать еще три необязательных
параметра.  Вторым аргументом задается граница поиска.  Третий аргумент,
если назначить ему значение <CODE>t</CODE> заставляет функцию вернуть значение
<CODE>nil</CODE> в случае неудачного поиска, а не сообщать об ошибке.
Четвертый аргумент задает число повторов поиска.  (В Emacs, вы можете
вызвать описание любой функций нажав <KBD>C-h f</KBD>, и набрав имя функции в
минибуфере).
</P><P>

В определении функции <CODE>count-words-region</CODE> значение конца области
содержится в переменной <CODE>end</CODE>, которая передется в нее при вызове,
как аргумент.  Поэтому мы можем просто добавить <CODE>end</CODE> в качестве
еще одного аргумента для функцит поиска:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(re-search-forward "\\w+\\W*" end)
</pre></td></tr></table></P><P>

Однако, если вы сделаете только это изменение в определении
<CODE>count-words-region</CODE> и снова проверите работу функции на области
состоящей из пробелов, то вы снова получите сообщение об ошибке
<SAMP>`Search failed'</SAMP>.
</P><P>

Причина ясна --- поиск ограничен областью, и заканчивается неудачей,
как и ожидалось --- ведь в области нет символов, которые могут
входить в состав слова.  Поскольку поиск завершился неудачей, то мы
получаем сообщение об ошибке.  Но этого нам тоже не нужно; мы хотим
чтобы в этом случае Emacs сообщил нам "Область НЕ содержит слов."
        
Эта проблема устраняется путем задания третьего аргумента <CODE>t</CODE> для
функции <CODE>re-search-forward</CODE>, что заставляет функцию вместо
отображения сообщения об ошибке просто вернуть значение <CODE>nil</CODE>, в
случае если поиск завершился неудачей.
</P><P>

Однако, если вы внесете это изменение и заново протестируете его, в
эхо-области появится сообщение "Подсчет слов в области ..." и <small>...</small>
оно будет отображаться до тех пор, пока вы не нажмете <KBD>C-g</KBD>
(<CODE>keyboard-quit</CODE>).
</P><P>

Причина в следующем: поиск ограничен областью как и раньше, и если вы
вызвали эту функция на области где слов нет, то поиск закончится
неудачей --- ведь там нет символов составляющих слово, все как
положено.  Теперь функция <CODE>re-search-forward</CODE> возвратит <CODE>nil</CODE>,
а не сообщит об ошибке.  Больше она ничего не сделает, а точнее она не
переместит курсор, что происходит в случае успешного поиска, в виде
побочного эффекта функции.  После того, как функция
<CODE>re-search-forward</CODE> вернула <CODE>nil</CODE> вычислится следующее
выражение цикла <CODE>while</CODE>.  В этом выражении увеличивается значение
<CODE>count</CODE>.  Затем цикл повторяется.  Проверка-истина-ложь возвращает
истину, поскольку значение точки все еще меньше, чем значение конца
области --- ведь функция <CODE>re-search-forward</CODE> не переместила
точку.  Цикл повторяется --- <small>...</small> снова <small>...</small> и снова.
</P><P>

Значит определение функции <CODE>count-words-region</CODE> надо еще немного
подправить, для того чтобы проверка-истина-ложь цикла <CODE>while</CODE>
возвращала ложь в случае неудачного поиска.  Можно сказать по другому, в
проверке-истина-ложь должны быть выполнены два условия перед тем, как
переменная <CODE>count</CODE> будет увеличена --- точка должна находиться
в пределах области и функция поиска должна успешно найти одно слово.
</P><P>

Поскольку оба эти условия должны быть выполнены вместе, то их можно
обьединить в одном выражении с помощью функции <CODE>and</CODE> и использовать
это выражение как проверку-истина-ложь для всего цикла <CODE>while</CODE>,
следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(and (&#60; (point) end) (re-search-forward "\\w+\\W*" end t))
</pre></td></tr></table></P><P>

(See section <A HREF="elisp-intro-ru_14.html#SEC154">12.4 <CODE>forward-paragraph</CODE>: сокровищница функций</A>, для получения информации о функции
<CODE>and</CODE>).
</P><P>

Выражение <CODE>re-search-forward</CODE> возвращает <CODE>t</CODE>, если поиск
успешен и в виде побочного эффекта перемещает курсор.  Соответственно
при нахождении новых слов курсор перемещается по области.  Когда,
наконец, функция поиска не смогла найти еще одно слово или когда курсор
достигает конца области, то проверка-истина-ложь возвращает ложь, цикл
<CODE>while</CODE> завершается, и функция <CODE>count-words-region</CODE> отображает
в эхо-области результат поиска.
</P><P>

После внесения всех вышеизложенных изменений безошибочная, (по крайней
мере я больше не находил ошибок) функция <CODE>count-words-region</CODE>
выглядит следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>;;; Окончательная версия: <CODE>while</CODE>
(defun count-words-region (beginning end)  
  "Сообщает число слов в области.
Словом считается текст в котором за хотя мы одним символом входящим в
состав слова следует хотя бы один символ не входящий в состав слов.
Таблица синтаксиса текущего буфера определяет, какими должны быть эти
символы."
  (interactive "r")
  (message "Подсчет слов в области ... ")

;;; 1. Соответствующая инициализация.
  (save-excursion
    (goto-char beginning)
    (let ((count 0))

;;; 2. Запуск цикла while.
      (while (and (&#60; (point) end))
                  (re-search-forward "\\w+\\W*" end t)
        (setq count (1+ count)))

;;; 3. Сообщаем о результатах пользователю.
      (cond ((zerop count)
             (message 
              "Область НЕ содержит слов."))
            ((= 1 count) 
             (message 
              "В области содержится 1 слово."))
       	    ((and (&#60; 1 count) (&#62; 5 count))
	     (message 
              "В области содержиться %d словa." count))
            (t 
             (message 
              "В области содержится %d слов." count))))))
</pre></td></tr></table></P><P>

<A NAME="recursive-count-words"></A>
<HR SIZE="6">
<A NAME="SEC169"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC168"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC170"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC167"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC165"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_16.html#SEC171"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 13.2 Рекурсивный подсчет слов </H2>
<!--docid::SEC169::-->
<P>

Можно переписать функцию для подсчета слов с помощью рекурсии, которая
заменит цикл <CODE>while</CODE>.  Давайте посмотрим, как это делается.
</P><P>

Во-первых, мы должны вспомнить, что функция <CODE>count-words-region</CODE>
выполняет три основные задачи: подготавливает все необходимое для начала
подсчета слов; считает количество слов в области; и отображает для
пользователя информационное сообщение, в котором говорится, сколько слов
в области.
</P><P>

Если мы создадим одну рекурсивную функцию, которая будет делать все это
сразу, то информационное сообщение будет появляться при каждом
рекурсивном вызове.  Если в области содержится 13 слов, то мы увидим
тринадцать сообщений в эхо-области, одно за другим.  Это не очень
удобно!  Вместо этого, мы создадим две функции для выполнения этой
задачи, одна из которых (рекурсивная функция) будет вызываться из тела
другой.  Внешняя функция будет подготавливать условия для подсчета слов
и отображать информационное сообщение; другая будет считать слова.
</P><P>

Давайте начнем с функции, котороя будет отображать сообщение.  Мы
можем назвать ее также --- <CODE>count-words-region</CODE>.
</P><P>

Именно эту функцию будет вызывать пользователь.  Она должна быть
интерактивной.  На самом деле она будет очень похожа на предыдущую
версию этой функции, если не считать того, что для подсчета слов будет
вызываться функция <CODE>recursive-count-words</CODE>.
</P><P>

Мы можем с легкостью создать шаблон этой функции, основанный на
предыдущих наработках:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>;; Рекурсивная версия; использует функцию поиска regexp
(defun count-words-region (beginning end)  
  "<VAR>документация</VAR><small>...</small>"
  (<VAR>выражение-interactive</VAR><small>...</small>)

;;; 1. Соответствующая подготовка.
  (<VAR>Сообщение о начале работы</VAR>)
  (<VAR>Инициализация переменных</VAR><small>...</small>

;;; 2. Подсчет слов.
    <VAR>вызов рекурсивной функции</VAR>

;;; 3. Отображает сообщение для пользователя.
    <VAR>сообщаем о результатах работы</VAR>))
</pre></td></tr></table></P><P>

Определение выглядит понятным и хорошо знакомым, если не считать того,
что число слов, которое будет возвращать рекурсивная функция надо
использовать для отображения результата работы.  Немного подумав можно
предложить использовать для этого выражение <CODE>let</CODE>: мы можем связать
какую-нибудь переменную в списке переменных выражения <CODE>let</CODE> с
числом слов в области, которое возвращает рекурсивный вызов; и после
этого, в выражении <CODE>cond</CODE> использовать эту переменную для
отображения результатов пользователю.
</P><P>

Обычно считают, что создание и инициализация локальных переменных в
выражении <CODE>let</CODE> это что-то второстепенное, а вот дальше в теле
выражения будет выполняться `основная' работа функции.  Но в нашем
случае, то что считается `основной' работой функции --- подсчет
слов, происходит при инициализации переменной в выражении <CODE>let</CODE>.
</P><P>

С <CODE>let</CODE>, определение функции выглядит следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun count-words-region (beginning end)  
  "Печатает число слов в области."
  (interactive "r")

;;; 1. Соответствующие подготовления.
  (message "Подсчет слов в области ... ")
  (save-excursion
    (goto-char beginning)

;;; 2. Подсчет слов.
    (let ((count (recursive-count-words end)))    

;;; 3. Отображение результатов работы.
      (cond ((zerop count)
             (message 
              "Область НЕ содержит слов."))
            ((= 1 count) 
             (message 
              "В области содержится 1 слово."))
       	    ((and (&#60; 1 count) (&#62; 5 count))
	     (message 
              "В области содержиться %d словa." count))
            (t 
             (message 
              "В области содержится %d слов." count))))))
</pre></td></tr></table></P><P>

Теперь нам надо написать рекурсивную функцию для подсчета слов.
</P><P>

Рекурсивная функция должна содержать поменьшей мере три части:
`рекурсивную-проверку', `выражение-следующего-вызова' и рекурсивный
вызов.
</P><P>

Рекурсивная проверка определяет нужно ли снова вызывать функцию или нет.
Поскольку мы подсчитываем слова в области и будем использовать функцию,
которая перемещает курсор вперед через слово, то рекурсивная проверка
может проверять находится ли курсор в пределах области.  Рекурсивная
проверка должна найти значение точки и определить больше или меньше
значение точки, чем конец области.  Для этого мы можем использовать
функцию <CODE>point</CODE>.  Ясно, что для этого мы должны передать значение
конца области в виде аргумента при вызове рекурсивной функции
производящей подсчет слов.
</P><P>

Кроме этого в рекурсивной проверке надо выяснить чем закончился поиск
слова, ведь если поиск был неудачен, то рекурсивные вызовы должны
прекратиться.
</P><P>

Выражение-следующего-вызова должно изменять какое-нибудь значение, чтобы
рекурсивная функция когда-нибудь перестала вызывать себя и остановилась.
Если быть более точным, то выражение-следующего-вызова должно изменять
некоторое значение, таким образом, чтобы в нужное время рекурсивная
проверка прекратила рекурсивные вызовы.  В нашем случае
выражение-следующего-вызова может быть выражением, которое лишь
перемещает курсор слово за словом.
</P><P>

Третья часть рекурсивной функции --- это рекурсивный вызов.
</P><P>

Где-то, также нам понадобится часть, которая выполняет основную `работу'
функции, часть, которая и производит счет слов.  Необходимая часть!
</P><P>

Но сейчас мы уже можем схематично обрисовать рекурсивную функцию:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun recursive-count-words (region-end)
  "<VAR>документация</VAR><small>...</small>"
   <VAR>рекурсивная-проверка</VAR>
   <VAR>выражение-следующего-вызова</VAR>
   <VAR>рекурсивный вызов</VAR>)
</pre></td></tr></table></P><P>

Сейчас, как обычно, нам надо заполнить соответствующие части шаблона.
Давайте начнем с самого простого случая: если точка находиться в конце
области или за ее пределами, там где нет слов, то функция должна
возвращать ноль.  Аналогично, если поиск закончился неудачей, и больше
слов в области нет, то функция также должна возвращать ноль.
</P><P>

С другой стороны, если точка находится в пределах области и поиск
завершился успехом, то слово найдено и функция должна вызвать саму
себя.
</P><P>

То есть, рекурсивная-проверка может выглядеть следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(and (&#60; (point) region-end)
     (re-search-forward "\\w+\\W*" region-end t))
</pre></td></tr></table></P><P>

Обратите внимание, что функция поиска входит в состав
рекурсивной-проверки --- функция поиска возвращает <CODE>t</CODE> в случае
успеха и <CODE>nil</CODE> в случает неудачи.  (See section <A HREF="elisp-intro-ru_15.html#SEC168">Ошибка с пробелами in <CODE>count-words-region</CODE></A>, для объяснения того
как работает <CODE>re-search-forward</CODE>).
</P><P>

Рекурсивная-проверка --- это проверка-истина-ложь в выражении
<CODE>if</CODE>.  Ясно, что в случае успеха рекурсивной-проверки, в then-часть
выражения <CODE>if</CODE> должен происходить рекурсивный вызов функции; если
рекурсивная-проверка закончится неудачей, то в else-части должен
вернуться ноль, поскольку или точка вышла за пределы области или поиск
завершился неудачей потому что не удалось найти слово.
</P><P>

Но до того, как мы перейдем к рекурсивному вызову, нам надо рассмотреть
выражение-следующего-вызова.  Что оно собой представляет?  Любопытно,
что это функция поиска в рекурсивной проверке.
</P><P>

Кроме того, что функция поиска возвращает <CODE>t</CODE> или <CODE>nil</CODE> в
вызвавшую ее функцию, <CODE>re-search-forward</CODE> также перемещает точку
вперед через слово.  Именно это действие изменяет значение точки, так
что рекурсивные вызовы прекратятся тогда, когда точка переместится в
конец области.  Соответственно выражение <CODE>re-search-forward</CODE> и
есть выражение-следующего-вызова.
</P><P>

Схематично тело функции <CODE>recursive-count-words</CODE> выглядит
следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if <VAR>рекурсивная-проверка-выражение-следующего-вызова-два-в-одном</VAR>
    ;; then
    <VAR>рекурсивный-вызов</VAR>
  ;; else
  <VAR>вернуть-ноль</VAR>)
</pre></td></tr></table></P><P>

Остается ответить на один вопрос, как производить подсчет слов?
</P><P>

Если вы не привыкли к созданию рекурсивных функций, то вам будет трудно
ответить на такой вопрос.  Но постепенно вы овладеете мастерством
создания рекурсивных функций.
</P><P>

Мы знаем, что механизм подсчета должен быть как-то связан с рекурсивным
вызовом функции.  В самом деле, поскольку выражение-следующего-вызова
перемещает курсор вперед через слово, то рекурсивный вызов происходит
для каждого слова, механизм подсчета может быть выражением, в котором
единица прибавляется к значению возвращаемому
<CODE>recursive-count-words</CODE>.
</P><P>

Рассмотрим следующие случаи:
</P><P>

<UL>
<LI>
Если в области содержится два слова, то функция должна возвратить
значение, которое получится если прибавить единицу к значению
возвращаемому, при вызове функции для области содержащей одно слово,
ведь первое мы уже прибавили.
<P>

<LI>
Если в области одно слово, то функция должна вернуть значение, которое
получится, если прибавить единицу к значению возвращаемому при вызове
функции для области где уже нет слов --- в этом случае функция
должна вернуть ноль.
<P>

<LI>
Если в области нет слов, то функция должна возвратить ноль.
</UL>
<P>

В шаблоне, который мы уже набросали, else-часть выражения <CODE>if</CODE>
возвращает ноль для случая, когда слов уже не осталось.  Это значит, что
then-часть выражения <CODE>if</CODE>, должна вернуть результат сложения
единицы и значения, которое возвратит рекурсивный вызов функции на
оставшейся части области.
</P><P>

Then-часть будет выглядеть следующим образом, где <CODE>1+</CODE> ---
функция которая добавляет единицу к своему аргументу.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(1+ (recursive-count-words region-end))
</pre></td></tr></table></P><P>

Теперь вся функция <CODE>recursive-count-words</CODE> принимает следующий
вид:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun recursive-count-words (region-end)
  "<VAR>документация</VAR><small>...</small>"

;;; 1. рекурсивная-проверка
  (if (and (&#60; (point) region-end)          
           (re-search-forward "\\w+\\W*" region-end t))

;;; 2. then-part: рекурсивный вызов
      (1+ (recursive-count-words region-end))  

;;; 3. else-part
    0))             
</pre></td></tr></table></P><P>

Давайте рассмотрим как работает эта функция:
</P><P>

Если в области нет слов, то вычисляется else-часть выражения <CODE>if</CODE> и
функция возвращает ноль.
</P><P>

Если в области одно слово, то значение точки меньше чем значение
<CODE>region-end</CODE> и поиск завершается успехом.  В этом случае
проверка-истина-ложь выражения <CODE>if</CODE> возвращает <CODE>t</CODE> и
вычисляется then-часть выражения <CODE>if</CODE>.  Запускается механизм счета.
Это выражение возвращает значение (это будет значением всей функции),
которое равно сумме единицы и значения возвращаемого рекурсивным
вызовом.
</P><P>

Поскольку выражение-следующего-вызова уже переместило точку через одно
(и в нашем случае единственное) слово в области, это значит, что когда
функция <CODE>(recursive-count-words region-end)</CODE> будет вычисляется
второй раз (в результате рекурсивного вызова), то значение точки будет
равным или большим, чем значение конца региона.  Поэтому, при этом
вызове функция <CODE>recursive-count-words</CODE> вернет ноль.  Ноль будет
добавлен к единице и первоначальный вызов <CODE>recursive-count-words</CODE>
возвратит результат сложения единицы и нуля, то есть значение 1. В нашем
случае это правильное значение.
</P><P>

Ясно, что если в области два слова, то первый вызов
<CODE>recursive-count-words</CODE> вернет результат сложения единицы и
значение, которое возвратит вызов <CODE>recursive-count-words</CODE> на
области содержащей оставшееся слово. В результате один плюс один даст
два, а это правильное значение.
</P><P>

Рассуждая подобным образом, если в области три слова, то первый вызов
<CODE>recursive-count-words</CODE> вернет результат сложения единицы и
значения возвращаемого вызовом <CODE>recursive-count-words</CODE> на области,
которая содержит два слова --- и так далее, и так далее.
</P><P>

Полностью документированные функции выглядят следующим образом:
</P><P>

Рекурсивная функция:
</P><P>

<A NAME="IDX69"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun recursive-count-words (region-end)
  "Возвращает количество слов между точкой и region-end."

;;; 1. рекурсивная-проверка
  (if (and (&#60; (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))

;;; 2. then-часть: рекурсивный вызов
      (1+ (recursive-count-words region-end)) 

;;; 3. else-часть
    0))             
</pre></td></tr></table></P><P>

Верхняя функция:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun count-words-region (beginning end)  
  "Печатает число слов в области.
Словом считается текст в котором за хотя бы одним символом входящим в
состав слова следует хотя бы один символ не входящий в состав слов.
Таблица синтаксиса текущего буфера определяет, какими должны быть эти
символы."

  (interactive "r")
;;; 1. Соответствующие подготовления.
  (message "Подсчет слов в области ... ")
  (save-excursion
    (goto-char beginning)

;;; 2. Подсчет слов.
    (let ((count (recursive-count-words end)))    

;;; 3. Отображение результатов работы.
      (cond
       ((zerop count)
	(message 
	 "Область НЕ содержит слов."))
       ((= 1 count) 
	(message 
	 "В области содержится 1 слово."))
       ((and (&#60; 1 count) (&#62; 5 count))
	(message 
	 "В области содержиться %d словa." count))
       (t 
	(message 
	 "В области содержится %d слов." count))))))
</pre></td></tr></table></P><P>

<A NAME="Упражнения на счет"></A>
<HR SIZE="6">
<A NAME="SEC170"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC169"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_16.html#SEC171"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC165"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC165"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_16.html#SEC171"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 13.3 Упражнения: Сколько знаков пунктуации </H2>
<!--docid::SEC170::-->
<P>

С помощью цикла <CODE>while</CODE> напишите функцию, которая подсчитывает
знаки пунктуации (точки, запятые, знаки вопроса, воскличательные знаки и
т.п) в области.  Перепишите ее используя рекурсию.
</P><P>

<A NAME="Слова в defun"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_15.html#SEC165"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_16.html#SEC171"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
on <I>March, 10  2004</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
