<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on March, 10  2004 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Программирование на Emacs Lisp: Список удалений</TITLE>

<META NAME="description" CONTENT="Программирование на Emacs Lisp: Список удалений">
<META NAME="keywords" CONTENT="Программирование на Emacs Lisp: Список удалений">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC215"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_21.html#SEC214"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_21.html#SEC214"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_23.html#SEC226"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> B. Обработка списка удалений </H1>
<!--docid::SEC215::-->
<P>

Список удалений являeтся списком, который превращен в кольцо с помощью
функции <CODE>rotate-yank-pointer</CODE>.  Команды <CODE>yank</CODE> и
<CODE>yank-pop</CODE> используют функцию <CODE>rotate-yank-pointer</CODE>.  В этом
приложение описывается функция <CODE>rotate-yank-pointer</CODE>, а также
команды <CODE>yank</CODE> и <CODE>yank-pop</CODE>.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC216">B.1 Функция <CODE>rotate-yank-pointer</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Перемещает указатель по списку.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC222">B.2 <CODE>yank</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC225">B.3 <CODE>yank-pop</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="rotate-yank-pointer"></A>
<HR SIZE="6">
<A NAME="SEC216"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC215"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC217"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> B.1 Функция <CODE>rotate-yank-pointer</CODE> </H2>
<!--docid::SEC216::-->
<P>

Функция <CODE>rotate-yank-pointer</CODE> изменяет элемент в списке удалений,
на который указывает <CODE>kill-ring-yank-pointer</CODE>.  Например, эта
функция может изменить <CODE>kill-ring-yank-pointer</CODE> чтобы он указывал
на третий элемент, а не на второй.
</P><P>

Вот код функции <CODE>rotate-yank-pointer</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun rotate-yank-pointer (arg)
  "Циклическое вращение rotate-yank-pointer."
  (interactive "p")
  (let ((length (length kill-ring)))

    (if (zerop length)

        ;; then-часть
        (error "Kill ring is empty")

      ;; else-часть
      (setq kill-ring-yank-pointer
            (nthcdr (% (+ arg
                          (- length
                             (length
                              kill-ring-yank-pointer)))
                       length)
                    kill-ring)))))
</pre></td></tr></table></P><P>

Функция выглядит сложной, но как обычно, она может быть разобрана по
частям.  Сначала взгляним на ее скелет:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun rotate-yank-pointer (arg)
  "Циклическое вращение rotate-yank-pointer."
  (interactive "p")
  (let <VAR>varlist</VAR>
    <VAR>body</VAR><small>...</small>)
</pre></td></tr></table></P><P>

Эта функция принимает один аргумент, который называется <CODE>arg</CODE>.  Она
имеет короткую строку документации; и она интерактивная, используя
маленькую букву <SAMP>`p'</SAMP>, которая означает, что аргумент должен быть
обработанным префиксом, который передается функции как число.
</P><P>

Телом определения функции является выражение <CODE>let</CODE>, которое само имеет
тело и список переменных <VAR>varlist</VAR>.
</P><P>

Выражение <CODE>let</CODE> объявляет переменную, которая будет использоваться
только в области видимости данной функции.  Эта переменная имеет имя
<CODE>length</CODE> и связана со значением равным количеству объектов в списке
удалений. Подсчет производится с помощью функции <CODE>length</CODE>.
(Заметьте, что эта функция имеет тоже имя, что и переменная
<CODE>length</CODE>; но в одном случае это слово используется для именования
функции, а во втором случае, для именования переменной. Эти два имени
достаточно отличаются. Аналогично, англоговорящие пользователи будут
различать значения слова <SAMP>`ship'</SAMP> когда они говорят: "I must ship
this package immediately." и "I must get aboard the ship immediately.")
</P><P>

Функция <CODE>length</CODE> сообщает количество объектов в списке, так что
выражение <CODE>(length kill-ring)</CODE> вернет количество объектов в списке
удалений. 
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC217">B.1.1 Тело функции <CODE>rotate-yank-pointer</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="тело rotate-yk-ptr"></A>
<HR SIZE="6">
<A NAME="SEC217"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC218"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> B.1.1 Тело функции <CODE>rotate-yank-pointer</CODE> </H3>
<!--docid::SEC217::-->
<P>

Тело функции <CODE>rotate-yank-pointer</CODE> состоит из выражения <CODE>let</CODE>, а
тело выражения <CODE>let</CODE> состоит из выражения <CODE>if</CODE>.
</P><P>

Выражение <CODE>if</CODE> используется для определения того, если ли объекты в
списке удалений. Если список удалений пуст, то функция <CODE>error</CODE>
прекращает работу функции и выдает сообщение в области сообщений. Но если в
списке удалений есть объекты, то функция продолжает работу.
</P><P>

Вот if-часть и then-часть выражения <CODE>if</CODE>:
</P><P>

<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if (zerop length)                      ; if-часть
    (error "Kill ring is empty")        ; then-часть
  <small>...</small>
</pre></td></tr></table></P><P>

Если в списке удалений ничего нет, то его длина должна быть равна нулю и
пользователю отправляется сообщение об ошибке: <SAMP>`Kill ring is
empty'</SAMP>.  Выражение <CODE>if</CODE> использует функцию <CODE>zerop</CODE>, которая
возвращает истинное значение, если тестируемый объект равен нулю. Когда
тест <CODE>zerop</CODE>возвращает истинное значение, то оценивается then-часть
выражения <CODE>if</CODE>.  then-часть--- это список, который начинается с
функции <CODE>error</CODE>, которая похожа на функцию <CODE>message</CODE>
(see section <A HREF="elisp-intro-ru_3.html#SEC27">1.8.5 Функция <CODE>message</CODE></A>), в том, что она выдает сообщение в область
сообщений. Однако, в добавлении к выдаче сообщения, <CODE>error</CODE> также
останавливает вычисление функции, в которой она вызвана. В этом случае,
это означает, что остальная часть функции не будет выполнена в том
случае, если длина списка удалений равна нулю.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC218">else-часть выражения <CODE>if</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC219">Функция вычисления остатка <CODE>%</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC220">Использование <CODE>%</CODE> в <CODE>rotate-yank-pointer</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC221">Указатель на последний элемент</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="rotate-yk-ptr else-part"></A>
<HR SIZE="6">
<A NAME="SEC218"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC217"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC219"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC217"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> else-часть выражения <CODE>if</CODE> </H4>
<!--docid::SEC218::-->
<P>

else-часть выражения <CODE>if</CODE> предназначена для установки значения
<CODE>kill-ring-yank-pointer</CODE> для тех случаев, когда в списке удалений
что-то есть. Код выглядит примерно так:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq kill-ring-yank-pointer
      (nthcdr (% (+ arg
                    (- length
                       (length kill-ring-yank-pointer)))
                 length)
              kill-ring)))))
</pre></td></tr></table></P><P>

Этот код нуждается в тщательном рассмотрении.  Очевидно, что
<CODE>kill-ring-yank-pointer</CODE> устанавливается равным содержимому
CDR от списка уничтожений, с использованием функции
<CODE>nthcdr</CODE>, которая была описана в предыдущих разделах.
(See section <A HREF="elisp-intro-ru_10.html#SEC118">8.5 <CODE>copy-region-as-kill</CODE></A>.). Но как это делается?
</P><P>

До того, как мы будем рассматривать код, давайте рассмотрим назначение
функции <CODE>rotate-yank-pointer</CODE>.
</P><P>

Функция <CODE>rotate-yank-pointer</CODE> изменяет значение, на которое
указывает <CODE>kill-ring-yank-pointer</CODE>. Если
<CODE>kill-ring-yank-pointer</CODE> начинается с указания на первый элемент
списка, то вызов функции <CODE>rotate-yank-pointer</CODE> заставит ее
указывать на второй элемент; а если <CODE>kill-ring-yank-pointer</CODE>
указывает на второй элемент, то вызов <CODE>rotate-yank-pointer</CODE>
заставит его указывать на третий элемент. (И если при вызове
<CODE>rotate-yank-pointer</CODE> задан аргумент больший единици, то это
заставит указатель переместиться на несколько элементов).
</P><P>

Функция <CODE>rotate-yank-pointer</CODE> использует <CODE>setq</CODE> для задания
значения на которое указывает <CODE>kill-ring-yank-pointer</CODE>. Если
<CODE>kill-ring-yank-pointer</CODE> указывает на первый элемент списка
уничтожений, то, в простейшем случае, функция
<CODE>rotate-yank-pointer</CODE> должна заставить указывать его на второй
элемент. Смотря с другой стороны, <CODE>kill-ring-yank-pointer</CODE> должен
быть установлен в значение равное результату выполнения CDR для
списка уничтожений.
</P><P>

Так, с данными условиями,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq kill-ring-yank-pointer
   ("some text" "a different piece of text" "yet more text"))

(setq kill-ring
   ("some text" "a different piece of text" "yet more text"))
</pre></td></tr></table></P><P>

код должен сделать следующее:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq kill-ring-yank-pointer (cdr kill-ring))
</pre></td></tr></table></P><P>

В качестве результата <CODE>kill-ring-yank-pointer</CODE> будет выглядеть
следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>kill-ring-yank-pointer
     => ("a different piece of text" "yet more text"))
</pre></td></tr></table></P><P>

Настоящее выражение <CODE>setq</CODE> использует функцию <CODE>nthcdr</CODE> для
выполнения данной работы.
</P><P>

Как мы видели ранее (see section <A HREF="elisp-intro-ru_9.html#SEC101">7.3 <CODE>nthcdr</CODE></A>), функция <CODE>nthcdr</CODE> работает
путем последовательного выполнения CDR для списка --- она
берет CDR от CDR от CDR <small>...</small>
</P><P>

Два следующих выражения дают одинаковый результат:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq kill-ring-yank-pointer (cdr kill-ring))

(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
</pre></td></tr></table></P><P>

Однако в функции <CODE>rotate-yank-pointer</CODE>, первым аргументом для
<CODE>nthcdr</CODE> является сложное выражение, с некоторым количеством
арифметических операций внутри него:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(% (+ arg
      (- length
         (length kill-ring-yank-pointer)))
   length)
</pre></td></tr></table></P><P>

Как обычно, нам нужно сначала посмотреть в наиболее глубоко
вставленное выражение, а затем подняться к охватывающим выражениям.
</P><P>

Наиболее глубоко вложенным выражением является <CODE>(length
kill-ring-yank-pointer)</CODE>.  Это выражение определяет длину текущего
значения <CODE>kill-ring-yank-pointer</CODE>.  (Помните, что
<CODE>kill-ring-yank-pointer</CODE> --- имя переменной, чьим значением
является список).
</P><P>

Определение длины находится внутри выражения:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(- length (length kill-ring-yank-pointer))
</pre></td></tr></table></P><P>

В этом выражении, первое употребление <CODE>length</CODE> относится к
переменной, которой присвоено значение длины списка удалений в
выражении <CODE>let</CODE> в начале функции.  (Кто-то может думать, что
функция была бы более понятной, если бы переменная <CODE>length</CODE> была
бы названа <CODE>length-of-kill-ring</CODE>; но если вы посмотрите в текст
функции, то увидите, что она настолько короткая, что именование
переменной <CODE>length</CODE> не доставляет беспокойства, до тех пор пока
вы разбиваете функции на небольшие кусочки, как мы это делаем тут).
</P><P>

Так что строка <CODE>(- length (length kill-ring-yank-pointer))</CODE>
возвращает разницу между длиной списка удалений и длиной списка на
который указывает <CODE>kill-ring-yank-pointer</CODE>.
</P><P>

Для того чтобы понять, как все это работает в функции
<CODE>rotate-yank-pointer</CODE>, давайте рассмотрим случай, когда
<CODE>kill-ring-yank-pointer</CODE> указывает на первый элемент списка
удалений как и <CODE>kill-ring</CODE> и посмотрим что произойдет, если
функкцию <CODE>rotate-yank-pointer</CODE> вызвали с аргументом 1.
</P><P>

В этом случае переменная <CODE>length</CODE> и значение выражения
<CODE>(length kill-ring-yank-pointer)</CODE> будут тем же самым так как
переменная <CODE>length</CODE> это длина списка удалений, а
<CODE>kill-ring-yank-pointer</CODE> указывает на весь список удалений.
Следовательно значение
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(- length (length kill-ring-yank-pointer))
</pre></td></tr></table></P><P>

будет равно нулю.  Так как значение <CODE>arg</CODE> будет 1 это значит, что
значение всего выражения
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(+ arg (- length (length kill-ring-yank-pointer)))
</pre></td></tr></table></P><P>

будет 1.
</P><P>

Таким образом первый аргумент функции <CODE>nthcdr</CODE> будет результатом
выражения
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(% 1 length)
</pre></td></tr></table></P><P>

<A NAME="Вычисление остатка"></A>
<HR SIZE="6">
<A NAME="SEC219"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC218"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC220"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC217"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> Функция вычисления остатка <CODE>%</CODE> </H4>
<!--docid::SEC219::-->
<P>

Для того чтобы понять выражение <CODE>(% 1 length)</CODE>, нам надо
познакомиться с функцией <CODE>%</CODE>.  Согласно ее документации (которую я
вызвал нажав <KBD>C-h f <KBD>%</KBD> <KBD>RET</KBD></KBD>) функция <CODE>%</CODE> возвращает
остаток от деления своего первого аргумента на второй.  Например остаток
от деления 5 на 2 равен 1.  (2 входит в 5 дважды с остатком 1)
</P><P>

Для людей, которые далеки от математики, это может даже казаться
удивительным, мы делим меньшее число на большее и получаем остаток.  В
только что рассмотренном примере мы разделили 5 на 2.  А что получится,
если мы разделим 2 на 5?  Если вы умеете пользоваться дробями ответ ясен
2/5 или .4; но если мы можем использовать только целые числа, результат
будет иным.  Ясно что 5 может входить в 2 ноль раз, но чему равен
остаток?  Для этого рассмотрим несколько простых примеров:
</P><P>

<UL>
<LI>
5 разделить на 5 равно 1 остаток 0; 
<P>

<LI>
6 разделить на 5 равно 1 остаток 1; 
<P>

<LI>
7 разделить на 5 равно 1 остаток 2; 
<P>

<LI>
Аналогично, 10 разделить на 5 равно 2 остаток 0;
<P>

<LI>
11 разделить на 5 равно 2 остаток 1;
<P>

<LI>
12 разделить на 5 равно 2 остаток 2;
</UL>
<P>

Таким образом можно догадаться, что
</P><P>

<UL>
<LI>
ноль разделить на 5 будет ноль с остатком ноль;
<P>

<LI>
1 разделить на 5 будет ноль с остатком 1; 
<P>

<LI>
2 разделить на 5 будет ноль с остатком 2; 
</UL>
<P>

и так далее.
</P><P>

Так в этом коде, если значение <CODE>length</CODE> равно 5, тогда результат
вычисления
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(% 1 5)
</pre></td></tr></table></P><P>

равен 1.  (Я все-таки проверил это, расположив курсор после выражения и
нажал <KBD>C-x C-e</KBD>.  В эхо-области появилось 1.)
</P><P>

<A NAME="rotate-yk-ptr остаток"></A>
<HR SIZE="6">
<A NAME="SEC220"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC219"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC221"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC217"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> Использование <CODE>%</CODE> в <CODE>rotate-yank-pointer</CODE> </H4>
<!--docid::SEC220::-->
<P>

Когда <CODE>kill-ring-yank-pointer</CODE> указывает на начало списка удалений
и в функцию <CODE>rotate-yank-pointer</CODE> передана 1, выражение <CODE>%</CODE>
возвращает 1:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(- length (length kill-ring-yank-pointer))
     => 0
</pre></td></tr></table></P><P>

следовательно,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(+ arg (- length (length kill-ring-yank-pointer)))
     => 1
</pre></td></tr></table></P><P>

и наконец:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(% (+ arg (- length (length kill-ring-yank-pointer)))
   length)
     => 1
</pre></td></tr></table></P><P>

независимо от того чему равно значение <CODE>length</CODE>.
</P><P>

В результате этого выражение <CODE>setq kill-ring-yank-pointer</CODE> можно
привести к виду:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
</pre></td></tr></table></P><P>

Что здесь происходит легко понять, вместо того чтобы указывать на первый
элемент списка удалений,  <CODE>kill-ring-yank-pointer</CODE> теперь будет
указывать на второй элемент.
</P><P>

Ясно, что если в функцию <CODE>rotate-yank-pointer</CODE> вызвали с аргументом
2, тогда <CODE>kill-ring-yank-pointer</CODE> будет равен <CODE>(nthcdr 2
kill-ring)</CODE>; и так далее для различных значений аргумента.
</P><P>

Аналогично, если <CODE>kill-ring-yank-pointer</CODE> вначале указывал на
второй элемент списка удалений, его длина короче чем длина всего списка
удалений на 1, а так как вычисление остатка основано на выражении
<CODE>(% (+ arg 1) length)</CODE>, то <CODE>kill-ring-yank-pointer</CODE> будет
теперь указывать на третий элемент списка удалений, если функцию
<CODE>rotate-yank-pointer</CODE> вызвали со значением 1.
</P><P>

<A NAME="посл элмт kill-rng-yk-ptr"></A>
<HR SIZE="6">
<A NAME="SEC221"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC220"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC217"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> Указатель на последний элемент </H4>
<!--docid::SEC221::-->
<P>

Последний важный вопрос, что произойдет, если
<CODE>kill-ring-yank-pointer</CODE> указывает на <EM>последний</EM> элемент
списка удалений?  Вызов функции <CODE>rotate-yank-pointer</CODE> ни к чему не
приведет?  Неправильно!  Произойдет очень интересная вещь.
<CODE>kill-ring-yank-pointer</CODE> теперь будет снова указывать на начало
списка удалений.
</P><P>

Давайте попытаемся это понять, анализируя код, если например длина
списка удалений равна 5 и функцию <CODE>rotate-yank-pointer</CODE> вызвали с
аргументом 1.  Когда <CODE>kill-ring-yank-pointer</CODE> указывает на
последний элемент списка удалений его длина равна 1.  Код выглядит
следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(% (+ arg (- length (length kill-ring-yank-pointer))) length)
</pre></td></tr></table></P><P>

Если вместо переменных подставить их числовые значения, выражение будет
выглядеть следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(% (+ 1 (- 5 1)) 5)
</pre></td></tr></table></P><P>

Это выражение можно вычислить начиная с самого внутреннего списка и
продвигаясь в внешнему: Значение <CODE>(- 5 1)</CODE> равно 4; сумма <CODE>(+
1 4)</CODE> равна 5; и остаток от деления 5 на 5 равен нулю.  По этому в теле
функции <CODE>rotate-yank-pointer</CODE> будет вычислено следующее выражение
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq kill-ring-yank-pointer (nthcdr 0 kill-ring))
</pre></td></tr></table></P><P>

в результате чего <CODE>kill-ring-yank-pointer</CODE> будет указывать на
начало списка удалений.
</P><P>

Теперь понятно, что последовательные вызовы <CODE>rotate-yank-pointer</CODE>
перемещают <CODE>kill-ring-yank-pointer</CODE> от элемента к элементу в списке
удалений до тех пор пока <CODE>kill-ring-yank-pointer</CODE> не достигнет
конца списка; после этого происходит прыжок в начало.  Именно поэтому
список удалений называют кольцом (kill ring), так как постоянно
происходит перемещение от конца к началу, как будто у этого списка не
конца!  (У кольца нет конца!)
</P><P>

<A NAME="yank"></A>
<HR SIZE="6">
<A NAME="SEC222"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC221"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC223"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC225"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> B.2 <CODE>yank</CODE> </H2>
<!--docid::SEC222::-->
<P>

После того как мы изучили функцию <CODE>rotate-yank-pointer</CODE> код функции
<CODE>yank</CODE> будет нам легко понятен.  В нем только одна сложная часть,
когда происходит обработка аргумента для передачи в функцию
<CODE>rotate-yank-pointer</CODE>.
</P><P>

The code looks like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun yank (&#38;optional arg)
  "Вставка последнего удаленного текста.
С аргументом C-U, то же самое только точка в начале 
(а метка в конце).  С аргументом n, вставка  n-того 
недавно удаленного текста.
Смотри также команду \\[yank-pop]."

  (interactive "*P")
  (rotate-yank-pointer (if (listp arg) 0
                         (if (eq arg '-) -1
                           (1- arg))))
  (push-mark (point))
  (insert (car kill-ring-yank-pointer))
  (if (consp arg)
      (exchange-point-and-mark)))
</pre></td></tr></table></P><P>

С первого взгляда мы уже можем понять что происходит в последний строках
функции.  Ставится метка; затем вставляется первый элемент (CAR)
<CODE>kill-ring-yank-pointer</CODE>; и после этого, если в функцию передали
как аргумент <CODE>cons</CODE> точка и метка меняются местами, так что курсор
будет в начале вставленного текста, а метка в конце, а не наоборот.  Все
это обьясняется в документации к функции.  Сама функция интерактивная с
<CODE>"*P"</CODE>.  Это означает, что она не работает для буферов
только-для-чтения, и в функцию передается необработанный префикс
аргумент.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC223">Передача аргумента</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Передаем аргумент в <CODE>rotate-yank-pointer</CODE>.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp-intro-ru_22.html#SEC224">Передаем отрицательный аргумент</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="аргумент rotate-yk-ptr"></A>
<HR SIZE="6">
<A NAME="SEC223"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC224"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC225"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> Передача аргумента </H4>
<!--docid::SEC223::-->
<P>

Самая сложная часть функции <CODE>yank</CODE> это там, где происходит
обработка аргумента для передачи в функцию <CODE>rotate-yank-pointer</CODE>.
К счастью эта часть не так сложна, как кажется на первый взгляд.
</P><P>

В результате обработки аргумента одним или двумя выражениями <CODE>if</CODE>
получается число, которое и передается в функцию
<CODE>rotate-yank-pointer</CODE>.
</P><P>

Если снабдить код комментариями и отформатировать его для
удобочитаемости, то получиться следующее:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if (listp arg)                         ; if-часть
    0                                   ; then-часть
  (if (eq arg '-)                       ; else-часть, внутреннее if
      -1                                ; внутреннее if's then-часть
    (1- arg))))                         ; внутреннее if's else-часть
</pre></td></tr></table></P><P>

Этот код состоит из двух выражений <CODE>if</CODE>, одна из которых является
else-частью другого.
</P><P>

Первое или внешнее выражение <CODE>if</CODE> проверяет, является ли аргумент
переданный в функцию <CODE>yank</CODE> списком.  Кажется немного странным, но
это будет истиной, если функция <CODE>yank</CODE> вызвана без аргумента, так
как тогда аргументу будет присвоено значение <CODE>nil</CODE>, а вычисление
выражения <CODE>(listp nil)</CODE> вернет истину!  Так, что, если в функцию
<CODE>yank</CODE> не передали аргумента, функцию <CODE>rotate-yank-pointer</CODE>
вызываемую внутри <CODE>yank</CODE> будет передан ноль.  Это значит, что
указатель не будет перемещатся и будет вставлен первый элемент на
который указывает <CODE>kill-ring-yank-pointer</CODE>, что мы и ожидали.
Аналогично, если аргумент функции <CODE>yank</CODE> был <KBD>C-u</KBD>, это снова
будет считаться списком, и опять при вызове функции
<CODE>rotate-yank-pointer</CODE> ей будет передан ноль.  (<KBD>C-u</KBD> производит
необработанный префикс-аргумент <CODE>(4)</CODE>, то есть список, состоящий из
одного элемента.)  В тоже время, в конце функции этот аргумент будет
считаться как <CODE>cons</CODE>, так что метка будет расположена в конце, а
точка в начале вставленного текста.  (Именно для этого и предназначен
аргумент <CODE>P</CODE> к <CODE>interactive</CODE>.)
</P><P>

then-часть внешнего выражения <CODE>if</CODE> обрабатывает случай, когда в
функцию не передан аргумент или когда передано <KBD>C-u</KBD>.  else-часть
обрабатывает другую ситуацию.  else-часть сама это другое выражение
<CODE>if</CODE>.
</P><P>

Внутреннее выражение <CODE>if</CODE> проверяет равен ли аргумент знаку минус.
(Это можно сделать, нажав одновременно клавиши  <KBD>META</KBD> и <KBD>-</KBD> или
нажать клавишу <KBD>ESC</KBD>, а потом <KBD>-</KBD>).  В этом случае в функцию
<CODE>rotate-yank-pointer</CODE> будет передан как аргумент  <KBD>-1</KBD>.  Это
переместит  <CODE>kill-ring-yank-pointer</CODE> в обратном направлении, что мы
и хотели.
</P><P>

Если проверка-истина-ложь внутреннего выражения <CODE>if</CODE> вернет ложь
(то есть, если аргумент не знак минус), в этом случае будет вычислятся
else-часть выражения.  Это выражение <CODE>(1- arg)</CODE>.  Это произойдет
только в том случае, когда аргумент или положительное число или
отрицательное число (а не только знак минус).  Выражение <CODE>(1- arg)</CODE>
всего лишь уменьшает <CODE>arg</CODE> на единицу и возвращает его.  (Функция
<CODE>-1</CODE>) вычитает единицу из своего аргумента.)  Это означает, что
если аргумент к функции <CODE>rotate-yank-pointer</CODE> равен 1 он будет
уменьшен до нуля то есть будет вставлен первый элемент на который
указывает <CODE>kill-ring-yank-pointer</CODE>, то есть то что мы и ожидали.
</P><P>

<A NAME="отрицательный аргумент rotate-yk-ptr"></A>
<HR SIZE="6">
<A NAME="SEC224"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC223"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC225"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC216"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC225"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> Передаем отрицательный аргумент </H4>
<!--docid::SEC224::-->
<P>

Последний вопрос на который мы еще не ответили, что произойдет если в
функцию остатка <CODE>%</CODE>, или в функцию <CODE>nthcdr</CODE> будет передан
отрицательный аргумент?  
</P><P>

Ответ можно найти проведя небольшой эксперимент.  После вычисления
<CODE>(% -1 5)</CODE> вернется отрицательное число; и если функцию
<CODE>nthcdr</CODE> вызвать с отрицательным числом она вернет то же самое
значение как будто бы была вызвана с аргументом 0.  Это можно проверить
вычислив следующие выражения.
</P><P>

Здесь <SAMP>`=>'</SAMP> указывает на результат вычисления вышестоящего
выражения.  Вы может сделать это как обычно расположив курсор после
выражения и нажав <KBD>C-x C-e</KBD> (<CODE>eval-last-sexp</CODE>), конечно если вы
читаете этот документ в Инфо не выходя из GNU Emacs.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(% -1 5)
     => -1

(setq animals '(cats dogs elephants))
     => (cats dogs elephants)

(nthcdr 1 animals)
     => (dogs elephants)

(nthcdr 0 animals)
     => (cats dogs elephants)

(nthcdr -1 animals)
     => (cats dogs elephants)
</pre></td></tr></table></P><P>

Так что если в функцию <CODE>yank</CODE> было передано отрицательное число или
знак минус, то указатель <CODE>kill-ring-yank-point</CODE> циклически
перемещается в обратном направлении до конца списка.  Затем он остается
там, в отличии от других случаев, когда он перемещается от конца списка
к началу.  Это очень разумно.
</P><P>

<A NAME="yank-pop"></A>
<HR SIZE="6">
<A NAME="SEC225"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC224"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_23.html#SEC226"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_23.html#SEC226"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> B.3 <CODE>yank-pop</CODE> </H2>
<!--docid::SEC225::-->
<P>

После того, как мы изучили функцию <CODE>yank</CODE> понять функцию
<CODE>yank-pop</CODE> станет очень легко.  Если пропустить документацию для
сохранения места ее код выглядит следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun yank-pop (arg)
  (interactive "*p")
  (if (not (eq last-command 'yank))
      (error "Предыдущая команда не yank"))
  (setq this-command 'yank)
  (let ((before (&#60; (point) (mark))))
    (delete-region (point) (mark))
    (rotate-yank-pointer arg)
    (set-mark (point))
    (insert (car kill-ring-yank-pointer))
    (if before (exchange-point-and-mark))))
</pre></td></tr></table></P><P>

Видно, что это интерактивная функция, аргумент в <CODE>interactive</CODE>
равен <SAMP>`p'</SAMP>, значит в функцию будет передан обработанный префикс
аргумент.  Команду можно использовать только, если предыдущая команда
была <CODE>yank</CODE>; в противном случае печатается сообщение об ошибке.
Эта проверка использует переменную <CODE>last-command</CODE>, которую мы уже
обсуждали. (See section <A HREF="elisp-intro-ru_10.html#SEC118">8.5 <CODE>copy-region-as-kill</CODE></A>.)
</P><P>

В выражении <CODE>let</CODE> переменной <CODE>before</CODE> присваивается или истина
или ложь в зависимости от того была ли расположена точка перед меткой
или за ней, после этого удаляется область расположенная между точкой и
меткой.  Это как раз та область текста, которая была вставлена
предыдущей командой yank и именно этот текст мы сейчас заменим.  Затем
указатель <CODE>kill-ring-yank-pointer</CODE> перемещается так чтобы мы заново
не вставили предыдущий вставленный текст.  Ставится метка.  Затем
вставляется текст на который указывает сейчас
<CODE>kill-ring-yank-pointer</CODE>, это перемещает точку в конец нового
вставленного текста.  Если до этого точка была расположена до метки,
тогда точка и метка меняются местами, чтобы все было как раньше.  Вот
собственно и все что происходит в этой функции!
</P><P>

<A NAME="Полный график"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_22.html#SEC222"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_23.html#SEC226"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_24.html#SEC243">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp-intro-ru_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
on <I>March, 10  2004</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">_uacct = "UA-78697-3"; urchinTracker(); </script></body>
</HTML>
