<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Сборка и тестирование программ</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_27.html">previous</A>, <A HREF="emacs_29.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC311" HREF="emacs_toc.html#TOC311">Сборка и тестирование программ</A></H1>
<P>
<A NAME="IDX1552"></A>
<A NAME="IDX1553"></A>
<A NAME="IDX1554"></A>


<P>
  В предыдущей главе обсуждались команды Emacs, полезные для внесения
изменений в программы.  Эта глава имеет дело с командами, которые
помогают в обширном процессе разработки и сопровождения программ.




<H2><A NAME="SEC312" HREF="emacs_toc.html#TOC312">Запуск компиляторов в Emacs</A></H2>
<P>
<A NAME="IDX1555"></A>
<A NAME="IDX1556"></A>
<A NAME="IDX1557"></A>
<A NAME="IDX1558"></A>
<A NAME="IDX1559"></A>


<P>
  Emacs может запускать компиляторы для недиалоговых языков, таких как
Си и Фортран, как подчиненные процессы, подавая протокол ошибок в буфер
Emacs.  Он также может произвести разбор сообщений об ошибках и показать
вам строки исходных текстов, где произошла ошибка.


<DL COMPACT>

<DT><KBD>M-x compile</KBD>
<DD>
Асинхронно запускает компилятор под управлением Emacs, выводя сообщения
об ошибках в буфер <TT>`*compilation*'</TT>.
<DT><KBD>M-x grep</KBD>
<DD>
Асинхронно запускает @command{grep} под управлением Emacs, перечисляя
совпавшие строки в буфере <TT>`*grep*'</TT>.
<DT><KBD>M-x grep-find</KBD>
<DD>
Запускает @command{grep} через @command{find} с предоставленными
пользователем аргументами, направляя вывод в буфер <TT>`*grep*'</TT>.
<DT><KBD>M-x kill-compilation</KBD>
<DD>
<DT><KBD>M-x kill-grep</KBD>
<DD>
Уничтожает работающие подпроцессы компиляции или @command{grep}.
</DL>

<P>
<A NAME="IDX1560"></A>
  Чтобы запустить @command{make} или другую команду компиляции,
выполните <KBD>M-x compile</KBD>.  Эта команда считывает командную строку
оболочки, используя минибуфер, и затем выполняет эту командную строку в
подчиненной оболочке, помещая вывод в буфер с именем
<TT>`*compilation*'</TT>.  В качестве рабочего каталога для выполнения этой
команды используется каталог по умолчанию текущего буфера, следовательно,
компиляция производится в этом каталоге.


<P>
<A NAME="IDX1561"></A>
  Когда считывается командная строка оболочки, появляется минибуфер,
содержащий командную строку по умолчанию; это команда, которую вы
использовали при последнем применении <KBD>M-x compile</KBD>.  Если вы
наберете просто <KBD>RET</KBD>, то снова будет использована та же самая
командная строка.  Для первой <KBD>M-x compile</KBD> по умолчанию
используется <SAMP>`make -k'</SAMP>. Значение по умолчанию берется из переменной
<CODE>compile-command</CODE>; если соответствующая команда компиляции для
файла является чем-то другим, не <SAMP>`make -k'</SAMP>, то может быть полезно
иметь для этого файла локальное значение <CODE>compile-command</CODE>
(see section <A HREF="emacs_36.html#SEC451">Локальные переменные в файлах</A>).


<P>
  Запуск компиляции показывает буфер <TT>`*compilation*'</TT> в другом окне,
но не выбирает его.  Строка режима этого буфера сообщает вам,
закончилась ли компиляция, при помощи слов <SAMP>`run'</SAMP> или <SAMP>`exit'</SAMP> в
круглых скобках.  Вы не обязаны держать этот буфер видимым, компиляция
продолжается в любом случае.  Пока компиляция продолжается, в строках
режима всех буферов появляется слово <SAMP>`Compiling'</SAMP>.  Если это слово
исчезает, компиляция закончена.


<P>
  Если вы хотите видеть протокол компиляции по мере его появления,
переключитесь в буфер <SAMP>`*compilation*'</SAMP> и переместите точку в его
конец.  Когда точка расположена в конце, новый вывод процесса компиляции
вставляется перед точкой, и она остается в конце.  Если точка не
находится в конце этого буфера, она остается на своем месте, тогда как
дальнейший вывод компиляции добавляется в конец буфера.


<P>
<A NAME="IDX1562"></A>
  Если вы установите переменную <CODE>compilation-scroll-output</CODE> в
значение, отличное от <CODE>nil</CODE>, то буфер компиляции всегда
прокручивается, чтобы показывать вывод по мере его появления.


<P>
<A NAME="IDX1563"></A>
  Чтобы прекратить процесс компиляции, выполните команду <CODE>M-x
kill-compilation</CODE>.  Когда процесс компиляции будет прерван, строка
режима буфера <TT>`*compilation*'</TT> изменится, и в ней будет слово
<SAMP>`signal'</SAMP> вместо <SAMP>`run'</SAMP>.  Запуск новой компиляции также
уничтожает любую работающую компиляцию, так как в одно время может
существовать только одна.  Однако <KBD>M-x compile</KBD> требует
подтверждения перед фактическим уничтожением уже запущенной компиляции.




<H2><A NAME="SEC313" HREF="emacs_toc.html#TOC313">Поиск с Grep под Emacs</A></H2>

<P>
<A NAME="IDX1564"></A>
  Точно так же, как вы запускаете из Emacs компилятор, и затем
обращаетесь к строкам, где были ошибки компиляции, вы можете запустить
@command{grep} и затем обратиться к строкам, где были найдены
совпадения.  Это работает путем интерпретации сообщений о совпадениях от
@command{grep} как сообщений об "ошибках".


<P>
  Чтобы сделать это, наберите <KBD>M-x grep</KBD> и введите командную строку,
указывающую, как нужно запускать @command{grep}.  Используйте те же
аргументы, которые вы дали бы @command{grep} при обычном запуске:
регулярное выражение в формате @command{grep} (обычно в одиночных
кавычках, чтобы отменить особый смысл специальных символов оболочки), за
которым следуют имена файлов, в которых можно использовать шаблоны.
Вывод из @command{grep} идет в буфер <TT>`*compilation*'</TT>.  Вы можете
обратиться к совпавшимстрокам при помощи <KBD>C-x `</KBD> и <KBD>RET</KBD>, как к
ошибкам компиляции.


<P>
  Если вы зададите для <KBD>M-x grep</KBD> префиксный аргумент, она найдет в
окрестности точки тег (see section <A HREF="emacs_27.html#SEC276">Таблицы тегов</A>) и поместит его в команду
<CODE>grep</CODE> по умолчанию.


<P>
<A NAME="IDX1565"></A>
  Команда <KBD>M-x grep-find</KBD> похожа на <KBD>M-x grep</KBD>, но предлагает
другую командную строку по умолчанию -- строку, которая запускает
@command{find} и @command{grep}, так что поиск производится в каждом
файле дерева каталогов.  Смотрите также команду <CODE>find-grep-dired</CODE>,
section <A HREF="emacs_33.html#SEC386">Dired и @command{find}</A>.




<H2><A NAME="SEC314" HREF="emacs_toc.html#TOC314">Режим Compilation</A></H2>

<P>
<A NAME="IDX1566"></A>
<A NAME="IDX1567"></A>
<A NAME="IDX1568"></A>
  В буфере <TT>`*compilation*'</TT> используется особый основной режим,
режим Compilation, основная цель которого -- предоставить удобный
способ просмотреть строку исходного текста, где случилась ошибка.


<DL COMPACT>

<DT><KBD>C-x `</KBD>
<DD>
Обратиться к позиции следующего сообщения об ошибке компиляции или
совпадения, найденного @command{grep}.
<DT><KBD><KBD>RET</KBD></KBD>
<DD>
Обратиться к позиции сообщения об ошибке, в которой находится точка.
Эта команда применяется в буфере компиляции.
<DT><KBD>Mouse-2</KBD>
<DD>
Обратиться к позиции сообщения об ошибке, на котором вы щелкнули.
</DL>

<P>
<A NAME="IDX1569"></A>
<A NAME="IDX1570"></A>
  Вы можете обратиться к исходному тексту для любого конкретного
сообщения об ошибке, переместив точку в буфере <TT>`*compilation*'</TT> к
этому сообщению и нажав <KBD>RET</KBD> (<CODE>compile-goto-error</CODE>).  Или
щелкните на этом сообщении об ошибке <KBD>Mouse-2</KBD>; тогда вам не
обязательно сначала переключаться в буфер <TT>`*compilation*'</TT>.


<P>
  Чтобы последовательно сделать грамматический разбор сообщений
компилятора об ошибках, набирайте <KBD>C-x `</KBD> (<CODE>next-error</CODE>).
Знак, стоящий после <KBD>C-x</KBD> -- это обратная кавычка или "акцент
грав", а не обычная одиночная кавычка.  Эта команда доступна во всех
буферах, а не только в буфере <TT>`*compilation*'</TT>; она показывает
следующее сообщение об ошибке вверху одного окна и текст, в котором
находится эта ошибка, в другом окне.


<P>
  Когда <KBD>C-x `</KBD> используется первый раз после начала компиляции, она
передвигается к положению первой ошибки.  Последующие использования
<KBD>C-x `</KBD> продвигают вниз к следующим ошибкам.  Если вы обратились к
файлу по какому-то сообщению об ошибке с помощью <KBD>RET</KBD> или
<KBD>Mouse-2</KBD>, последующие команды <KBD>C-x `</KBD> продвигаются с этого
места.  Когда <KBD>C-x `</KBD> доходит до конца буфера и не может найти
больше сообщений, она завершается неуспехом и Emacs выдает ошибку.


<P>
  <KBD>C-u C-x `</KBD> начинает просмотр буфера <TT>`*compilation*'</TT> сначала.
Это один из способов еще раз обработать один и тот же набор ошибок.


<P>
  Режим Compilation также переопределяет ключи <KBD>SPC</KBD> и <KBD>DEL</KBD> для
прокрутки по целому экрану, а <KBD>M-n</KBD> и <KBD>M-p</KBD> -- для перемещения
к следующему или предыдущему сообщению об ошибке.  Вы также можете
использовать <KBD>M-{</KBD> и <KBD>M-}</KBD> для перемещения вверх и вниз к
сообщению об ошибке для другого исходного файла.


<P>
  Возможности режима Compilation также доступны во второстепенном режиме,
называемом Compilation Minor.  Он позволяет вам разбирать сообщения об
ошибках в любом буфере, а не только в обычном буфере для вывода протокола
компиляции.  Для включения этого второстепенного режима наберите
<KBD>M-x compilation-minor-mode</KBD>.  Это определит ключи <KBD>RET</KBD> и
<KBD>Mouse-2</KBD> как в основном режиме Compilation.


<P>
  Второстепенный режим Compilation работает в любом буфере, если
содержимое этого буфера имеет понятный ему формат.  В буфере Rlogin
(see section <A HREF="emacs_35.html#SEC426">Оболочка на удаленной машине</A>), второстепенный режим Compilation
автоматически получает удаленные исходные файлы по FTP (see section <A HREF="emacs_19.html#SEC109">Имена файлов</A>).




<H2><A NAME="SEC315" HREF="emacs_toc.html#TOC315">Подоболочки для компиляции</A></H2>

<P>
  Emacs использует для команды компиляции оболочку, но ей указывается,
что она должна быть неинтерактивной.  В частности, это означает, что
оболочка начинается без подсказки.  Если вы обнаружите, что буфер
<TT>`*compilation*'</TT> уродуют ваши обычные подсказки оболочки, то это
значит, что вы сделали ошибку в вашем файле инициализации оболочки,
установив подсказку, не учитывая условий, когда она не должна
появляться.  (Файл инициализации может называться <TT>`.bashrc'</TT>,
<TT>`.profile'</TT>, <TT>`.cshrc'</TT>, <TT>`.shrc'</TT> или еще как-нибудь в
зависимости от используемой вами оболочки.)  Файл инициализации оболочки
должен устанавливать подсказку, только если подсказка уже есть.
Покажем, как это нужно делать в csh:



<PRE>
if ($?prompt) set prompt = ...
</PRE>

<P>
А так это делается в bash:



<PRE>
if [ "${PS1+set}" = set ]
then PS1=...
fi
</PRE>

<P>
  Могут быть и другие вещи, которые вы должны делать только в
интерактивной оболочке.  Для проверки условия интерактивного запуска вы
можете использовать такой же метод.


<P>
  "Операционная система" MS-DOS не поддерживает асинхронные
подпроцессы; чтобы как-то обойти этот недостаток, <KBD>M-x compile</KBD> в
MS-DOS запускает команду компиляции синхронно.  Как следствие, вы должны
дождаться завершения этой команды до того, как сможете сделать что-то в
Emacs.  See section <A HREF="emacs_40.html#SEC513">Emacs и MS-DOS</A>.




<H2><A NAME="SEC316" HREF="emacs_toc.html#TOC316">Запуск отладчиков в Emacs</A></H2>
<P>
<A NAME="IDX1571"></A>
<A NAME="IDX1572"></A>
<A NAME="IDX1573"></A>
<A NAME="IDX1574"></A>
<A NAME="IDX1575"></A>
<A NAME="IDX1576"></A>
<A NAME="IDX1577"></A>
<A NAME="IDX1578"></A>
<A NAME="IDX1579"></A>


<P>
  Библиотека GUD (Grand Unified Debugger@transnote{Единый отладчик.})
предоставляет интерфейс к различным символьным отладчикам из Emacs.  Мы
рекомендуем отладчик GDB, который распространяется свободно, но вы также
можете запускать DBX, SDB или XDB, если они у вас есть.  GUD может также
служить интерфейсом к отладочному режиму Perl, отладчику Python PDB и
JDB, отладчику Java.




<H3><A NAME="SEC317" HREF="emacs_toc.html#TOC317">Запуск GUD</A></H3>

<P>
  Существует несколько команд для запуска отладчика, каждая
соответствует конкретной программе-отладчику.


<DL COMPACT>

<DT><KBD>M-x gdb <KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX1580"></A>
Запускает GDB как подпроцесс Emacs.  Эта команда создает буфер для ввода
и вывода GDB и переключает в него.  Если буфер GDB уже существует, она
просто переключает в этот буфер.

<DT><KBD>M-x dbx <KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX1581"></A>
Аналогично, но запускает DBX вместо GDB.

<DT><KBD>M-x xdb <KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX1582"></A>
<A NAME="IDX1583"></A>
Аналогично, но запускает XDB, а не GDB.  Используйте переменную
<CODE>gud-xdb-directories</CODE> для задания каталогов поиска исходных файлов.

<DT><KBD>M-x sdb <KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX1584"></A>
Аналогично, но запускает SDB, а не GDB.

  Некоторые версии SDB не называют в своих сообщениях имена исходных
файлов.  Когда вы используйте их, у вас должна быть создана правильная
таблица тегов (see section <A HREF="emacs_27.html#SEC276">Таблицы тегов</A>), чтобы GUD мог найти функции в исходных
файлах.  Если вы не обращались к таблице тегов или таблица тегов не
содержит одну из функций, вы получите сообщение, говорящее <SAMP>`The sdb
support requires a valid tags table to work'</SAMP>.@transnote{Для работы
поддержки sdb требуется правильная таблица тегов.}  Если это случилось,
создайте в рабочем каталоге правильную таблицу тегов и попробуйте снова.

<DT><KBD>M-x perldb <KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX1585"></A>
Запускает интерпретатор Perl в отладочном режиме для отладки
<VAR>файла</VAR>, программы на Perl.

<DT><KBD>M-x jdb <KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX1586"></A>
Запускает для отладки <VAR>файла</VAR> отладчик Java.

<DT><KBD>M-x pdb <KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX1587"></A>
Запускает для отладки <VAR>файла</VAR> отладчик Python.
</DL>

<P>
  Каждая из этих команд принимает один аргумент: командную строку для
вызова отладчика.  В простейшем случае, задайте просто имя исполняемого
файла, который вы хотите отлаживать.  Вы также можете использовать
ключи, поддерживаемые вашим отладчиком.  Однако шаблоны и переменные
оболочки недопустимы.  GUD предполагает, что первый аргумент, не
начинающийся с <SAMP>`-'</SAMP>, является именем исполняемого файла.


<P>
  Emacs может запустить только один отладочный процесс в одно время.




<H3><A NAME="SEC318" HREF="emacs_toc.html#TOC318">Управление отладчиком</A></H3>

<P>
  Когда вы запустили отладчик с помощью GUD, он использует буфер Emacs
для обычного ввода и вывода.  Этот буфер называется буфером GUD.
Отладчик показывает строки исходных файлов, обращаясь к ним в буферах
Emacs.  Стрелка (<SAMP>`=&#62;'</SAMP>) в одном из буферов указывает на исполняемую
в данный момент строку.  Перемещение точки в буфере не изменяет
положения стрелки.


<P>
  Вы можете в любое время начать редактировать исходные файлы в тех
буферах, которые их показывают.  Стрелка не является частью текста
файла; она появляется лишь на экране.  Если вы действительно изменяете
исходный файл, помните, что удаление или вставка строк собьет положение
стрелки; GUD не может определить, какая строка строка соответствовала
номеру строки в сообщении отладчика до вашего изменения.  Кроме того,
чтобы ваши изменения нашли отражение в таблицах отладчика, вам обычно
придется перекомпилировать и перезапустить программу.


<P>
  Если вы захотите, вы можете полностью управлять процессом отладчика
через его буфер, который использует вариант режима Shell.  Доступны все
обычные команды вашего отладчика, и вы можете использовать команды
истории режима Shell для их повторения.  See section <A HREF="emacs_35.html#SEC420">Режим Shell</A>.




<H3><A NAME="SEC319" HREF="emacs_toc.html#TOC319">Команды GUD</A></H3>

<P>
  Буфер диалога с GUD использует вариант режима Shell, так что вам
доступны команды этого режима (see section <A HREF="emacs_35.html#SEC420">Режим Shell</A>).  Режим GUD также
предоставляет команды для установки и сброса контрольных точек, для
выбора фреймов стека и для пошагового прохода по программе.  Эти команды
доступны как в буфере GUD, так и глобально, но с разными привязками.


<P>
  Команды управления контрольными точками обычно используются в буферах,
обращающихся к файлам, потому что они дают способ указать где поставить
или убрать контрольную точку.  Вот глобальные привязки для установки
контрольных точек:


<DL COMPACT>

<DT><KBD>C-x <KBD>SPC</KBD></KBD>
<DD>
<A NAME="IDX1588"></A>
Устанавливает контрольную точку в исходной строке, где находится точка.
</DL>

<P>
<A NAME="IDX1589"></A>
  Это другая специальная команда, предоставляемая GUD.  Ключи,
начинающиеся с <KBD>C-c</KBD>, доступны только в буфере диалога с GUD.
Привязки ключей, начинающиеся с <KBD>C-x C-a</KBD>, доступны и в буфере
диалога с GUD, и в исходных файлах.


<DL COMPACT>

<DT><KBD>C-c C-l</KBD>
<DD>
<A NAME="IDX1590"></A>
<DT><KBD>C-x C-a C-l</KBD>
<DD>
<A NAME="IDX1591"></A>
Отображает в другом окне последнюю строку, на которую появилась ссылка в
буфере GUD (то есть строку, указанную в последнем сообщении о позиции в
программе).  Это запускает команду <CODE>gud-refresh</CODE>.

<DT><KBD>C-c C-s</KBD>
<DD>
<A NAME="IDX1592"></A>
<DT><KBD>C-x C-a C-s</KBD>
<DD>
<A NAME="IDX1593"></A>
Исполняет одну строку кода (<CODE>gud-step</CODE>).  Если строка содержит
вызов функции, выполнение останавливается после входа в нее.

<DT><KBD>C-c C-n</KBD>
<DD>
<A NAME="IDX1594"></A>
<DT><KBD>C-x C-a C-n</KBD>
<DD>
<A NAME="IDX1595"></A>
Исполняет одну строку кода, проходя через вызовы функций без остановки
(<CODE>gud-next</CODE>).

<DT><KBD>C-c C-i</KBD>
<DD>
<A NAME="IDX1596"></A>
<DT><KBD>C-x C-a C-i</KBD>
<DD>
<A NAME="IDX1597"></A>
Исполняет одну машинную инструкцию (<CODE>gud-stepi</CODE>).

<DT><KBD>C-c C-r</KBD>
<DD>
<A NAME="IDX1598"></A>
<DT><KBD>C-x C-a C-r</KBD>
<DD>
<A NAME="IDX1599"></A>
Продолжает исполнение с неопределенной точкой останова.  Программа
продолжит работу до тех пор, пока не попадет на контрольную точку,
завершится или получит сигнал, проверяемый отладчиком (<CODE>gud-cont</CODE>).

<DT><KBD>C-c C-d</KBD>
<DD>
<A NAME="IDX1600"></A>
<DT><KBD>C-x C-a C-d</KBD>
<DD>
<A NAME="IDX1601"></A>
Удаляет контрольную точку (одну или несколько) в текущей строке
исходного текста, если они поставлены (<CODE>gud-remove</CODE>).  Если вы
вызовите эту команду в буфере диалога с GUD, она применяется к строке,
на который в последний раз остановилась программа.

<DT><KBD>C-c C-t</KBD>
<DD>
<A NAME="IDX1602"></A>
<DT><KBD>C-x C-a C-t</KBD>
<DD>
<A NAME="IDX1603"></A>
Устанавливает временную контрольную точку на текущей исходной строке,
если такая есть в данный момент.  Если вы вызовите эту команду в буфере
диалога с GUD, она применяется к строке, на которой программа
остановилась в последний раз.
</DL>

<P>
  Перечисленные выше команды относятся ко всем поддерживаемым
отладчикам.  Если вы пользуетесь GDB или DBX (некоторыми версиями),
доступны такие дополнительные команды:


<DL COMPACT>

<DT><KBD>C-c &#60;</KBD>
<DD>
<A NAME="IDX1604"></A>
<DT><KBD>C-x C-a &#60;</KBD>
<DD>
<A NAME="IDX1605"></A>
Выбирает следующий внешний фрейм стека (<CODE>gud-up</CODE>).  Это
эквивалентно команде <SAMP>`up'</SAMP>.

<DT><KBD>C-c &#62;</KBD>
<DD>
<A NAME="IDX1606"></A>
<DT><KBD>C-x C-a &#62;</KBD>
<DD>
<A NAME="IDX1607"></A>
Выбирает следующий внутренний фрейм стека (<CODE>gud-down</CODE>).  Это
эквивалентно команде <SAMP>`down'</SAMP>.
</DL>

<P>
  Если вы пользуетесь GDB, доступны следующие привязки:


<DL COMPACT>

<DT><KBD><KBD>TAB</KBD></KBD>
<DD>
<A NAME="IDX1608"></A>
<A NAME="IDX1609"></A>
Завершает имя символа (<CODE>gud-gdb-complete-command</CODE>).  Этот ключ
доступен только в буфере диалога с GUD и требует GDB версии 4.13 или
более поздней.

<DT><KBD>C-c C-f</KBD>
<DD>
<A NAME="IDX1610"></A>
<DT><KBD>C-x C-a C-f</KBD>
<DD>
<A NAME="IDX1611"></A>
Исполняет программу до тех пор, пока не произойдет возврат из
выбранного фрейма стека (или пока программа не остановится по другой
причине).
</DL>

<P>
  Эти команды интерпретируют числовой аргумент как счетчик повторений,
если это имеет смысл.


<P>
  Так как <KBD>TAB</KBD> служит командой завершения, вы не можете
использовать ее для набора знака табуляции в качестве ввода для
программы, которую вы отлаживаете в GDB.  Вместо этого, чтобы ввести
знак табуляции, набирайте <KBD>C-q <KBD>TAB</KBD></KBD>.




<H3><A NAME="SEC320" HREF="emacs_toc.html#TOC320">Настройка GUD</A></H3>

<P>
<A NAME="IDX1612"></A>
<A NAME="IDX1613"></A>
<A NAME="IDX1614"></A>
<A NAME="IDX1615"></A>
<A NAME="IDX1616"></A>
<A NAME="IDX1617"></A>
<A NAME="IDX1618"></A>
  Во время запуска GUD выполняет одну из следующих ловушек:
<CODE>gdb-mode-hook</CODE>, если вы пользуетесь GDB; <CODE>dbx-mode-hook</CODE>,
если вы пользуетесь DBX; <CODE>sdb-mode-hook</CODE>, если вы пользуетесь SDB;
<CODE>xdb-mode-hook</CODE>, если вы пользуетесь XDB; <CODE>perldb-mode-hook</CODE>
для отладочного режима Perl; <CODE>jdb-mode-hook</CODE> для PDB;
<CODE>jdb-mode-hook</CODE> для JDB.  Вы можете использовать эти ловушки для
определения ваших собственных привязок ключей для буфера диалога с
отладчиком.  See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.


<P>
  Вот удобный способ определить команду, которая посылает отладчику
некоторую командную строку и устанавливает для нее привязку в буфере
диалога с отладчиком:


<P>
<A NAME="IDX1619"></A>

<PRE>
(gud-def <VAR>функция</VAR> <VAR>командная-строка</VAR> <VAR>привязка</VAR> <VAR>док-строка</VAR>)
</PRE>

<P>
  Это определит команду с именем <VAR>функция</VAR>, которая посылает
процессу отладчика <VAR>командную-строку</VAR>, и даст ей строку описания
<VAR>док-строка</VAR>.  Вы можете использовать определенную таким образом
команду в любом буфере.  Если <VAR>привязка</VAR> не равна <CODE>nil</CODE>,
<CODE>gud-def</CODE> также привязывает эту команду к <KBD>C-c <VAR>привязка</VAR></KBD>
в режиме буфера GUD и к <KBD>C-x C-a <VAR>привязка</VAR></KBD> глобально.


<P>
  Командная строка может содержать определенные
<SAMP>`%'</SAMP>-последовательности, которые обозначают данные, подставляемые во
время вызова <VAR>функции</VAR>:


<DL COMPACT>

<DT><SAMP>`%f'</SAMP>
<DD>
Имя текущего исходного файла.  Если текущим является буфер GUD, то
"текущий исходный файл" -- это файл, в котором программа
остановилась.

<DT><SAMP>`%l'</SAMP>
<DD>
Номер текущей исходной строки.  Если текущим является буфер GUD, то
"текущая исходная строка" -- это строка, на которой остановилась
программа.

<DT><SAMP>`%e'</SAMP>
<DD>
Текст lvalue языка Си или выражения вызова функции, в котором или рядом
с которым находится точка.

<DT><SAMP>`%a'</SAMP>
<DD>
Текст шестнадцатиричного адреса, в котором или рядом с которым находится
точка.

<DT><SAMP>`%p'</SAMP>
<DD>
Числовой аргумент вызванной функции в виде десятичного числа.  Если эта
команда используется без числового аргумента, <SAMP>`%p'</SAMP> будет пустой
строкой.

Если вы не использовали <SAMP>`%p'</SAMP> в командной строке, определяемая вами
команда будет игнорировать любой числовой аргумент.
</DL>


<H2><A NAME="SEC321" HREF="emacs_toc.html#TOC321">Исполнение лисповских выражений</A></H2>

<P>
  В Emacs есть несколько основных режимов для языков Лисп и Scheme.  В
них используются одни и те же команды редактирования, но разные команды
для исполнения выражений Лиспа.  У каждого режима свое предназначение.


<DL COMPACT>

<DT>Режим Emacs-Lisp
<DD>
Режим для редактирования исходных файлов программ, запускаемых в Emacs
Lisp.  Этот режим определяет <KBD>C-M-x</KBD> для вычисления текущего
определения функции.  See section <A HREF="emacs_28.html#SEC322">Библиотеки Лисп-программ для Emacs</A>.
<DT>Режим Lisp Interaction
<DD>
Режим для диалогового сеанса с Emacs Lisp. Он определяет <KBD>C-j</KBD> для
вычисления s-выражения перед точкой и вставки его значения в буфер.
See section <A HREF="emacs_28.html#SEC324">Буферы диалога с Лиспом</A>.
<DT>Режим Lisp
<DD>
Режим для редактирования исходных файлов программ, которые запускают в
Лиспах, отличных от Emacs Lisp.  Этот режим определяет <KBD>C-M-x</KBD> так,
чтобы он посылал текущее определение функции подчиненному Лисп-процессу.
See section <A HREF="emacs_28.html#SEC325">Запуск внешнего Лиспа</A>.
<DT>Режим Inferior Lisp
<DD>
Режим для диалогового сеанса с подчиненным процессом Лиспа.  Этот режим
объединяет специальные средства режима Lisp и режима Shell (see section <A HREF="emacs_35.html#SEC420">Режим Shell</A>).
<DT>Режим Scheme
<DD>
Подобен режиму Lisp, но для программ на Scheme.
<DT>Режим Inferior Scheme
<DD>
Режим для диалогового сеанса с подчиненным процессом Scheme.
</DL>

<P>
  Большинство команд редактирования для работы с программами на Лиспе на
самом деле доступны глобально.  See section <A HREF="emacs_27.html#SEC249">Редактирование программ</A>.




<H2><A NAME="SEC322" HREF="emacs_toc.html#TOC322">Библиотеки Лисп-программ для Emacs</A></H2>
<P>
<A NAME="IDX1620"></A>
<A NAME="IDX1621"></A>


<P>
  Лисп-программы для команд редактирования хранятся в файлах, чьи имена
традиционно оканчиваются на <TT>`.el'</TT>. Это окончание сообщает Emacs,
что редактировать их следует в режиме Emacs-Lisp (see section <A HREF="emacs_28.html#SEC321">Исполнение лисповских выражений</A>).


<P>
<A NAME="IDX1622"></A>
  Чтобы выполнить файл с кодом на Emacs Lisp, используйте <KBD>M-x
load-file</KBD>.  Эта команда считывает имя файла, используя минибуфер, и
затем выполняет содержимое этого файла как Лисп-программу.  Для этого
нет необходимости сначала обращаться к файлу, в любом случае эта команда
считывает файл таким, каким он находится на диске, а не как текст в
буфере Emacs.


<P>
<A NAME="IDX1623"></A>
<A NAME="IDX1624"></A>
  Если файл Лисп-программы установлен в каталогах с библиотеками Emacs
Lisp, пользователи могут загрузить его, используя <KBD>M-x
load-library</KBD>.  Программы могут загрузить его, вызывая
<CODE>load-library</CODE>, или с помощью <CODE>load</CODE>, более низкоуровневой
функции, которая похожа на эту, но допускает некоторые дополнительные
аргументы.


<P>
  <KBD>M-x load-library</KBD> отличается от <KBD>M-x load-file</KBD> тем, что она
просматривает последовательность каталогов и пробует три имени в каждом
из них.  Предположим, ваш аргумент -- это <VAR>lib</VAR>; три этих имени ---
это <TT>`<VAR>lib</VAR>.elc'</TT>, <TT>`<VAR>lib</VAR>.el'</TT> и наконец просто
<TT>`<VAR>lib</VAR>'</TT>.  Если существует файл <TT>`<VAR>lib</VAR>.elc'</TT>, по
соглашению это файл, получаемый в результате компиляции; лучше загрузить
скомпилированный файл, так как он загружается и работает быстрее.


<P>
  Если <CODE>load-library</CODE> обнаружит, что <TT>`<VAR>lib</VAR>.el'</TT> новее, чем
<TT>`<VAR>lib</VAR>.elc'</TT>, она напечатает сообщение, потому что это похоже на
то, что кто-то внес изменения в <TT>`.el'</TT>-файл и забыл его
перекомпилировать.


<P>
  Так как аргумент для <CODE>load-library</CODE> обычно не является сам по
себе действительным именем файла, то завершение имени файла недоступно.
Действительно, используя эту команду, вы не знаете точно, какое имя
файла будет использовано.


<P>
<A NAME="IDX1625"></A>
   Последовательность каталогов, просматриваемых <KBD>M-x load-library</KBD>,
определяется переменной <CODE>load-path</CODE>, списком строк, являющихся
именами каталогов. По умолчанию значение этого списка содержит каталог,
где хранится Лисп-код самого Emacs.  Если у вас есть свои собственные
библиотеки, поместите их в один каталог и добавьте этот каталог к
<CODE>load-path</CODE>.  <CODE>nil</CODE> в этом списке означает текущий каталог по
умолчанию, но скорее всего, ставить в список <CODE>nil</CODE> -- не самая
лучшая идея.  Если вы сами решили, что хотите иметь <CODE>nil</CODE> в этом
списке, то наиболее вероятно, что в действительности вы хотите в этот
раз использовать <KBD>M-x load-file</KBD>.


<P>
<A NAME="IDX1626"></A>
  Часто вы не должны давать никакой команды, чтобы загрузить
какую-нибудь библиотеку, так как определенные в ней команды настроены
таким образом, что выполняют <EM>автозагрузку</EM> этой библиотеки.
Попытка запуска любой из этих команд приводит к вызову <CODE>load</CODE> для
загрузки нужной библиотеки.  Это меняет определения автозагрузки на
действительные определения из библиотеки.


<P>
<A NAME="IDX1627"></A>
  Код на Emacs Lisp может быть откомпилирован в байт-код, который
загружается быстрее, занимает после загрузки меньше памяти и быстрее
выполняется.  @xref{Byte Compilation,, Byte Compilation, @external{elisp}, the Emacs Lisp Reference Manual}.  По соглашению,
скомпилированный код библиотеки помещается в отдельный файл, чье имя
состоит из имени исходного файла библиотеки с добавленным <SAMP>`c'</SAMP>.
Таким образом, скомпилированный код для <TT>`foo.el'</TT> попадает в
<TT>`foo.elc'</TT>.  Поэтому <CODE>load-library</CODE> сначала ищет
<SAMP>`.elc'</SAMP>-файлы.




<H2><A NAME="SEC323" HREF="emacs_toc.html#TOC323">Вычисление выражений Emacs-Lisp</A></H2>
<P>
<A NAME="IDX1628"></A>
<A NAME="IDX1629"></A>


<P>
<A NAME="IDX1630"></A>
  Программы на Лиспе, предназначенные для запуска в Emacs, нужно
редактировать в режиме Emacs-Lisp. Это происходит автоматически для
файлов, чьи имена кончаются на <TT>`.el'</TT>.  В противоположность этому,
сам режим Lisp используется для редактирования Лисп-программ,
предназначенных для других Лисп-систем.  Чтобы перейти в режим
Emacs-Lisp, используете команду <KBD>M-x emacs-lisp-mode</KBD>.


<P>
  Для проверки программ на Лиспе, предназначенных для запуска в Emacs,
часто полезно вычислять какую-нибудь часть программы в том виде, как
она находится в буфере Emacs.  Например, после изменения текста
определения лисповской функции, вычисление определения устанавливает это
изменение для будущих вызовов функции.  Вычисление лисповских выражений
также удобно при любом редактировании для запуска неинтерактивных
функций (функций, которые не являются командами).


<DL COMPACT>

<DT><KBD>M-:</KBD>
<DD>
Считывает одно лисповское выражение в минибуфере, вычисляет его и
печатает его значение в эхо-области (<CODE>eval-expression</CODE>).
<DT><KBD>C-x C-e</KBD>
<DD>
Вычисляет лисповское выражение, находящееся перед точкой, и печатает его
значение в эхо-области (<CODE>eval-last-sexp</CODE>).
<DT><KBD>C-M-x</KBD>
<DD>
Вычисляет определение функции, содержащее точку или находящееся после
нее, и печатает его значение в эхо-области (<CODE>eval-defun</CODE>).
<DT><KBD>M-x eval-region</KBD>
<DD>
Вычисляет все лисповские выражения в области.
<DT><KBD>M-x eval-current-buffer</KBD>
<DD>
Вычисляет все лисповские выражения в этом буфере.
</DL>

<P>
<A NAME="IDX1631"></A>
<A NAME="IDX1632"></A>
  <KBD>M-:</KBD> (<CODE>eval-expression</CODE>) -- это самая основная команда для
интерактивного вычисления лисповских выражений.  Она считывает
выражение, используя минибуфер, так что вы можете выполнить любое
выражение в любом буфере, независимо от того, что этот буфер содержит.
Когда выражение вычислено, то текущим буфером опять является тот,
который был текущим, когда вы набирали <KBD>M-:</KBD>.


<P>
<A NAME="IDX1633"></A>
<A NAME="IDX1634"></A>
  В режиме Emacs-Lisp ключ <KBD>C-M-x</KBD> привязан к команде
<CODE>eval-defun</CODE>, которая анализирует определение функции, следующее за
точкой или содержащее ее, как выражение Лиспа и вычисляет его.  Значение
печатается в эхо-области.  Эта команда удобна для установки в среде
Лиспа изменений, которые вы только что сделали в тексте определения
функции.


<P>
  <KBD>C-M-x</KBD> обрабатывает выражения <CODE>defvar</CODE> особо.  Обычно
вычисление выражения <CODE>defvar</CODE> не делает ничего, если определяемая
им переменная уже имеет значение.  Но <KBD>C-M-x</KBD> всегда
переустанавливает эту переменную в начальное значение, заданное
выражением <CODE>defvar</CODE>.  Эта особенность удобна для отладки программ
на Лиспе.


<P>
<A NAME="IDX1635"></A>
<A NAME="IDX1636"></A>
  Команда <KBD>C-x C-e</KBD> (<CODE>eval-last-sexp</CODE>) вычисляет лисповское
выражением, находящееся в этом буфере перед точкой, и показывает его
значение в эхо-области.  Она доступна во всех основных режимах, а не
только в режиме Emacs-Lisp.  Она не обрабатывает <CODE>defvar</CODE> особо.


<P>
  Если командам <KBD>C-M-x</KBD>, <KBD>C-x C-e</KBD> или <KBD>M-:</KBD> задан числовой
аргумент, то они вставляют значение в текущий буфер в позиции точки, а
не в печатают эхо-области.  Значение аргумента не играет роли.


<P>
<A NAME="IDX1637"></A>
<A NAME="IDX1638"></A>
  Самой общей командой для вычисления Лисп-выражений из буфера является
<CODE>eval-region</CODE>.  <KBD>M-x eval-region</KBD> анализирует текст из области
как одно или несколько лисповских выражений, вычисляя их одно за другим.
<KBD>M-x eval-current-buffer</KBD> похожа на предыдущую, но вычисляет весь
буфер.  Это оправданный способ установки Лисп-кода из файла, который вы
как раз готовы проверить.  После нахождения и исправления ошибки
используйте <KBD>C-M-x</KBD> в каждой функции, которую вы изменяете.  Это
сохранит соответствие между миром Лиспа и исходным файлом.




<H2><A NAME="SEC324" HREF="emacs_toc.html#TOC324">Буферы диалога с Лиспом</A></H2>

<P>
  Буфер <TT>`*scratch*'</TT>, выбираемый в момент запуска Emacs,
предназначен для интерактивного вычисления Лисп-выражений внутри Emacs.


<P>
  Простейший способ использования буфера <TT>`*scratch*'</TT> -- вставлять
лисповские выражения, оканчивая каждое из них вводом <KBD>C-j</KBD>.  Эта
команда считывает Лисп-выражение перед точкой, вычисляет его и вставляет
его значение в печатном представлении перед точкой.  Результатом будет
полный протокол вычисленных вами выражений и их значений.


<P>
  Основной режим буфера <SAMP>`*scratch*'</SAMP> называется Lisp Interaction; он
во всем эквивалентен режиму Emacs-Lisp, за исключением привязки для
<KBD>C-j</KBD>.


<P>
<A NAME="IDX1639"></A>
  Целесообразность этого свойства состоит в том, что у Emacs должен быть
буфер в момент запуска, но этот буфер неудобен для редактирования
файлов, так как новый буфер создается для каждого файла, к которому вы
обращаетесь.  Я думаю, что самое полезное, что может делать начальный
буфер, -- это вести протокол интерпретатора Лиспа.  <KBD>M-x
lisp-interaction-mode</KBD> переведет любой буфер в режим Lisp Interaction.


<P>
<A NAME="IDX1640"></A>
  Альтернативный способ интерактивного вычисления выражений Emacs Lisp
предоставляет режим Inferior Emacs-Lisp, который имеет интерфейс, похожий
скорее на интерфейс режима Shell (see section <A HREF="emacs_35.html#SEC420">Режим Shell</A>).  Наберите
<KBD>M-x ielm</KBD>, чтобы создать буфер <TT>`*ielm*'</TT>, использующий этот
режим.




<H2><A NAME="SEC325" HREF="emacs_toc.html#TOC325">Запуск внешнего Лиспа</A></H2>

<P>
  Emacs имеет средства для запуска программ в других Лисп-системах.  Вы
можете запустить Лисп-процесс как подчиненный процесс Emacs и передавать
ему выражения, которые нужно вычислить.  Вы также можете передать
подчиненному Лисп-процессу измененные определения функций
непосредственно из буферов Emacs, в которых вы редактируете программы на
Лиспе.


<P>
<A NAME="IDX1641"></A>
<A NAME="IDX1642"></A>
<A NAME="IDX1643"></A>
  Чтобы запустить подчиненный Лисп-процесс, наберите <KBD>M-x run-lisp</KBD>.
Это запускает программу с именем @command{lisp}, ту же программу,
которую бы вы запустили, набрав @command{lisp} как команду оболочки, с
выводом и вводом, идущими через буфер Emacs с именем <TT>`*lisp*'</TT>.
Следует сказать, что любой "терминальный вывод" от Лиспа пойдет в этот
буфер, передвигая вперед точку, и любой "терминальный ввод" для Лиспа
приходит из текста в буфере.  (Вы можете изменить имя исполняемого
файла Лиспа, установив переменную <CODE>inferior-lisp-program</CODE>.)


<P>
 Чтобы дать ввод в Лисп, отправьте сь в конец буфера и наберите нужный
текст, завершив его вводом <KBD>RET</KBD>.  Буфер <TT>`*lisp*'</TT> находится в
режиме Inferior Lisp, режиме, который объединяет специальные
характеристики режима Lisp и большую часть свойств режима Shell
(see section <A HREF="emacs_35.html#SEC420">Режим Shell</A>).  Определение <KBD>RET</KBD> как команды, посылающей
строку подпроцессу, -- это одна из особенностей режима Shell.


<P>
<A NAME="IDX1644"></A>
  Для запуска исходных файлов программ во внешних Лиспах используйте
режим Lisp.  Этот режим можно выбирать при помощи <KBD>M-x lisp-mode</KBD>;
он используется автоматически для файлов, имена которых оканчиваются на
<TT>`.l'</TT>, <TT>`.lsp'</TT> или <TT>`.lisp'</TT>, какие и применяются в
большинстве Лисп-систем.


<P>
<A NAME="IDX1645"></A>
<A NAME="IDX1646"></A>
  Когда вы редактируете функцию в программе на Лиспе, которая работает в
данный момент, простейшим способом пересылки измененного определения в
подчиненный Лисп-процесс является ключ <KBD>C-M-x</KBD>.  В режиме Lisp при
этом запускается функция <CODE>lisp-send-defun</CODE>, которая находит
определение функции рядом или следом за точкой и посылает его как ввод в
Лисп-процесс.  (Emacs может послать ввод в любой подчиненный процесс
независимо от того, какой буфер является текущим.)


<P>
  Сравним значения <KBD>C-M-x</KBD> в режиме Lisp (для редактирования
программ, запускаемых в другой Лисп-системе) и режиме Emacs-Lisp (для
редактирования программ на Лиспе, предназначенных для работы в Emacs): в
обоих режимах она имеет действие установки определения, в котором
находится точка, но способ выполнения этого различается, согласно тому,
где находится соответствующая среда Лиспа.  See section <A HREF="emacs_28.html#SEC321">Исполнение лисповских выражений</A>.
<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_27.html">previous</A>, <A HREF="emacs_29.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
</BODY>
</HTML>
