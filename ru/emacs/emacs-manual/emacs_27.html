<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Редактирование программ</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_26.html">previous</A>, <A HREF="emacs_28.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC249" HREF="emacs_toc.html#TOC249">Редактирование программ</A></H1>
<P>
<A NAME="IDX1266"></A>
<A NAME="IDX1267"></A>
<A NAME="IDX1268"></A>


<P>
  В Emacs есть много команд, предназначенных для понимания синтаксиса
языков программирования, таких как Лисп и Си. Эти команды могут:



<UL>
<LI>

Передвигать или уничтожать сбалансированные выражения или
<EM>s-выражения</EM> (see section <A HREF="emacs_27.html#SEC251">Списки и s-выражения</A>).
<LI>

Передвигать через или помечать выражения верхнего уровня ---
<EM>определения функций</EM> в Лиспе, функции в Си (see section <A HREF="emacs_27.html#SEC253">Определения функций</A>).
<LI>

Показывать, как сбалансированы круглые скобки (see section <A HREF="emacs_27.html#SEC266">Автоматическое отображение парных скобок</A>).
<LI>

Вставлять, уничтожать или выравнивать комментарии (see section <A HREF="emacs_27.html#SEC267">Управление комментариями</A>).
<LI>

Следовать обычным соглашениям об отступах, принятых в языке
(see section <A HREF="emacs_27.html#SEC254">Отступы в программах</A>).
</UL>

<P>
  Команды для слов, предложений и абзацев очень удобны при
редактировании программ, даже хотя их традиционным применением является
редактирование текстов на естественном языке.  Большинство символов
содержат слова (see section <A HREF="emacs_26.html#SEC218">Слова</A>); предложения могут быть найдены в строках
или комментариях (see section <A HREF="emacs_26.html#SEC219">Предложения</A>).  Абзацы так таковые не
присутствуют в коде, но команды работы с абзацами тем не менее полезны,
так как основные режимы для языков программирования определяют абзацы
как куски текста, начинающиеся и заканчивающиеся пустыми строками
(see section <A HREF="emacs_26.html#SEC220">Абзацы</A>).  Разумное использование пустых строк для улучшения
читаемости программы будет также предоставлять командам, оперрирующим с
абзацами, интересные куски текста для работы.


<P>
  Средство выборочного показа полезно для просмотра общей структуры
функции (see section <A HREF="emacs_16.html#SEC85">Выборочный показ</A>).  Это средство делает так, что на
экране появляются только те строки, отступ в которых меньше заданной
величины.




<H2><A NAME="SEC250" HREF="emacs_toc.html#TOC250">Основные режимы для языков программирования</A></H2>

<P>
<A NAME="IDX1269"></A>
<A NAME="IDX1270"></A>
<A NAME="IDX1271"></A>
<A NAME="IDX1272"></A>
<A NAME="IDX1273"></A>
<A NAME="IDX1274"></A>
<A NAME="IDX1275"></A>
  Emacs также имеет основные режимы для языков программирования Лисп,
Scheme (вариант Лиспа), Awk, Си, Си++, Фортран, Icon, Java, Objective-C,
Паскаль, Perl, Pike, CORBA IDL, и Tcl.  Есть также основной режим для
Make-файлов, называемый режимом Makefile.  Второй альтернативный режим
для Perl называется режимом CPerl.


<P>
  В идеале, основной режим должен быть реализован для каждого языка
программирования, который вы можете пожелать редактировать при помощи
Emacs; но часто режим для одного языка может обслуживать другие языки со
схожим синтаксисом.  Существующие режимы для языков -- это те, которые
кто-то взял на себя труд написать.


<P>
  Есть несколько разновидностей режима Lisp, которые отличаются способом
взаимодействия с исполнением Лиспа.  See section <A HREF="emacs_28.html#SEC323">Вычисление выражений Emacs-Lisp</A>.


<P>
  Каждый из основных режимов для языка программирования определяет ключ
<KBD>TAB</KBD> для запуска функции, делающей отступ, которой известны
соглашения об отступах для этого языка и которая соответственно изменяет
отступ текущей строки.  Например, в режиме С, <KBD>TAB</KBD> привязан к
<CODE>c-indent-line</CODE>.  <KBD>C-j</KBD> обычно определяется так, чтобы делать
<KBD>RET</KBD>, за которым следует <KBD>TAB</KBD>; таким образом, эта команда тоже
делает отступ в режимозависимом виде.


<P>
<A NAME="IDX1276"></A>
<A NAME="IDX1277"></A>
  В большинстве языков программирования отступ часто изменяется от
строки к строке.  Следовательно, основные режимы для таких языков
перепривязывают <KBD>DEL</KBD> так, чтобы он трактовал знак табуляции как
эквивалентное количество пробелов (используя команду
<CODE>backward-delete-char-untabify</CODE>).  Это позволяет стирать отступ по
одному столбцу, не заботясь о том, сделан ли он с помощью пробелов или
знаков табуляции.  Чтобы удалить в этих режимах знак табуляции перед
точкой, используйте <KBD>C-b C-d</KBD>.


<P>
  Режимы языков программирования определяют, что абзацы разделяются
только пустыми строками, так что команды работы с абзацами остаются
полезными.  Режим Auto Fill, включенный в основном режиме языка
программирования, делает отступ в создаваемых им новых строках.


<P>
<A NAME="IDX1278"></A>
<A NAME="IDX1279"></A>
<A NAME="IDX1280"></A>
<A NAME="IDX1281"></A>
<A NAME="IDX1282"></A>
<A NAME="IDX1283"></A>
<A NAME="IDX1284"></A>
<A NAME="IDX1285"></A>
  Включение основного режима запускает обычную ловушку, называемую
<EM>ловушкой режима</EM>, которая является значением лисповской переменной.
Для каждого основного режима есть своя ловушка, и имя этой ловушки
всегда составляется из имени команды, запускающей этот режим, и слова
<SAMP>`-hook'</SAMP>.  Например, включение режима С запускает ловушку
<CODE>c-mode-hook</CODE>, тогда как включение режима Lisp запускает ловушку
<CODE>lisp-mode-hook</CODE>.  See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.




<H2><A NAME="SEC251" HREF="emacs_toc.html#TOC251">Списки и s-выражения</A></H2>

<P>
<A NAME="IDX1286"></A>
  По соглашению, ключи Emacs для работы со сбалансированными выражениями
обычно являются Control-Meta-знаками.  По действию они стремятся
походить на свои Control- и Meta-аналоги.  Обычно считается, что эти
команды имеют отношение к выражениям в языках программирования, но они
могут оказаться полезными в любом языке, в котором существует какая-либо
разновидность круглых скобок (включая естественные языки).


<P>
<A NAME="IDX1287"></A>
<A NAME="IDX1288"></A>
<A NAME="IDX1289"></A>
  Эти команды делятся на два класса.  Некоторые имеют дело только со
<EM>списками</EM> (заключенными в скобки группами).  Они не видят ничего,
кроме круглых, квадратных или фигурных скобок (тех, которые должны быть
сбалансированы в языке, с которым вы работаете) и управляющих символов,
которые могут быть использованы, чтобы экранировать эти скобки.


<P>
  Другие команды имеют дело с выражениями или <EM>s-выражениями</EM>.
Слово `s-выражение' происходит от <EM>s-expression</EM>, старого термина
для выражения в Лиспе.  Но в Emacs понятие `s-выражение' не
ограничивается Лиспом.  Оно обозначает выражение в любом языке, на
котором написана ваша программа.  Каждый язык программирования имеет
свой собственный основной режим, который настраивает синтаксические
таблицы так, что выражения на этом языке рассматриваются как
s-выражения.


<P>
  Обычно s-выражение включает в себя символы, числа и строковые
константы, а также все, что содержится в круглых, квадратных или
фигурных скобках.


<P>
  В языках, которые используют префиксные и инфиксные операторы, таких
как Си, не все выражения могут быть s-выражениями.  Например, режим С не
распознает <SAMP>`foo + bar'</SAMP> как s-выражение, несмотря на то, что это
<EM>является</EM> выражением Си; он распознает <SAMP>`foo'</SAMP> как одно
s-выражение и <SAMP>`bar'</SAMP> как другое, со знаком <SAMP>`+'</SAMP> в качестве
пунктуации между ними.  Это фундаментальная неоднозначность: как
<SAMP>`foo + bar'</SAMP>, так и <SAMP>`foo'</SAMP> являются законными кандидатами на
s-выражение, через которое нужно передвинуться, если точка находится на
<SAMP>`f'</SAMP>.  Заметьте, что <SAMP>`(foo + bar)'</SAMP> -- это единое s-выражение в
режиме С.


<P>
  Некоторые языки имеют туманную форму синтаксиса выражений, и никто не
позаботился о том, чтобы Emacs его правильно понимал.




<H2><A NAME="SEC252" HREF="emacs_toc.html#TOC252">Команды работы со списками и s-выражениями</A></H2>

<DL COMPACT>

<DT><KBD>C-M-f</KBD>
<DD>
Передвинуться вперед через s-выражение (<CODE>forward-sexp</CODE>).
<DT><KBD>C-M-b</KBD>
<DD>
Передвинуться назад через s-выражение (<CODE>backward-sexp</CODE>).
<DT><KBD>C-M-k</KBD>
<DD>
Уничтожить s-выражение вперед (<CODE>kill-sexp</CODE>).
<DT><KBD>C-M-<KBD>DEL</KBD></KBD>
<DD>
Уничтожить s-выражение назад (<CODE>backward-kill-sexp</CODE>).
<DT><KBD>C-M-u</KBD>
<DD>
Перейти вверх и назад по структуре списка (<CODE>backward-up-list</CODE>).
<DT><KBD>C-M-d</KBD>
<DD>
Перейти вниз и вперед по структуре списка (<CODE>down-list</CODE>).
<DT><KBD>C-M-n</KBD>
<DD>
Передвинуться вперед через список (<CODE>forward-list</CODE>).
<DT><KBD>C-M-p</KBD>
<DD>
Передвинуться назад через список (<CODE>backward-list</CODE>).
<DT><KBD>C-M-t</KBD>
<DD>
Переставить выражения (<CODE>transpose-sexps</CODE>).
<DT><KBD>C-M-@</KBD>
<DD>
Поставить метку после следующего выражения (<CODE>mark-sexp</CODE>).
</DL>

<P>
<A NAME="IDX1290"></A>
<A NAME="IDX1291"></A>
<A NAME="IDX1292"></A>
<A NAME="IDX1293"></A>
  Чтобы передвинуться вперед через s-выражение, используйте <KBD>C-M-f</KBD>
(<CODE>forward-sexp</CODE>).  Если первая значащая литера после точки -- это
открывающий ограничитель (<SAMP>`('</SAMP> в Лиспе; <SAMP>`('</SAMP>, <SAMP>`['</SAMP> или
<SAMP>`{'</SAMP> в Си), то <KBD>C-M-f</KBD> передвигает за парный закрывающий
ограничитель.  Если этот знак начинает символ, строку или число, то
<KBD>C-M-f</KBD> передвигает через них.


<P>
  Команда <KBD>C-M-b</KBD> (<CODE>backward-sexp</CODE>) двигает назад через
s-выражение.  Подробные правила похожи на описанные выше для
<KBD>C-M-f</KBD>, но с противоположным направлением.  Если перед s-выражением
стоят какие-либо префиксные символы (в Лиспе это одиночная кавычка,
обратная кавычка и запятая), то <KBD>C-M-b</KBD> переходит и через них.
Команды для s-выражений передвигаются через комментарии, как это
делается для пропусков в большинстве режимов.


<P>
  <KBD>C-M-f</KBD> или <KBD>C-M-b</KBD> с аргументом повторяют операцию заданное
число раз; с отрицательным аргументом, они перемещают в противоположном
направлении.


<P>
<A NAME="IDX1294"></A>
<A NAME="IDX1295"></A>
<A NAME="IDX1296"></A>
<A NAME="IDX1297"></A>
  Уничтожение целого s-выражения может быть сделано при помощи
<KBD>C-M-k</KBD> (<CODE>kill-sexp</CODE>) или <KBD>C-M-<KBD>DEL</KBD></KBD>
(<CODE>backward-kill-sexp</CODE>).  <KBD>C-M-k</KBD> уничтожает знаки, через
которые передвинула бы <KBD>C-M-f</KBD>, а <KBD>C-M-<KBD>DEL</KBD></KBD> уничтожает
знаки, через которые передвинула бы <KBD>C-M-b</KBD>.


<P>
<A NAME="IDX1298"></A>
<A NAME="IDX1299"></A>
<A NAME="IDX1300"></A>
<A NAME="IDX1301"></A>
  <EM>Команды для списков</EM> передвигают через списки, как и команды
s-выражений, но легко перескакивают через любое количество других видов
s-выражений (символы, строки и так далее).  Это <KBD>C-M-n</KBD>
(<CODE>forward-list</CODE>) и <KBD>C-M-p</KBD> (<CODE>backward-list</CODE>).  Они полезны
в основном тем, что обычно игнорируют комментарии (так как комментарии
как правило не содержат никаких списков).


<P>
<A NAME="IDX1302"></A>
<A NAME="IDX1303"></A>
<A NAME="IDX1304"></A>
<A NAME="IDX1305"></A>
  <KBD>C-M-n</KBD> и <KBD>C-M-p</KBD> остаются на одном уровне скобок, когда это
возможно.  Чтобы передвинуться <EM>вверх</EM> на один (или <VAR>n</VAR>)
уровень, используйте <KBD>C-M-u</KBD> (<CODE>backward-up-list</CODE>).  <KBD>C-M-u</KBD>
двигает назад и вверх мимо одного непарного открывающего ограничителя.
Положительный аргумент служит счетчиком повторов; отрицательный аргумент
меняет направление движения и также запрашивает повторение, таким
образом, в этом случае движение происходит вперед и вверх на один или
больше уровней.


<P>
  Чтобы передвинуться <EM>вниз</EM> по структуре списков, используйте
<KBD>C-M-d</KBD> (<CODE>down-list</CODE>).  В режиме Lisp, где <SAMP>`('</SAMP> -- это
единственный открывающий ограничитель, это почти то же самое, что и
поиск <SAMP>`('</SAMP>.  Количество уровней скобок, на какое следует спуститься,
определяет аргумент.


<P>
<A NAME="IDX1306"></A>
<A NAME="IDX1307"></A>
<A NAME="IDX1308"></A>
  Команда <KBD>C-M-t</KBD> (<CODE>transpose-sexp</CODE>), которая переносит
предыдущее s-выражение через следующее, отчасти кажется случайно сюда
попавшей, но тем не менее она очень удобна.  Аргумент служит для
подсчета числа повторов, а отрицательный аргумент перетаскивает
выражение в обратном направлении (таким образом отменяя действие
<KBD>C-M-t</KBD> с положительным аргументом).  Аргумент, равный нулю, вместо
того чтобы ничего не делать, переставляет местами s-выражения,
кончающиеся после точки и метки.


<P>
<A NAME="IDX1309"></A>
<A NAME="IDX1310"></A>
  Чтобы установить область вокруг следующего s-выражения в буфере,
используйте <KBD>C-M-@</KBD> (<CODE>mark-sexp</CODE>), которая ставит пометку в то
же самое место, куда должна бы была передвинуться <KBD>C-M-f</KBD>.
<KBD>C-M-@</KBD> воспринимает аргумент так же, как <KBD>C-M-f</KBD>.  В
частности, отрицательный аргумент удобен для установки метки в начале
предыдущего s-выражения.


<P>
  Понимание синтаксиса командами для списков и s-выражений полностью
управляется синтаксической таблицей.  Любой знак может быть объявлен,
например, открывающим ограничителем и действовать как открывающая
круглая скобка.  See section <A HREF="emacs_36.html#SEC469">Синтаксическая таблица</A>.




<H2><A NAME="SEC253" HREF="emacs_toc.html#TOC253">Определения функций</A></H2>
<P>
<A NAME="IDX1311"></A>


<P>
  В Emacs, заключенные в скобки группы на верхнем уровне в буфере
называются <EM>определениями функций</EM>.  Это название происходит от того
факта, что большинство списков верхнего уровня в Лисп-файле -- это
экземпляры специальной формы <CODE>defun</CODE>, но любая группа верхнего
уровня, заключенная в скобки, на языке Emacs понимается как определение
функции, независимо от ее содержания и от используемого языка
программирования.  Например, тело функции в Си -- это определение
функции.


<DL COMPACT>

<DT><KBD>C-M-a</KBD>
<DD>
Передвинуться к началу текущего или предшествующего определения функции
(<CODE>beginning-of-defun</CODE>).
<DT><KBD>C-M-e</KBD>
<DD>
Передвинуться в конец текущего или следующего определения функции
(<CODE>end-of-defun</CODE>).
<DT><KBD>C-M-h</KBD>
<DD>
Пометить область вокруг всего текущего или следующего определения
функции (<CODE>mark-defun</CODE>).
</DL>

<P>
<A NAME="IDX1312"></A>
<A NAME="IDX1313"></A>
<A NAME="IDX1314"></A>
<A NAME="IDX1315"></A>
<A NAME="IDX1316"></A>
<A NAME="IDX1317"></A>
  Команды движения к началу или концу текущего определения функции ---
это <KBD>C-M-a</KBD> (<CODE>beginning-of-defun</CODE>) и <KBD>C-M-e</KBD>
(<CODE>end-of-defun</CODE>).


<P>
<A NAME="IDX1318"></A>
  Если вы пожелаете произвести какие-то действия над текущим
определением функции, используйте <KBD>C-M-h</KBD> (<CODE>mark-defun</CODE>),
которая ставит точку в начале и метку в конце текущего или следующего
определения функции.  Например, это простейший способ получить готовое
для перемещения в другое место определение функции.  В режиме С,
<KBD>C-M-h</KBD> запускает функцию <CODE>c-mark-function</CODE>, которая почти
эквивалентна <CODE>mark-defun</CODE>; различие состоит в том, что она
переходит через объявления аргументов, имя функции и тип возвращаемых
данных, так что функция Си оказывается внутри области полностью.
See section <A HREF="emacs_13.html#SEC59">Команды для пометки текстуальных объектов</A>.


<P>
  Emacs предполагает, что любые открывающие скобки, найденные в самом
левом столбце, -- это начало определения функции.  Поэтому
<STRONG>никогда не ставьте открывающие скобки с левого края в
Лисп-файле, если они не являются началом списка верхнего уровня.
Никогда не ставьте открывающую фигурную скобку или другой открывающий
ограничитель в начале строки в программе на Си, если только они не
начинают тело функции.</STRONG>  Большинство возможных проблем возникает, когда
вы хотите поставить открывающий ограничитель в начале строки внутри
строковой константы.  Чтобы избежать неприятностей, поставьте
экранирующий знак (<SAMP>`\'</SAMP> в Си и Emacs Lisp, <SAMP>`/'</SAMP> в некоторых
других диалектах Лиспа) перед открывающим ограничителем.  Это не
повлияет на содержимое строки.


<P>
  В очень далеком прошлом оригинальный Emacs находил определения
функций, двигаясь вверх по уровням скобок до тех пор, пока не доходил до
уровня, от которого некуда было идти дальше.  Это всегда требовало
просмотра полного пути обратно до начала буфера, даже для маленькой
функции.  Чтобы ускорить эту операцию, Emacs был изменен, и теперь он
предполагает, что любой знак <SAMP>`('</SAMP> (или любой другой, приписанный к
синтаксическому классу открывающего ограничителя) на левой границе
строки -- это начало определения функций.  Эта эвристика почти всегда
правильна и позволяет избежать ресурсоемкого просмотра; однако, она
требует выполнения описанных выше соглашений.




<H2><A NAME="SEC254" HREF="emacs_toc.html#TOC254">Отступы в программах</A></H2>
<P>
<A NAME="IDX1319"></A>


<P>
  Наилучший способ сохранить правильность отступов в программе -- это
использовать Emacs для создания новых отступов по мере внесения
изменений.  В Emacs есть команды для создания правильного отступа
одиночной строки, заданного числа строк или всех строк внутри одной
группы, заключенной в скобки.


<P>
  Emacs также предоставляет программу структурной печати для Лиспа,
реализованную в библиотеке <CODE>pp</CODE>.  Эта программа переформатирует
лисповский объект, выбирая отступы таким образом, чтобы результат хорошо
выглядел и удобно читался.




<H3><A NAME="SEC255" HREF="emacs_toc.html#TOC255">Основные команды для отступов в программах</A></H3>

<DL COMPACT>

<DT><KBD><KBD>TAB</KBD></KBD>
<DD>
Установить отступ текущей строки.
<DT><KBD>C-j</KBD>
<DD>
Эквивалент <KBD>RET</KBD>, за которым следует <KBD>TAB</KBD>
(<CODE>newline-and-indent</CODE>).
</DL>

<P>
<A NAME="IDX1320"></A>
<A NAME="IDX1321"></A>
<A NAME="IDX1322"></A>
  Основная команда отступа -- это <KBD>TAB</KBD>, которая дает текущей
строке правильный отступ, основываясь на отступе предыдущих строк.
Функция, которую запускает <KBD>TAB</KBD>, зависит от основного режима; в
режиме Lisp это <CODE>lisp-indent-line</CODE>, в режиме С это
<CODE>c-indent-line</CODE> и так далее.  Эти функции понимают различные
синтаксисы разных языков, но все они делают примерно одно и то же.
<KBD>TAB</KBD> в основном режиме любого языка программирования вставляет или
удаляет пробельные знаки в начале текущей строки, независимо от того,
где в строке располагается точка.  Если точка находится среди пробельных
знаков в начале строки, <KBD>TAB</KBD> оставляет ее после них; в противном
случае <KBD>TAB</KBD> оставляет точку фиксированной по отношению к окружающим
ее знакам.


<P>
  Чтобы вставить в точке знак табуляции, используйте <KBD>C-q
<KBD>TAB</KBD></KBD>.


<P>
<A NAME="IDX1323"></A>
<A NAME="IDX1324"></A>
  При вводе нового кода используйте <KBD>C-j</KBD>
(<CODE>newline-and-indent</CODE>), которая эквивалентна <KBD>RET</KBD>, за которой
следует <KBD>TAB</KBD>.  <KBD>C-j</KBD> создает пустую строку, а затем дает ей
соответствующий отступ.


<P>
  <KBD>TAB</KBD> создает отступ во второй и следующих строках тела группы,
заключенной в скобки, так, что каждая оказывается под предыдущей;
поэтому, если вы изменяете отступ одной строки на нестандартный, то
строки ниже будут стремиться следовать ему.  Такое поведение удобно в
тех случаях, когда вы заменяете стандартный результат <KBD>TAB</KBD>,
поскольку вы нашли его неэстетичным для какой-то строки.


<P>
  Помните, что открывающие круглые и фигурные скобки или другие
открывающие ограничители на левом крае рассматриваются Emacs (и
правилами отступа) как начало функции.  Поэтому вы никогда не должны
ставить открывающий ограничитель, не являющийся началом функции, в
нулевом столбце, даже внутри строковой константы.  Это ограничение
жизненно важно для скорости работы команд отступа; вы должны просто
принять его.  Для более подробной информации об этом смотрите
section <A HREF="emacs_27.html#SEC253">Определения функций</A>.




<H3><A NAME="SEC256" HREF="emacs_toc.html#TOC256">Отступ в нескольких строках</A></H3>

<P>
  Если вы хотите поменять отступ нескольких строк кода, которые были
изменены или передвинуты на другой уровень в структуре списков, вы
имеете в своем распоряжении несколько команд.


<DL COMPACT>

<DT><KBD>C-M-q</KBD>
<DD>
Сделать новый отступ во всех строках в пределах одного списка
(<CODE>indent-sexp</CODE>).
<DT><KBD>C-u <KBD>TAB</KBD></KBD>
<DD>
Сдвинуть весь список жестко в сторону так, чтобы его первая строка
получила надлежащий отступ.
<DT><KBD>C-M-\</KBD>
<DD>
Сделать новый отступ во всех строках в области (<CODE>indent-region</CODE>).
</DL>

<P>
<A NAME="IDX1325"></A>
<A NAME="IDX1326"></A>
  Вы можете вновь сделать отступ содержимого одиночного списка,
переместив точку в его начало и набрав <KBD>C-M-q</KBD> (это команда
<CODE>indent-sexp</CODE> в режиме Lisp, <CODE>c-indent-exp</CODE> в режиме С; она
также привязана к другим подходящим функциям в других режимах).  Отступ
строки, на которой начинается это s-выражение, не изменяется; поэтому
изменяется только относительный отступ в пределах списка, а не его
позиция.  Чтобы исправить также и его позицию, наберите <KBD>TAB</KBD> перед
<KBD>C-M-q</KBD>.


<P>
<A NAME="IDX1327"></A>
  Если относительный отступ внутри списка правильный, но отступ его
первой строки -- нет, перейдите к этой строке и наберите <KBD>C-u
<KBD>TAB</KBD></KBD>.  <KBD>TAB</KBD> с числовым аргументом делает в текущей строке
обычный отступ, а затем изменяет отступ во всех строках в группе,
начиная с текущей, на ту же самую величину.  Другими словами, она
обновляет отступ целой группы как неделимой единицы.  Это разумно, хотя
и не изменяет строки, которые начинаются внутри строковых констант, или
строки препроцессора Си, когда это происходит в режиме С.


<P>
  Можно указать диапазон строк, в которых следует вновь сделать отступ,
другим способом -- с помощью области.  Команда <KBD>C-M-\</KBD>
(<CODE>indent-region</CODE>) применяет <KBD>TAB</KBD> к каждой строке, чей первый
знак находится между точкой и меткой.




<H3><A NAME="SEC257" HREF="emacs_toc.html#TOC257">Настройка отступов для Лиспа</A></H3>
<P>
<A NAME="IDX1328"></A>


<P>
  Образец отступа для лисповского выражения может зависеть от функции,
вызываемой этим выражением.  Для каждой лисповской функции вы можете
выбирать среди нескольких предопределенных образцов отступа или
определить произвольный отступ с помощью программы на Лиспе.


<P>
  Стандартный шаблон отступа таков: вторая строка выражения сдвигается
под первый аргумент, если он находится на той же самой строке, что и
начало выражения; в противном случае вторая строка сдвигается под имя
функции.  Каждая следующая строка имеет тот же отступ, что и предыдущая
строка с той же глубиной вложенности.


<P>
<A NAME="IDX1329"></A>
  Если переменная <CODE>lisp-indent-offset</CODE> не равна <CODE>nil</CODE>, то она
перекрывает обычный шаблон отступа для второй строки выражения, так что
такие строки всегда сдвигаются вправо на <CODE>lisp-indent-offset</CODE>
столбцов дальше, чем содержащий их список.


<P>
<A NAME="IDX1330"></A>
     Стандартный шаблон перекрывается в некоторых определенных функциях.
Для функций, чьи имена начинаются с <CODE>def</CODE>, отступ второй строки
всегда делается на <CODE>lisp-body-indention</CODE> дополнительных столбцов
дальше открывающей скобки, начинающей выражение.


<P>
  Стандартный шаблон может перекрываться различными способами для
отдельных функций согласно свойству имени этой функции
<CODE>lisp-indent-function</CODE>.  Есть четыре варианта для этого свойства:


<DL COMPACT>

<DT><CODE>nil</CODE>
<DD>
Это то же самое, что и отсутствие свойства; используется стандартный
шаблон отступа.
<DT><CODE>defun</CODE>
<DD>
Шаблон, используемый для имен функций, которые начинаются с <CODE>def</CODE>,
также используется и для этой функции.
<DT>число, <VAR>n</VAR>
<DD>
Первые <VAR>n</VAR> аргументов этой функции считаются <EM>отличительными</EM>
аргументами, остальные рассматриваются как <EM>тело</EM> выражения.  Строка
в этом выражении отступается в соответствии с тем, является ли в ней
первый аргумент отличительным или нет.  Если аргумент является частью
тела, то строка отступается на <CODE>lisp-body-indent</CODE> столбцов больше,
чем открывающая скобка, начинающая содержащее ее выражение.  Если
аргумент является отличительным, и это первый или второй аргумент, то
отступ делается на <EM>вдвое большее</EM> число дополнительных столбцов.
Если аргумент отличителен и не является первым или вторым, то для этой
строки применяется стандартный шаблон.
<DT>символ, <VAR>символ</VAR>
<DD>
<VAR>символ</VAR> должен быть именем функции; эта функция вызывается для
вычисления отступа строки в пределах этого выражения.  Функция получает
два аргумента:
<DL COMPACT>

<DT><VAR>состояние</VAR>
<DD>
Значение, возвращаемое из <CODE>parse-partial-sexp</CODE> (это примитив Лиспа
для подсчета величины отступов и вложенностей), когда она делает разбор
вплоть до начала этой строки.
<DT><VAR>позиция</VAR>
<DD>
Позиция, с которой начинается строка, в которой делается отступ.
</DL>
Она должна возвращать либо число, которое равно количеству столбцов
отступа для этой строки, либо список, чей головной элемент является
таким числом.  Отличие между возвращением числа и возвращением списка
заключается в том, что число говорит, что все следующие строки того же
уровня вложенности должны получать такой же отступ, как эта строка;
список говорит, что следующие строки могут требовать отличные отступы.
Это важно, если отступы подсчитываются с помощью <KBD>C-M-q</KBD>; если
значение -- это число, то <KBD>C-M-q</KBD> не нуждается в пересчете отступа
для следующих строк до конца списка.
</DL>



<H3><A NAME="SEC258" HREF="emacs_toc.html#TOC258">Команды для отступов в Си</A></H3>

<P>
  Вот команды для создания отступов в режиме C и родственных с ним:


<DL COMPACT>

<DT><CODE>C-c C-q</CODE>
<DD>
<A NAME="IDX1331"></A>
<A NAME="IDX1332"></A>
Обновляет отступ в текущем определении функции верхнего уровня или
собирает в одно целое объявление типа (<CODE>c-indent-defun</CODE>).

<DT><CODE>C-M-q</CODE>
<DD>
<A NAME="IDX1333"></A>
<A NAME="IDX1334"></A>
Обновляет отступ в каждой строке сбалансированного выражения, которое
следует после точки (<CODE>c-indent-exp</CODE>).  Префиксный аргумент
подавляет проверку ошибок и вывод предупреждений о недопустимом
синтаксисе.

<DT><CODE><KBD>TAB</KBD></CODE>
<DD>
<A NAME="IDX1335"></A>
Обновляет отступ в текущей строке и/или в некоторых случаях вставляет
знак табуляции (<CODE>c-indent-command</CODE>).

Если <CODE>c-tab-always-indent</CODE> равна <CODE>t</CODE>, эта команда всегда
обновляет отступ текущей строки и не делает ничего больше.  Это
принимается по умолчанию.

Если эта переменная равна <CODE>nil</CODE>, данная команда обновляет отступ
текущей строки, только если точка находится с левого края или на
отступе; в противном случае она вставляет табуляцию (или эквивалентное
число пробелов, если <CODE>indent-tabs-mode</CODE> равна <CODE>nil</CODE>).

Любое другое значение (не <CODE>nil</CODE> или <CODE>t</CODE>) означает, что нужно
всегда обновлять отступ строки, а также вставлять знак табуляции, если
точка находится внутри комментария, строки или директивы препроцессора.

<DT><CODE>C-u <KBD>TAB</KBD></CODE>
<DD>
Обновляет отступ текущей строки в соответствии с ее синтаксисом; кроме
того, жестко смещает все остальные строки выражения, начинающегося на
текущей строке.  See section <A HREF="emacs_27.html#SEC256">Отступ в нескольких строках</A>.
</DL>

<P>
  Чтобы обновить отступ всего текущего буфера, наберите <KBD>C-x h
C-M-\</KBD>.  Это сначала выделяет весь буфер как область, а затем обновляет
отступ в этой области.


<P>
  Чтобы обновить отступ в текущем блоке, используйте <KBD>C-M-u C-M-q</KBD>.
Эта команда перемещает к началу блока и делает в нем отступ.




<H3><A NAME="SEC259" HREF="emacs_toc.html#TOC259">Настройка отступа в Си</A></H3>

<P>
  Режим C и родственные режимы используют простой, но гибкий механизм
для настройки отступа.  Этот механизм работает в два этапа: сначала
строки классифицируются синтаксически в соответствии с их содержимым и
контекстом; затем каждому виду синтаксических конструкций привязывается
значение сдвига, который вы можете настроить.




<H4><A NAME="SEC260" HREF="emacs_toc.html#TOC260">Шаг 1 -- синтаксический анализ</A></H4>
<P>
<A NAME="IDX1336"></A>


<P>
  На первом шаге механизм отступов в Си смотрит на строку перед той, в
которой вы в данный момент делаете отступ, и определяет синтаксические
компоненты конструкции на этой строке.  Он строит список этих
синтаксических компонентов, где каждый компонент содержит
<EM>синтаксический символ</EM> и, иногда, позицию в буфере.  Некоторые
синтаксические символы описывают грамматические элементы, например
<CODE>statement</CODE> и <CODE>substatement</CODE>; другие описывают положения в
составе грамматических элементов, например <CODE>class-open</CODE> и
<CODE>knr-argdecl</CODE>.


<P>
  По идее, строка кода на Си всегда имеет отступ относительно отступа
какой-то строки выше по этому буферу.  Это представляется позицией в
буфере в списке синтаксических компонентов.


<P>
  Вот пример.  Предположим, что у нас есть следующий код в буфере с
режимом C++ (номера строк в действительности не появляются в буфере):



<PRE>
1: void swap (int&#38; a, int&#38; b)
2: {
3:   int tmp = a;
4:   a = b;
5:   b = tmp;
6: }
</PRE>

<P>
  Если вы наберете <KBD>C-c C-s</KBD> (что запускает команду
<CODE>c-show-syntactic-information</CODE>) на строке 4, будет показан
результат работы механизма отступов для этой строки:



<PRE>
((statement . 32))
</PRE>

<P>
  Это указывает на то, что данная строка является оператором, и она
имеет отступ относительно позиции 32 в буфере, то есть относительно
<SAMP>`i'</SAMP> в <CODE>int</CODE> на строке 3.  Если вы переместите курсор к строке
3 и наберете <KBD>C-c C-s</KBD>, это покажет следующее:



<PRE>
((defun-block-intro . 28))
</PRE>

<P>
  Это указывает на то, что строка <CODE>int</CODE> -- это первый оператор в
блоке, и она имеет отступ относительно позиции 28, то есть фигурной
скобки сразу после заголовка функции.


<P>
Вот еще один пример:



<PRE>
1: int add (int val, int incr, int doit)
2: {
3:   if (doit)
4:     {
5:       return (val + incr);
6:     }
7:   return (val);
8: }
</PRE>

<P>
Если в строке 4 набрать <KBD>C-c C-s</KBD>, вы увидите вот что:



<PRE>
((substatement-open . 43))
</PRE>

<P>
  Это говорит, что данная фигурная скобка <EM>открывает</EM> блок
подоператора.  Кстати, <EM>подоператор</EM> -- это строка после операторов
<CODE>if</CODE>, <CODE>else</CODE>, <CODE>while</CODE>, <CODE>do</CODE>, <CODE>switch</CODE>,
<CODE>for</CODE>, <CODE>try</CODE>, <CODE>catch</CODE>, <CODE>finally</CODE> или
<CODE>synchronized</CODE>.


<P>
<A NAME="IDX1337"></A>
<A NAME="IDX1338"></A>
<A NAME="IDX1339"></A>
  Внутри команд для отступа в Си, после того как строка синтаксически
проаналицирована, описание результатов анализа хранится в списке в
переменной <CODE>c-syntactic-context</CODE>.  Каждый элемент этого списка ---
это <EM>синтаксический компонент</EM>: пара, содержащая синтаксический
символ и (возможно) соответствующую ему позицию в буфере.  В списке
компонент может несколько элементов; как правило только один из них
имеет позицию в буфере.




<H4><A NAME="SEC261" HREF="emacs_toc.html#TOC261">Шаг 2 -- подсчет отступа</A></H4>
<P>
<A NAME="IDX1340"></A>
<A NAME="IDX1341"></A>


<P>
  Механизма отступов в Си вычисляет величину отступа для текущей строки,
используя список синтаксических компонентов, <CODE>c-syntactic-context</CODE>,
полученный из синтаксического анализа.  Каждый компонент -- это пара,
которая содержит синтаксический символ и может содержать позицию в
буфере.


<P>
  Каждый компонент дает вклад в окончательный отступ строки двумя
путями.  Во-первых, синтаксический символ определяет элемент
<CODE>c-offsets-alist</CODE>, это ассоциативный список, ставящий в
соответствие синтаксическим символам величины сдвига.  Сдвиг каждого
синтаксического символа добавляется к общему отступу.  Во-вторых, если
компонент включает позицию в буфере, к отступу добавляется номер столбца
этой позиции.  Все эти сдвиги и номера столбцов с сумме дают общий
отступ.


<P>
  Следующие примеры демонстрируют работу механизма отступов в языке Си:



<PRE>
1: void swap (int&#38; a, int&#38; b)
2: {
3:   int tmp = a;
4:   a = b;
5:   b = tmp;
6: }
</PRE>

<P>
  Предположим, что точка находится на строке 3, и вы нажимаете
<KBD>TAB</KBD>, чтобы обновить в этой строке отступ.  Как объяснялось выше
(see section <A HREF="emacs_27.html#SEC260">Шаг 1 -- синтаксический анализ</A>), синтаксическим компонетом этой строки
будет:



<PRE>
((defun-block-intro . 28))
</PRE>

<P>
  В данном случае при подсчете отступа сначала просматривается
<CODE>defun-block-intro</CODE> в ассоциативном списке <CODE>c-offsets-alist</CODE>.
Предположим, что там найдено число 2; оно добавляется к общему
(инициализированному нулем), выдавая общей обновленный отступ в 2
пробела.


<P>
  Следующий шаг -- найти номер столбца для позиции 28 в буфере.
Поскольку фигурная скобка в позиции 28 расположена в нулевом столбце, к
общему числу добавляется 0.  Так как в этой строке есть только один
синтаксический компонет, общий отступ для этой строки равен двум
пробелам.



<PRE>
1: int add (int val, int incr, int doit)
2: {
3:   if (doit)
4:     {
5:       return(val + incr);
6:     }
7:   return(val);
8: }
</PRE>

<P>
  Если вы нажмете <KBD>TAB</KBD> в строке 4, повторяется такой же процесс, но
с иными данными.  Список синтаксических компонентов для этой строки
таков:



<PRE>
((substatement-open . 43))
</PRE>

<P>
  Здесь первое, что делается для посчета отступа, -- ищется символ
<CODE>substatement-open</CODE> в <CODE>c-offsets-alist</CODE>.  Будем считать, что
сдвиг для этого символа равен 2.  В этом месте промежуточное общее
значение равно 2 (0 + 2 = 2).  Затем к нему добавляется номер строки
позиции 43 в буфере, где стоит <SAMP>`i'</SAMP> из <CODE>if</CODE> на строке 3.  Этот
знак расположен во втором столбце на строке.  Итого в сумме получается 4
пробела.


<P>
<A NAME="IDX1342"></A>
  Если при анализе строки появляется синтаксический символ, который
отсутствует в <CODE>c-offsets-alist</CODE>, он игнорируется; и это является
ошибкой, если кроме того переменная <CODE>c-strict-syntax-p</CODE> отлична от
<CODE>nil</CODE>.




<H4><A NAME="SEC262" HREF="emacs_toc.html#TOC262">Изменение стиля отступов</A></H4>

<P>
   Есть два способа настроить стиль отступов для режимов, подобных
режиму C.  Во-первых, вы можете выбрать один из предопределенных стилей,
каждый из которых задает сдвиги для всех синтаксических символов.  Для
большей гибкости вы можете настоить обработку отдельных синтаксических
символов.  See section <A HREF="emacs_27.html#SEC263">Синтаксические символы</A>, перечень всех определенных
синтаксических символов.


<DL COMPACT>

<DT><KBD>M-x c-set-style <KBD>RET</KBD> <VAR>стиль</VAR> <KBD>RET</KBD></KBD>
<DD>
Выбирает предопределенный стиль <VAR>стиль</VAR>.  Чтобы получить перечень
поддерживаемых стилей, наберите при вводе стиля знак <KBD>?</KBD>; чтобы
узнать, как выглядит тот или иной стиль, выберите его и примените для
фрагмента кода на Си.

<DT><KBD>C-c C-o <VAR>символ</VAR> <KBD>RET</KBD> <VAR>сдвиг</VAR> <KBD>RET</KBD></KBD>
<DD>
Устанавливает сдвиг для синтаксического символа <VAR>символ</VAR>
(<CODE>c-set-offset</CODE>).  Второй аргумент, <VAR>сдвиг</VAR>, указывает новую
величину сдвига.
</DL>

<P>
   Размер отступа для каждого синтаксического символа управляется
переменной <CODE>c-offsets-alist</CODE>.  Ее значение -- это ассоциативный
список, и каждый элемент этого списка имеет форму
<CODE>(<VAR>синтаксический-символ</VAR> . <VAR>сдвиг</VAR>)</CODE>.  Изменяя сдвиги для
разных синтаксических символов, вы можете настраивать отступы в
мельчайших подробностях.  Чтобы изменить этот ассоциативный список,
используйте <CODE>c-set-offset</CODE> (смотрите ниже).


<P>
   Значение каждого сдвига в <CODE>c-offsets-alist</CODE> может быть целым
числом, именем функции или переменной, списком или одним их символов
<CODE>+</CODE>, <CODE>-</CODE>, <CODE>++</CODE>, <CODE>--</CODE>, <CODE>*</CODE> или <CODE>/</CODE>,
обозначающих положительные или отрицательные кратные переменной
<CODE>c-basic-offset</CODE>.  Таким образом, если вы хотите поменять уровни
отступов с трех пробелов на два пробела, установите
<CODE>c-basic-offset</CODE> в значение 3.


<P>
   Использование функции в качестве значения сдвига предоставляет полную
гибкость в настройке отступов.  Эта функция вызывается с одним
аргументом, содержащим пару из синтаксического символа и позиции в
буфере, если она есть.  Функция должна возвращать целое число, равное
сдвигу.


<P>
  Если значением сдвига является список, его элементы обрабатываются в
соответствии с описанными выше правилами, пока не найдено отличное от
<CODE>nil</CODE> значение.  Тогда это значение добавляется к общему отступу
обычным способом.  Основное применение этого состоит в сложении
результатов нескольких функций.


<P>
<A NAME="IDX1343"></A>
<A NAME="IDX1344"></A>
   Команда <KBD>C-c C-o</KBD> (<CODE>c-set-offset</CODE>) -- это простейший способ
установить сдвиги, как интерактивно, так и в вашем файле
<TT>`~/.emacs'</TT>.  Сначала укажите синтаксический символ, а потом
желаемый сдвиг.  See section <A HREF="emacs_27.html#SEC263">Синтаксические символы</A>, перечень допустимых
синтаксических символов и их значений.




<H4><A NAME="SEC263" HREF="emacs_toc.html#TOC263">Синтаксические символы</A></H4>

<P>
   Это таблица допустимых синтаксических символов для отступов режима C
и родственных с ним режимов и их синтаксические значения.  Обычно всем
этим символам приписывается сдвиг в <CODE>c-offsets-alist</CODE>.


<DL COMPACT>

<DT><CODE>string</CODE>
<DD>
Внутри строки, занимащей несколько строк в буфере.

<DT><CODE>c</CODE>
<DD>
Внутри многострочного блочного комментария в стиле Си.

<DT><CODE>defun-open</CODE>
<DD>
На фигурной скобке, которая открывает определение функции.

<DT><CODE>defun-close</CODE>
<DD>
На фигурной скобке, которая закрывает определение функции.

<DT><CODE>defun-block-intro</CODE>
<DD>
На первой строке определения функции верхнего уровня.

<DT><CODE>class-open</CODE>
<DD>
На фигурной скобке, которая открывает определение класса.

<DT><CODE>class-close</CODE>
<DD>
На фигурной скобке, которая закрывает определение класса.

<DT><CODE>inline-open</CODE>
<DD>
На фигурной скобке, которая открывает определяемый внутри класса
inline-метод.

<DT><CODE>inline-close</CODE>
<DD>
На фигурной скобке, которая закрывает определяемый внутри класса
inline-метод.

<DT><CODE>extern-lang-open</CODE>
<DD>
На фигурной скобке, которая открывает блок на внешнем языке.

<DT><CODE>extern-lang-close</CODE>
<DD>
На фигурной скобке, которая закрывает блок на внешнем языке.

<DT><CODE>func-decl-cont</CODE>
<DD>
На области между списком аргументов в определении функции и открывающей
это определение фигурной скобкой (исключая определения функций в стиле
K&#38;R).  В Си вы не можете писать здесь ничего, кроме пробельных знаков и
комментариев; в Си++ и Java в этом контекте могут появляться объявления
<CODE>throws</CODE> и другие вещи.

<DT><CODE>knr-argdecl-intro</CODE>
<DD>
На первой строке объявления аргументов в стиле K&#38;R Си.

<DT><CODE>knr-argdecl</CODE>
<DD>
На одной из последующих строк объявления аргументов в стиле K&#38;R Си.

<DT><CODE>topmost-intro</CODE>
<DD>
На первой строке определения конструкции самого верхнего уровня.

<DT><CODE>topmost-intro-cont</CODE>
<DD>
На остальных строках определения самого верхнего уровня.

<DT><CODE>member-init-intro</CODE>
<DD>
На первой строке списка инициализаций членов.

<DT><CODE>member-init-cont</CODE>
<DD>
На последующих строках списка инициализаций членов.

<DT><CODE>inher-intro</CODE>
<DD>
На первой строке списка множественного наследования.

<DT><CODE>inher-cont</CODE>
<DD>
На одной их последующих строк множественного наследования.

<DT><CODE>block-open</CODE>
<DD>
На открывающей фигурной скобке операторного блока.

<DT><CODE>block-close</CODE>
<DD>
На закрывающей фигурной скобке операторного блока.

<DT><CODE>brace-list-open</CODE>
<DD>
На открывающей фигурной скобке списка массива <CODE>enum</CODE> или
<CODE>static</CODE>.

<DT><CODE>brace-list-close</CODE>
<DD>
На закрывающей фигурной скобке списка массива <CODE>enum</CODE> или
<CODE>static</CODE>.

<DT><CODE>brace-list-intro</CODE>
<DD>
На первой строке списка массива <CODE>enum</CODE> или <CODE>static</CODE>.

<DT><CODE>brace-list-entry</CODE>
<DD>
На одной их последующих строк списка массива <CODE>enum</CODE> или
<CODE>static</CODE>.

<DT><CODE>brace-entry-open</CODE>
<DD>
На одной из последующих строк списка массива <CODE>enum</CODE> или
<CODE>static</CODE>, когда строка начинается с открывающей фигурной скобки.

<DT><CODE>statement</CODE>
<DD>
На обычном операторе.

<DT><CODE>statement-cont</CODE>
<DD>
На строке продолжения оператора.

<DT><CODE>statement-block-intro</CODE>
<DD>
На первой  строке нового операторного блока.

<DT><CODE>statement-case-intro</CODE>
<DD>
На первой строке "блока" <CODE>case</CODE>.

<DT><CODE>statement-case-open</CODE>
<DD>
На первой строке блока <CODE>case</CODE>, начинающейся с фигурной скобки.

<DT><CODE>inexpr-statement</CODE>
<DD>
На операторном блоке внутри выражения.  Это используется для расширения
GNU в языке Си и для для специальных функций Pike, которые принимают в
качестве аргумента операторный блок.

<DT><CODE>inexpr-class</CODE>
<DD>
На определении класса внутри выражения.  Это используется для аноноимных
классов и аноноимных инициализаторов массивов в Java.

<DT><CODE>substatement</CODE>
<DD>
На первой строке после <CODE>if</CODE>, <CODE>while</CODE>, <CODE>for</CODE>, <CODE>do</CODE>
или <CODE>else</CODE>.

<DT><CODE>substatement-open</CODE>
<DD>
На фигурной скобке, открывающей блок подоператора.

<DT><CODE>case-label</CODE>
<DD>
На метке <CODE>case</CODE> или <CODE>default</CODE>.

<DT><CODE>access-label</CODE>
<DD>
На метках доступа Си++ <CODE>private</CODE>, <CODE>protected</CODE> или
<CODE>public</CODE>.

<DT><CODE>label</CODE>
<DD>
На обычной метке.

<DT><CODE>do-while-closure</CODE>
<DD>
На <CODE>while</CODE>, который завершает конструкцию <CODE>do</CODE>-<CODE>while</CODE>.

<DT><CODE>else-clause</CODE>
<DD>
На <CODE>else</CODE> конструкции <CODE>if</CODE>-<CODE>else</CODE>.

<DT><CODE>catch-clause</CODE>
<DD>
На строках <CODE>catch</CODE> и <CODE>finally</CODE> в конструкциях
<CODE>try</CODE>...<CODE>catch</CODE> в Си++ и Java.

<DT><CODE>comment-intro</CODE>
<DD>
На строке, содержащей только начало комментария.

<DT><CODE>arglist-intro</CODE>
<DD>
На первой строке списка аргументов.

<DT><CODE>arglist-cont</CODE>
<DD>
На одной из последующих строк списка аргументов, когда на строке с
открывающей список аргументов круглой скобкой нет ни одного аргумента.

<DT><CODE>arglist-cont-nonempty</CODE>
<DD>
На одной из последующих строк списка аргументов, когда на строке с
открывающей список аргументов круглой скобкой есть хотя бы один
аргумент.

<DT><CODE>arglist-close</CODE>
<DD>
На закрывающей круглой скобке списка аргументов.

<DT><CODE>stream-op</CODE>
<DD>
На одной строк продолжения конструкции потокового оператора.

<DT><CODE>inclass</CODE>
<DD>
На конструкции, вложенной в определение класса.  Отступ относителен
открывающей фигурной скобке определения класса.

<DT><CODE>inextern-lang</CODE>
<DD>
На конструкции, вложенной в блок на внешнем языке.

<DT><CODE>inexpr-statement</CODE>
<DD>
На первой строке операторного блока внутри выражения.  Это нужно для
расширения GCC в языке Си, которое использует синтаксис <CODE>({
... })</CODE>.  Это также нужно для специальных функций в Pike,
принимающих в качестве аргумента операторный блок.

<DT><CODE>inexpr-class</CODE>
<DD>
На первой строке определения класса внутри выражения.  Это используется
для аноноимных классов и аноноимных инициализаторов массивов в Java.

<DT><CODE>cpp-macro</CODE>
<DD>
На начале макроса препроцессора.

<DT><CODE>friend</CODE>
<DD>
На объявлении Си++ <CODE>friend</CODE>.

<DT><CODE>objc-method-intro</CODE>
<DD>
На первой строке определения метода Objective-C.

<DT><CODE>objc-method-args-cont</CODE>
<DD>
На одной из строк продолжения определения метода Objective-C.

<DT><CODE>objc-method-call-cont</CODE>
<DD>
На одной из строк продолжения вызова метода Objective-C.

<DT><CODE>inlambda</CODE>
<DD>
Как <CODE>inclass</CODE>, но применяется внутри лямбда-функций (т.е.
анонимных).  Используется только в Pike.

<DT><CODE>lambda-intro-cont</CODE>
<DD>
На строке, продолжающей заголовок лямбда-функции, между ключевым
словом <CODE>lambda</CODE> и телом функции.  Используется только в Pike.
</DL>



<H4><A NAME="SEC264" HREF="emacs_toc.html#TOC264">Переменные, управляющие отступами в Си</A></H4>

<P>
  Этот раздел описывает дополнительные переменные, которые управляют
поведением отступов в режиме C и родственных с ним режимах.


<DL COMPACT>

<DT><CODE>c-offsets-alist</CODE>
<DD>
<A NAME="IDX1345"></A>
Ассоциативный список синтаксических символов и их сдвигов.  Вы не должны
менять его прямо, делайте это через <CODE>c-set-offset</CODE>.
See section <A HREF="emacs_27.html#SEC262">Изменение стиля отступов</A>, для подробностей.

<DT><CODE>c-style-alist</CODE>
<DD>
<A NAME="IDX1346"></A>
Переменная для определения стилей отступов; смотрите ниже.

<DT><CODE>c-basic-offset</CODE>
<DD>
<A NAME="IDX1347"></A>
Базовый сдвиг, используемый символами <CODE>+</CODE> и <CODE>-</CODE> в
<CODE>c-offsets-alist</CODE>.

<DT><CODE>c-special-indent-hook</CODE>
<DD>
<A NAME="IDX1348"></A>
Ловушка для специальных подстроек отступов, определяемых пользователем.
Эта ловушка вызывается после того, как в строке уже сделан отступ
режимом C или родственным с ним режимом.
</DL>

<P>
  Переменная <CODE>c-style-alist</CODE> задает предопределенные стили
отступов.  Каждый элемент имеет форму <CODE>(<VAR>имя</VAR>
<VAR>установка-переменной</VAR>...)</CODE>, где <VAR>имя</VAR> -- это имя стиля.
Каждая <VAR>установка-переменной</VAR> имеет форму <CODE>(<VAR>переменная</VAR>
. <VAR>значение</VAR>)</CODE>; <VAR>переменная</VAR> -- это одна из настроечных
переменных, используемых режимом C, а <VAR>значение</VAR> -- это значение
для этой переменной, когда используется выбранный стиль.


<P>
  Когда <VAR>переменная</VAR> равна <CODE>c-offsets-alist</CODE>, это особый
случай: <VAR>значение</VAR> добавляется в начало значения
<CODE>c-offsets-alist</CODE>, а не замещает его.  Следовательно,
<VAR>значение</VAR> не обязано указывать каждый синтаксический символ ---
можно написать только те, для которых стиль отличен от принимаемого по
умолчанию.


<P>
  Отступы строк, содержащих только комментарии, также подвержены влиянию
переменной <CODE>c-comment-only-line-offset</CODE> (see section <A HREF="emacs_27.html#SEC296">Комментарии в режимах C</A>).




<H4><A NAME="SEC265" HREF="emacs_toc.html#TOC265">Стили отступов в Си</A></H4>
<P>
<A NAME="IDX1349"></A>
<A NAME="IDX1350"></A>


<P>
  <EM>Стиль Си</EM> -- это набор настроек стиля отступов.  Emacs
поставляется с несколькими предопределенными стилями отступов для C и
родственных режимов, включая <CODE>gnu</CODE>, <CODE>k&#38;r</CODE>, <CODE>bsd</CODE>,
<CODE>stroustrup</CODE>, <CODE>linux</CODE>, <CODE>python</CODE>, <CODE>java</CODE>,
<CODE>whitesmith</CODE>, <CODE>ellemtel</CODE> и <CODE>cc-mode</CODE>.  По умолчанию
применяется стиль <CODE>gnu</CODE>.


<P>
<A NAME="IDX1351"></A>
<A NAME="IDX1352"></A>
  Чтобы выбрать нужный вам стиль, используйте команду <KBD>M-x
c-set-style</KBD>.  Задавайте имя стиля в качестве аргумента (регистр не
имеет значения).  Выбранный стиль применяется только к новым буферам, но
не к тем, что вы уже редактируете.  Вы также можете установить
переменную <CODE>c-default-style</CODE>, чтобы указать стиль для различных
основных режимов.  Ее значением должен быть ассоциативный список, где
каждый элемент задает один основной режим и стиль отступов, который для
него нужно использовать.  Например,
  

<PRE>
(setq c-default-style
      '((java-mode . "java") (other . "gnu")))
</PRE>

<P>
определяет явный выбор для режима Java и велит принимать стиль
<SAMP>`gnu'</SAMP> по умолчанию для остальных C-подобных режимов.


<P>
<A NAME="IDX1353"></A>
  Чтобы определить новый стиль отступов в Си, вызовите функцию
<CODE>c-add-style</CODE>:



<PRE>
(c-add-style <VAR>имя</VAR> <VAR>значения</VAR> <VAR>применить-сразу</VAR>)
</PRE>

<P>
Здесь <VAR>имя</VAR> -- это имя нового стиля (строка), а <VAR>значения</VAR> ---
это ассоциативный список, чьи элементы имеют форму
<CODE>(<VAR>переменная</VAR> . <VAR>значение</VAR>)</CODE>.  Задаваемые вами переменные
должны быть среди описанных в этом руководстве (see section <A HREF="emacs_27.html#SEC264">Переменные, управляющие отступами в Си</A>).


<P>
Если <VAR>применить-сразу</VAR> не равна <CODE>nil</CODE>, <CODE>c-add-style</CODE>
переключает в новый стиль сразу после его определения.




<H2><A NAME="SEC266" HREF="emacs_toc.html#TOC266">Автоматическое отображение парных скобок</A></H2>
<P>
<A NAME="IDX1354"></A>
<A NAME="IDX1355"></A>


<P>
  Способность Emacs находить парные скобки предназначается для того,
чтобы автоматически показывать, как скобки в тексте соответствуют друг
другу.  Всякий раз, когда вы набираете самовставляющийся знак, который
является закрывающим ограничителем, курсор на мгновение передвигается в
положение соответствующего открывающего ограничителя, при условии, что
он находится на экране.  Если его нет на экране, то в эхо-области
показывается немного текста, начинающегося с открывающего ограничителя.
В любом случае вы можете сказать, какая группа закрывается.


<P>
  В Лиспе автоматическое соответствие применяется только к круглым
скобкам.  В Си оно применяется также к фигурным и квадратным скобкам.
Emacs узнает, какие знаки рассматривать как парные ограничители,
основываясь на синтаксической таблице, которая устанавливается основным
режимом.  See section <A HREF="emacs_36.html#SEC469">Синтаксическая таблица</A>.


<P>
  Если отрывающий и закрывающий ограничители не соответствуют друг
другу, как например в <SAMP>`[x)'</SAMP>, в эхо-области появляется
предупреждающее сообщение.  Правильные пары описываются в синтаксической
таблице.


<P>
<A NAME="IDX1356"></A>
<A NAME="IDX1357"></A>
<A NAME="IDX1358"></A>
  Отображением парных скобок управляют три переменные.
<CODE>blink-matching-paren</CODE> включает или выключает эту возможность;
<CODE>nil</CODE> выключает, а значение по умолчанию, равное <CODE>t</CODE>, включает
ее.  <CODE>blink-matching-delay</CODE> говорит, сколько секунд нужно ожидать;
по умолчанию это 1, но на некоторых системах полезно задать часть
секунды.  <CODE>blink-matching-paren-distance</CODE> указывает, сколько знаков
в обратном направлении надо исследовать, чтобы найти парный открывающий
ограничитель.  Если пара не будет найдена на таком расстоянии, то
сканирование останавливается и ничего не отображается.  Это делается для
того, чтобы избежать больших затрат времени на поиск парного
ограничителя в том случае, если пары не существует.  По умолчанию она
равна 12000.


<P>
<A NAME="IDX1359"></A>
<A NAME="IDX1360"></A>
  При использовании X Windows вы можете запросить более мощную
альтернативную разновидность автоматического показа парных скобок,
включив режим Show Paren.  Этот режим выключает обычный способ
отображения парных скобок и использует вместо него подсветку совпадений.
Когда точка находится после закрывающей скобки, подвечиваются эта
закрывающая скобка и парная ей открывающая; иначе, если точка находится
перед открывающей скобкой, подсвечивается парная скобка.  (Подсвечивать
открывающую скобку после точки не нужно, потому что поверх этого знака
находится курсор.)  Для включения и выключения этого режима используйте
команду <KBD>M-x show-paren-mode</KBD>.




<H2><A NAME="SEC267" HREF="emacs_toc.html#TOC267">Управление комментариями</A></H2>
<P>
<A NAME="IDX1361"></A>


<P>
  Поскольку комментарии являются весьма важной частью программирования,
Emacs предоставляет особые команды для редактирования и вставки
комментарев.




<H3><A NAME="SEC268" HREF="emacs_toc.html#TOC268">Команды для комментариев</A></H3>

<P>
<A NAME="IDX1362"></A>
<A NAME="IDX1363"></A>
<A NAME="IDX1364"></A>


<P>
  Команды комментариев вставляют, уничтожают и выравнивают комментарии:


<DL COMPACT>

<DT><KBD>M-;</KBD>
<DD>
Вставить или выровнять комментарий в текущей строке
(<CODE>indent-for-comment</CODE>).
<DT><KBD>C-x ;</KBD>
<DD>
Установить столбец комментария (<CODE>set-comment-column</CODE>).
<DT><KBD>C-u - C-x ;</KBD>
<DD>
Уничтожить комментарий в текущей строке (<CODE>kill-comment</CODE>).
<DT><KBD>C-M-j</KBD>
<DD>
Подобна <KBD>RET</KBD>, за которой следует вставка или выравнивание
комментария (<CODE>indent-new-comment-line</CODE>).
<DT><KBD>M-x comment-region</KBD>
<DD>
Добавить или удалить ограничители комментариев на всех строках области.
</DL>

<P>
  Команда, которая создает комментарии, называется <KBD>M-;</KBD>
(<CODE>indent-for-comment</CODE>).  Если на строке еще нет комментария, то
создается новый комментарий, выровненный по особому столбцу, называемому
<EM>столбцом комментария</EM>.  Комментарий создается вставкой строки, с
которой, как думает Emacs, должны начинаться комментарии (значение
<CODE>comment-start</CODE>, смотрите ниже).  Точка оставляется за этой
строкой.  Если текст в строке текста простирается дальше столбца
комментария, то делается отступ до подходящей границы (обычно
вставляется по крайней мере один пробел).  Если основной режим определил
строку, завершающую комментарий, то она вставляется после точки, чтобы
сохранить правильный синтаксис.


<P>
  <KBD>M-;</KBD> может быть использована также и для выравнивания
существующего комментария.  Если строка уже содержит начало комментария,
то <KBD>M-;</KBD> просто передвигает за него точку и делает отступ до
принятой позиции.  Исключение: комментарии, начинающиеся в столбце 0, не
сдвигаются.


<P>
  Некоторые основные режимы имеют особые правила отступа для некоторых
видов комментариев в определенных контекстах.  Например, в коде на
Лиспе, комментарии, начинающиеся с двойной точки с запятой, имеют отступ
такой же, как если бы они были строками кода, а не отступ до столбца
комментария.  Комментарии, начинающиеся с трех точек с запятой,
предполагается располагать с левой границы строки.  Emacs понимает эти
соглашения, выполняя отступ комментария с двойной точкой с запятой,
используя <KBD>TAB</KBD> и не изменяя отступ комментария с тройной точкой с
запятой вообще.



<PRE>
;; Эта просто пример функции
;;; Здесь годятся и 2, и 3 точки с запятой.
(defun foo (x)
;;; А теперь первая часть функции
  ;; Следующая строка добавляет единицу.
  (1+ x))           ; Эта строка добавляет единицу.
</PRE>

<P>
  Для комментария в коде на Си, которому на его строке предшествуют
только пробельные знаки, делается такой же отступ, как для строки кода.


<P>
  Даже когда существующий комментарий имеет правильный отступ, <KBD>M-;</KBD>
по-прежнему полезна для перехода сразу к началу комментария.


<P>
<A NAME="IDX1365"></A>
<A NAME="IDX1366"></A>
  Команда <KBD>C-u - C-x ;</KBD> (<CODE>kill-comment</CODE>) уничтожает комментарий
в текущей строке, если он там есть.  Отступ перед началом комментария
также уничтожается.  Если на этой строке нет комментария, то ничего не
делается.  Чтобы перенести комментарий в другую строку, передвиньтесь в
конец этой строки, сделайте <KBD>C-y</KBD> и затем <KBD>M-;</KBD>, чтобы заново
его выровнять.  Заметьте, что <KBD>C-u - C-x ;</KBD> -- это не отдельный
ключ; это <KBD>C-x ;</KBD> (<CODE>set-comment-column</CODE>) с отрицательным
аргументом.  Эта команда запрограммирована таким образом, что когда она
получает отрицательный аргумент, она вызывает <CODE>kill-comment</CODE>.
Однако, <CODE>kill-comment</CODE> -- это допустимая команда, которую вы
можете непосредственно привязать к ключу, если вы этого хотите.




<H3><A NAME="SEC269" HREF="emacs_toc.html#TOC269">Многострочные комментарии</A></H3>

<P>
<A NAME="IDX1367"></A>
<A NAME="IDX1368"></A>
<A NAME="IDX1369"></A>
  Если вы набираете комментарий и обнаруживаете, что хотели бы
продолжить его на другой строке, то вы можете использовать команду
<KBD>C-M-j</KBD> (<CODE>indent-new-comment-line</CODE>).  Она завершает набранный
вами комментарий, затем создает новую пустую строку и начинает новый
комментарий, с отступом под старым комментарием.  Когда действует режим
Auto Fill, то переход за столбец заполнения во время набора комментария
приводит к тому, что комментарий будет продолжаться именно таким
образом.  Если во время набора <KBD>C-M-j</KBD> точка находится не в конце
строки, то текст в оставшейся части строки становится частью новой
строки комментария.


<P>
<A NAME="IDX1370"></A>
  Чтобы превратить существующие строки в строки комментариев,
используйте команду <KBD>M-x comment-region</KBD>.  Она добавляет
ограничители к строкам, которые начинаются в области, делая их таким
образом комментариями.  С отрицательным аргуменом, она делает обратное
--- удаляет ограничители комментариев из строк области.


<P>
  С положительнм аргументом, <CODE>comment-region</CODE> повторяет последний
знак из добавляемой последовательности, начинающей комментарий.  Таким
образом, в режиме Lisp, <KBD>C-u 2 M-x comment-region</KBD> добавит <SAMP>`;;'</SAMP>
на каждую строку.  Повторение ограничителей комментария -- это способ
привлечения к нему внимания.  В Лиспе для получения правильных отступов
вы должны использовать аргумент, равный двум, между определениями
функций, и трем -- внутри определений функций.


<P>
<A NAME="IDX1371"></A>
  Переменная <CODE>comment-padding</CODE> указывает, сколько пробелов должна
вставить <CODE>comment-region</CODE> в каждую строку между ограничителем
комментария и изначальным текстом этой строки.  По умолчанию это 1.




<H3><A NAME="SEC270" HREF="emacs_toc.html#TOC270">Параметры управления комментариями</A></H3>

<P>
<A NAME="IDX1372"></A>
<A NAME="IDX1373"></A>
<A NAME="IDX1374"></A>
  Столбец комментария хранится в переменной <CODE>comment-column</CODE>.  Вы
можете явно установить ее на нужное число.  Или вы можете использовать
команду <KBD>C-x ;</KBD> (<CODE>set-comment-column</CODE>), которая устанавливает
столбец комментария равным тому столбцу, где находится точка.  <KBD>C-u
C-x ;</KBD> устанавливает столбец комментария так, чтобы он соответствовал
последнему комментарию перед точкой в этом буфере, и затем делает
<KBD>M-;</KBD>, чтобы выравнять строку текущего комментария под предыдущую.
Отметим, что <KBD>C-u - C-x ;</KBD> запускает функцию <CODE>kill-comment</CODE>,
как описано выше.


<P>
  Переменная <CODE>comment-column</CODE> -- это собственная переменная
каждого буфера: установка ее влияет только на текущий буфер, но
существует и значение по умолчанию, которое вы также можете изменить с
помощью <CODE>setq-default</CODE>.  See section <A HREF="emacs_36.html#SEC450">Локальные переменные</A>.  Многие
основные режимы инициализируют эту переменную для текущего буфера.


<P>
<A NAME="IDX1375"></A>
  Команды работы с комментариями распознают комментарии, основываясь на
регулярном выражении, которое является значением переменной
<CODE>comment-start-skip</CODE>.  Убедитесь, что это регулярное выражение не
соответствует пустой строке.  Оно может соответствовать чему-то
большему, чем просто ограничителю, начинающему комментарий, в самом
строгом значении этого слова; например, в режиме С значение этой
переменной равно <CODE>"/\\*+ *"</CODE>, что соответствует дополнительным
звездочкам и пробелам после самого <SAMP>`/*'</SAMP>.  (Обратите внимание,
<SAMP>`\\'</SAMP> требуется в синтаксисе Лиспа для того, чтобы включить в строку
<SAMP>`\'</SAMP>, которая нужна, чтобы отменить для первой звездочки ее
специальное значение в синтаксисе регулярных выражений.
See section <A HREF="emacs_17.html#SEC95">Синтаксис регулярных выражений</A>.)


<P>
<A NAME="IDX1376"></A>
<A NAME="IDX1377"></A>
  Когда команда для комментариев создает новый комментарий, она
вставляет в его начало значение <CODE>comment-start</CODE>.  Значение
<CODE>comment-end</CODE> вставляется после точки, так что оно будет следовать
за текстом, который вы вставите в этот комментарий.  В режиме С
<CODE>comment-start</CODE> имеет значение <CODE>"/* "</CODE>, а
<CODE>comment-end</CODE> имеет значение <CODE>" */"</CODE>.


<P>
<A NAME="IDX1378"></A>
 Переменная <CODE>comment-multi-line</CODE> управляет тем, как ведет себя
<KBD>C-M-j</KBD> (<CODE>indent-new-comment-line</CODE>) при использовании внутри
комментария.  Если <CODE>comment-multi-line</CODE> равна <CODE>nil</CODE>, как это
обычно и бывает, то комментарий на текущей строке завершается, а на
новой строке начинается новый комментарий.  Если
<CODE>comment-multi-line</CODE> отлична от <CODE>nil</CODE>, то новая следующая
строка подготавливается как часть того же самого комментария, который
находился на первой строке.  Это выполняется следующим образом: в старой
строке не вставляется ограничитель комментария, и в новую строку не
вставляеся начало комментария.  В тех языках, где работают многострочные
комментарии, выбор значений для этой переменной -- дело вашего вкуса.


<P>
<A NAME="IDX1379"></A>
  Переменная <CODE>comment-indent-function</CODE> должна содержать функцию,
которая будет вызываться для подсчета отступа во вновь вставляемом
комментарии или для выравнивания существующего комментария.  Эта функция
вызывается без аргумента, но с точкой в начале комментария или в конце
строки, если вставляется новый комментарий.  Она должна возвратить номер
столбца, в котором должен начинаться комментарий.  Например, в режиме
Lisp эта функция-ловушка для создания отступа основывает свое решение на
том, сколько точек с запятой начинают существующий комментарий, и на
коде в предыдущих строках.




<H2><A NAME="SEC271" HREF="emacs_toc.html#TOC271">Редактирование без разбалансированных скобок</A></H2>

<P>
@hyphenation{s-вы-ра-же-ний}
<DL COMPACT>

<DT><KBD>M-(</KBD>
<DD>
Поставить скобки вокруг следующего s-выражения (или s-выражений)
(<CODE>insert-parentheses</CODE>).
<DT><KBD>M-)</KBD>
<DD>
Передвинуться через следующую закрывающую скобку и сделать новый отступ
(<CODE>move-past-close-and-reindent</CODE>).
</DL>

<P>
<A NAME="IDX1380"></A>
<A NAME="IDX1381"></A>
<A NAME="IDX1382"></A>
<A NAME="IDX1383"></A>
  Команды <KBD>M-(</KBD> (<CODE>insert-parentheses</CODE>) и <KBD>M-)</KBD>
(<CODE>move-past-close-and-reindent</CODE>) созданы для облегчения такого вида
редактирования, при котором скобки всегда остаются сбалансированными.
<KBD>M-(</KBD> вставляет пару скобок, либо вместе, как в <SAMP>`()'</SAMP>, либо,
если задан аргумент, вокруг следующих нескольких s-выражений, и
оставляет точку после открытой скобки.  Точка остается после открывающей
скобки.  Команда <KBD>M-)</KBD> перемещается через закрывающую скобку, удаляя
любой предшествующий ей отступ и делая после нее отступ при помощи
<KBD>C-j</KBD>.


<P>
  Например, вместо набора <KBD>( F O O )</KBD>, вы можете набрать <KBD>M-( F
O O</KBD>, что имеет тот же самый эффект, за исключением того, что курсор
остается перед закрывающей скобкой.


<P>
<A NAME="IDX1384"></A>
  <KBD>M-(</KBD> может вставлять перед открывающей скобкой пробел в
зависимости от синтаксического класса предыдущего знака.  Установите
<CODE>parens-require-spaces</CODE> в значение <CODE>nil</CODE>, если вы хотите
подавить это.




<H2><A NAME="SEC272" HREF="emacs_toc.html#TOC272">Завершение для имен символов</A></H2>
<P>
<A NAME="IDX1385"></A>


<P>
  Обычно завершение происходит в минибуфере.  Но один из видов
завершения доступен во всех буферах: завершение для имен символов.


<P>
<A NAME="IDX1386"></A>
  <KBD>M-<KBD>TAB</KBD></KBD> (<CODE>lisp-complete-symbol</CODE>) запускает команду,
завершающую частично набранный символ перед точкой, используя множество
имен символов, имеющих смысл в этом контексте.  Все дополняющие знаки,
определяемые по частичному имени, вставляются в точке.


<P>
  Если частичное имя в буфере имеет более одного возможного завершения,
и у них нет общих дополняющих знаков, в другом окне показывается
перечень всех возможных завершений.


<P>
<A NAME="IDX1387"></A>
<A NAME="IDX1388"></A>
<A NAME="IDX1389"></A>
<A NAME="IDX1390"></A>
  В большинстве основных режимов для языков программирования,
<KBD>M-<KBD>TAB</KBD></KBD> запускает команду <CODE>complete-symbol</CODE>, которая
предоставляет два типа завершения.  Обычно она делает завершения,
основываясь на таблице тегов (see section <A HREF="emacs_27.html#SEC276">Таблицы тегов</A>); с числовым аргументом
(независимо от его зачения), она делает завершение, основываясь на
именах, перечисленных в указателе понятий в Info-файле для этого языка.
Поэтому чтобы завершить имя символа, определенного в вашей собственной
программе, используйте <KBD>M-<KBD>TAB</KBD></KBD> без аргумента; чтобы завершить
имя стандартной библиотечной функции, используйте <KBD>C-u M-<KBD>TAB</KBD></KBD>.
Конечно, основанное на Info завершение работает, только если есть
Info-файл для стандартной библиотеки функций вашего языка, и только если
он установлен в вашей системе.


<P>
<A NAME="IDX1391"></A>
<A NAME="IDX1392"></A>
<A NAME="IDX1393"></A>
  В режиме Emacs-Lisp пространство имен для завершения обычно состоит из
нетривиальных символов, присутствующих в данный момент в Emacs -- тех,
что имеют определение функции, значение или свойства.  Однако, если
непосредственно перед началом частичного символа есть открывающая
скобка, в качестве завершений рассматриваются только символы с
определением функции.  Команда, реализующая это, называется
<CODE>lisp-complete-symbol</CODE>.


<P>
  В режиме Text и родственных с ним, <KBD>M-<KBD>TAB</KBD></KBD> завершает слова,
основываясь на словаре программы проверки правописания.
See section <A HREF="emacs_18.html#SEC107">Поиск и исправление орфографических ошибок</A>.




<H2><A NAME="SEC273" HREF="emacs_toc.html#TOC273">Режим Which Function</A></H2>

<P>
  Режим Which Function -- это второстепенный режим, который показывает
в строке режима имя текущей функции по мере того, как вы передвигаетесь
по буферу.


<P>
<A NAME="IDX1394"></A>
<A NAME="IDX1395"></A>
  Чтобы включить (или выключить) режим Which Function, используйте
команду <KBD>M-x which-function-mode</KBD>.  Это глобальная команда; она
применяется ко всем буферам, как к существующим, так и к тем, что еще
будут созданы.  Однако, это затрагивает только определенные основные
режимы, перечисленные в значении <CODE>which-func-modes</CODE>.  (Если это
значение <CODE>t</CODE>, то режим Which Function применяется ко всем основным
режимам, которые знают, как это поддерживается -- к основным режимам,
поддерживающим Imenu.)




<H2><A NAME="SEC274" HREF="emacs_toc.html#TOC274">Команды документации</A></H2>

<P>
  Когда вы редактируете код на Лиспе, предназначенный для запуска в
Emacs, вы можете использованы команды <KBD>C-h f</KBD>
(<CODE>describe-function</CODE>) и <KBD>C-h v</KBD> (<CODE>describe-variable</CODE>) для
печати документации о функциях и переменных, которые вы хотите вызвать.
Эти команды используют минибуфер для считывания имени функции или
переменной и показывают документацию в окне.


<P>
  Для большего удобства эти команды предоставляют аргументы по
умолчанию, основанные на коде в окрестности точки.  <KBD>C-h f</KBD>
устанавливает значение по умолчанию равным функции, вызванной в списке
самого глубокого уровня, содержащем точку.  <KBD>C-h v</KBD> использует в
качестве значения по умолчанию имя символа, находящегося вокруг или
рядом с точкой.


<P>
<A NAME="IDX1396"></A>
<A NAME="IDX1397"></A>
<A NAME="IDX1398"></A>
  Для кода на Emacs Lisp вы также можете использовать режим Eldoc.  Этот
второстепенный режим постоянно показывает в эхо-области список
аргументов для функции, которая вызывается в точке.  (Другими словами,
он находит вызов функции, который содержит точку, и показывает список
аргументов этой функции.)  Режим Eldoc применим только к режимам Emacs
Lisp и Lisp Interaction.  Для включения и выключения этого режима
используйте команду <KBD>M-x eldoc-mode</KBD>.


<P>
<A NAME="IDX1399"></A>
<A NAME="IDX1400"></A>
<A NAME="IDX1401"></A>
  Для Си, Лиспа и других языков вы можете использовать <KBD>C-h C-i</KBD>
(<CODE>info-lookup-symbol</CODE>), чтобы просмотреть документацию Info по
какому-то символу.  Вы задаете символ в минибуфере; по умолчанию берется
символ, находящийся в буфере в точке.  Где искать документацию по
символам -- в каких Info-файлах и каких именных указателях ---
определяет основной режим.  Вы можете также использовать <KBD>M-x
info-lookup-file</KBD> для нахождения документации для имени файла.


<P>
<A NAME="IDX1402"></A>
  Вы можете прочитать "страницу man" для команды операционной системы,
библиотечной функции или системного вызова с помощью команды <KBD>M-x
manual-entry</KBD>.  Для форматирования страницы она запускает программу
@command{man} и, если позволяет ваша операционная система, делает это
асинхронно, чтобы вы могли продолжать редактирование, пока страница
форматируется.  (MS-DOS и MS-Windows 3 не допускают асинхронных
подпроцессов, так что на этих системах вы не можете редактировать, когда
Emacs ожидает, пока @command{man} закончит работу.)  Результат
направляется в буфер с именем <TT>`*Man <VAR>тема</VAR>*'</TT>.  Эти буферы
используют особый основной режим, режим Man, который облегчает прокрутку
и просмотр других страниц man.  Для получения подробностей наберите
<KBD>C-h m</KBD> в буфере страницы man.


<P>
<A NAME="IDX1403"></A>
  Для длинных страниц правильная установка начертаний может занять
значительное время.  По умолчанию Emacs использует в страницах man
начертания, если может показывать разные шрифты или цвета.  Вы можете
выключить использование разных начертаний в страницах man, установив
переменную <CODE>Man-fontify-manpage-flag</CODE> равной <CODE>nil</CODE>.


<P>
<A NAME="IDX1404"></A>
  Если вы вставите текст страницы man в буфер Emacs каким-то другим
способом, вы можете использовать команду <KBD>M-x Man-fontify-manpage</KBD>,
чтобы произвести те же преобразования, что делает <KBD>M-x
manual-entry</KBD>.


<P>
  Проект GNU надеется когда-нибудь заменить большинство страниц man на
лучше организованные руководства, которые вы можете просматривать с
помощью Info.  See section <A HREF="emacs_12.html#SEC54">Другие команды для получения справки</A>.  Поскольку этот процесс завершен
лишь частично, читать страницы man все еще полезно.




<H2><A NAME="SEC275" HREF="emacs_toc.html#TOC275">Журналы изменений</A></H2>

<P>
<A NAME="IDX1405"></A>
<A NAME="IDX1406"></A>
<A NAME="IDX1407"></A>
<A NAME="IDX1408"></A>
  Команда Emacs <KBD>C-x 4 a</KBD> добавляет в журнал изменений новую запись
для файла, который вы редактируете
(<CODE>add-change-log-entry-other-window</CODE>).


<P>
  Файл журнала изменений содержит хронологическое описание того, почему
и когда вы изменяли программу, состоящее из последовательности записей,
описывающих отдельные изменения.  Как правило оно хранится в файле с
именем <TT>`ChangeLog'</TT> в том же самом каталоге, в котором находится
файл, который вы редактируете, или в одном из его родительских
каталогов.  Единственный файл <TT>`ChangeLog'</TT> может записывать
изменения для всех файлов в его каталоге и во всех его подкаталогах.


<P>
  Запись в журнале изменений начинается со строки заголовка, которая
содержит ваше имя, ваш адрес электронной почты (получаемый из
переменной <CODE>user-mail-address</CODE>) и текущую дату и время.  Кроме этих
строк заголовка, каждая строка в журнале изменений начинается с пробела
или табуляции.  Основная часть записи состоит из <EM>пунктов</EM>, каждый
из которых начинается со строки, начинающейся с пропуска и звездочки.
Вот пример двух записей, обе датированы маем 1993 года и обе содержат
два пункта:



<PRE>
1993-05-25  Richard Stallman  &#60;rms@gnu.org&#62;

        * man.el: Rename symbols `man-*' to `Man-*'.
        (manual-entry): Make prompt string clearer.

        * simple.el (blink-matching-paren-distance):
        Change default to 12,000.

1993-05-24  Richard Stallman  &#60;rms@gnu.org&#62;

        * vc.el (minor-mode-map-alist): Don't use it if it's void.
        (vc-cancel-version): Doc fix.
</PRE>

<P>
(Предыдущие версии Emacs использовали другой формат даты.)


<P>
  Одна запись может описывать несколько изменений; каждое изменение
должно описываться в отдельном пункте.  Обычно между пунктами должна
быть пустая строка.  Когда пункты связаны между собой (части одного
изменения в разных местах), группируйте их, не оставляя между ними
пустую строку.  Вторая запись выше содержит два пункта, сгруппированных
таким способом.


<P>
  <KBD>C-x 4 a</KBD> обращается к файлу журнала изменений и создает новую
запись, если только последний по времени пункт не датирован сегодняшним
днем и не несет ваше имя.  Также она создает новый пункт для текущего
файла.  Для многих языков она может даже предположить имя измененной
функции или объекта.


<P>
<A NAME="IDX1409"></A>
<A NAME="IDX1410"></A>
<A NAME="IDX1411"></A>
  К файлу журнала изменений обращаются в режиме Change Log.  В этом
основном режиме каждая связка сгруппированных пунктов считается одним
абзацем, а каждая запись считается страницей.  Это облегчает
редактирование записей.  <KBD>C-j</KBD> и автоматическое заполнение делают в
каждой новой строке такой же отступ, как в предыдущей; это удобно для
ввода содержимого записей.


<P>
  Системы управления версиями дают другой способ отслеживания изменений
в вашей программе и ведения журнала изменений.  See section <A HREF="emacs_19.html#SEC131">Буфер журнальной записи</A>.




<H2><A NAME="SEC276" HREF="emacs_toc.html#TOC276">Таблицы тегов</A></H2>
<P>
<A NAME="IDX1412"></A>


<P>
  <EM>Таблица тегов</EM> -- это описание того, как многофайловая программа
разбивается на файлы.  Она перечисляет имена файлов-компонентов и имена
и позиции функций (или других именованных подъединиц) в каждом файле.
Объединение связанных файлов делает возможным поиск или замену во всех
файлах с помощью одной команды.  Запись имен функций и позиций делает
возможной команду <KBD>M-.</KBD>, которая находит определение, отыскивая
сведения о том, в каком файле оно находится.


<P>
  Таблицы тегов хранятся в файлах, именуемых <EM>файлами таблиц тегов</EM>.
Общепринятое имя для файла таблицы тегов -- <TT>`TAGS'</TT>.


<P>
  Каждый элемент в таблице тегов записывает имя одного тега, имя файла,
в котором этот тег определен (явно), и местоположение определения тега в
этом файле.


<P>
  Какие именно имена из описанных файлов записываются в таблице тегов,
зависит от языка программирования описанного файла.  Обычно они включают
все функции и подпрограммы, могут также включать глобальные переменные,
типы данных и что-нибудь еще относящееся к делу.  Каждое записанное имя
называется <EM>тегом</EM>.




<H3><A NAME="SEC277" HREF="emacs_toc.html#TOC277">Синтаксис тегов исходного файла</A></H3>

<P>
  В наиболее популярных языках синтаксис тегов определяется следующим
образом:



<UL>
<LI>

В программе на Си, любая функция Си или typedef -- это тег, тегом
являются и определения <CODE>struct</CODE>, <CODE>union</CODE> и <CODE>enum</CODE>.
Определения макросов (<CODE>#define</CODE>) и констант (<CODE>enum</CODE>) также
являются тегами, если только вы не задали при создании таблицы тегов
ключ @option{--no-defines}.  Аналогично, тегами являются глобальные
переменные, если только вы не задали ключ @option{--no-globals}.
Использование @option{--no-globals} и @option{--no-defines} может
сделать файлы таблиц тегов гораздо меньше.

<LI>

В коде на Си++, помимо всех тегов кода Си распознаются также
функции-члены и, возможно, переменные-члены, если вы используете ключ
@option{--members}.  Теги для переменных и функций в классах именуются
как <SAMP>`<VAR>класс</VAR>::<VAR>переменная</VAR>'</SAMP> и
<SAMP>`<VAR>класс</VAR>::<VAR>функция</VAR>'</SAMP>.

<LI>

В коде на Java, теги включают все конструкции, распознаваемые в Си++
плюс конструкции <CODE>extends</CODE> и <CODE>implements</CODE>.  Теги для
переменных и функций в классах именуются как
<SAMP>`<VAR>класс</VAR>.<VAR>переменная</VAR>'</SAMP> и <SAMP>`<VAR>класс</VAR>.<VAR>функция</VAR>'</SAMP>.

<LI>

В тексте для LaTeX, тегами служат аргументы каждой из команд
<CODE>\chapter</CODE>, <CODE>\section</CODE>, <CODE>\subsection</CODE>,
<CODE>\subsubsection</CODE>, <CODE>\eqno</CODE>, <CODE>\label</CODE>, <CODE>\ref</CODE>,
<CODE>\cite</CODE>, <CODE>\bibitem</CODE>, <CODE>\part</CODE>, <CODE>\appendix</CODE>,
<CODE>\entry</CODE> или <CODE>\index</CODE>.

Другие команды тоже могут создавать теги, если вы укажете их в
переменной среды @env{TEXTAGS} перед вызовом @command{etags}.  Значением
этой переменной среды должен быть разделенный двоеточиями список имен
команд.


<PRE>
TEXTAGS="def:newcommand:newenvironment"
export TEXTAGS
</PRE>

задает (с использованием синтаксиса Bourne shell), что команды
<SAMP>`\def'</SAMP>, <SAMP>`\newcommand'</SAMP> и <SAMP>`\newenvironment'</SAMP> также
определяют теги.

<LI>

В коде на Лиспе любая функция, определенная через <CODE>defun</CODE>, любая
переменная, определенная через <CODE>defvar</CODE> или <CODE>defconst</CODE>, и
вообще первый аргумент любого выражения, которое начинается с
<SAMP>`(def'</SAMP> в нулевом столбце, являются тегом.

<LI>

В коде на Scheme теги включают все определяемое с помощью <CODE>def</CODE> или
конструкции, чье имя начинается с <SAMP>`def'</SAMP>.  Они также включают
переменные, установленные с помощью <CODE>set!</CODE> на верхнем уровне файла.
</UL>

<P>
  Поддерживаются также несколько других языков:



<UL>
<LI>

В коде ассемблера, теги -- это метки, появляющиеся в начале строки, за
которыми идет двоеточие.

<LI>

Во входных файлах Bison или Yacc каждое правило определяет
конструируемый им нетерминал как тег.  Части файла, содержащие код на
Си, анализируются как код Си.

<LI>

В коде на Cobol тегами служат имена параграфов; то есть любые слова,
которые начинаются в столбце 8, и после которых стоит точка.

<LI>

В коде на Erlang тегами служат определенные в файле функции, записи и
макросы.

<LI>

В Фортран-коде тегами являются функции, подпрограммы и блоки данных.

<LI>

В коде на Паскале тегами будут определенные в файле функции и процедуры.

<LI>

В коде на Perl тегами являются процедуры, определяемые ключевым словом
<CODE>sub</CODE>.

<LI>

В коде на Postscript тегами являются функции.

<LI>

В коде на Прологе теги появляются на левой границе.
</UL>

<P>
  Вы также можете генерировать теги, основываясь на сопоставлении
регулярных выражений (see section <A HREF="emacs_27.html#SEC278">Создание таблицы тегов</A>), чтобы обработать
другие форматы и языки.




<H3><A NAME="SEC278" HREF="emacs_toc.html#TOC278">Создание таблицы тегов</A></H3>
<P>
<A NAME="IDX1413"></A>


<P>
  Для создания файла таблицы тегов используется программа
@command{etags}.  Она знает несколько языков, как описано в
предыдущем разделе.
@command{etags} запускается следующим образом:



<PRE>
etags <VAR>входные-файлы</VAR>...
</PRE>

<P>
Программа @command{etags} считывает указанные файлы и записывает таблицу
тегов под именем <TT>`TAGS'</TT> в текущем рабочем каталоге.
@command{etags} распознает язык, используемый во входном файле,
основываясь на имени этого файла и его содержании.  Вы можете указать
язык с помощью ключа <SAMP>`--language=<VAR>имя</VAR>'</SAMP>, описанного ниже.


<P>
  Если данные таблицы тегов становятся устаревшими из-за изменений в
описанных в таблице файлах, то таблица тегов обновляется тем же
способом, что был применен для ее начального создания.  Нет
необходимости делать это часто.


<P>
  Если таблица тегов не в состоянии записать тег или записывает его не
для того файла, то Emacs может не найти его определение.  Однако, если
позиция, записанная в таблицу тегов, становится немного неверной (из-за
некоторого редактирования в файле, в котором находится определение этого
тега), то единственным следствием будет слегка замедленный поиск тега.
Даже если хранящаяся позиция совсем неправильна, Emacs все-таки найдет
тег, но для этого он должен будет обследовать весь файл.


<P>
  Таким образом, вам нужно обновлять таблицу тегов, когда вы определяете
новые теги, которые вы хотите внести в список, или когда вы перемещаете
определения тегов из одного файла в другой, или когда изменения
становятся существенными.  Обычно нет нужды обновлять таблицу тегов
после каждого редактирования или даже каждый день.


<P>
  Одна таблица тегов может как бы включать другую.  Имя включаемого
файла тегов указывается с помощью ключа <SAMP>`--include=<VAR>файл</VAR>'</SAMP> при
создании включающего файла.  Последний файл затем ведет себя так, как
если бы он содержал все файлы, заданные во включенном файле, так же как
и те файлы, которые он содержит непосредственно.


<P>
  Если при запуске @command{etags} вы зададите исходные файлы по
относительным именам, файл тегов будет содержать имена файлов,
относительные к каталогу, в котором этот файл тегов был изначально
записан.  Тогда вы сможете переместить все дерево каталогов, содержащее
и файл тегов, и исходные файлы, и файл тегов все равно будет правильно
ссылаться на исходные файлы.


<P>
 Если в качестве аргументов @command{etags} вы зададите абсолютные имена
файлов, то файл тегов будет содержать абсолютные имена.  Тогда файл
тегов будет так же ссылаться на те же исходные файлы, даже если вы
переместите его, до тех пор, пока исходные файлы остаются на старом
месте.  Абсолютные имена файлов начинаются с <SAMP>`/'</SAMP>, или с
<SAMP>`<VAR>устройство</VAR>:/'</SAMP> в MS-DOS и MS-Windows.


<P>
  Когда вы хотите создать таблицы тегов для очень большого числа файлов,
у вас могут возникнуть проблемы с их перечислением в командной строке,
поскольку некоторые системы накладывают ограничение на ее длину.
Простейший способ обойти это ограничение -- сказать @command{etags}
считывать имена файлов со стандартного ввода, набрав дефис на месте имен
файлов, как здесь:



<PRE>
find . -name "*.[chCH]" -print | etags -
</PRE>

<P>
  Используйте ключ @option{--language=<VAR>имя</VAR>} для явного указания
языка.  Вы можете перемешивать эти ключи с именами файлов; каждый
относится к имена файла, которое следует за ним.  Задайте
@option{--language=auto}, чтобы велеть @command{etags} продолжать самой
предполагать язык по имени и содержимому файла.  Задайте
@option{--language=none}, чтобы полностью выключить специфичную для
языка обработку; тогда @command{etags} распознает теги только по
сопоставлению с регулярным выражением.  <SAMP>`etags --help'</SAMP> печатает
перечень языков, которые знает @command{etags}, и правила предположения
языка по имени файла.


<P>
  Ключ @option{--regex} предоставляет общий способ распознавания тегов,
основаный на сопоставлении с регулярным выражением.  Вы можете свободно
перемешивать эти ключи с именами файлов.  Каждый ключ @option{--regex}
добавляется к предшествующим и применяется только к последующим файлам.
Синтаксис таков:



<PRE>
--regex=/<VAR>regexp-тег</VAR>[/<VAR>regexp-имя</VAR>]/
</PRE>

<P>
где <VAR>regexp-тег</VAR> используется для нахождения строк тегов.  Оно
всегда зацепленное, то есть ведет себя так, как если бы в начале стояло
<SAMP>`^'</SAMP>.  Если вы хотите учесть отступы, просто назовите совпадением
произвольное количество пропусков, начав ваше регулярное выражение с
<SAMP>`[ \t]*'</SAMP>.  Знак <SAMP>`\'</SAMP> в регулярных выражениях экранирует
следующий знак, а <SAMP>`\t'</SAMP> обозначает символ табуляции.  Обратите
внимание, @command{etags} не обрабатывает другие управляющие
последовательности Си для специальных знаков.


<P>
<A NAME="IDX1414"></A>
   @command{etags} придерживается того же синтаксиса регулярных
выражений, что и Emacs, но с введением <EM>оператора интервала</EM>,
который работает как в @command{grep} и @command{ed}.  Синтаксис
оператора интервала такой: <SAMP>`\{<VAR>m</VAR>,<VAR>n</VAR>\}'</SAMP>, это означает,
что нужно найти совпадение с предыдущим выражением по меньшей мере
<VAR>m</VAR> раз и вплоть до <VAR>n</VAR> раз.


<P>
  <VAR>regexp-тег</VAR> не должно совпадать с большим числом знаков, чем это
необходимо для распознавания нужного вам тега.  Если соответствие
таково, что <VAR>regexp-тег</VAR> неизбежно совпадает с большим, чем нужно,
числом знаков, вы можете найти полезным добавить <VAR>regexp-имя</VAR>, чтобы
сузить область тега.  Вы можете найти примеры ниже.


<P>
  Ключ @option{-R} удаляет все регулярные выражения, определенные
ключами @option{--regex}.  Он применяется к следующим за ним именам
файлов, как вы можете видеть из следующего примера:



<PRE>
etags --regex=/<VAR>reg1</VAR>/ voo.doo --regex=/<VAR>reg2</VAR>/ \
    bar.ber -R --lang=lisp los.er
</PRE>

<P>
Здесь @command{etags} выбирает язык для анализа <TT>`voo.doo'</TT> и
<TT>`bar.ber'</TT> в соответствии с их содержимым.  @command{etags} также
использует <VAR>reg1</VAR> для распознавания дополнительных тегов в
<TT>`voo.doo'</TT> и оба выражения <VAR>reg1</VAR> и <VAR>reg2</VAR> для распознавания
дополнительных тегов в <TT>`bar.ber'</TT>.  Для распознавания тегов в
<TT>`los.er'</TT> @command{etags} использует правила тегов для Лиспа и не
использует регулярные выражения.


<P>
  Вот еще несколько примеров.  Регулярные выражения взяты в кавычки,
чтобы оболочка не интерпретировала их по-своему.



<UL>
<LI>

Сделать теги для макроса <CODE>DEFVAR</CODE> в исходных файлах Emacs:


<PRE>
--regex='/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/'
</PRE>

<LI>

Сделать теги для VHDL-файлов (этот пример -- одна строка, разбитая
здесь для правильного форматирования):


<PRE>
--language=none
--regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/'
--regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
\( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'
</PRE>

<LI>

Сделать теги для файлов на Tcl (этот последний пример показывает
использование аргумента <VAR>regexp-имя</VAR>):


<PRE>
--lang=none --regex='/proc[ \t]+\([^ \t]+\)/\1/'
</PRE>

</UL>

<P>
  Чтобы получить перечень других доступных ключей @command{etags},
выполните @command{etags --help}.




<H3><A NAME="SEC279" HREF="emacs_toc.html#TOC279">Выбор таблицы тегов</A></H3>

<P>
<A NAME="IDX1415"></A>
<A NAME="IDX1416"></A>
  Emacs хранит в каждый момент одну <EM>выбранную</EM> таблицу тегов, и все
команды для работы с таблицами тегов используют эту выбранную таблицу.
Чтобы выбрать таблицу тегов, наберите <KBD>M-x visit-tags-table</KBD>,
которая считает имя файла таблицы тегов как аргумент.  Имя <TT>`TAGS'</TT> в
каталоге по умолчанию используется как имя файла по умолчанию.


<P>
  Все, что делает эта команда, -- сохраняет имя файла в переменной
<CODE>tags-file-name</CODE>.  Emacs фактически не считывает содержимое таблицы
тегов до тех пор, пока вы не попытаетесь использовать его.
Самостоятельная установка этой переменной так же хороша, как и
использование <CODE>visit-tags-table</CODE>.  Начальное значение переменной
равно <CODE>nil</CODE>; это значение сообщает всем командам для работы с
таблицами тегов, что они должны запрашивать, какое имя файла таблицы
тегов надо использовать.


<P>
  Использование <CODE>visit-tags-table</CODE>, когда таблица тегов уже
загружена, дает вам выбор: вы можете добавить новую таблицу тегов к
текущему списку таких таблиц или начать новый список.  Команды работы с
тегами используют все таблицы тегов в текущем списке.  Если вы начинаете
новый список, новая таблица тегов используется <EM>вместо</EM> остальных.
Если вы добавляете новую таблицу тегов к текущему списку, она
используется <EM>вместе</EM> с остальными.  Когда команды работы с тегами
сканируют список таблиц тегов, они не всегда начинают с начала списка;
они начинают с первой таблицы, которая описывает текущий файл (если
такая есть), проходят далее до конца списка и затем просматривают список
с начала до тех пор, пока в нем не будут проверены все таблицы.


<P>
<A NAME="IDX1417"></A>
  Вы можете явно задать список таблиц тегов, установив переменную
<CODE>tags-table-list</CODE> в значение списка строк, как показано:



<PRE>
(setq tags-table-list
      '("~/emacs" "/usr/local/lib/emacs/src"))
</PRE>

<P>
Это заставляет команды, работающие с тегами, просматривать файлы
<TT>`TAGS'</TT> в каталогах <TT>`~/emacs'</TT> и
<TT>`/usr/local/lib/emacs/src'</TT>.  Порядок зависит от того, в каком файле
вы сейчас находитесь и какая таблица тегов упоминает этот файл, как
обяснено выше.


<P>
  Не установливайте переменные <CODE>tags-file-name</CODE> и
<CODE>tags-table-list</CODE> одновременно.




<H3><A NAME="SEC280" HREF="emacs_toc.html#TOC280">Поиск определения тега</A></H3>

<P>
  Самая важная вещь, которую вам позволяют делать таблицы тегов, -- это
поиск определения конкретного тега.


<DL COMPACT>

<DT><KBD>M-. <VAR>тег</VAR> <KBD>RET</KBD></KBD>
<DD>
Найти первое определение <VAR>тега</VAR> (<CODE>find-tag</CODE>).
<DT><KBD>C-u M-.</KBD>
<DD>
Найти следующее по очереди определение последнего заданного тега.
<DT><KBD>C-u - M-.</KBD>
<DD>
Вернуться к предыдущему найденному тегу.
<DT><KBD>C-M-. <VAR>образец</VAR> <KBD>RET</KBD></KBD>
<DD>
Найти тег, чье имя совпадает с <VAR>образцом</VAR> (<CODE>find-tag-regexp</CODE>).
<DT><KBD>C-u C-M-.</KBD>
<DD>
Найте следующий тег, чье имя совпадает с последним использованным
образцом.
<DT><KBD>C-x 4 . <VAR>тег</VAR> <KBD>RET</KBD></KBD>
<DD>
Найте первое определение <VAR>тега</VAR>, но показать его в другом окне
(<CODE>find-tag-other-window</CODE>).
<DT><KBD>C-x 5 . <VAR>тег</VAR> <KBD>RET</KBD></KBD>
<DD>
Найте первое определение <VAR>тега</VAR> и создать новый фрейм для выбора
буфера (<CODE>find-tag-other-frame</CODE>).
<DT><KBD>M-*</KBD>
<DD>
Вернуться к тому месту, где вы ранее вызвали <KBD>M-.</KBD> и товарищей.
</DL>

<P>
<A NAME="IDX1418"></A>
<A NAME="IDX1419"></A>
  <KBD>M-.</KBD> (<CODE>find-tag</CODE>) -- это команда для поиска определения
заданного тега.  Она ищет его по таблице тегов как строку и затем
использует эту информацию из таблицы тегов для того, чтобы определить
файл, в котором находится определение, и приблизительную положение
определения в файле.  Затем <CODE>find-tag</CODE> обращается к этому файлу,
передвигает точку в приблизительную позицию и начинает поиск определения
на постоянно возрастающем расстоянии.


<P>
  Если задается пустой аргумент (просто <KBD>RET</KBD>), то в качестве имени
тега, который надо найти, используется s-выражение, находящееся в буфере
перед или вокруг точки.  Для получения информации о s-выражениях
смотрите section <A HREF="emacs_27.html#SEC251">Списки и s-выражения</A>,


<P>
  Аргумент для <KBD>M-.</KBD> не обязан быть полным именем тега; достаточно
части.  Это возможно, потому что <KBD>M-.</KBD> находит в таблице теги,
которые содержат <VAR>тег</VAR> как построку.  Однако, она предпочитает
точное совпадение совпадению лишь построки.  Чтобы найти другие теги,
которые соответствуют той же подстроке, следует дать <CODE>find-tag</CODE>
числовой аргумент, как в <KBD>C-u M-.</KBD>; эта команда не считываает имя
тега, но продолжает поиск по тексту таблицы тегов другого тега,
содержащего самую последнюю использованную подстроку.  Если у вас есть
настоящая клавиша <KBD>META</KBD>, то <KBD>M-0 M-.</KBD> может служить более
простой альтернативой <KBD>C-u M-.</KBD>.


<P>
<A NAME="IDX1420"></A>
<A NAME="IDX1421"></A>
<A NAME="IDX1422"></A>
<A NAME="IDX1423"></A>
  Подобно большинству команд, которые могут переключать буферы,
<CODE>find-tag</CODE> имеет вариант, который показывает новый буфер в другом
окне, и еще один, который создает новый фрейм.  Первая команда -- это
<KBD>C-x 4 .</KBD>, которая вызывает функцию <CODE>find-tag-other-window</CODE>.
Вторая, <KBD>C-x 5 .</KBD>, вызывает <CODE>find-tag-other-frame</CODE>.


<P>
  Чтобы вернуться к местам, где вы недавно находили теги, используйте
<KBD>C-u - M-.</KBD>; в более общем виде, <KBD>M-.</KBD> с отрицательным числовым
аргументом.  Эта команда может перенести вас в другой буфер.  <KBD>C-x 4
.</KBD> с отрицательным аргументом находит предыдущее положение тега в другом
окне.


<P>
<A NAME="IDX1424"></A>
<A NAME="IDX1425"></A>
<A NAME="IDX1426"></A>
  Так же, как вы можете вернуться к местам, где вы недавно находили
теги, вы можете вернуться к местам, <EM>откуда</EM> вы их нашли.
Используйте для этого <KBD>M-*</KBD>, что вызывает команду
<CODE>pop-tag-mark</CODE>.  Типичное применение этих команд -- найти и
изучить определение чего-то с помощью <KBD>M-.</KBD> и затем вернуться к тому
месту, где вы были, с помощью <KBD>M-*</KBD>.


<P>
  И <KBD>C-u - M-.</KBD>, и <KBD>M-*</KBD> позволяют вам пошагово проходить назад
до глубины, определяемой переменной <CODE>find-tag-marker-ring-length</CODE>.


<P>
<A NAME="IDX1427"></A>
<A NAME="IDX1428"></A>
  Команда <KBD>C-M-.</KBD> (<CODE>find-tag-regexp</CODE>) обращается к тегам,
соответствующим заданному регулярному выражению.  Она похожа на
<KBD>M-.</KBD>, но производит сопоставление с регулярным выражением, а не со
строкой.




<H3><A NAME="SEC281" HREF="emacs_toc.html#TOC281">Поиск и замена при помощи таблиц тегов</A></H3>

<P>
  Команды этого раздела обращаются и просматривают все файлы,
перечисленные в выбранной таблице тегов, один за другим.  Таблица тегов
служит для этих команд только для того, чтобы определить
последовательность поиска в файлах.


<DL COMPACT>

<DT><KBD>M-x tags-search <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Поиск <VAR>regexp</VAR> во всех файлах в выбранной таблице тегов.
<DT><KBD>M-x tags-query-replace <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD> <VAR>замена</VAR> <KBD>RET</KBD></KBD>
<DD>
Осуществить <CODE>query-replace-regexp</CODE> в каждом файле в выбранной
таблице тегов.
<DT><KBD>M-,</KBD>
<DD>
Перезапустить одну из вышеупомянутых команд из текущего положения точки
(<CODE>tags-loop-continue</CODE>).
</DL>

<P>
<A NAME="IDX1429"></A>
  <KBD>M-x tags-search</KBD> считывает регулярное выражение, используя
минибуфер, затем ищет это регулярное выражение по очереди в каждом файле
из выбранной таблицы тегов.  Она показывает имя файла, который в данный
момент просматривается, таким образом, вы можете следить за ходом
поиска.  Как только определяется местонахождение, <CODE>tags-search</CODE>
возвращается.


<P>
<A NAME="IDX1430"></A>
<A NAME="IDX1431"></A>
  Найдя одно соответствие, вы, вероятно, захотите найти все остальные.
Чтобы найти еще одно соответствие, наберите <KBD>M-,</KBD>
(<CODE>tags-loop-continue</CODE>), это возобновит <CODE>tags-search</CODE>.  Эта
команда просматривает остаток текущего буфера и затем оставшиеся файлы
таблицы тегов.


<P>
<A NAME="IDX1432"></A>
  <KBD>M-x tags-query-replace</KBD> осуществляет во всех файлах в таблице
тегов единую замену регулярного выражения с подтверждением.  Она
считывает регулярное выражение, которое следует искать, и строку для
замены, точно так же, как обычная <KBD>M-x query-replace-regexp</KBD>.  Она
ищет очень похоже на <KBD>M-x tags-search</KBD>, но с повторами, обрабатывая
совпадения согласно вашему вводу.  See section <A HREF="emacs_17.html#SEC97">Команды замены</A>, более подробную
информацию о замене с подтверждением.


<P>
  Можно пройти по всем файлам в таблице тегов с помощью едиственного
вызова <KBD>M-x tags-query-replace</KBD>.  Но иногда бывает полезно временно
выйти, что вы можете сделать с помощью любого события ввода, не имеющего
особого смысла при замене с подтверждением.  Вы можете впоследствии
возобновить замену с подтверждением, набрав <KBD>M-,</KBD>; эта команда
возобновляет последнюю сделанную вами команду поиска или замены тегов.


<P>
  Команды этого раздела приводят к гораздо более широкому поиску, чем
семейство <CODE>find-tag</CODE>.  Команды <CODE>find-tag</CODE> ищут только
определения тегов, совпадающих с вашей подстрокой или регулярным
выражением.  Команды <CODE>tags-search</CODE> и <CODE>tags-query-replace</CODE>
находят каждое вхождение регулярного выражения, как делают в текущем
буфере обычные команды поиска и замены.


<P>
  Эти команды создают буферы только временно, для файлов, в которых они
должны делать поиск (для тех, к которым уже не обращается какой-нибудь
буфер Emacs).  Буферы, в которых нет совпадений, быстро уничтожаются;
остальные продолжают существовать.


<P>
  Вас, возможно, поразило, что <CODE>tags-search</CODE> очень похожа на
@command{grep}.  Вы можете также запустить саму @command{grep} как
подчиненную Emacs, и Emacs покажет вам совпадающие строки одну за
другой.  Это работает во многом похоже на запуск компиляции; обращение к
тем позициям в исходных файлах, где @command{grep} нашла совпадения,
работает как обращение к ошибкам компиляции.  See section <A HREF="emacs_28.html#SEC312">Запуск компиляторов в Emacs</A>.




<H3><A NAME="SEC282" HREF="emacs_toc.html#TOC282">Запросы к таблице тегов</A></H3>

<DL COMPACT>

<DT><KBD>M-x list-tags <KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>
<DD>
Показать список тегов, определенных в заданном <VAR>файле</VAR> с текстом
программы.
<DT><KBD>M-x tags-apropos <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Показать список всех тегов, соответствующих регулярному выражению
<VAR>regexp</VAR>.
</DL>

<P>
<A NAME="IDX1433"></A>
  <KBD>M-x list-tags</KBD> считывает имя одного из файлов, описанных в
выбранной таблице тегов, и показывает список всех тегов, определенных в
этом файле.  Аргумент "имя файла" фактически является просто строкой
для сравнения с именами, записанными в таблице тегов; он считывается как
строка, а не как имя файла.  Поэтому завершение и значение по умолчанию
невозможны, и вы должны вводить имя файла в том же самом виде, в котором
оно появляется в таблице тегов.  Не включайте каталог как часть имени
файла, если имя файла, записанного в таблице тегов, не включает каталог.


<P>
<A NAME="IDX1434"></A>
  <KBD>M-x tags-apropos</KBD> похожа на <CODE>apropos</CODE> для тегов
(see section <A HREF="emacs_12.html#SEC50">Поиск по контексту</A>).  Она считывает регулярное выражение,
затем находит все теги в выбранной таблице тегов, чьи вхождения
соответствуют этому регулярному выражению, и показывает найденные имена
тегов.


<P>
  Вы также можете производить в буфере завершение в пространстве имен,
составленном из имен тегов текущих таблиц.  See section <A HREF="emacs_27.html#SEC272">Завершение для имен символов</A>.




<H2><A NAME="SEC283" HREF="emacs_toc.html#TOC283">Объединение файлов с помощью Emerge</A></H2>
<P>
<A NAME="IDX1435"></A>
<A NAME="IDX1436"></A>
<A NAME="IDX1437"></A>


<P>
  Нередко программисты перебегают друг другу дорогу и изменяют одну и ту
же программу в двух разных направлениях.  Чтобы справиться с этой
путаницей, вам необходимо объединить две эти версии.  Emerge упрощает
это. Смотрите также section <A HREF="emacs_19.html#SEC157">Сравнение файлов</A>, о командах для сравнения
файлов более ручным методом, и @ref{Emerge,,, @external{ediff}, The
Ediff Manual}.




<H3><A NAME="SEC284" HREF="emacs_toc.html#TOC284">Обзор Emerge</A></H3>

<P>
Чтобы запустить Emerge, выполните одну из этих четырех команд:


<DL COMPACT>

<DT><KBD>M-x emerge-files</KBD>
<DD>
<A NAME="IDX1438"></A>
Объединяет два заданных файла.

<DT><KBD>M-x emerge-files-with-ancestor</KBD>
<DD>
<A NAME="IDX1439"></A>
Объединяет два заданных файла, со ссылкой на общего предка.

<DT><KBD>M-x emerge-buffers</KBD>
<DD>
<A NAME="IDX1440"></A>
Объединяет два буфера.

<DT><KBD>M-x emerge-buffers-with-ancestor</KBD>
<DD>
<A NAME="IDX1441"></A>
Объединяет два буфера со ссылкой на общего предка в третьем буфере.
</DL>

<P>
<A NAME="IDX1442"></A>
<A NAME="IDX1443"></A>
  Команды Emerge сравнивают два файла или буфера и отображают результат
сравнения в трех буферах: по одному на каждый входной файл (<EM>буфер
A</EM> и <EM>буфер B</EM>) и один (<EM>буфер объединения</EM>), где объединение и
происходит.  Буфер объединения показывает весь объединяемый текст, а не
только различия.  Везде, где буферы различаются, вы можете выбрать тот,
из которого вы хотите внести фрагмент.


<P>
  Команды Emerge, которые принимают ввод из существующих буферов,
используют только их доступные части, если эти буферы сужены
(see section <A HREF="emacs_35.html#SEC432">Сужение</A>).


<P>
  Если доступна общая начальная версия, от которой происходят оба
сливаемых текста, Emerge может использовать ее, чтобы вывести
предположение о том, какая из альтернатив правильна.  Когда одна из
текущих версий находится в согласии с предком, Emerge предполагает, что
другая текущая версия -- это обдуманное изменение, которое должно
сохраниться в объединенной версии.  Если вы хотите указать общий
начальный текст, используйте команды <SAMP>`with-ancestor'</SAMP>.  Эти команды
считывают три файла или имени буфера -- вариант A, вариант B и их
общего предка.


<P>
  После того как сравнение завершено, и буферы подготовлены, начинается
интерактивное объединение.  Вы можете управлять им, набирая особые
<EM>команды объединения</EM> в буфере объединения.  Этот буфер показывает
вам полный объединенный текст, а не только различия.  Для каждого
промежутка различий между входными текстами вы можете сохранить любой
или отредактировать их вместе.


<P>
  В буфере объединения используется особый основной режим, режим Emerge,
с командами для принятия таких решений.  Но вы также можете
редактировать этот буфер с помощью обычных команд Emacs.


<P>
  В любой момент времени внимание Emerge сосредоточено на одном
конкретном изменении, называемом <EM>выделенным</EM>.  Это изменение
помечается в трех буферах таким образом:



<PRE>
vvvvvvvvvvvvvvvvvvvv
<VAR>различающийся текст</VAR>
^^^^^^^^^^^^^^^^^^^^
</PRE>

<P>
Emerge последовательно нумерует все различия, и строка режима всегда
показывает номер выделенного различия.


<P>
  Обычно буфер объединения изначально содержит версию A текста.  Но
когда версия A изменения согласуется с общим предком, для этого
изменения предпочтение отдается версии B.


<P>
  Когда вы выходите, Emerge оставляет объединенный текст в буфере
объединения.  Тогда вы можете сохранить его с помощью <KBD>C-x C-w</KBD>.
Если вы задали <CODE>emerge-files</CODE> или <CODE>emerge-files-with-ancestor</CODE>
числовой аргумент, эти команды считает имя выходного файла в минибуфере.
(Это последнее имя, которое они считывают.)  Тогда при выходе из Emerge
объединенный текст сохраняется в выходном файле.


<P>
  Обычно команды Emerge сохраняет выходной буфер, когда вы выходите.
Если вы прервете Emerge с помощью <KBD>C-]</KBD>, команда Emerge не сохранит
выходной буфер, но вы можете записать его сами, если хотите.




<H3><A NAME="SEC285" HREF="emacs_toc.html#TOC285">Подрежимы Emerge</A></H3>

<P>
  Вы можете выбирать из двух режимов для отдания команд объединения:
режим Fast и режим Edit.  В режиме Fast основные команды объединения ---
это одиночные знаки, но обычные команды Emacs выключены.  Это удобно,
если вы используете только команды объединения.  В режиме Edit все
команды объединения начинаются с префикса <KBD>C-c C-c</KBD>, и доступны
также обычные команды Emacs.  Это позволяет редактировать буфер
объединения, но замедляет операции Emerge.


<P>
  Используйте <KBD>e</KBD>, чтобы переключится в режим Edit, и <KBD>C-c C-c
f</KBD>, чтобы переключится в режим Fast.  Строка режима изображает режимы
Edit и Fast при помощи <SAMP>`E'</SAMP> и <SAMP>`F'</SAMP>.


<P>
  Emerge имеет два дополнительных подрежима, которые затрагивают способ
работы определенных команд объединения: режим Auto Advance и режим Skip
Prefers.


<P>
  Если действует режим Auto Advance, команды <KBD>a</KBD> и <KBD>b</KBD>
продвигают к следующему различию.  Это позволяет вам быстрее сделать
объединение, поскольку вы просто выбираете одну из входных альтернатив.
Строка режима изображает режим Auto Advance как <SAMP>`A'</SAMP>.


<P>
  Если действует режим Skip Prefers, команды <KBD>n</KBD> и <KBD>p</KBD>
пропускают различия в состояниях prefer-A и prefer-B (see section <A HREF="emacs_27.html#SEC286">Состояние различия</A>).  Таким образом, вы видите только те различия, для которых ни
одна из версий не предполагается "правильной".  Строка режима
изображает режим Skip Prefers с помощью <SAMP>`S'</SAMP>.


<P>
<A NAME="IDX1444"></A>
<A NAME="IDX1445"></A>
  Используйте команду <KBD>s a</KBD> (<CODE>emerge-auto-advance-mode</CODE>), чтобы
установить или сбросить режим Auto Advance.  Используйте <KBD>s s</KBD>
(<CODE>emerge-skip-prefers-mode</CODE>), чтобы установить или сбросить режим
Skip Prefers.  Эти команды включают режим, если им задан положительный
аргумент, выключают при отрицательном аргументе и переключают режим,
если аргумент не задан.




<H3><A NAME="SEC286" HREF="emacs_toc.html#TOC286">Состояние различия</A></H3>

<P>
  Различия в буфере объединения помечаются строками знаков <SAMP>`v'</SAMP> и
<SAMP>`^'</SAMP>.  Каждое различие имеет одно из семи следующих состояний:


<DL COMPACT>

<DT>A
<DD>
Различие показывает версию A.  Команда <KBD>a</KBD> всегда производит это
состояние; строка режима отображает его как <SAMP>`A'</SAMP>.

<DT>B
<DD>
Различие показывает версию B.  Команда <KBD>b</KBD> всегда производит это
состояние; строка режима отображает его как <SAMP>`B'</SAMP>.

<DT>default-A
<DD>
<DT>default-B
<DD>
Различие показывает версию A или B по умолчанию, потому что вы не
сделали выбор.  Все различия изначально имеют состояние default-A (и
таким образом, буфер объединения -- это копия буфера A), кроме тех, для
которых "предпочтительна" другая альтернатива (смотрите ниже).

Когда вы выбираете различие, его состояние заменяется из default-A или
default-B на простое A или B.  Таким образом, выбранное различие никогда
не находится в состоянии default-A или default-B, и эти состояния
никогда не отображаются в строке режима.

Команда <KBD>d a</KBD> выбирает в качестве состояния по умолчанию default-A,
а <KBD>d b</KBD> выбирает default-B.  Это состояние по умолчанию применяется
ко всем различиям, которые вы никогда не выбирали и для которых нет
предпочтительной альтернативы.  Если вы продвигаетесь последовательно,
то различия, которые вы не выбирали, -- это те, что находятся после
выбранного.  Таким образом, продвигаясь последовательно, вы можете в
результате сделать A версией по умолчанию для некоторых фрагментов
буфера объединения, а B -- версией по умолчанию для остальных
фрагментов, используя между различиями <KBD>d a</KBD> и <KBD>d b</KBD>.

<DT>prefer-A
<DD>
<DT>prefer-B
<DD>
Различие показывает состояние A или B, потому что оно
<EM>предпочтительно</EM>.  Это означает, что вы не сделали явного выбора,
но похоже на то, что верна одна из альтернатив, так как вторая
согласуется с общим предком.  Значит, когда буфер A находится в согласии
с общим предком, предпочтительна версия B, потому что скорее всего это и
есть действительное изменение.

Эти состояния показываются в строке режима как <SAMP>`A*'</SAMP> и <SAMP>`B*'</SAMP>.

<DT>combined
<DD>
Различие показывает комбинацию состояний A и B, как результат команд
<KBD>x c</KBD> или <KBD>x C</KBD>.

Когда различие имеет это состояние, команды <KBD>a</KBD> и <KBD>b</KBD> не делают
для него ничего, если только вы не зададите им числовой аргумент.

Строка режима показывает это состояние как <SAMP>`comb'</SAMP>.
</DL>



<H3><A NAME="SEC287" HREF="emacs_toc.html#TOC287">Команды объединения</A></H3>

<P>
  Это команды объединения для режима Fast; в режиме Edit предваряйте их
набором <KBD>C-c C-c</KBD>:


<DL COMPACT>

<DT><KBD>p</KBD>
<DD>
Выбирает предыдущее различие.

<DT><KBD>n</KBD>
<DD>
Выбирает следующее различие.

<DT><KBD>a</KBD>
<DD>
Выбирает версию A этого различия.

<DT><KBD>b</KBD>
<DD>
Выбирает версию B этого различия.

<DT><KBD>C-u <VAR>n</VAR> j</KBD>
<DD>
Выбирает различие номер <VAR>n</VAR>.

<DT><KBD>.</KBD>
<DD>
Выбирает различие, содержащее точку.  Вы можете использовать эту команды
в буфере объединения или в буферах A и B.

<DT><KBD>q</KBD>
<DD>
Выход -- завершает объединение.

<DT><KBD>C-]</KBD>
<DD>
Прерывание -- выходит и не сохраняет вывод.

<DT><KBD>f</KBD>
<DD>
Переход в режим Fast.  (В режиме Edit это на самом деле <KBD>C-c C-c
f</KBD>.)

<DT><KBD>e</KBD>
<DD>
Переход в режим Edit.

<DT><KBD>l</KBD>
<DD>
Центирирует (как <KBD>C-l</KBD>) все три окна.

<DT><KBD>-</KBD>
<DD>
Задает часть префиксного числового аргумента.

<DT><KBD><VAR>цифра</VAR></KBD>
<DD>
Также задает часть префиксного числового аргумента.

<DT><KBD>d a</KBD>
<DD>
Выбирает A как версию по умолчанию для буфера объединения начиная с
этого места.

<DT><KBD>d b</KBD>
<DD>
Выбирает B как версию по умолчанию для буфера объединения начиная с
этого места.

<DT><KBD>c a</KBD>
<DD>
Копирует версию A этого различия в список уничтожений.

<DT><KBD>c b</KBD>
<DD>
Копирует версию B этого различия в список уничтожений.

<DT><KBD>i a</KBD>
<DD>
Вставляет версию A этого различия в точке.

<DT><KBD>i b</KBD>
<DD>
Вставляет версию B этого различия в точке.

<DT><KBD>m</KBD>
<DD>
Помещает точку и метку вокруг этого различия.

<DT><KBD>^</KBD>
<DD>
Прокручивает все три окна вниз (как <KBD>M-v</KBD>).

<DT><KBD>v</KBD>
<DD>
Прокручивает все три окна вверх (как <KBD>C-v</KBD>).

<DT><KBD>&#60;</KBD>
<DD>
Прокручивает все три окна влево (как <KBD>C-x &#60;</KBD>).

<DT><KBD>&#62;</KBD>
<DD>
Прокручивает все три окна вправо (как <KBD>C-x &#62;</KBD>).

<DT><KBD>|</KBD>
<DD>
Переустанавливает горизонтальную прокрутку во всех трех окнах.

<DT><KBD>x 1</KBD>
<DD>
Сужает окно объединения до одной строки.  (Используйте <KBD>C-u l</KBD>,
чтобы восстановить его полный размер.)

<DT><KBD>x c</KBD>
<DD>
Комбинирует две версии этого различия (see section <A HREF="emacs_27.html#SEC289">Комбинирование двух версий</A>).

<DT><KBD>x f</KBD>
<DD>
Показывает имена файлов/буферов, с которыми работает Emerge, в окне
справки.  (Используйте <KBD>C-u l</KBD>, чтобы восстановить окна.)

<DT><KBD>x j</KBD>
<DD>
Сцепляет это различие со следующим.  (<KBD>C-u x j</KBD> сцепляет это
различие с предыдущим.)

<DT><KBD>x s</KBD>
<DD>
Разбивает это различие на два.  До того, как применить эту команду,
расположите точку в каждом их буферов в том месте, где вы хотите разбить
различие.

<DT><KBD>x t</KBD>
<DD>
Выбрасывает одинаковые строки сверху и снизу различия.  Такие строки
появляются, когда версии A и B идентичны, но отличаются от
первоначальной версии.
</DL>



<H3><A NAME="SEC288" HREF="emacs_toc.html#TOC288">Выход из Emerge</A></H3>

<P>
  Команда <KBD>q</KBD> (<CODE>emerge-quit</CODE>) завершает объединение, записывая
результаты в выходной файл, если вы его задали.  Она восстанавливает
правильное содержимое буферов A и B или уничтожает их, если они были
созданы Emerge, и вы не изменяли их.  Она также выключает в буфере
объединения команды Emerge, поскольку выполнение их теперь может
повредить содержимое различных буферов.


<P>
  <KBD>C-]</KBD> прерывает объединение.  Это означает выход без записи
выходного файла.  Если вы не указали выходной файл, то между прерыванием
и завершением объединения на самом деле нет разницы.


<P>
  Если команды Emerge были вызваны из другой программы на Лиспе, то в
случае успешного завершения возвращается значение <CODE>t</CODE>, а если вы
прервали объединение, возвращается <CODE>nil</CODE>.




<H3><A NAME="SEC289" HREF="emacs_toc.html#TOC289">Комбинирование двух версий</A></H3>

<P>
  Иногда вы хотите сохранить <EM>оба</EM> варианта некоторого изменения.
Чтобы сделать так, используйте <KBD>x c</KBD>, которая редактирует буфер
объединения следующим образом:



<PRE>
#ifdef NEW
<VAR>версия из буфера A</VAR>
#else /* not NEW */
<VAR>версия из буфера B</VAR>
#endif /* not NEW */
</PRE>

<P>
<A NAME="IDX1446"></A>
Хотя этот пример показывает условные конструкции препроцессора Си,
разделяющие два альтернативные версии, вы можете задать используемые
строки, устанавливая переменную <CODE>emerge-combine-versions-template</CODE>
по вашему выбору.  В этой строке <SAMP>`%a'</SAMP> говорит, где нужно помещать
версию A, а <SAMP>`%b'</SAMP> говорит, говорит помещать версию B.  Установка по
умолчанию, которая выдает результат, показанный выше, выглядит следующим
так:



<PRE>
"#ifdef NEW\n%a#else /* not NEW */\n%b#endif /* not NEW */\n"
</PRE>



<H3><A NAME="SEC290" HREF="emacs_toc.html#TOC290">Тонкие вопросы, связанные с Emerge</A></H3>

<P>
  В процессе объединения вы не должны пытаться редактировать буферы A и
B сами.  Emerge временно изменяет их, но в конце возвращает в исходное
состояние.


<P>
  Вы можете производить любое число объединений одновременно -- только
не используйте один и тот же буфер в качестве входного более чем для
одного объединения, так как временные изменения, сделанные в этих
буферах, столкнулись бы друг с другом.


<P>
  Запуск Emerge может занять продолжительное время, поскольку ей
требуется полностью сравнить файлы.  Emacs не можете ничего делать, пока
@command{diff} не завершится.  Возможно, в будущем кто-то изменит Emerge
так, что она будет делать сравнение в фоновом режиме, когда входные
файлы велики -- тогда вы могли бы продолжать в Emacs другие дела, пока
Emerge действительно не будет готова принимать команды.


<P>
<A NAME="IDX1447"></A>
  После подготовки объединения Emerge запускает ловушку
<CODE>emerge-startup-hook</CODE> (see section <A HREF="emacs_36.html#SEC449">Ловушки</A>).




<H2><A NAME="SEC291" HREF="emacs_toc.html#TOC291">Режим C и родственные с ним</A></H2>
<P>
<A NAME="IDX1448"></A>
<A NAME="IDX1449"></A>
<A NAME="IDX1450"></A>
<A NAME="IDX1451"></A>
<A NAME="IDX1452"></A>
<A NAME="IDX1453"></A>
<A NAME="IDX1454"></A>
<A NAME="IDX1455"></A>
<A NAME="IDX1456"></A>
<A NAME="IDX1457"></A>
<A NAME="IDX1458"></A>
<A NAME="IDX1459"></A>


<P>
  Этот раздел описывает особые средства, доступные в режимах C, C++,
Objective-C, Java, CORBA IDL и Pike.  Когда мы говорим "режим C и
родственные с ним", мы имеем в виду эти режимы.




<H3><A NAME="SEC292" HREF="emacs_toc.html#TOC292">Команды перемещения в режиме C</A></H3>

<P>
  Этот раздел описывает команды для перемещения точки в режиме C и
родственных с ним режимах.


<DL COMPACT>

<DT><CODE>C-c C-u</CODE>
<DD>
<A NAME="IDX1460"></A>
<A NAME="IDX1461"></A>
Перемещает точку назад к содержащей ее условной констукции
препроцессора, оставляя метку в текущей позиции.  Префиксный аргумент
работает в качестве счетчика повторов.  С отрицательным аргументом,
перемещает точку вперед к концу этой условной констукции препроцессора.
При проходе назад, <CODE>#elif</CODE> рассматривается как <CODE>#else</CODE>, за
которой стоит <CODE>#if</CODE>.  При проходе вперед <CODE>#elif</CODE> игнорируется.

<DT><CODE>C-c C-p</CODE>
<DD>
<A NAME="IDX1462"></A>
<A NAME="IDX1463"></A>
Перемещает точку назад через условную констукцию препроцессора, оставляя
метку в текущей позиции.  Префиксный аргумент служит в качестве счетчика
повторов.  С отрицательным аргументом, перемещает вперед.

<DT><CODE>C-c C-n</CODE>
<DD>
<A NAME="IDX1464"></A>
<A NAME="IDX1465"></A>
Перемещает точку вперед через условную констукцию препроцессора,
оставляя метку в текущей позиции.  Префиксный аргумент служит в качестве
счетчика повторов.  С отрицательным аргументом, перемещает назад.

<DT><CODE>M-a</CODE>
<DD>
<A NAME="IDX1466"></A>
<A NAME="IDX1467"></A>
Перемещает точку к началу самого внутреннего оперетора Си
(<CODE>c-beginning-of-statement</CODE>).  Если точка уже находится в начале
оператора, перемещает к началу предыдущего.  С префиксным аргументом
<VAR>n</VAR>, перемещает назад на <VAR>n</VAR> - 1 операторов.

Если точка находится внутри строки или комментария или после комментария
(между ними только пропуск), эта команда перемещает по предложениям, а
не по операторам.

Если эта функция вызвана из программы, она принимает три необязательных
аргумента: префиксный числовой аргумент, предел позиции в буфере (не
перемещаться назад далее этой позиции) и флаг, который говорит, нужно ли
двигаться по предложениям внутри комментария.

<DT><CODE>M-e</CODE>
<DD>
<A NAME="IDX1468"></A>
<A NAME="IDX1469"></A>
Перемещает точку к концу самого внутреннего оперетора Си; как <KBD>M-a</KBD>,
но перемещает в противоположном направлении (<CODE>c-end-of-statement</CODE>).

<DT><CODE>M-x c-backward-into-nomenclature</CODE>
<DD>
<A NAME="IDX1470"></A>
Перемещает точку назад к началу секции или слова в нотации Си++.  С
префиксным аргументом <VAR>n</VAR>, перемещает <VAR>n</VAR> раз.  Если <VAR>n</VAR>
отрицательно, перемещает вперед.  Нотация Си++ обозначает запись имен
символов в стиле ИменованиеСимволовВСмешанномРегистреИБезПодчерков;
каждая заглавная буква начинает секцию или слово.

В проекте GNU мы рекомендуем использовать для разделения слов в
идентификаторах Си или Си++ подчерки, а не изменение регистра.

<DT><CODE>M-x c-forward-into-nomenclature</CODE>
<DD>
<A NAME="IDX1471"></A>
Перемещает точку назад к концу секции или слова в нотации Си++.  С
префиксным аргументом <VAR>n</VAR>, перемещает <VAR>n</VAR> раз.
</DL>



<H3><A NAME="SEC293" HREF="emacs_toc.html#TOC293">Электрик-знаки в Си</A></H3>

<P>
  В режиме Си и родственных с ним некоторые печатные знаки являются
"электрическими" -- помимо вставки самих себя, они также обновляют
отступ в текущей строке и могут вставлять переводы строк.  Это средство
управляется переменной <CODE>c-auto-newline</CODE>.  "Электрик"-знаки ---
это <KBD>{</KBD>, <KBD>}</KBD>, <KBD>:</KBD>, <KBD>#</KBD>, <KBD>;</KBD>, <KBD>,</KBD>, <KBD>&#60;</KBD>,
<KBD>&#62;</KBD>, <KBD>/</KBD>, <KBD>*</KBD>, <KBD>(</KBD> и <KBD>)</KBD>.


<P>
  Электрик-знаки вставляют переводы строк, только если включено средство
<EM>auto-newline</EM> (это отображается в строке режима как <SAMP>`/a'</SAMP> после
имени режима).  Это средство управляется переменной
<CODE>c-auto-newline</CODE>.  Вы можете включить или выключить его командой
<KBD>C-c C-a</KBD>:


<DL COMPACT>

<DT><KBD>C-c C-a</KBD>
<DD>
<A NAME="IDX1472"></A>
<A NAME="IDX1473"></A>
Перекючает автоматическую вставку переводов строк
(<CODE>c-toggle-auto-state</CODE>).  С префиксным аргументом, эта команда
включает такую возможность, если аргумент положителен, и выключает, если
аргумент отрицателен.
</DL>

<P>
  Двоеточие -- это электрик-знак, поскольку это подходит для одного
двоеточия.  Но это неудобно, когда вы хотите вставить двойное двоеточие
в Си++.  Вы можете вставить двойное двоеточие в Си++ без вставки отступа
или перевода строки, набирая <KBD>C-c :</KBD>.


<DL COMPACT>

<DT><KBD>C-c :</KBD>
<DD>
<A NAME="IDX1474"></A>
<A NAME="IDX1475"></A>
Вставляет в точке оператор области видимости, двойное двоеточие, не
изменяя отступ строки и не добавляя новых строк
(<CODE>c-scope-operator</CODE>).
</DL>

<P>
  Электрик-ключ <KBD>#</KBD> обновляет отступ строки, если он оказался в
начале директивы препроцессора.  Это происходит, когда значение
<CODE>c-electric-pound-behavior</CODE> равно <CODE>(alignleft)</CODE>.  Вы можете
выключить эту возможность, устанавливая <CODE>c-electric-pound-behavior</CODE>
в <CODE>nil</CODE>.


<P>
   Переменная <CODE>c-hanging-braces-alist</CODE> управляет вставкой переводов
строк до и после вставленных фигурных скобок.  Это ассоциативный список
с элементами в такой форме: <CODE>(<VAR>синтаксический-символ</VAR>
. <VAR>список-пс</VAR>)</CODE>.  Большинство синтаксических символов, перечисленных
в <CODE>c-offsets-alist</CODE>, имеют смысл и здесь.


<P>
   Список <VAR>список-пс</VAR> может содержать один из символов <CODE>before</CODE>
и <CODE>after</CODE>, либо оба, или это может быть <CODE>nil</CODE>.  Когда
вставляется фигурная скобка, в <CODE>c-hanging-braces-alist</CODE> ищется
определяемый ей синтаксический контекст; если он найден, используется
<VAR>список-пс</VAR> для выяснения того, где нужно вставить перевод строки:
перед фигурной скобкой, после нее или и до, и после.  Если ничего не
найдено, по умолчанию вставляет перевод строки до и после фигурных
скобок.


<P>
   Переменная <CODE>c-hanging-colons-alist</CODE> управляет вставкой переводов
строк до и после вставленных двоеточий.  Это ассоциативный список, чьи
элементы имеют форму <CODE>(<VAR>синтаксический-символ</VAR>
. <VAR>список-пс</VAR>)</CODE>.  Список <VAR>список-пс</VAR> может содержать любые из
символов <CODE>before</CODE> или <CODE>after</CODE>, либо оба, или это может быть
<CODE>nil</CODE>.


<P>
   Когда вставляется двоеточие, в этом cписке ищется определяемый им
синтаксический символ, и если он найден, используется <VAR>список-пс</VAR>
для выяснения того, где нужно вставить перевод строки: перед двоеточия,
после него или и там, и там.  Если этот символ не найден в списке,
переводы строк не вставляется.


<P>
   Электрик-знаки могут также автоматически удалять переводы строк,
когда включено средство для их автоматической вставки.  Это делает
автоматическую вставку переводов строк более приемлимой, путем удаления
переводов строк в большинстве случаев, когда это было бы желательно;
устанавливая переменную <CODE>c-cleanup-list</CODE>, вы можете указать <EM>в
каких</EM> случаях это происходить.  Значение этой переменной -- это список
символов, каждый из которых описывает один случай возможного удаления
перевода строки.  Вот перечень воспринимаемых символов и их значений:


<DL COMPACT>

<DT><CODE>brace-catch-brace</CODE>
<DD>
Сжимает конструкцию <SAMP>`} catch (<VAR>условие</VAR>) {'</SAMP>, помещаяя ее
целиком на одну строку.  Сжатие происходит, когда вы набираете
<SAMP>`{'</SAMP>, если между фигурными скобками нет ничего, кроме <CODE>catch</CODE> и
<VAR>условия</VAR>.

<DT><CODE>brace-else-brace</CODE>
<DD>
Сжимает конструкцию <SAMP>`} else {'</SAMP>, помещаяя ее целиком на одну
строку.  Сжатие происходит, когда вы набираете <SAMP>`{'</SAMP> после
<CODE>else</CODE>, но только если между фигурными скобками и <CODE>else</CODE> нет
ничего, кроме пропусков.

<DT><CODE>brace-elseif-brace</CODE>
<DD>
Сжимает конструкцию <SAMP>`} else if (...) {'</SAMP>, помещаяя ее целиком
на одну строку.  Сжатие происходит, когда вы набираете <SAMP>`{'</SAMP>, если
между <SAMP>`}'</SAMP> и <SAMP>`{'</SAMP> нет ничего, кроме пропусков, не считая эти
ключевые слова и условие для <CODE>if</CODE>.

<DT><CODE>empty-defun-braces</CODE>
<DD>
Сжимает фигурные скобки пустого определения функции, помещая их на одну
строку.  Сжатие происходит, когда вы набираете закрывающую фигурную
скобку.

<DT><CODE>defun-close-semi</CODE>
<DD>
Сжимает двоеточие и <CODE>struct</CODE> или подобный тип объявления, помещая
двоеточие на ту же строку, где стоит закрывающая фигурная скобка.
Сжатие происходит, когда вы вводите двоеточие.

<DT><CODE>list-close-comma</CODE>
<DD>
Сжимает запятые, следующие после фигурных скобок в массивах и сложных
инициализациях.  Сжатие происходит, когда вы набираете запятые.

<DT><CODE>scope-operator</CODE>
<DD>
Сжимает двойное двоеточие, которое может обозначать оператор области
видимости в Си++, помещая эти двоеточия вместе.  Сжатие происходит,
когда вы набираете второе двоеточие, но только если они разделены только
пропуском.
</DL>



<H3><A NAME="SEC294" HREF="emacs_toc.html#TOC294">Средство голодного удаления в Си</A></H3>

<P>
  Когда включено средство <EM>голодного удаления</EM> (это показывается в
строке режима как <SAMP>`/h'</SAMP> или <SAMP>`/ah'</SAMP> после имени режима), одна
команда <KBD>DEL</KBD> удаляет весь предшествующий пропуск, а не только одни
пробел.  Чтобы включать и выключать эту возможность, используйте
<KBD>C-c C-d</KBD>:


<DL COMPACT>

<DT><KBD>C-c C-d</KBD>
<DD>
<A NAME="IDX1476"></A>
<A NAME="IDX1477"></A>
Включает или выключает средство голодного удаления
(<CODE>c-toggle-hungry-state</CODE>).  С префиксным аргументом, эта команда
включает такую возможность, если аргумент положителен, и выключает, если
аргумент отрицателен.

<DT><KBD>C-c C-t</KBD>
<DD>
<A NAME="IDX1478"></A>
<A NAME="IDX1479"></A>
Переключает средства автоматической вставки перевода строки и голодного
удаления одновременно (<CODE>c-toggle-auto-hungry-state</CODE>).
</DL>

<P>
<A NAME="IDX1480"></A>
   Переменная <CODE>c-hungry-delete-key</CODE> говорит, включено ли средство
голодного удаления.




<H3><A NAME="SEC295" HREF="emacs_toc.html#TOC295">Другие команды режима C</A></H3>

<DL COMPACT>

<DT><KBD>C-M-h</KBD>
<DD>
<A NAME="IDX1481"></A>
<A NAME="IDX1482"></A>
Помещает метку в конце определения функции, а точку в начале
(<CODE>c-mark-function</CODE>).

<DT><KBD>M-q</KBD>
<DD>
<A NAME="IDX1483"></A>
<A NAME="IDX1484"></A>
Заполняет абзац, обрабатывая комментарии Си и Си++
(<CODE>c-fill-paragraph</CODE>).  Если какая-либо часть текущей строки является
комментарием или находится внутри комментария, эта команда заполняет
этот комментарий или его абзац, сохраняя отступы и ограничители
комментария.

<DT><KBD>C-c C-e</KBD>
<DD>
<A NAME="IDX1485"></A>
<A NAME="IDX1486"></A>
<A NAME="IDX1487"></A>
<A NAME="IDX1488"></A>
Запускает препроцессор Си для текста в области и показывает результат,
который включает раскрытия всех вызовов макросов
(<CODE>c-macro-expand</CODE>).  Текст буфера, написанный перед областью, также
передается препроцессору, так как там могут быть определения макросов,
но вывод для этой части не показывается.

Когда вы отлаживаете использующий макросы код на Си, бывает трудно точно
понять, как раскрываются макросы.  С этой командой вам не нужно это
понимать, вы можете видеть раскрытия.

<DT><KBD>C-c C-\</KBD>
<DD>
<A NAME="IDX1489"></A>
<A NAME="IDX1490"></A>
Вставляет или выравнивает знаки <SAMP>`\'</SAMP> в концах строк области
(<CODE>c-backslash-region</CODE>).  Это полезно после написания или
редактирования определения макроса Си.

Если строка уже завершается знаком <SAMP>`\'</SAMP>, эта команда подстраивает
размер пропуска перед ним.  В противном случае она вставляет новый
<SAMP>`\'</SAMP>.  Однако, последняя строка области рассматривается особо; в нее
не вставляется <SAMP>`\'</SAMP>, а если если этот знак там стоит, то он
удаляется.

<DT><KBD>M-x cpp-highlight-buffer</KBD>
<DD>
<A NAME="IDX1491"></A>
<A NAME="IDX1492"></A>
Подсвечивает части текста в соответствии с условными конструкциями
препроцессора.  Эта команда показывает еще один буфер с именем
<TT>`*CPP Edit*'</TT>, который служит в качестве графического меню для
выбора способа отображения конкретных видов условных конструкций и их
содержимого.  После изменения различных установок щелкните на
<SAMP>`[A]pply these settings'</SAMP> (или перейдите в этот буфер и нажмите
<KBD>a</KBD>), чтобы соответственно обновить подветку в буфере с режимом C.

<DT><KBD>C-c C-s</KBD>
<DD>
<A NAME="IDX1493"></A>
<A NAME="IDX1494"></A>
Показывает информацию о синтаксисе текущей исходной строки
(<CODE>c-show-syntactic-information</CODE>).  Это та информация, которая
управляет отступом строки.
</DL>



<H3><A NAME="SEC296" HREF="emacs_toc.html#TOC296">Комментарии в режимах C</A></H3>

<P>
   Режим C и родственные режимы используют несколько переменных для
управления форматом комментариев.


<DL COMPACT>

<DT><CODE>c-comment-only-line-offset</CODE>
<DD>
<A NAME="IDX1495"></A>
Дополнительный сдвиг для строки, которая содержит только начало
комментария.  Это может быть либо число, либо пара в форме
<CODE>(<VAR>не-привязанный-сдвиг</VAR> . <VAR>привязанный-сдвиг</VAR>)</CODE>, где
<VAR>не-привязанный-сдвиг</VAR> -- это размер сдвига, придаваемый
полнострочным комментариям, начинающимся не в нулевом столбце, а
<VAR>привязанный-сдвиг</VAR> -- это размер сдвига, даваемый полнострочным
комментариям, начинающимся в нулевом столбце.  Простое число в качестве
значения эквивалентно <CODE>(<VAR>значение</VAR> . 0)</CODE>.

<DT><CODE>c-comment-start-regexp</CODE>
<DD>
<A NAME="IDX1496"></A>
Эта локальная для буфера переменная указывает, как распознавать начало
комментария.

<DT><CODE>c-hanging-comment-ender-p</CODE>
<DD>
<A NAME="IDX1497"></A>
Если эта переменная равна <CODE>nil</CODE>, <CODE>c-fill-paragraph</CODE> оставляет
завершающую строку для блока комментария на отдельной строке.  Значение
по умолчанию равно <CODE>t</CODE>, что помещает закрывающий ограничитель
комментария <SAMP>`*/'</SAMP> в конце последней строки текста комментария.

<DT><CODE>c-hanging-comment-starter-p</CODE>
<DD>
<A NAME="IDX1498"></A>
Если эта переменная равна <CODE>nil</CODE>, <CODE>c-fill-paragraph</CODE> оставляет
начинающий ограничитель блока комментария на отдельной строке.  Значение
по умолчанию равно <CODE>t</CODE>, что помещает открывающий ограничитель
комментария <SAMP>`/*'</SAMP> в начале первой строки текста комментария.
</DL>



<H2><A NAME="SEC297" HREF="emacs_toc.html#TOC297">Режим Fortran</A></H2>
<P>
<A NAME="IDX1499"></A>
<A NAME="IDX1500"></A>


<P>
  Режим Fortran предоставляет специальные команды движения для
операторов и подпрограмм на Фортране и команды отступов, которые
понимают фортрановские соглашения о вложенности, номера строк и
операторы продолжения.  Режим Fortran имеет свой собственный режим Auto
Fill, который обрывает длинные строки на правильные с точки зрения
Фортрана строки продолжения.


<P>
  Предусматриваются специальные команды для комментариев, так как
комментарии в Фортране не похожи на комментарии в других языках.
Возможны встроенные сокращения, которые убыстряют набор, когда вы
вставляете ключевые слова Фортрана.


<P>
<A NAME="IDX1501"></A>
  Используйте <KBD>M-x fortran-mode</KBD>, чтобы переключиться в этот режим.
Эта команда запускает ловушку <CODE>fortran-mode-hook</CODE>
(see section <A HREF="emacs_36.html#SEC449">Ловушки</A>).




<H3><A NAME="SEC298" HREF="emacs_toc.html#TOC298">Команды движения</A></H3>

<P>
  Режим Fortran обеспечивает специальные команды для движения через
подпрограммы (функции и процедуры) и через операторы.  Есть также
команда для установки области вокруг подпрограмм, удобная для их
уничтожения и перемещения.


<P>
<A NAME="IDX1502"></A>
<A NAME="IDX1503"></A>
<A NAME="IDX1504"></A>
<A NAME="IDX1505"></A>
<A NAME="IDX1506"></A>
<A NAME="IDX1507"></A>
<A NAME="IDX1508"></A>
<A NAME="IDX1509"></A>
<A NAME="IDX1510"></A>
<A NAME="IDX1511"></A>


<DL COMPACT>

<DT><KBD>C-M-a</KBD>
<DD>
Переместить точку на начало подпрограммы
(<CODE>beginning-of-fortran-subprogram</CODE>).
<DT><KBD>C-M-e</KBD>
<DD>
Переместить точку на конец подпрограммы
(<CODE>end-of-fortran-subprogram</CODE>).
<DT><KBD>C-M-h</KBD>
<DD>
Поставить точку в начале подпрограммы, а метку в ее конце
(<CODE>mark-fortran-subprogram</CODE>).
<DT><KBD>C-c C-n</KBD>
<DD>
Перейти на начало текущего или следующего оператора
(<CODE>fortran-next-statement</CODE>).
<DT><KBD>C-c C-p</KBD>
<DD>
Перейти на конец текущего или предыдущего оператора
(<CODE>fortran-previous-statement</CODE>).
</DL>



<H3><A NAME="SEC299" HREF="emacs_toc.html#TOC299">Отступы в Фортране</A></H3>

<P>
   Для создания отступов в программах на Фортране необходимы специальные
команды и средства, чтобы быть уверенным в том, что различные
синтаксические единицы (номера строк, указатели комментариев и флаги
продолжения строк) появляются в тех столбцах, которые требует стандарт
Фортрана.




<H4><A NAME="SEC300" HREF="emacs_toc.html#TOC300">Команды отступа в Фортране</A></H4>

<DL COMPACT>

<DT><KBD><KBD>TAB</KBD></KBD>
<DD>
Сделать отступ текущей строки (<CODE>fortran-indent-line</CODE>).
<DT><KBD>C-j</KBD>
<DD>
Сделать отступ текущей строки и начать новую строку с отступом
(<CODE>fortran-indent-new-line</CODE>).
<DT><KBD>C-M-j</KBD>
<DD>
Прервать текущую строку и подготовить строку продолжения.
<DT><KBD>M-^</KBD>
<DD>
Соединить эту строку со следующей.
<DT><KBD>C-M-q</KBD>
<DD>
Сделать отступ во всех строках подпрограммы, в которой находится точка
(<CODE>fortran-indent-subprogram</CODE>).
</DL>

<P>
<A NAME="IDX1512"></A>
  Режим Fortran переопределяет <KBD>TAB</KBD> так, чтобы он делал новый
отступ в текущей строке для Фортрана (<CODE>fortran-indent-line</CODE>).
Номера строк и маркеры продолжения имеют отступ до требуемых столбцов, а
тело оператора получает независимый отступ, основанный на его
вложенности в программе.


<P>
<A NAME="IDX1513"></A>
<A NAME="IDX1514"></A>
  Ключ <KBD>C-j</KBD> запускает команду <CODE>fortran-indent-new-line</CODE>,
которая заново делает отступ в текущей строке, а затем создает новую
строку и деалет отступ в ней.  Эта команда полезна для создания нового
отступа в закрывающем операторе циклов <SAMP>`do'</SAMP> и других блоков перед
началом новой строки.


<P>
<A NAME="IDX1515"></A>
<A NAME="IDX1516"></A>
  Ключ <KBD>C-M-q</KBD> запускает <CODE>fortran-indent-subprogram</CODE>, команду
для создания отступа во всех строках фортрановской подпрограммы (функции
и процедуры), cодержащей точку.


<P>
<A NAME="IDX1517"></A>
<A NAME="IDX1518"></A>
  Ключ <KBD>C-M-j</KBD> запускает <CODE>fortran-split-line</CODE>, которая
разрывает строку соответствующим Фортрану способом.  В строке, которая
не является комментарием, вторая половина становится строкой продолжения
и имеет соответственный отступ.  В строке комментария обе половины
становятся отдельными строками комментария.


<P>
<A NAME="IDX1519"></A>
<A NAME="IDX1520"></A>
  <KBD>M-^</KBD> запускает команду <CODE>fortran-join-line</CODE>, которая более
или менее является обращением <CODE>fortran-split-line</CODE>.  Она объединяет
текущую и предшествующую строки подходящим для Фортрана способом.




<H4><A NAME="SEC301" HREF="emacs_toc.html#TOC301">Строки продолжения</A></H4>
<P>
<A NAME="IDX1521"></A>


<P>
<A NAME="IDX1522"></A>
  Большиство современных компиляторов Фортрана разрешают два способа
написания строк продолжения.  Если первый непробельный знак на строке
находится в столбце 5, то эта строка считается продолжением предыдущей.
Мы называем это <EM>фиксированным форматом</EM>; (В GNU Emacs мы всегда
остчитываем столбцы от нуля.)  Переменная
<CODE>fortran-continuation-string</CODE> указывает, какой знак надо помещать в
столбец 5.  Строка, начинающаяся со знака табуляции, за которым стоит
любая цифра, кроме <SAMP>`0'</SAMP>, также является строкой продолжения.  Этот
стиль продолжения мы называем <EM>табулированным форматом</EM>.


<P>
<A NAME="IDX1523"></A>
  Режим Fortran может делать строки продолжения в обоих стилях, но вы
должны указать, какой вы предпочитаете.  Этим выбором управляет значение
прееменной <CODE>indent-tabs-mode</CODE>: <CODE>nil</CODE> означает фиксированный
формат, а отличное от <CODE>nil</CODE> -- табулированный.  Вы можете судить о
действующим в данный момент формате по наличию или отсутствию в строке
режима слова <SAMP>`Tab'</SAMP>.


<P>
  Если текст на строке начинается с принятого в Фортране маркера
продолжения <SAMP>`$'</SAMP> или с непробельного знака в столбце 5, режим
Fortran считает эту строку строкой продолжения.  Когда вы делаете в
строке продолжения отступ с помощью <KBD>TAB</KBD>, эта строка приводится к
текущему стилю продолжения.  Когда вы разбиваете фортрановский оператор
с помощью <KBD>C-M-j</KBD>, на новой строке создается маркер продолжения в
соотвествии с этим стилем.


<P>
  Установка стиля продолжения затрагивает некоторые другие аспекты
редактирования в режиме Fortran.  При фиксированном формате, минимальный
номер столбаца для тела оператора равен шести.  Строки внутри
фортрановских блоков, отступ в которых больше этого числа, всегда
используют для пропусков только пробелы.  При табулированном формате,
минимальный номер столбца для тела оператора равен восьми, и пропуск
перед столбцом 8 всегда состоит из одного знака табуляции.


<P>
<A NAME="IDX1524"></A>
<A NAME="IDX1525"></A>
  Когда вы включаете режим Fortran для существующего файла, он старается
вычислить подходящий стиль продолжения автоматически, исходя из
содержимого этого файла.  Выбор определяет первая строка, которая
начинается с табуляции или шести пробелов.  Переменная
<CODE>fortran-analyze-depth</CODE> определяет, сколько строк нужно рассмотреть
(от начала файла); если ни одна их этих строк не укажет стиль, то он
определяется по переменной <CODE>fortran-tab-mode-default</CODE>.  Если она
равна <CODE>nil</CODE>, то используется фиксированный формат, отличное от
<CODE>nil</CODE> значение велит использовать табулированный формат.




<H4><A NAME="SEC302" HREF="emacs_toc.html#TOC302">Номера строк</A></H4>

<P>
  Если первым непробельным текстом на строке является число, режим
Fortran предполагает, что это номер строки, и перемещает его к столбцам
от 0 до 4.  (В GNU Emacs столбцы всегда отсчитываются от нуля.)


<P>
<A NAME="IDX1526"></A>
  Номера строк из четырех и менее цифр обычно имеют отступ на один
пробел.  Это управляется переменной <CODE>fortran-line-number-indent</CODE>,
значение которой является максимальным отступом, который может иметь
номер строки.  Номера строк получают такой отступ, чтобы они корректно
оканчивались в четвертом столбце, если при этом не требуется отступ
больше максимального.  По умолчанию значение переменной равно 1.


<P>
<A NAME="IDX1527"></A>
  Простая вставка номера строки достаточна для того, чтобы отступ у него
соответствовал этим правилам.  Как только вставляется каждая цифра,
отступ пересчитывается.  Чтобы выключить это свойство, установите
переменную <CODE>fortran-electric-line-number</CODE> в <CODE>nil</CODE>.  Тогда
вставка номеров строк будет похожа на вставку всего остального.




<H4><A NAME="SEC303" HREF="emacs_toc.html#TOC303">Синтаксические соглашения</A></H4>

<P>
  Режим Fortran предполагает, что вы следуете определенным соглашениям,
которые упрощают задачу понимания программ на Фортране в достаточной
степени, чтобы делать в них правильный отступ:



<UL>
<LI>

Два вложенных цикла <SAMP>`do'</SAMP> никогда не имеют общего оператора
<SAMP>`continue'</SAMP>.

<LI>

Ключевые слова Фортрана, такие как <SAMP>`if'</SAMP>, <SAMP>`else'</SAMP>, <SAMP>`then'</SAMP>,
<SAMP>`do'</SAMP> и другие, написаны без внутренних пробелов и разрывов строк.

Компиляторы Фортрана обычно игнорируют все пробельные знаки вне
строковых констант, но режим Fortran не распознает эти ключевые слова,
если они разорваны.  Конструкции вроде <SAMP>`else if'</SAMP> или <SAMP>`end do'</SAMP>
допустимы, но второе слово должно быть на той же строке, что и первое, а
не на строке продолжения.
</UL>

<P>
Если вы не следуете этим соглашениям, команды отступа могут сделать
отступ в некоторых строках неэстетично.  Однако, правильная программа на
Фортране будет сохранять свое значение при новых отступах, даже если эти
соглашения не соблюдались.




<H4><A NAME="SEC304" HREF="emacs_toc.html#TOC304">Переменные для управления отступами</A></H4>

<P>
<A NAME="IDX1528"></A>
<A NAME="IDX1529"></A>
<A NAME="IDX1530"></A>
<A NAME="IDX1531"></A>
<A NAME="IDX1532"></A>
<A NAME="IDX1533"></A>
  Несколько дополнительных переменных управляют тем, как работает отступ
в Фортране:


<DL COMPACT>

<DT><CODE>fortran-do-indent</CODE>
<DD>
Дополнительный отступ в пределах каждого уровня оператора <SAMP>`do'</SAMP> (по
умолчанию 3).

<DT><CODE>fortran-if-indent</CODE>
<DD>
Дополнительный отступ в пределах каждого уровня оператора <SAMP>`if'</SAMP> (по
умолчанию 3).  Это же значение используется для дополнительного отступа
каждого уровня оператора Фортрана90 <SAMP>`where'</SAMP>.

<DT><CODE>fortran-structure-indent</CODE>
<DD>
Дополнительный отступ в пределах каждого уровня операторов
<SAMP>`structure'</SAMP>, <SAMP>`union'</SAMP> или <SAMP>`map'</SAMP> (по умолчанию 3).

<DT><CODE>fortran-continuation-indent</CODE>
<DD>
Дополнительный отступ для тел строк продолжения (по умолчанию 5).

<DT><CODE>fortran-check-all-num-for-matching-do</CODE>
<DD>
Если это <CODE>nil</CODE>, команды отступа считают, что каждый оператор
<SAMP>`do'</SAMP> кончается на операторе <SAMP>`continue'</SAMP>.  Поэтому при
вычислении отступа для оператора, отличного от <SAMP>`continue'</SAMP>, они
могут сократить время, не выполняя в этом месте проверку окончания
оператора <SAMP>`do'</SAMP>.  Если это не <CODE>nil</CODE>, то команды отступа для
любого пронумерованного оператора должны проверять, не заканчивается ли
там <SAMP>`do'</SAMP>.  По умолчанию значение равно <SAMP>`nil'</SAMP>.

<DT><CODE>fortran-blink-matching-if</CODE>
<DD>
Если это <CODE>t</CODE>, создание отступа для оператора <SAMP>`endif'</SAMP> на
мгновение перемещает курсор к парному оператору <SAMP>`if'</SAMP>, чтобы вы
видели, где он находится.  По умолчанию <CODE>nil</CODE>.

<DT><CODE>fortran-minimum-statement-indent-fixed</CODE>
<DD>
Минимальный отступ для операторов Фортрана при использовании
фиксированного формата для строк продолжения.  Тела операторов никогда
не получают отступ менее этого.  По умолчанию это 6.

<DT><CODE>fortran-minimum-statement-indent-tab</CODE>
<DD>
Минимальный отступ для операторов Фортрана при использовании
табулированного формата строк продолжения.  Тела операторов никогда не
получают отступ менее этого.  По умолчанию это 8.
</DL>



<H3><A NAME="SEC305" HREF="emacs_toc.html#TOC305">Комментарии в Фортране</A></H3>

<P>
  Обычные команды Emacs для комментариев предполагают, что
комментарии могут следовать за строкой кода.  В Фортране стандартный
синтаксис комментариев требует отведения строки целиком только под
комментарий.  Поэтому режим Fortran заменяет стандартные команды
комментариев в Emacs и определяет некоторые новые переменные.


<P>
  Режим Fortran также может обрабатывать нестандартный синтаксис
комментариев, когда комментарии начинаются с <SAMP>`!'</SAMP> и могут следовать
за другим текстом.  Так как только некоторые компиляторы Фортрана
признают такой синтаксис, режим Fortran не вставляет такие комментарии,
если вы не потребовали этого заранее.  Чтобы сделать это, установите
переменной <CODE>comment-start</CODE> значение <SAMP>`"!"'</SAMP>
(see section <A HREF="emacs_36.html#SEC442">Переменные</A>).


<DL COMPACT>

<DT><KBD>M-;</KBD>
<DD>
Выровнять комментарий или вставить новый комментарий
(<CODE>fortran-comment-indent</CODE>).

<DT><KBD>C-x ;</KBD>
<DD>
Применяется только к нестандартным комментариям <SAMP>`!'</SAMP>.

<DT><KBD>C-c ;</KBD>
<DD>
Превратить все строки области в комментарии или (с аргументом)
превратить их обратно в реальный код (<CODE>fortran-comment-region</CODE>).
</DL>

<P>
  <KBD>M-;</KBD> в режиме Fortran переопределяется на
<CODE>fortran-comment-indent</CODE>.  Как и обычная команда <KBD>M-;</KBD>, она
распознает любой вид существующих комментариев и соответственно
выравнивает его текст; если существующего комментария нет, то
комментарий вставляется и выравнивается.  Но вставка и выравнивание
комментариев в режиме Fortran не такие, как в других режимах.


<P>
  Когда должен быть вставлен новый комментарий, то, если текущая строка
пустая, вставляется полная строка комментария.  В непустой строке
вставляется нестандартный комментарий с <SAMP>`!'</SAMP>, если вы сказали, что
хотите их использовать.  В противном случае в новую строку перед текущей
вставляется полная строка комментария.


<P>
  Нестандартные комментарии с <SAMP>`!'</SAMP> выравниваются, как комментарии в
других языках, но полнострочные комментарии выравниваются иначе.  В
стандартном полнострочном комментарие сам ограничитель комментария
должен всегда появляться в нулевом столбце.  Что может выравниваться,
так это текст в пределах комментария.  Вы можете выбирать из трех
возможных видов выравнивания, устанавливая переменную
<CODE>fortran-comment-indent-style</CODE> в одно из этих значений:


<P>
<A NAME="IDX1534"></A>
<A NAME="IDX1535"></A>
<DL COMPACT>

<DT><CODE>fixed</CODE>
<DD>
Текст выравнивается по фиксированному столбцу, который является суммой
<CODE>fortran-commenrt-line-column</CODE> и минимального отступа оператора.
Это значение принимается по умолчанию.

Минимальный отступ операторов -- это
<CODE>fortran-minimum-statement-indent-fixed</CODE> для стиля продолжения с
фиксированным форматом и <CODE>fortran-minimum-statement-indent-tab</CODE> для
стиля с табулированным форматом.

<DT><CODE>relative</CODE>
<DD>
Текст выравнивается так, как если бы он был строкой кода, но с
дополнительными <CODE>fortran-comment-line-column</CODE> столбцами отступа.

<DT><CODE>nil</CODE>
<DD>
Текст в полнострочных комментариях не перемещается автоматически.
</DL>

<P>
<A NAME="IDX1536"></A>
  Кроме того, вы можете определить знак, который используется для
отступа в пределах полнострочных комментариев, устанавливая переменной
<CODE>fortran-comment-indent-char</CODE> значение, равное строке из одного
знака, который вы хотите использовать.


<P>
<A NAME="IDX1537"></A>
<A NAME="IDX1538"></A>
  В режиме Fortran вводятся две переменные, <CODE>comment-line-start</CODE> и
<CODE>comment-line-start-skip</CODE>, которые играют для полнострочных
комментариев ту же роль, что и <CODE>comment-start</CODE> и
<CODE>comment-start-skip</CODE> для обычных, следующих за текстом
комментариев.  Обычно они устанавливаются правильно режимом Fortran, так
что их не нужно менять.


<P>
  Обычная команда Emacs для создания комментария <KBD>C-x ;</KBD>
переопределена.  Если вы используете комментарии с <SAMP>`!'</SAMP>, эта команда
может быть использована с ними.  Иначе она бесполезна в режиме Fortran.


<P>
<A NAME="IDX1539"></A>
<A NAME="IDX1540"></A>
<A NAME="IDX1541"></A>
  Команда <KBD>C-c ;</KBD> (<CODE>fortran-comment-region</CODE>) превращает все
строки области в комментарии, вставляя <SAMP>`C$$$'</SAMP> в начале каждой из
строк.  С числовым аргументом, она превращает область обратно в реальный
код, удаляя <SAMP>`C$$$'</SAMP> из начала каждой строки в этой области.  Строка,
используемая для этих комментариев, может управляться установкой
переменной <CODE>fortran-comment-region</CODE>.  Заметим, что здесь мы имеем
пример команды и переменной с одним и тем же именем.  Эти два варианта
использования имени никогда не конфликтуют, так как в Лиспе и в Emacs
всегда понятно по контексту, какое из них имеется в виду.




<H3><A NAME="SEC306" HREF="emacs_toc.html#TOC306">Режим Fortran Auto Fill</A></H3>

<P>
  Режим Fortran Auto Fill -- это второстепенный режим, который
автоматически разбивает фортрановские операторы, когда они становятся
слишом широкими по мере того, как вы их вставляете.  Разбиение оператора
влечет создание строки продолжения с использованием
<CODE>fortran-continuation-string</CODE> (see section <A HREF="emacs_27.html#SEC301">Строки продолжения</A>).  Разбиение происходит, когда вы
набираете <KBD>SPC</KBD>, <KBD>RET</KBD> или <KBD>TAB</KBD>, а также в командах для
отступов в Фортране.


<P>
<A NAME="IDX1542"></A>
  <KBD>M-x fortran-auto-fill-mode</KBD> включает режим Fortran Auto Fill,
если он был выключен, или выключает, если он был включен.  Эта команда
работает так же, как работает <KBD>M-x auto-fill-mode</KBD> для обычного
режима Auto Fill (see section <A HREF="emacs_26.html#SEC222">Заполнение текста</A>).  Положительный аргумент включает
режим Fortran Auto Fill, а отрицательный выключает.  Вы можете узнать,
действует ли режим Fortran Auto Fill, по наличию слова <SAMP>`Fill'</SAMP> в
строке режима в круглых скобках.  Режим Fortran Auto Fill -- это
второстепенный режим, включаемый и выключаемый в каждом буфере отдельно.
See section <A HREF="emacs_36.html#SEC441">Второстепенные режимы</A>.


<P>
<A NAME="IDX1543"></A>
  Режим Fortran Auto Fill разрывает строки на пробелах или разделителях,
когда строки становятся длиннее желаемой ширины (значения
<CODE>fill-column</CODE>).  Разделителями, на которых режим Fortran Auto Fill
может разорвать строку, являются <SAMP>`,'</SAMP>, <SAMP>`''</SAMP>, <SAMP>`+'</SAMP>, <SAMP>`-'</SAMP>,
<SAMP>`/'</SAMP>, <SAMP>`*'</SAMP>, <SAMP>`='</SAMP> и <SAMP>`)'</SAMP>.  Разрыв происходит после
разделителя, если переменная <CODE>fortran-break-before-delimiters</CODE>
равна <CODE>nil</CODE>.  Иначе (и по умолчанию) разрыв делается перед
разделителем.


<P>
  По умолчанию режим Fortran Auto Fill не задействован.  Если вы хотите,
чтобы это средство было включено постоянно, добавьте к
<CODE>fortran-mode-hook</CODE> функцию-ловушку, которая выполнит
<CODE>(fortran-auto-fill-mode 1)</CODE>.  See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.




<H3><A NAME="SEC307" HREF="emacs_toc.html#TOC307">Проверка столбцов в Фортране</A></H3>

<DL COMPACT>

<DT><KBD>C-c C-r</KBD>
<DD>
Кратковременно показать "линейку столбцов" над текущей строкой
(<CODE>fortran-column-ruler</CODE>).
<DT><KBD>C-c C-w</KBD>
<DD>
Временно разделить текущее окно по горизонтали таким образом, чтобы оно
стало шириной в 72 столбца.  Это может помочь вам избежать выхода за
лимит в 72 столбца, который накладывают некоторые компиляторы Фортрана
(<CODE>fortran-window-create-momentarily</CODE>).
</DL>

<P>
<A NAME="IDX1544"></A>
<A NAME="IDX1545"></A>
<A NAME="IDX1546"></A>
     Команда <KBD>C-c C-r</KBD> (<CODE>fortran-column-ruler</CODE>) кратковременно
показывает над текущей строкой линейку столбцов.  Линейка столбцов ---
это две строки текста, которые показывают вам позиции столбцов, имеющих
специальные значения в Фортран-программах.  Квадратные скобки показывают
границы столбцов для номеров строк, а фигурные скобки показывают границы
столбцов для тела оператора.  Над ними показаны номера столбцов.


<P>
  Заметьте, что номера столбцов считаются от нуля, как всегда в GNU
Emacs.  В связи с этим номера могут на единицу меньше, чем те, к которым
вы привыкли; но указываемые ими позиции в строке стандартны для
Фортрана.


<P>
  Текст, используемый для показа линейки столбцов, зависит от значения
переменной <CODE>indent-tabs-mode</CODE>.  Если <CODE>indent-tabs-mode</CODE> равна
<CODE>nil</CODE>, то в качестве линейки столбцов используется значение
переменной <CODE>fortran-column-ruler-fixed</CODE>.  Иначе показывается
переменная <CODE>fortran-column-ruler-tab</CODE>.  Изменяя эти переменные, вы
можете изменить вид линейки столбцов.


<P>
<A NAME="IDX1547"></A>
<A NAME="IDX1548"></A>
     Для еще большей помощи используйте команду <CODE>C-c C-w</CODE>
(<CODE>fortran-window-create</CODE>), которая разделяет теущее окно по
горизонтали, делая его ширину равной 72 столбцам.  При редактировании в
этом окне вы можете непосредственно видеть, когда вы сделали строку
слишком длинной, чтобы она была правильной с точки зрения Фортрана.




<H3><A NAME="SEC308" HREF="emacs_toc.html#TOC308">Сокращения ключевых слов Фортрана</A></H3>

<P>
  Режим Fortran обеспечивает множество встроенных сокращений для часто
встречающихся ключевых слов и объявлений.  Это те же виды сокращений,
которые вы можете определить сами.  Чтобы использовать их, вы должны
включить режим Abbrev.  See section <A HREF="emacs_29.html#SEC326">Сокращения</A>.


<P>
  Встроенные сокращения необычны в одном: все они начинаются с точки с
запятой.  Обычно вы не можете использовать точку с запятой в
сокращениях, но режим Fortran делает это возможным, изменяя синтаксис
точки с запятой на "составную часть слова".


<P>
  Например, одно встроенное фортрановское сокращение -- это <SAMP>`;с'</SAMP>
для <SAMP>`continue'</SAMP>.  Если вы вставите <SAMP>`;с'</SAMP> и затем поставите знаки
пунктуации, например пробел или перевод строки, то <SAMP>`;с'</SAMP>
автоматически изменится на <SAMP>`continue'</SAMP>, при условии, что включен
режим Abbrev.


<P>
  Наберите <SAMP>`;?'</SAMP>  или <SAMP>`;C-h'</SAMP>, чтобы просмотреть все встроенные
сокращения для Фортрана и то, чему они соответствуют.




<H3><A NAME="SEC309" HREF="emacs_toc.html#TOC309">Другие команды режима Fortran</A></H3>

<DL COMPACT>

<DT><KBD>C-x n d</KBD>
<DD>
Сужает до текущей подпрограммы Фортрана.
</DL>

<P>
<A NAME="IDX1549"></A>
<A NAME="IDX1550"></A>
  Режим Fortran переопределяет ключ <KBD>C-x n d</KBD> для запуска команды
<CODE>fortran-narrow-to-subprogram</CODE>, которая служит фортрановским
аналогом обычного определения этого ключа.  Она сужает буфер до
подпрограммы, содержащей точку.




<H2><A NAME="SEC310" HREF="emacs_toc.html#TOC310">Режим Asm</A></H2>

<P>
<A NAME="IDX1551"></A>
Режим Asm -- это основной режим для редактирования файлов на
ассемблерном коде.  Он определяет следующие команды:


<DL COMPACT>

<DT><KBD><KBD>TAB</KBD></KBD>
<DD>
<CODE>tab-to-tab-stop</CODE>.
<DT><KBD>C-j</KBD>
<DD>
Вставляет перевод строки и делает отступ, используя
<CODE>tab-to-tab-stop</CODE>.
<DT><KBD>:</KBD>
<DD>
Вставляет двоеточие и затем удаляет отступ перед меткой, предшествующей
двоеточию.  Затем делает <CODE>tab-to-tab-stop</CODE>.
<DT><KBD>;</KBD>
<DD>
Вставляет или выравнивает комментарий.
</DL>

<P>
  Переменная <CODE>asm-comment-char</CODE> определяет, какой знак начинает
комментарий в синтаксисе ассемблера.
<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_26.html">previous</A>, <A HREF="emacs_28.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
</BODY>
</HTML>
