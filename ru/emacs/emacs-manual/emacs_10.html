<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Минибуфер</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_9.html">previous</A>, <A HREF="emacs_11.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC36" HREF="emacs_toc.html#TOC36">Минибуфер</A></H1>
<P>
<A NAME="IDX148"></A>


<P>
  <EM>Минибуфер</EM> используется командами Emacs для чтения более сложных,
чем простое число, аргументов.  Аргументами минибуфера могут быть имена
файлов, имена буферов, имена функций Лиспа, имена команд Emacs и много
других вещей в зависимости от считывающих аргумент команд.  Для
редактирования аргументов в минибуфере могут быть использованы обычные
команды редактирования Emacs.


<P>
<A NAME="IDX149"></A>
  Когда вы используете минибуфер, он появляется в эхо-области, и туда
передвигается курсор терминала.  Начало строки минибуфера показывает
<EM>подсказку</EM>, которая говорит, какой ввод вы должны давать, и как он
будет применен.  Часто подсказка происходит от имени команды, для
которой нужен этот аргумент.  Подсказка обычно кончается двоеточием.


<P>
<A NAME="IDX150"></A>
  Иногда в круглых скобках после двоеточия появляется <EM>аргумент по
умолчанию</EM>; он тоже является частью подсказки.  Значение по умолчанию
будет использовано как значение аргумента, если вы вводите пустой
аргумент (например, просто наберете <KBD>RET</KBD>).  К примеру, команды,
считывающие имена буферов, всегда показывают значение, принимаемое по
умолчанию; оно является именем буфера, который будет использован в
дальнейшем, если вы просто наберете <KBD>RET</KBD>.


<P>
   Простейший способ дать аргумент минибуферу -- набрать желаемый текст
и завершить его <KBD>RET</KBD>, клавишей для выхода из минибуфера.  Вы можете
отменить команду, которая запрашивает аргумент, и выйти из минибуфера,
набрав <KBD>C-g</KBD>.


<P>
  Минибуфер использует пространство экрана, отведенное под эхо-область,
но это может противоречить другим способам использования эхо-области в
Emacs.  Emacs обрабатывает такие конфликты следующим образом:



<UL>
<LI>

Если какая-то команда получает ошибку, пока вы находитесь в минибуфере,
то это не отменяет минибуфер.  Однако, эхо-область нужна для сообщения
об ошибке, и поэтому сам минибуфер прячется на время.  Он возвращается
через несколько секунд или сразу же, как только вы наберете что-нибудь.

<LI>

Если в минибуфере вы используете команду, чьей целью является печать
сообщения в эхо-области, такую как <KBD>C-x =</KBD>, то сообщение
отображается как обычно, а минибуфер прячется на время.  Он возвращается
через несколько секунд, или как только вы наберете что-то еще.

<LI>

Когда используется минибуфер, эхо набираемых знаков не производится.
</UL>



<H2><A NAME="SEC37" HREF="emacs_toc.html#TOC37">Минибуфер для имен файлов</A></H2>

<P>
  Иногда минибуфер появляется уже с текстом.  Например, когда вам
предлагается задать имя файла, минибуфер появляется с содержащимся в нем
<EM>каталогом, заданным по умолчанию</EM>, который оканчивается косой
чертой.  Это делается, чтобы проинформировать вас о том, в каком
каталоге будет находиться файл, если вы не зададите каталог.  Например,
минибуфер может начинаться так:



<PRE>
Find File: /u2/emacs/src/
</PRE>

<P>
где <SAMP>`Find File: '</SAMP> служит подсказкой.  Напечатав <KBD>buffer.c</KBD>,
вы задаете файл с именем <TT>`/u2/emacs/buffer.c'</TT>.  Чтобы найти файлы в
соседних каталогах, используется <KBD>..</KBD>; таким образом, если вы
наберете <KBD>../lisp/simple.el</KBD>, то получите файл
<TT>`/u2/emacs/lisp/simple.el'</TT>.  Или вы можете уничтожить ненужное вам
имя каталога с помощью <KBD>M-<KBD>DEL</KBD></KBD> (see section <A HREF="emacs_26.html#SEC218">Слова</A>).


<P>
  Если вам не нужно ничего из каталога по умолчанию, вы можете
уничтожить его с помощью <KBD>C-a C-k</KBD>.  Но в этом нет необходимости; вы
можете просто проигнорировать его.  Вставьте после каталога по умолчанию
абсолютное имя файла, начинающееся с косой черты или тильды.  Например,
чтобы задать файл <TT>`/etc/termcap'</TT>, просто вставьте это имя, при этом
вы получите в минибуфере такую строку:



<PRE>
Find File: /u2/emacs/src//etc/termcap
</PRE>

<P>
<A NAME="IDX151"></A>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
GNU Emacs придает двойной косой черте особое назначение (обычно нет
смысла писать две косые черты подряд): они означают "пропустить все
перед второй косой чертой в паре".  Таким образом,
<SAMP>`/u2/emacs/src/'</SAMP> в предыдущем примере будет проигнорировано, и вы
получите файл <TT>`/etc/termcap'</TT>.


<P>
Если вы установите <CODE>insert-default-directory</CODE> равной <CODE>nil</CODE>,
каталог по умолчанию не появляется в минибуфере.  Таким образом,
минибуфер появляется пустым.  Но набираемое вами имя, если оно
относительно, по-прежнему интерпретируется с учетом того же каталога по
умолчанию.




<H2><A NAME="SEC38" HREF="emacs_toc.html#TOC38">Редактирование в минибуфере</A></H2>

<P>
  Минибуфер -- это буфер Emacs (хотя и своеобразный), и обычные команды
Emacs годятся для редактирования текста вводимых вами аргументов.


<P>
  Так как <KBD>RET</KBD> в минибуфере определен для выхода, вы не можете
использовать его для вставки ограничителя новой строки в минибуфер.
Чтобы вставить перевод строки, введите <KBD>C-o</KBD> или <KBD>C-q C-j</KBD>.
(Напомним, что ограничитель новой строки -- это на самом деле знак
control-J.)


<P>
  Минибуфер имеет свое собственное окно, которое всегда присутствует на
экране, но действует так, как если бы его не было, когда минибуфер не
используется.  Когда же минибуфер используется, его ничем не отличается
от всех остальных окон; вы можете перейти в другое окно с помощью
<KBD>C-x o</KBD>, отредактировать текст в других окнах и может быть даже
обратиться к нескольким файлам перед возвращением в минибуфер для
представления аргумента.  Вы можете уничтожить текст в другом окне,
вернуться в окно минибуфера и затем восстановить этот текст, чтобы
использовать его в аргументе.  See section <A HREF="emacs_21.html#SEC169">Множество окон</A>.


<P>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>
<A NAME="IDX158"></A>
<A NAME="IDX159"></A>
  Однако существуют некоторые ограничения на использование окна
минибуфера.  Вы не можете переключить в нем буферы -- минибуфер и его
окно связаны вместе.  Точно также, вы не можете поделить или уничтожить
окно минибуфера.  Но вы можете сделать его выше обычным способом с
помощью <KBD>C-x ^</KBD>.  Если вы включите режим Resize-Minibuffer, то окно
минибуфера по необходимости увеличивается вертикально, чтобы вместить
текст, который вы поместили в минибуфер.  Используйте <KBD>M-x
resize-minibuffer-mode</KBD>, чтобы включить или выключить этот
второстепенный режим (see section <A HREF="emacs_36.html#SEC441">Второстепенные режимы</A>).


<P>
<A NAME="IDX160"></A>
  Прокрутка работает в окне минибуфера особым образом.  Когда высота
минибуфера равна только одной строке, и он содержит длинную строку
текста, которая не уместилась бы не экране, с помощью прокрутки
автоматически поддерживается перекрытие одной строки продолжения другой
на определенное число знаков.  Переменная
<CODE>minibuffer-scroll-overlap</CODE> указывает число знаков, на которое
нужно делать перекрытие; по умолчанию это 20.


<P>
  Если во время нахождения в минибуфере вы запускаете команду, которая
показывает в другом окне справочный текст любого вида, вы можете
использовать в минибуфере команду <KBD>C-M-v</KBD> для прокрутки этого окна.
Это свойство вступает в действие, если попытка получить завершение в
минибуфере дает вам список возможных вариантов.  See section <A HREF="emacs_21.html#SEC172">Использование других окон</A>.


<P>
<A NAME="IDX161"></A>
  Emacs обычно запрещает большинство команд, использующих минибуфер,
когда минибуфер активен.  Это правило было введено, чтобы рекурсивные
минибуферы не запутывали начинающих пользователей.  Если вы хотите
получить возможность использования таких команд в минибуфере, установите
переменную <CODE>enable-recursive-minibuffers</CODE> не равной <CODE>nil</CODE>.




<H2><A NAME="SEC39" HREF="emacs_toc.html#TOC39">Завершение</A></H2>
<P>
<A NAME="IDX162"></A>


<P>
  Для ввода значений некоторых видов аргументов вы можете использовать
<EM>завершение</EM>.  Завершение означает, что вы набираете часть
аргумента, а Emacs явно дополняет остаток полностью или настолько,
насколько можно определить по набранной вами части.


<P>
  Когда завершение доступно, определенные клавиши -- <KBD>TAB</KBD>,
<KBD>RET</KBD> и <KBD>SPC</KBD> -- перепривязываются для дополнения
представленного в минибуфере текста до более длинной строки, которую
этот текст представляет, путем сопоставления его с <EM>вариантами
завершения</EM>, которые предоставляются командой, считывающей этот
аргумент.  Знак <KBD>?</KBD> определен как показывающий список возможных
завершений того, что вы уже ввели.


<P>
  Например, когда <KBD>M-x</KBD> использует минибуфер для чтения имени
команды, она предоставляет для завершения список всех имеющихся имен
команд Emacs.  Клавиши завершения сопоставляют текст в минибуфере со
всеми именами команд, находят какие-то дополнительные знаки имени,
которые подразумеваются уже представленными в минибуфере, и добавляют
эти знаки к тем, которые вы дали.  Поэтому можно напечатать <KBD>M-x ins
<KBD>SPC</KBD> b <KBD>RET</KBD></KBD> вместо <KBD>M-x insert-buffer <KBD>RET</KBD></KBD>
(например).


<P>
  Регистр обычно имеет значение при завершении, так как он имеет
значение в большинстве имен, которые вы можете завершить (имена буферов,
файлов, команд).  Таким образом, <SAMP>`fo'</SAMP> не завершится до <SAMP>`Foo'</SAMP>.
Когда вы завершаете имя, в котором регистр не имеет значения, то при
завершении регистр может быть проигнорирован.




<H3><A NAME="SEC40" HREF="emacs_toc.html#TOC40">Пример завершения</A></H3>

<P>
<A NAME="IDX163"></A>
<A NAME="IDX164"></A>
  Здесь может помочь конкретный пример.  Если вы наберете <KBD>M-x au
<KBD>TAB</KBD></KBD>, <KBD>TAB</KBD> ищет варианты (в данном случае имена команд),
которые начинаются с <SAMP>`au'</SAMP>.  Их несколько, включая
<CODE>auto-fill-mode</CODE> и <CODE>auto-save-mode</CODE>, но все они одинаково
начинаются на <CODE>auto-</CODE>, поэтому <SAMP>`au'</SAMP> в минибуфере изменяется на
<SAMP>`auto-'</SAMP>.


<P>
  Если вы немедленно снова наберете <KBD>TAB</KBD>, то появятся несколько
возможностей для следующих знаков -- это может быть любой из
<SAMP>`cfilrs'</SAMP>, -- поэтому больше ничего не добавляется, но в другом
окне показывается список всех возможных завершений.


<P>
  Если вы продолжаете набирать <KBD>f <KBD>TAB</KBD></KBD>, то этот <KBD>TAB</KBD>
увидит <SAMP>`auto-f'</SAMP>.  Единственное имя команды, которое так начинается,
--- это <CODE>auto-fill-mode</CODE>, таким образом завершение вставляет ее
остаток.  Теперь вы имеете в минибуфере <SAMP>`auto-fill-mode'</SAMP> просто
после набора <KBD>au <KBD>TAB</KBD> f <KBD>TAB</KBD></KBD>.  Заметьте, что <KBD>TAB</KBD>
обладает в минибуфере таким действием, потому что когда возможно
завершение, он привязан к команде <CODE>minibuffer-complete</CODE>.




<H3><A NAME="SEC41" HREF="emacs_toc.html#TOC41">Команды завершения</A></H3>

<P>
     Здесь представлен список всех команд завершения, определенных в
минибуфере, когда завершение доступно.


<DL COMPACT>

<DT><KBD><KBD>TAB</KBD></KBD>
<DD>
Завершить представленный в минибуфере текст насколько это возможно
(<CODE>minibuffer-complete</CODE>).
<DT><KBD><KBD>SPC</KBD></KBD>
<DD>
Завершить текст в минибуфере, но не прибавлять более одного слова
(<CODE>minibuffer-complete-word</CODE>).
<DT><KBD><KBD>RET</KBD></KBD>
<DD>
Представить текст в минибуфере как аргумент, возможно сначала дополняя
его, как описано ниже (<CODE>minibuffer-complete-and-exit</CODE>).
<DT><KBD>?</KBD>
<DD>
Напечатать список всех возможных завершений текста в минибуфере
(<CODE>minibuffer-list-completions</CODE>).
</DL>

<P>
<A NAME="IDX165"></A>
<A NAME="IDX166"></A>
  <KBD>SPC</KBD> завершает очень похоже на <KBD>TAB</KBD>, но никогда не идет
дальше следующего дефиса или пробела.  Если в минибуфере есть
<SAMP>`auto-f'</SAMP>, и вы наберете <KBD>SPC</KBD>, он обнаружит, что завершение ---
это <SAMP>`auto-fill-mode'</SAMP>, но остановит завершение после <SAMP>`fill-'</SAMP>.
Это даст <SAMP>`auto-fill-'</SAMP>.  Еще один <KBD>SPC</KBD> в этом месте завершает
полностью до <SAMP>`auto-fill-mode'</SAMP>.  <KBD>SPC</KBD> в минибуфере, когда
возможно завершение, запускает функцию <CODE>minibuffer-complete-word</CODE>.


<P>
  Вот несколько команд, которые вы можете использовать для выбора
завершения в окне, показывающем перечень вариантов:


<DL COMPACT>

<DT><KBD>Mouse-2</KBD>
<DD>
<A NAME="IDX167"></A>
 
Щелчок второй кнопкой мыши выбирает одно из завершений из перечня
возможных вариантов (<CODE>mouse-choose-completion</CODE>).  Обычно вы
используете эту команду, когда точка находится в минибуфере; но вы
должны щелкнуть в перечне завершений, а не самом минибуфере.

<A NAME="IDX168"></A>
<DT><KBD><KBD>PRIOR</KBD></KBD>
<DD>
<DT><KBD>M-v</KBD>
<DD>
Нажатие <KBD>PRIOR</KBD> (или <KBD>PAGE-UP</KBD>) или <KBD>M-v</KBD>, когда вы
находитесь в минибуфере, выбирает окно, показывающее буфер с перечнем
завершений (<CODE>switch-to-completions</CODE>).  Это прокладывает путь к
использованию команд, перечисленных ниже.  (Выбор это окна обычным
способом имеет тот же эффект, но этот способ удобнее.)

<A NAME="IDX169"></A>
<DT><KBD><KBD>RET</KBD></KBD>
<DD>
Нажатие <KBD>RET</KBD> <EM>в буфере с перечнем завершений</EM> выбирает
завершение, на котором или после которого находится точка
(<CODE>choose-completion</CODE>).  Чтобы использовать эту команду, вы должны
сначала переключиться в окно, показывающее перечень завершений.

<A NAME="IDX170"></A>
<DT><KBD><KBD>RIGHT</KBD></KBD>
<DD>
Нажатие правой курсорной стрелки <KBD>RIGHT</KBD> <EM>в буфере с перечнем
завершений</EM> передвигает точку к следующему завершению
(<CODE>next-completion</CODE>).

<A NAME="IDX171"></A>
<DT><KBD><KBD>LEFT</KBD></KBD>
<DD>
Нажатие левой курсорной стрелки <KBD>LEFT</KBD> <EM>в буфере с перечнем
завершений</EM> передвигает точку ближе к началу буфера, к предыдущему
завершению (<CODE>previous-completion</CODE>).
</DL>



<H3><A NAME="SEC42" HREF="emacs_toc.html#TOC42">Строгое завершение</A></H3>

<P>
  Существует три различных варианта работы <KBD>RET</KBD> при завершении в
минибуфере, зависящие от того, как будет использован аргумент.



<UL>
<LI>

<EM>Строгое</EM> завершение используется, когда бессмысленно давать
какой-либо другой аргумент, кроме одной из известных альтернатив.
Например, когда <KBD>C-x k</KBD> считывает имя буфера для уничтожения, то
бессмысленно давать что либо, кроме имени существующего буфера.  При
строгом завершении <KBD>RET</KBD> отказывается выходить, если текст в
минибуфере не завершается с точным соответствием шаблону.

<LI>

<EM>Осторожное</EM> завершение подобно строгому завершению за исключением
того, что <KBD>RET</KBD> выходит, только если текст уже совпадал в точности с
шаблоном, не нуждающемся в завершении.  Если текст -- не точное
совпадение, <KBD>RET</KBD> не выходит, но делает завершение текста.  Если это
завершает текст до точного совпадения, то второй <KBD>RET</KBD> выйдет.

Осторожное завершение используется для чтения имен файлов, которые
должны уже существовать.

<LI>

<EM>Свободное</EM> завершение используется, когда любая строка является
подходящей, и список альтернатив завершения дается просто для справки.
Например, когда <KBD>C-x C-f</KBD> считывает имя файла для обращения,
допустимо любое имя файла, на случай, если вы захотите создать новый
файл.  При свободном завершении <KBD>RET</KBD> берет текст в минибуфере точно
как он дан, не завершая его.
</UL>

<P>
  Команды завершения показывают в окне список всех возможных вариантов
всякий раз, когда возможно более чем одно завершение для следующего
знака.  Кроме того, набор <KBD>?</KBD> явно запрашивает такой список.  Если
перечень завершений длинный, вы можете прокрутить его с помощью
<KBD>C-M-v</KBD> (see section <A HREF="emacs_21.html#SEC172">Использование других окон</A>).




<H3><A NAME="SEC43" HREF="emacs_toc.html#TOC43">Параметры завершения</A></H3>

<P>
<A NAME="IDX172"></A>
  При завершении имен файлов определенные имена обычно игнорируются.
Переменная <CODE>completion-ignored-extension</CODE> содержит список строк;
файл, чье имя кончается на любую из этих строк, игнорируется как
возможное завершение.  Стандартное значение этой переменной имеет
несколько элементов, включая <CODE>".о"</CODE>, <CODE>".elc"</CODE>, <CODE>".dvi"</CODE> и
<CODE>"~"</CODE>.  Действие таково: например, <SAMP>`foo'</SAMP> может завершиться до
<SAMP>`foo.c'</SAMP>, даже если <SAMP>`foo.o'</SAMP> также существует.  Однако, если
<EM>все</EM> возможные завершения кончаются на "игнорируемые" строки,
тогда они не игнорируются.  Игнорируемые расширения не относятся к
спискам завершений -- эти списки всегда упоминают все возможные
завершения.


<P>
<A NAME="IDX173"></A>
  Обычно команда завершения, которая обнаруживает, что следующий знак
нельзя определить, автоматически показывает список всех возможных
завершений.  Если переменная <CODE>completion-auto-help</CODE> установлена в
значение <CODE>nil</CODE>, этого не происходит, и чтобы просмотреть возможные
варианты, вы должны набрать <KBD>?</KBD>.


<P>
<A NAME="IDX174"></A>
  Библиотека <CODE>complete</CODE> реализовывает более мощный вид завершения,
который может дополнять несколько слов одновременно.  Например, она
может завершить сокращение имени команды <CODE>p-b</CODE> до
<CODE>print-buffer</CODE>, потому что ни одна другая команда не начинается с
двух слов, чьи первые буквы -- это <SAMP>`p'</SAMP> и <SAMP>`b'</SAMP>.  Чтобы
использовать эту библиотеку, напишите <CODE>(load "complete")</CODE> в вашем
файле <TT>`~/.emacs'</TT> (see section <A HREF="emacs_36.html#SEC470">Файл инициализации, <TT>`~/.emacs'</TT></A>).


<P>
<A NAME="IDX175"></A>
  Режим Icomplete предоставляет постоянно обновляющуюся информацию,
говорящую вам, какие завершения доступны для уже введенного текста.
Этот второстепенный режим включается и выключается с помощью команды
<KBD>M-x icomplete-mode</KBD>.




<H2><A NAME="SEC44" HREF="emacs_toc.html#TOC44">История минибуфера</A></H2>
<P>
<A NAME="IDX176"></A>
<A NAME="IDX177"></A>


<P>
  Все введенные вами в минибуфер аргументы сохраняются в <EM>списке
истории минибуфера</EM>, чтобы вы могли снова использовать их позже в новом
аргументе.  Текст старых аргументов вставляется в минибуфер особыми
командами.  Они сбрасывают старое содержимое минибуфера, так что вы
можете думать о них как о командах движения по списку предыдущих
аргументов.


<DL COMPACT>

<DT><KBD><KBD>UP</KBD></KBD>
<DD>
<DT><KBD>M-p</KBD>
<DD>
Перемещается к предыдущей строке аргумента, сохраненной в истории
минибуфера (<CODE>previous-history-element</CODE>).
<DT><KBD><KBD>DOWN</KBD></KBD>
<DD>
<DT><KBD>M-n</KBD>
<DD>
Перемещается к следующей строке аргумента, сохраненной в истории
минибуфера (<CODE>next-history-element</CODE>).
<DT><KBD>M-r <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Перемещается к более раннему аргументу в истории минибуфера, в котором
есть совпадение с <VAR>regexp</VAR>
(<CODE>previous-matching-history-element</CODE>).
<DT><KBD>M-s <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Перемещается к более позднему аргументу в истории минибуфера, в котором
есть совпадение с <VAR>regexp</VAR> (<CODE>next-matching-history-element</CODE>).
</DL>

<P>
<A NAME="IDX178"></A>
<A NAME="IDX179"></A>
<A NAME="IDX180"></A>
<A NAME="IDX181"></A>
  Простейший способ повторно использовать сохраненные аргументы из
списка истории -- передвигаться по списку истории по одному аргументу.
Находясь в минибуфере, используйте <KBD>M-p</KBD> или стрелку вверх
(<CODE>previous-history-element</CODE>) чтобы "перейти" к предыдущему вводу
минибуфера, и <KBD>M-n</KBD> или стрелку вниз (<CODE>next-history-element</CODE>)
для "перехода" к следующему.


<P>
  Предыдущий ввод, который вы извлекаете из истории, полностью замещает
содержимое минибуфера.  Чтобы использовать его в качестве аргумента,
выйдите из минибуфера как обычно, с помощью <KBD>RET</KBD>.  Вы также можете
отредактировать текст перед использованием; это не изменяет элемент
истории, к которому вы "перешли", но ваш новый аргумент вставляется в
конец списка истории как отдельный элемент.


<P>
  Для многих аргументов минибуфера есть значение "по умолчанию".  В
некоторых случаях команды истории знают значение по умолчанию.  Тогда вы
можете вставить это значение в минибуфер в виде текста, используя
<KBD>M-n</KBD> для перехода "в будущее" по истории.  Мы надеемся в конце
концов сделать это свойство доступным всегда, когда у минибуфера есть
значение по умолчанию.


<P>
<A NAME="IDX182"></A>
<A NAME="IDX183"></A>
<A NAME="IDX184"></A>
<A NAME="IDX185"></A>
  Также есть команды для поиска вперед или назад по истории; они
производят поиск элементов истории, которые соответствуют задаваемому
вами в минибуфере регулярному выражению.  <KBD>M-r</KBD>
(<CODE>previous-matching-history-element</CODE>) производит поиск более старых
элементов истории, тогда как <KBD>M-s</KBD>
(<CODE>next-matching-history-element</CODE>) производит поиск более новых
элементов.  По особому разрешению эти команды могут использовать
минибуфер для считывания аргументов, хотя вы уже находитесь в
минибуфере, когда запускаете их.  Как и при наращиваемом поиске,
заглавная буква в регулярном выражении делает поиск регистрозависимым
(see section <A HREF="emacs_17.html#SEC96">Поиск и регистр букв</A>).


<P>
  Каждое использование минибуфера записывает ваш ввод в список истории,
но есть отдельные списки для различных видов аргументов.  Например, есть
список для имен файлов, используемый всеми командами, считывающими имена
файлов.  (У него есть особенность: этот список истории записывает
абсолютное имя файла, не больше и не меньше, даже если вы ввели его
иначе.)


<P>
  Существуют несколько других особенных списков истории, включая список
для имен команд, считываемых командой <KBD>M-x</KBD>, список для имен
буферов, список для аргументов команд вроде <CODE>query-replace</CODE> и
список команд компиляции, считываемых командой <CODE>compile</CODE>.  И
наконец, есть список истории для "разного", который используют
большинство аргументов минибуфера.


<P>
<A NAME="IDX186"></A>
  Переменная <CODE>history-length</CODE> задает максимальную длину списка
истории минибуфера; как только список дорастает до этой длины, самый
старый элемент удаляется при добавлении нового.  Если значение
<CODE>history-length</CODE> равно <CODE>t</CODE>, то ограничения на длину нет, и
элементы не удаляются никогда.




<H2><A NAME="SEC45" HREF="emacs_toc.html#TOC45">Повтор команд минибуфера</A></H2>
<P>
<A NAME="IDX187"></A>
<A NAME="IDX188"></A>


<P>
  Каждая команда, которая использует минибуфер по крайней мере один раз,
записывается в специальный список истории вместе со значением аргументов
минибуфера, так что вы можете легко ее повторить.  В частности,
записывается каждое использование <KBD>M-x</KBD>, так как <KBD>M-x</KBD>
использует минибуфер для чтения имени команды.


<P>
<A NAME="IDX189"></A>
<DL COMPACT>

<DT><KBD>C-x <KBD>ESC</KBD> <KBD>ESC</KBD></KBD>
<DD>
Повторное выполнение последней команды минибуфера
(<CODE>repeat-complex-command</CODE>).
<DT><KBD>M-x list-command-history</KBD>
<DD>
Вывести полную историю всех команд, которые может повторить <KBD>C-x
<KBD>ESC</KBD> <KBD>ESC</KBD></KBD>, начиная с более новых.
</DL>

<P>
<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
  <KBD>C-x <KBD>ESC</KBD> <KBD>ESC</KBD></KBD> используется для повторного выполнения
недавней команды, использовавшей минибуфер.  Запущенная без аргумента,
она повторяет последнюю такую команду.  Числовой аргумент определяет,
какую команду повторить; единица означает первую от конца, а большие
числа определяют более ранние команды.


<P>
  <KBD>C-x <KBD>ESC</KBD> <KBD>ESC</KBD></KBD> действует при помощи превращения
предыдущей команды в выражение Лиспа и последующего входа в минибуфер,
инициализированый текстом этого выражения.  Если вы набираете просто
<KBD>RET</KBD>, то команда повторяется как прежде.  Вы можете также изменить
команду путем редактирования лисповского выражения.  То выражение, что
вы в конце концов представите, и будет выполнено.  Повторенная команда
добавляется в начало истории команд, если она не идентична самой
последней выполненной команде, которая уже была там.


<P>
  Даже если вы не понимаете синтаксиса Лиспа, вероятнее всего будет
очевидно, какая команда отражается для повторения.  Если вы не меняли
текст, вы можете быть уверены, что он повторится точно так, как прежде.


<P>
  Находясь в минибуфере по команде <KBD>C-x <KBD>ESC</KBD> <KBD>ESC</KBD></KBD>, вы
можете использовать команды истории минибуфера (<KBD>M-p</KBD>, <KBD>M-n</KBD>,
<KBD>M-r</KBD>, <KBD>M-s</KBD>; see section <A HREF="emacs_10.html#SEC44">История минибуфера</A>) для продвижения по
списку сохраненных полностью команд.  После того, как вы найдете
желаемую предыдущую команду, вы можете как обычно отредактировать ее
выражение и затем предоставить его снова, набрав <KBD>RET</KBD>.


<P>
<A NAME="IDX192"></A>
  Перечень предыдущих команд, использовавших минибуфер, хранится как
лисповский список в переменной <CODE>command-history</CODE>.  Каждый элемент
--- это лисповское выражение, которое описывает одну команду и ее
аргументы.  Программы на Лиспе могут повторно выполнять команды путем
передачи в <CODE>eval</CODE> соответствующего элемента <CODE>command-history</CODE>.
<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_9.html">previous</A>, <A HREF="emacs_11.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
</BODY>
</HTML>
