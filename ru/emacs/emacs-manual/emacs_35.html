<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Разнообразные команды</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_34.html">previous</A>, <A HREF="emacs_36.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC412" HREF="emacs_toc.html#TOC412">Разнообразные команды</A></H1>

<P>
  Эта глава содержит несколько небольших тем, которые не вписываются в
другие главы: чтение сетевых новостей, запуск команд оболочки и
подпроцессов оболочки, использование одного разделяемого Emacs для
утилит, которые предполагают запуск редактора как подпроцесса, печать
твердой копии, сортировка текста, сужение отображения до части буфера,
редактирование двухколоночных и двоичных файлов, сохранение сеансов
Emacs для последующего продолжения, эмуляция других редакторов и
различные развлечения.




<H2><A NAME="SEC413" HREF="emacs_toc.html#TOC413">Gnus</A></H2>
<P>
<A NAME="IDX2297"></A>
<A NAME="IDX2298"></A>


<P>
Gnus -- это пакет Emacs, разработанный в первую очередь для чтения и
отправки новостей Usenet.  Его также можно использовать для чтения и
написания ответов на сообщения из многих других источников -- почты,
удаленных каталогов, дайджестов и других.


<P>
Здесь мы даем введение в Gnus и описываем некоторые основные
возможности.
Для получения подробной информации о Gnus наберите <KBD>M-x info</KBD> и
выберите затем руководство по Gnus.


<P>
<A NAME="IDX2299"></A>
Чтобы запустить Gnus, напечатайте <KBD>M-x gnus <KBD>RET</KBD></KBD>.




<H3><A NAME="SEC414" HREF="emacs_toc.html#TOC414">Буферы Gnus</A></H3>

<P>
  В противоположность большинству обычных пакетов Emacs, Gnus использует
для показа информации и получения команд несколько разных буферов.
Большую часть времени пользователи проводят в трех буферах: <EM>буфере
групп</EM>, <EM>буфере резюме</EM> и <EM>буфере статьи</EM>.


<P>
  <EM>Буфер групп</EM> содержит перечень групп.  Это первый буфер, который
Gnus показывает после запуска.  Обычно в нем показаны только те группы,
на которые вы подписаны, и в которых есть непрочтенные статьи.
Используйте этот буфер для выбора конкретной группы.


<P>
  <EM>Буфер резюме</EM> построчно перечисляет статьи одной группы.  По
умолчанию для каждой статьи показываются автор, заголовок и число строк,
но это можно настроить по своему вкусу, как и большую часть того, что
отображает Gnus.  Буфер резюме создается, когда вы выбираете группу в
буфере групп, и уничтожается, когда вы покидаете эту группу.
Используйте этот буфер для выбора статьи.


<P>
  <EM>Буфер статьи</EM> показывает саму статью.  При обычном использовании
Gnus вы не выбираете этот буфер -- все полезные команды,
предназначенные для действий над статьей, работают из буфера резюме.  Но
вы можете выбрать буфер статьи и выполнять все команды Gnus из него,
если хотите.




<H3><A NAME="SEC415" HREF="emacs_toc.html#TOC415">Когда Gnus запускается</A></H3>

<P>
  При запуске Gnus считывает ваш файл инициализации новостей
<TT>`.newsrc'</TT> и пытается установить связь с локальным сервером
новостей, который служит хранилищем статей.  Сервер новостей не обязан
быть тем же компьютером, на который вы вошли.


<P>
  Если вы запустили Gnus и соединились с сервером, но не видите в буфере
групп ни одной группы, наберите <KBD>L</KBD> или <KBD>A k</KBD>, чтобы получить
перечень всех групп.  Затем нажимайте <KBD>u</KBD>, чтобы переключать
подписку на группы.


<P>
  Когда вы запускаете Gnus первый раз, он подписывает вас на несколько
избранных групп.  Все остальные группы сначала <EM>уничтожены</EM> с вашей
точки зрения; вы можете получить их перечень с помощью <KBD>A k</KBD>.  Все
новые группы, появляющиеся в дальнейшем на сервере, становятся для вас
<EM>зомбированными</EM>; наберите <KBD>A z</KBD>, чтобы получить их перечень.
Вы можете подписаться на группы, показанные в этих списках, используя
команду <KBD>u</KBD>.


<P>
  Когда вы покидаете Gnus при помощи <KBD>q</KBD>, он автоматически
записывает в ваших файлах инициализации <TT>`.newsrc'</TT> и
<TT>`.newsrc.eld'</TT> статус подписки всех групп.  Обычно вам не стоит
редактировать эти файлы вручную, но вы можете это делать, если знаете
как.




<H3><A NAME="SEC416" HREF="emacs_toc.html#TOC416">Обзор команд Gnus</A></H3>

<P>
  Чтение новостей -- это двухшаговый процесс:



<OL>
<LI>

Выберите группу в буфере групп.

<LI>

Выбирайте статьи в буфере резюме.  Каждая выбранная статья показывается
в буфере статьи в большом окне под буфером резюме в маленьком окне.
</OL>

<P>
  Каждый буфер Gnus имеет свои особые команды; однако, смысл любого
данного ключа в различных буферах Gnus обычно аналогичен, даже если и
различается.  Вот команды буферов групп и резюме:


<DL COMPACT>

<DT><KBD>q</KBD>
<DD>
<A NAME="IDX2300"></A>
 <A NAME="IDX2301"></A>
 
В буфере групп, обновляет файл инициализации <TT>`.newsrc'</TT> и покидает
Gnus.

В буфере резюме, покидает текущую группу и возвращает в буфер групп.
Таким образом, дважды нажав <KBD>q</KBD>, вы выйдете из Gnus.

<A NAME="IDX2302"></A>
<A NAME="IDX2303"></A>
<DT><KBD>L</KBD>
<DD>
В буфере групп, перечисляет все доступные группы на вашем сервере
новостей (кроме тех, что вы уничтожили).  Это может быть длинный список!

<A NAME="IDX2304"></A>
<A NAME="IDX2305"></A>
<DT><KBD>l</KBD>
<DD>
В буфере групп, перечисляет только те группы, на которые вы подписаны, и
которые содержат непрочтенные статьи.

<A NAME="IDX2306"></A>
<A NAME="IDX2307"></A>
<A NAME="IDX2308"></A>
<A NAME="IDX2309"></A>
<DT><KBD>u</KBD>
<DD>
В буфере групп, отменяет подписку (или устанавливает ее) на группу,
перечисленную в строке, в которой находится точка.  Когда вы выходите из
Gnus, нажав <KBD>q</KBD>, Gnus перечисляет в вашем файле <TT>`.newsrc'</TT> те
группы, на которые вы подписаны.  При следующем запуске Gnus вы не
увидите эту группу, потому что обычно Gnus показывает только группы, на
которые вы подписаны.

<A NAME="IDX2310"></A>
<A NAME="IDX2311"></A>
<DT><KBD>C-k</KBD>
<DD>
В буфере групп, "уничтожает" группу на текущей строке -- даже не
перечисляет ее отныне в <TT>`.newsrc'</TT>.  Это затрагивает как текущий
сеанс Gnus, так и последующие.

Когда вы покидаете Gnus при помощи <KBD>q</KBD>, Gnus записывает информацию в
файле <TT>`.newsrc'</TT>, описывая все группы, кроме тех, что вы
"уничтожили".

<A NAME="IDX2312"></A>
<A NAME="IDX2313"></A>
<DT><KBD><KBD>SPC</KBD></KBD>
<DD>
В буфере групп, выбирает группу на строке под курсором и показывает
первую непрочтенную статью в этой группе.

В буфере резюме,


<UL>
<LI>

Выбирает статью под курсором, если ни одна еще не выбрана.

<LI>

Прокручивает текст текущей статьи (если такая есть).

<LI>

Выбирает следующую непрочтенную статью, если текущая статья кончилась.
</UL>

Таким образом, вы можете пройти по всем статьям, последовательно нажимая
<KBD>SPC</KBD>.

<A NAME="IDX2314"></A>
<DT><KBD><KBD>DEL</KBD></KBD>
<DD>
В буфере групп, перемещает точку к предыдущей группе, содержащей
непрочтенные статьи.

<A NAME="IDX2315"></A>
В буфере резюме, прокручивает текст статьи назад.

<A NAME="IDX2316"></A>
<A NAME="IDX2317"></A>
<A NAME="IDX2318"></A>
<DT><KBD>n</KBD>
<DD>
Перемещает точку к следующей непрочитанной группе или выбирает следующую
непрочитанную статью.

<A NAME="IDX2319"></A>
<A NAME="IDX2320"></A>
<A NAME="IDX2321"></A>
<DT><KBD>p</KBD>
<DD>
Перемещает точку к предыдущей непрочитанной группе или выбирает
предыдущую непрочитанную статью.

<A NAME="IDX2322"></A>
<A NAME="IDX2323"></A>
<A NAME="IDX2324"></A>
<A NAME="IDX2325"></A>
<A NAME="IDX2326"></A>
<A NAME="IDX2327"></A>
<A NAME="IDX2328"></A>
<A NAME="IDX2329"></A>
<DT><KBD>C-n</KBD>
<DD>
<DT><KBD>C-p</KBD>
<DD>
Перемещает точку к следующему или предыдущему пункту, даже если он
помечен как прочтенный.  Это не выбирает группу или статью на той
строке.

<A NAME="IDX2330"></A>
<A NAME="IDX2331"></A>
<DT><KBD>s</KBD>
<DD>
В буфере резюме, начинает наращиваемый поиск в тексте текущего буфера
статьи, точно так же, как если бы вы переключились в буфер статьи и
набрали <KBD>C-s</KBD>.

<A NAME="IDX2332"></A>
<A NAME="IDX2333"></A>
<DT><KBD>M-s <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
В буфере резюме, производит поиск статей, содержащих совпадение с
<VAR>regexp</VAR>.

</DL>



<H2><A NAME="SEC417" HREF="emacs_toc.html#TOC417">Запуск команд оболочки из Emacs</A></H2>
<P>
<A NAME="IDX2334"></A>
<A NAME="IDX2335"></A>


<P>
  В Emacs есть команды для передачи одиночных командных строк
подчиненным процессам оболочки.  Существует возможность интерактивного
запуска оболочки с вводом и выводом в буфер Emacs с именем
<TT>`*shell*'</TT>.


<DL COMPACT>

<DT><KBD>M-! <VAR>кмд</VAR> <KBD>RET</KBD></KBD>
<DD>
Запустить командную строку оболочки <VAR>кмд</VAR> и показать ее вывод
(<CODE>shell-command</CODE>).
<DT><KBD>M-| <VAR>кмд</VAR> <KBD>RET</KBD></KBD>
<DD>
Запустить командную строку оболочки <VAR>кмд</VAR> с содержимым области в
качестве ввода; возможна замена содержимого области выводом команды
(<CODE>shell-command-on-region</CODE>).
<DT><KBD>M-x shell</KBD>
<DD>
Запустить подоболочку с вводом и выводом через буфер Emacs.  Затем вы
можете задавать команды интерактивно.
</DL>



<H3><A NAME="SEC418" HREF="emacs_toc.html#TOC418">Отдельные команды оболочки</A></H3>

<P>
<A NAME="IDX2336"></A>
<A NAME="IDX2337"></A>
  <KBD>M-!</KBD> (<CODE>shell-command</CODE>) считывает в минибуфере строку текста
и выполняет ее как команду оболочки в подоболочке, созданной только для
этой команды.  Стандартный ввод команде поступает из нулевого устройства.
Если команда оболочки производит какой-либо вывод, то он поступает в
буфер Emacs с именем <TT>`*Shell Command Output*'</TT>, который отражается
не в выбранном, а в другом окне.  Числовой аргумент, как в <KBD>M-1
M-!</KBD>, велит команде вставить весь вывод в текущий буфер.  В этом случае
точка остается перед выводом, а метка устанавливается за ним.


<P>
  Если командная строка оболочки завершается на <SAMP>`&#38;'</SAMP>, она
выполняется асинхронно.  Для синхронной команды оболочки
<CODE>shell-command</CODE> возвращает выходное значение этой команды (0
обозначает успех), когда она вызывается из Лисп-программы.


<P>
<A NAME="IDX2338"></A>
<A NAME="IDX2339"></A>
  <KBD>M-|</KBD> (<CODE>shell-command-on-region</CODE>) похожа на <KBD>M-!</KBD>, но
команде оболочки передается в качестве стандартного ввода содержимое
области, а не пустота.  Если используется числовой аргумент, означающий
вставку вывода в текущий буфер, то старая область сначала удаляется, а
потом заменяется выводом.  Она возвращает выходное значение команды,
когда запускается из лисповской программы.


<P>
<A NAME="IDX2340"></A>
<A NAME="IDX2341"></A>
  Обе команды <KBD>M-!</KBD>  и <KBD>M-|</KBD> используют оболочку, указанную
переменной <CODE>shell-file-name</CODE>.  При запуске Emacs эта переменная
инициализируется на основании вашей переменной среды @env{SHELL}.  Если
в имени этого файла не указывается каталог, то просматриваются каталоги
в списке <CODE>exec-path</CODE>; этот список инициализируется при запуске
Emacs по переменной среды @env{PATH}.  Ваш файл <TT>`.emacs'</TT> может
отменять либо одну, либо обе эти инициализации по умолчанию.


<P>
   И <KBD>M-!</KBD>  и <KBD>M-|</KBD> ожидают завершения команды оболочки.  Чтобы
остановить ожидание, используйте команду <KBD>C-g</KBD>; она завершает
команду оболочки сигналом <CODE>SIGINT</CODE> -- тем же сигналом, который
обычно генерируется оболочкой при вводе <KBD>C-c</KBD>.  Emacs ждет, пока эта
команда на самом деле завершится.  Если команда оболочки не остановилась
(потому что она игнорирует сигнал <CODE>SIGINT</CODE>), наберите <KBD>C-g</KBD>
снова; это пошлет сигнал <CODE>SIGKILL</CODE>, который невозможно
проигнорировать.


<P>
  Чтобы указать систему кодирования для <KBD>M-!</KBD> или <KBD>M-|</KBD>,
используйте команду <KBD>C-x <KBD>RET</KBD> c</KBD> непосредственно перед ними.
See section <A HREF="emacs_23.html#SEC207">Задание системы кодирования</A>.


<P>
<A NAME="IDX2342"></A>
  Сообщения команды об ошибках обычно перемежаются с обычным выводом.
Если вы установите переменную <CODE>shell-command-default-error-buffer</CODE>
равной строке, являющейся именем буфера, протокол ошибок будет
вставляться перед точкой в буфере с этим именем.




<H3><A NAME="SEC419" HREF="emacs_toc.html#TOC419">Интерактивная подчиненная оболочка</A></H3>

<P>
<A NAME="IDX2343"></A>
  Для запуска интерактивной подоболочки с сохранением протокола в буфере
Emacs применяется <KBD>M-x shell</KBD>.  Эта команда создает (или вновь
использует) буфер с именем <TT>`*shell*'</TT> и запускает подоболочку с
вводом, приходящим из этого буфера, и выводом, идущим в него.  То есть,
любой "терминальный ввод" для подоболочки приходит из текста в буфере,
а любой "терминальный вывод" из подоболочки поступает в буфер,
продвигая точку вперед.  Для передачи ввода в подоболочку необходимо
отправиться в конец буфера, набрать нужное и завершить набором
<KBD>RET</KBD>.


<P>
  Emacs не ждет, пока подоболочка что-либо сделает.  Можно переключать
окна или буферы и редактировать их, пока оболочка ожидает, или пока она
выполняет команду.  Вывод из подоболочки ждет до тех пор, пока у Emacs
не появится время на его обработку; прием происходит всякий раз, когда
Emacs ожидает ввода с клавиатуры, а также когда есть свободное время.


<P>
<A NAME="IDX2344"></A>
<A NAME="IDX2345"></A>
<A NAME="IDX2346"></A>
  В качестве имени файла для загрузки подоболочки используется значение
переменной <CODE>explicit-shell-file-name</CODE>, если оно не <CODE>nil</CODE>.  В
противном случае, используется переменная среды @env{ESHELL} если она
установлена, или @env{SHELL}.  Если указанное имя файла является
относительным, просматриваются каталоги в списке <CODE>exec-path</CODE>; этот
инициализируется по переменной среды @env{PATH} во время запуска Emacs.
Ваш файл <TT>`.emacs'</TT> может перекрыть одну или обе из этих
инициализаций.


<P>
  Чтобы указать для оболочки систему кодирования, вы можете использовать
команду <KBD>C-x <KBD>RET</KBD> c</KBD> непосредственно перед <KBD>M-x shell</KBD>.  Вы
также можете задать систему кодирования после запуска оболочки с помощью
команды <KBD>C-x <KBD>RET</KBD> p</KBD> в ее буфере.  See section <A HREF="emacs_23.html#SEC207">Задание системы кодирования</A>.


<P>
  Как только оболочка запущена, на вход ей подается содержимое файла
<TT>`~/.emacs_<VAR>имя-оболочки</VAR>'</TT>, если этот файл существует, где
<VAR>имя-оболочки</VAR> является именем файла, из которого загружается
оболочка.  Например, если вы используете bash, то ей посылается файл
<TT>`~/.emacs_bash'</TT>.


<P>
<A NAME="IDX2347"></A>
<A NAME="IDX2348"></A>
<A NAME="IDX2349"></A>
  Команды @command{cd}, @command{pushd} и @command{popd}, передаваемые
подчиненной оболочке, отслеживаются в Emacs так, чтобы каталог по
умолчанию буфера <TT>`*shell*'</TT> всегда совпадал с рабочим каталогом
оболочки.  Эти команды распознаются синтаксически проверкой посылаемых
строк ввода.  Если вы используете для этих команд псевдонимы, то вы
можете указать Emacs, что их тоже следует распознавать.  Например, если
значение переменной <CODE>shell-pushd-regexp</CODE> соответствует началу
командной строки оболочки, то эта строка воспринимается как команда
@command{pushd}.  Если для <SAMP>`pushd'</SAMP> используются псевдонимы, то
необходимо изменить эту переменную.  Аналогично,
<CODE>shell-popd-regexp</CODE> и <CODE>shell-cd-regexp</CODE> используются для
распознавания команд, обозначающих <SAMP>`popd'</SAMP> и <SAMP>`cd'</SAMP>.  Причем эти
команды распознаются только в начале командной строки оболочки.


<P>
<A NAME="IDX2350"></A>
  Если Emacs получает ошибку при попытке обработать то, что он считает
командами <SAMP>`cd'</SAMP>, <SAMP>`pushd'</SAMP> или <SAMP>`popd'</SAMP>, он запускает ловушку
<CODE>shell-set-directory-error-hook</CODE> (see section <A HREF="emacs_36.html#SEC449">Ловушки</A>).


<P>
<A NAME="IDX2351"></A>
  Если Emacs не отслеживает правильно изменения текущего каталога
подоболочки, используйте команду <KBD>M-x dirs</KBD>, чтобы спросить оболочку,
какой у нее текущий каталог.  Эта команда работает для оболочек,
поддерживающих наиболее распространенный синтаксис команд; она не
работает с необычными оболочками.


<P>
<A NAME="IDX2352"></A>
  Вы также можете использовать <KBD>M-x dirtrack-mode</KBD>, чтобы включить
(или выключить) альтернативный и более агрессивный метод отслеживания
изменений текущего каталога.


<P>
  Emacs определяет в подоболочке переменную среды @env{EMACS} со
значением <CODE>t</CODE>.  Сценарий оболочки может проверить эту переменную,
чтобы определить, запущен ли он из подоболочки Emacs.




<H3><A NAME="SEC420" HREF="emacs_toc.html#TOC420">Режим Shell</A></H3>
<P>
<A NAME="IDX2353"></A>
<A NAME="IDX2354"></A>


<P>
  Буферы оболочки использует режим Shell, в котором определено несколько
специальных ключей, привязанных к префиксу <KBD>C-c</KBD>.  Они выбраны так,
что имитируют обычные клавиши редактирования и управления заданиями,
присутствующие в оболочках вне Emacs, с той лишь разницей, что сначала
вы должны набрать <KBD>C-c</KBD>.  Ниже приведен полный список таких ключей
режима Shell.


<DL COMPACT>

<DT><KBD><KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX2355"></A>
<A NAME="IDX2356"></A>
В конце буфера, посылает строку в качестве ввода; в противном случае
копирует текущую строку в конец буфера и посылает ее
(<CODE>send-shell-input</CODE>).  При копировании строки любой текст в ее
начале, соответствующий переменной <CODE>shell-prompt-pattern</CODE>,
пропускается; значение этой переменной должно быть регулярным
выражением, которое соответствует подсказкам, используемым в вашей
оболочке.

<DT><KBD><KBD>TAB</KBD></KBD>
<DD>
<A NAME="IDX2357"></A>
<A NAME="IDX2358"></A>
Завершает имя команды или файла перед точкой в буфере оболочки
(<CODE>comint-dynamic-complete</CODE>).  <KBD>TAB</KBD> также завершает ссылки на
историю (see section <A HREF="emacs_35.html#SEC424">Ссылки на историю оболочки</A>) и имена переменных среды.

<A NAME="IDX2359"></A>
<A NAME="IDX2360"></A>
Переменная <CODE>shell-completion-fignore</CODE> задает список расширений
файлов, которые должны игнорироваться при завершении в режиме Shell.
Установка по умолчанию игнорирует имена файлов, заканчивающиеся на
<SAMP>`~'</SAMP>, <SAMP>`#'</SAMP> или <SAMP>`%'</SAMP>.  Другие родственные с Comint режимы
используют переменную <CODE>comint-completion-fignore</CODE>.

<DT><KBD>M-?</KBD>
<DD>
<A NAME="IDX2361"></A>
<A NAME="IDX2362"></A>
Временно показывает список возможных завершений имени файла перед точкой
в буфере оболочки (<CODE>comint-dynamic-list-filename-completions</CODE>).

<DT><KBD>C-d</KBD>
<DD>
<A NAME="IDX2363"></A>
<A NAME="IDX2364"></A>
Либо удаляет один знак, либо посылает EOF
(<CODE>comint-delchar-or-maybe-eof</CODE>).  Набранный в конце буфера
оболочки, <KBD>C-d</KBD> посылает подоболочке EOF.  Набранный в любой
другой позиции в этом буфере, <KBD>C-d</KBD> удаляет один знак, как обычно.

<DT><KBD>C-c C-a</KBD>
<DD>
<A NAME="IDX2365"></A>
<A NAME="IDX2366"></A>
Перемещает в начало строки, но после подсказки, если она есть
(<CODE>comint-bol</CODE>).  Если вы наберете эту команду два раза подряд, на
второй раз она возвращает к метке процесса, то есть к началу ввода,
который вы еще не послали подоболочке.  (Обычно это одно и то же место
--- конец подсказки в текущей строке -- но после <KBD>C-c <KBD>SPC</KBD></KBD>
метка процесса может оказаться на предыдущей строке.)

<DT><KBD>C-c <KBD>SPC</KBD></KBD>
<DD>
Накапливает несколько строк ввода, и потом посылает их вместе.  Эта
команда вставляет перед точкой перевод строки, но не посылает
предшествующий текст на вход подоболочки -- по крайней мере не сейчас.
Обе строки, и та, что перед переводом строки, и та, что после, будут
посланы вместе (и с разделяющим их переводом строки), когда вы нажмете
<KBD>RET</KBD>.

<DT><KBD>C-c C-u</KBD>
<DD>
<A NAME="IDX2367"></A>
<A NAME="IDX2368"></A>
Уничтожает весь текст, который еще не был послан в качестве ввода
(<CODE>comint-kill-input</CODE>).

<DT><KBD>C-c C-w</KBD>
<DD>
<A NAME="IDX2369"></A>
Уничтожает слово перед точкой (<CODE>backward-kill-word</CODE>).

<DT><KBD>C-c C-c</KBD>
<DD>
<A NAME="IDX2370"></A>
<A NAME="IDX2371"></A>
Прерывает оболочку или ее текущее подзадание, если оно существует
(<CODE>comint-interrupt-subjob</CODE>).  Эта команда уничтожает также весь
предназначенный для ввода текст, который еще не был послан.

<DT><KBD>C-c C-z</KBD>
<DD>
<A NAME="IDX2372"></A>
<A NAME="IDX2373"></A>
Останавливает оболочку или ее текущее подзадание, если оно существует
(<CODE>comint-stop-subjob</CODE>).  Эта команда уничтожает также весь текст,
который еще не был послан в качестве ввода.

<DT><KBD>C-c C-\</KBD>
<DD>
<A NAME="IDX2374"></A>
<A NAME="IDX2375"></A>
Посылает сигнал выхода оболочке или ее текущему подзаданию, если оно
существует (<CODE>comint-quit-subjob</CODE>).  Эта команда уничтожает также
весь предназначенный для ввода текст, который еще не был послан.

<DT><KBD>C-c C-o</KBD>
<DD>
<A NAME="IDX2376"></A>
<A NAME="IDX2377"></A>
Уничтожает последнюю порцию вывода от команды оболочки
(<CODE>comint-kill-output</CODE>).  Это полезно, если команда оболочки
извергает много текста, который только мешает.

<DT><KBD>C-c C-r</KBD>
<DD>
<DT><KBD>C-M-l</KBD>
<DD>
<A NAME="IDX2378"></A>
<A NAME="IDX2379"></A>
<A NAME="IDX2380"></A>
Прокручивает окно так, чтобы начало последней порции вывода оказалось
вверху; также перемещает туда курсор (<CODE>comint-show-output</CODE>).

<DT><KBD>C-c C-e</KBD>
<DD>
<A NAME="IDX2381"></A>
<A NAME="IDX2382"></A>
Прокручивает окно, чтобы начало последней порции вывода оказалось внизу
(<CODE>comint-show-maximum-output</CODE>).

<DT><KBD>C-c C-f</KBD>
<DD>
<A NAME="IDX2383"></A>
<A NAME="IDX2384"></A>
<A NAME="IDX2385"></A>
Перемещает вперед на одну команду оболочки, но в пределах текущей строки
(<CODE>shell-forward-command</CODE>).  Переменная <CODE>shell-command-regexp</CODE>
указывает, как распознать конец команды.

<DT><KBD>C-c C-b</KBD>
<DD>
<A NAME="IDX2386"></A>
<A NAME="IDX2387"></A>
Перемещает назад на одну команду оболочки, но в пределах текущей строки
(<CODE>shell-backward-command</CODE>).

<DT><KBD>C-c C-l</KBD>
<DD>
<A NAME="IDX2388"></A>
<A NAME="IDX2389"></A>
Показывает историю команд оболочки этого буфера в другом окне
(<CODE>comint-dynamic-list-input-ring</CODE>).

<DT><KBD>M-x dirs</KBD>
<DD>
Спрашивает оболочку о текущем каталоге, чтобы Emacs скоординировался с
оболочкой.

<DT><KBD>M-x send-invisible <KBD>RET</KBD> <VAR>текст</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX2390"></A>
Считывает <VAR>текст</VAR> и посылает его на вход оболочки без эхо.  Это
полезно, когда команда оболочки запускает программу, спрашивающую
пароль.

Или вы можете сообщить Emacs, как распознавать запросы пароля и
выключать для них эхо:


<PRE>
(add-hook 'comint-output-filter-functions
          'comint-watch-for-password-prompt)
</PRE>

<DT><KBD>M-x comint-continue-subjob</KBD>
<DD>
<A NAME="IDX2391"></A>
Возобновляет процесс оболочки.  Это полезно, если вы нечаянно
приостановили процесс оболочки.<A NAME="DOCF6" HREF="emacs_foot.html#FOOT6">(6)</A>

<DT><KBD>M-x comint-strip-ctrl-m</KBD>
<DD>
<A NAME="IDX2392"></A>
Убирает все знаки control-M из текущей порции вывода оболочки.  Наиболее
удобный способ использовать эту команду -- запускать ее автоматически,
когда вы получаете вывод от подоболочки.  Чтобы сделать так, вычислите
следующее лисповское выражение:


<PRE>
(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
</PRE>

<DT><KBD>M-x comint-truncate-buffer</KBD>
<DD>
<A NAME="IDX2393"></A>
Эта команда усекает буфер оболочки до определенного максимального числа
строк, задаваемого переменной <CODE>comint-buffer-maximum-size</CODE>.  Это
можно сделать автоматически каждый раз при получении вывода от
подоболочки таким способом:


<PRE>
(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
</PRE>

</DL>

<P>
  Режим Shell также настраивает команды работы с абзацами таким образом,
что только подсказки оболочки начинают абзацы.  Таким образом, абзац
состоит из введенной команды плюс из следующего за ней в буфере вывода.


<P>
<A NAME="IDX2394"></A>
<A NAME="IDX2395"></A>
  Режим Shell происходит от режима Comint, режима общего назначения для
общения с интерактивными подпроцессами.  Большинство возможностей режима
Shell в действительности дает режим Comint, как вы можете понять из имен
перечисленных выше команд.  Особые средства режима Shell включают выбор
регулярного выражения для распознавания подсказки, средство отслеживания
каталогов и несколько пользовательских команд.


<P>
  Другие средства Emacs, использующие варианты режима Comint, включают
GUD (see section <A HREF="emacs_28.html#SEC316">Запуск отладчиков в Emacs</A>) и <KBD>M-x run-lisp</KBD> (see section <A HREF="emacs_28.html#SEC325">Запуск внешнего Лиспа</A>).


<P>
<A NAME="IDX2396"></A>
  Вы можете использовать <KBD>M-x comint-run</KBD> для выполнения любой
программы по вашему выбору в неизмененном режиме Comint -- без
особенностей режима Shell.




<H3><A NAME="SEC421" HREF="emacs_toc.html#TOC421">История команд оболочки</A></H3>

<P>
  Буферы оболочки поддерживают три способа повторения более ранних
команд.  Вы можете использовать те же ключи, что используются в
минибуфере; они работают во многом так же, как в минибуфере, вставляя
текст предыдущих команд, всегда оставляя точку в конце буфера.  Вы
можете переместиться по буферу назад к предыдущим командам в их
начальной позиции и затем снова послать их или скопировать в конец.  Или
вы можете использовать знак <SAMP>`!'</SAMP> для ссылок на старые команды.




<H4><A NAME="SEC422" HREF="emacs_toc.html#TOC422">Список истории оболочки</A></H4>

<DL COMPACT>

<DT><KBD>M-p</KBD>
<DD>
<A NAME="IDX2397"></A>
 <A NAME="IDX2398"></A>
 
Извлекает следующую более старую команду оболочки.

<A NAME="IDX2399"></A>
<A NAME="IDX2400"></A>
<DT><KBD>M-n</KBD>
<DD>
Извлекает следующую более новую команду оболочки.

<A NAME="IDX2401"></A>
<A NAME="IDX2402"></A>
<A NAME="IDX2403"></A>
<A NAME="IDX2404"></A>
<DT><KBD>M-r <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
<DT><KBD>M-s <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Производит поиск команды оболочки, соответствующей регулярному выражению
<VAR>regexp</VAR>, вперед или назад.

<DT><KBD>C-c C-x (режим Shell)</KBD>
<DD>
<A NAME="IDX2405"></A>
Извлекает следующую команду в списке истории.
</DL>

<P>
  Буферы оболочки предоставляют историю ранее введенных команд.  Чтобы
снова использовать команды оболочки, сохраненные в истории, используйте
команды редактирования <KBD>M-p</KBD>, <KBD>M-n</KBD>, <KBD>M-r</KBD> и <KBD>M-s</KBD>.  Они
работают так же, как команды истории минибуфера, за тем лишь
исключением, что действуют на текст в конце буфера оболочки, где вы
вставляли бы текст для отправки оболочке.


<P>
  <KBD>M-p</KBD> вставляет более раннюю команду оболочки в буфер оболочки.
Последовательное применение <KBD>M-p</KBD> извлекает последовательно все
более ранние команды оболочки, каждый раз замещая любой текст, уже
существовавший в качестве потенциального ввода для оболочки.  <KBD>M-n</KBD>
работает похоже, но последовательно находит более поздние команды
оболочки из этого буфера.


<P>
  Команды поиска в истории, <KBD>M-r</KBD> и <KBD>M-s</KBD>, считывают регулярное
выражение и производят поиск совпадающей команды в истории.  Кроме
предоставления выбора, какую именно команду вы хотите извлечь, они
работают точно так же, как <KBD>M-p</KBD> и <KBD>M-r</KBD>.  Если вы введете
пустое регулярное выражение, будет использовано то регулярное выражение,
которое вы предоставили в последний раз.


<P>
  Когда вы нашли желаемый предыдущий ввод, вы можете снова послать его,
нажав <KBD>RET</KBD>, или сначала отредактировать и затем послать, если
хотите.


<P>
  Часто бывает полезно заново выполнить несколько последовательных
команд оболочки, которые ранее выполнялись по порядку.  Чтобы сделать
это, сначала найдите и выполните первую команду в последовательности.
Затем наберите <KBD>C-c C-x</KBD>; это извлечет следующую команду -- ту,
которая шла за только что повторенной.  Затем нажмите <KBD>RET</KBD>, чтобы
заново выполнить эту команду.  Вы можете повторить несколько
последовательных команд, набирая <KBD>C-c C-x <KBD>RET</KBD></KBD> снова и снова.


<P>
  Эти команды получают текст более ранних команд оболочки из
специального списка истории, не из самого буфера оболочки.  Поэтому
редактирование буфера оболочки или даже уничтожение больших его частей
не влияет на историю, к которой обращаются эти команды.


<P>
<A NAME="IDX2406"></A>
  Некоторые оболочки сохраняют истории их команд в файлах, чтобы вы
могли сослаться на старые команды из предыдущих сеансовx.  Emacs
считывает файл истории команд для выбранной вами оболочки, чтобы
проинициализировать свою собственную историю команд.  Этот файл
называется <TT>`~/.bash_history'</TT> в bash, <TT>`~/.sh_history'</TT> в ksh и
<TT>`~/.history'</TT> в других оболочках.




<H4><A NAME="SEC423" HREF="emacs_toc.html#TOC423">Копирование истории оболочки</A></H4>

<DL COMPACT>

<DT><KBD>C-c C-p</KBD>
<DD>
<A NAME="IDX2407"></A>
 <A NAME="IDX2408"></A>
 
Перемещает точку к предыдущей подсказке (<CODE>comint-previous-prompt</CODE>).

<A NAME="IDX2409"></A>
<A NAME="IDX2410"></A>
<DT><KBD>C-c C-n</KBD>
<DD>
Перемещает точку к следующей подсказке (<CODE>comint-next-prompt</CODE>).

<A NAME="IDX2411"></A>
<A NAME="IDX2412"></A>
<DT><KBD>C-c <KBD>RET</KBD></KBD>
<DD>
Копирует команду ввода, в которой находится точка, вставляя ее копию в
конец буфера (<CODE>comint-copy-old-input</CODE>).  Это полезно, если вы
переместили точку назад к предыдущей команде.  После того, как вы
скопировали эту команду, вы можете послать копию в качестве ввода, нажав
<KBD>RET</KBD>.  Если вы хотите, вы можете отредактировать копию перед
отправлением.
</DL>

<P>
  Перемещение к предыдущему вводу и последующее его копирование с
помощью <KBD>C-c <KBD>RET</KBD></KBD> дает тот же результат -- то же содержимое
буфера -- какой вы получили бы применением <KBD>M-p</KBD> достаточное число
раз, чтобы извлечь эту старую команду из списка истории.  Однако,
<KBD>C-c <KBD>RET</KBD></KBD> копирует текст из буфера, которые может отличаться
от того, что находится в списке истории, если вы редактировали в буфере
введенный текст после того, как он был послан.




<H4><A NAME="SEC424" HREF="emacs_toc.html#TOC424">Ссылки на историю оболочки</A></H4>
<P>
<A NAME="IDX2413"></A>


<P>
  Различные оболочки, включая csh и bash, поддерживают <EM>ссылки на
историю</EM>, которые начинаются с <SAMP>`!'</SAMP> и <SAMP>`^'</SAMP>.  Режим Shell может
понимать такие конструкции и делать для вас подстановку.  Если вы
вставили ссылку на историю и нажали <KBD>TAB</KBD>, это приведет к поиску
совпадающей команды в истории ввода, подстановке, если она необходима, и
помещению в буфер результата на место ссылки.  Например, вы можете
извлечь самую недавнюю команду, начинающуюся на <SAMP>`mv'</SAMP>, с помощью
<KBD>! m v <KBD>TAB</KBD></KBD>.  Вы можете отредактировать эту команду, если
хотите, и затем послать ее оболочке, нажав <KBD>RET</KBD>.


<P>
<A NAME="IDX2414"></A>
<A NAME="IDX2415"></A>
  Ссылки на историю действуют только после подсказки оболочки.
Переменная <CODE>shell-prompt-pattern</CODE> указывает, как распознать
подсказку.  Вообще, режимы Comint используют для определения подсказки
переменную <CODE>comint-prompt-regexp</CODE>; режим Shell использует
<CODE>shell-prompt-pattern</CODE>, чтобы установить локальное значение
<CODE>comint-prompt-regexp</CODE>.


<P>
<A NAME="IDX2416"></A>
  В режиме Shell есть возможность раскрывать ссылки на историю, когда вы
отправляете их оболочке.  Чтобы затребовать это, установите переменную
<CODE>comint-input-autoexpand</CODE> равной <CODE>input</CODE>.


<P>
<A NAME="IDX2417"></A>
  Вы можете сделать так, чтобы <KBD>SPC</KBD> производил раскрытие истории,
привязав <KBD>SPC</KBD> к команде <CODE>comint-magic-space</CODE>.




<H3><A NAME="SEC425" HREF="emacs_toc.html#TOC425">Параметры режима Shell</A></H3>

<P>
<A NAME="IDX2418"></A>
  Если переменная <CODE>comint-scroll-to-bottom-on-input</CODE> не равна
<CODE>nil</CODE>, команды вставки и восстановления прокручивают выбранное окно
книзу перед вставкой.


<P>
<A NAME="IDX2419"></A>
  Если <CODE>comint-scroll-show-maximum-output</CODE> не равна <CODE>nil</CODE>, то
прокрутка из-за поступления вывода старается разместить последнюю строку
текста на нижней строке окна, чтобы вы видели как можно больше полезного
текста.  (Это имитирует поведение прокрутки на многих терминалах.)  По
умолчанию эта переменная равна <CODE>nil</CODE>.


<P>
<A NAME="IDX2420"></A>
  Установкой <CODE>comint-scroll-to-bottom-on-output</CODE> вы можете сделать
так, чтобы точка перескакивала в конец буфера всякий раз при поступлении
вывода -- независимо от того, где точка была раньше.  Если значение
равно <CODE>this</CODE>, точка перескакивает в выбранном окне.  Если значение
равно <CODE>all</CODE>, точка перескакивает в каждом окне, показывающем этот
буфер Comint.  Если значение равно <CODE>other</CODE>, точка перескакивает во
всех невыбранных окнах, показывающих текущий буфер.  По умолчанию это
<CODE>nil</CODE>, что означает, что точка не должна перемещаться в конец.


<P>
<A NAME="IDX2421"></A>
  Переменная <CODE>comint-input-ignoredups</CODE> говорит, нужно ли сохранять
в истории последовательные одинаковые строки ввода.  Отличное от
<CODE>nil</CODE> значение велит опускать ввод, идентичный предыдущему.  По
умолчанию эта переменная равна <CODE>nil</CODE>; это значит, что сохраняется
любой ввод, даже если он эквивалентен предыдущему.


<P>
<A NAME="IDX2422"></A>
<A NAME="IDX2423"></A>
<A NAME="IDX2424"></A>
  Завершение имен файлов управляется тремя переменными.  Переменная
<CODE>comint-completion-addsuffix</CODE> говорит, вставляет ли завершение
пробел или косую черту, чтобы обозначить полностью завершенное имя файла
или каталога (не-<CODE>nil</CODE> велит вставлять пробел или косую черту).
<CODE>comint-completion-recexact</CODE>, если не равна <CODE>nil</CODE>, указывает
<KBD>TAB</KBD> выбирать наименьшее возможное завершение, если обычный
алгоритм завершения Emacs не может добавить даже одного знака.
<CODE>comint-completion-autolist</CODE>, если не равна <CODE>nil</CODE>, велит
перечислять все возможные завершения, когда нельзя найти точное
завершение.


<P>
<A NAME="IDX2425"></A>
  Команда <CODE>comint-dynamic-complete-variable</CODE> завершает имя
переменной, используя установки переменных среды внутри Emacs.
Переменные, управляющие завершением имен файлов, применяются и к
завершению имен переменных.  Эта команда обычно доступна через меню.


<P>
<A NAME="IDX2426"></A>
  При завершении команд обычно рассматриваются только исполняемые файлы.
Если вы установите <CODE>shell-command-execonly</CODE> равной <CODE>nil</CODE>,
будут рассматриваться также имена и неисполняемых файлов.


<P>
<A NAME="IDX2427"></A>
<A NAME="IDX2428"></A>
<A NAME="IDX2429"></A>
  Вы можете сконфигурировать поведение <SAMP>`pushd'</SAMP>.  Есть переменные,
которые указывают, ведет ли себя @command{pushd}, как @command{cd}, если
ей не задан аргумент (<CODE>shell-pushd-tohome</CODE>), выталкивает ли она
каталог, а не прокручивает, если ей задан числовой аргумент
(<CODE>shell-pushd-dextract</CODE>), и добавляет ли она каталоги в стек только
в том случае, если их еще нет в нем (<CODE>shell-pushd-dunique</CODE>).
Выбранные вами значения должны, разумеется, соответствовать вашей
оболочке.




<H3><A NAME="SEC426" HREF="emacs_toc.html#TOC426">Оболочка на удаленной машине</A></H3>
<P>
<A NAME="IDX2430"></A>
<A NAME="IDX2431"></A>
<A NAME="IDX2432"></A>
<A NAME="IDX2433"></A>


<P>
  Emacs предоставляет две команды для захода на другой компьютер и
общения с ним через буфер Emacs.


<DL COMPACT>

<DT><KBD>M-x telnet <KBD>RET</KBD> <VAR>имя-машины</VAR> <KBD>RET</KBD></KBD>
<DD>
Устанавливает с компьютером <VAR>имя-машины</VAR> соединение по Telnet.
<DT><KBD>M-x rlogin <KBD>RET</KBD> <VAR>имя-машины</VAR> <KBD>RET</KBD></KBD>
<DD>
Устанавливает с компьютером <VAR>имя-машины</VAR> соединение по Rlogin.
</DL>

<P>
<A NAME="IDX2434"></A>
  Используйте <KBD>M-x telnet</KBD>, чтобы установить соединение по Telnet с
другим компьютером.  (Telnet -- это стандартный протокол Internet для
захода на удаленную систему.)  Она считывает в минибуфере имя другого
компьютера в качестве аргумента.  Когда соединение установлено, общение
с другим компьютером работает похоже на общение с подоболочкой: вы
можете редактировать ввод с помощью обычных команд Emacs и посылать его
построчно, набирая <KBD>RET</KBD>.  Вывод вставляется в буфер вперемешку со
вводом.


<P>
<A NAME="IDX2435"></A>
<A NAME="IDX2436"></A>
  Используйте <KBD>M-x rlogin</KBD> для установки соединения по Rlogin.
Rlogin -- это другой протокол общения с удаленной системой, во многом
похожий на Telnet, но не совместимый с ним и поддерживаемый только на
некоторых системах.  Преимущества Rlogin состоят в том, что вы можете
сделать так, чтобы вам необязательно было задавать имя пользователя и
пароль при общении между часто используемыми машинами, и что вы можете
установить восьмибитное соединение.  (Чтобы сделать это в Emacs,
установите <CODE>rlogin-explicit-args</CODE> равной <CODE>("-8")</CODE> перед
запуском Rlogin.)


<P>
  <KBD>M-x rlogin</KBD> устанавливает каталог по умолчанию данного буфера
Emacs, чтобы получать доступ к удаленной машине через FTP (see section <A HREF="emacs_19.html#SEC109">Имена файлов</A>), и отслеживает команды оболочки, которые изменяют текущий
каталог, так же, как режим Shell.


<P>
<A NAME="IDX2437"></A>
  Есть два способа отслеживания каталогов в буфере Rlogin -- либо с
помощью имен удаленных каталогов <TT>`/<VAR>машина</VAR>:<VAR>кат</VAR>/'</TT>, либо с
помощью локальных имен (это работает, если "удаленная" машина разделяет
файловые системы с вашей начальной машиной).  Вы можете использовать
команду <CODE>rlogin-directory-tracking-mode</CODE>, чтобы переключать эти
режимы.  Отсутствие аргумента обозначает использование имен удаленных
каталогов, положительный аргумент обозначает использование локальных
имен, а отрицательный выключает отслеживание каталогов.




<H2><A NAME="SEC427" HREF="emacs_toc.html#TOC427">Использование Emacs в качестве сервера</A></H2>
<P>
<A NAME="IDX2438"></A>
<A NAME="IDX2439"></A>
<A NAME="IDX2440"></A>
<A NAME="IDX2441"></A>


<P>
  Различные программы, такие как @command{mail}, могут вызывать
выбранный вами редактор для редактирования определенного текста,
например, отправляемого сообщения.  По соглашению, большинство этих
программ используют переменную среды @env{EDITOR}, чтобы определить,
какой редактор надо запускать.  Если вы установите @env{EDITOR} равной
<SAMP>`emacs'</SAMP>, они вызовут Emacs -- но неудобным способом, запуская
новый отдельный процесс Emacs.  Это неудобно, потому что занимает время
и потому что новый процесс Emacs не разделяет буферы с существующим
процессом.


<P>
  Вы можете сделать так, чтобы в качестве редактора для программ вроде
@command{mail} использовался ваш существующий процесс Emacs, путем
применения клиента и сервера Emacs.  Вот как это делается.


<P>
<A NAME="IDX2442"></A>
  Во-первых, подготовка.  Внутри Emacs, вызовите функцию
<CODE>server-start</CODE>.  (Ваш файл <TT>`.emacs'</TT> может делать это
автоматически, если вы добавите в него выражение <CODE>(server-start)</CODE>.)
Затем, извне Emacs, установите переменную среды @env{EDITOR} равной
<SAMP>`emacsclient'</SAMP>.  (Заметьте, что некоторые программы используют другую
переменную среды; например, чтобы TeX использовал <SAMP>`emacsclient'</SAMP>,
вам нужно установить переменную среды @env{TEXEDIT} равной
<SAMP>`emacsclient +%d %s'</SAMP>.)


<P>
<A NAME="IDX2443"></A>
<A NAME="IDX2444"></A>
  Впоследствии, когда любая программа вызывает указанную программу
@env{EDITOR}, в результате вашему главному Emacs будет отправлено
сообщение, чтобы он обратился к файлу.  (Программа @command{emacsclient}
делает именно это.)  Emacs немедленно показывает этот буфер, и вы сразу
можете начать его редактирование.


<P>
  Когда вы завершите редактирование этого буфера, наберите <KBD>C-x #</KBD>
(<CODE>server-edit</CODE>).  Это сохранит файл и пошлет программе
@command{emacsclient} сообщение, приказывающее выйти.  Программы,
использующие @env{EDITOR}, ожидают, пока "редактор" (на самом деле,
@command{emacsclient}) не выйдет.  <KBD>C-x #</KBD> также проверяет другие
отложенные внешние запросы на редактирование различных файлов и выбирает
следующий.


<P>
  Вы можете переключиться в серверный буфер вручную, если хотите;
необязательно попадать в него с помощью <KBD>C-x #</KBD>.  Но <KBD>C-x #</KBD>
дает единственный способ сказать, что "закончили" с текущим.


<P>
<A NAME="IDX2445"></A>
  Если вы установите переменную
<CODE>server-window</CODE> равной окну или фрейму,
<KBD>C-x #</KBD> будет показывать серверный буфер в этом окне или фрейме.


<P>
  Пока @command{mail} или другое приложение ожидает завершения
@command{emacsclient}, @command{emacsclient} не читает терминальный
ввод.  Поэтому терминал, который использовала @command{mail}, как бы
блокируется на это время.  Чтобы редактировать в вашем главном Emacs,
вам нужна возможность использовать Emacs без этого терминала.  Есть два
способа добиться этого:



<UL>
<LI>

Используя оконную систему, запускайте @command{mail} и главный Emacs в
двух разных окнах.  Пока @command{mail} ожидает @command{emacsclient},
окно, в котором она запущена, блокируется, но вы можете использовать
Emacs, переключив окно.

<LI>

Используйте для запуска других программ, таких как @command{mail}, режим
Shell в Emacs; тогда @command{emacsclient} блокирует только подоболочку
в Emacs, и вы можете продолжать использовать Emacs для редактирования
этого файла.
</UL>

<P>
<A NAME="IDX2446"></A>
  Некоторые программы записывают для вашего редактирования временные
файлы.  После того, как вы отредактировали такой временный файл,
программа считывает его и удаляет.  Если сервер Emacs позже попросят
отредактировать файл с тем же именем, он не должен предполагать, что
этот файл имеет какое-либо отношение к предыдущему появлению этого же
имени.  Сервер делает это, уничтожая буфер временного файла, когда вы
закончили с ним.  Используйте переменную <CODE>server-temp-file-regexp</CODE>,
чтобы указать, какие файлы являются временными в этом смысле; ее
значением должно быть регулярное выражение, совпадающее с именами
временных файлов.


<P>
  Если вы запускаете @command{emacsclient} с ключом @option{--no-wait},
он возвращается сразу, не дожидаясь, пока вы "завершите" с буфером в
Emacs.




<H2><A NAME="SEC428" HREF="emacs_toc.html#TOC428">Вывод твердой копии</A></H2>
<P>
<A NAME="IDX2447"></A>
<A NAME="IDX2448"></A>


<P>
  Команды Emacs для создания твердой копии позволяют вам напечатать весь
буфер или только его часть с заголовками или без них.  Смотрите также
команды печати Dired (see section <A HREF="emacs_19.html#SEC158">Разнообразные действия над файлами</A>)
и дневника (see section <A HREF="emacs_34.html#SEC405">Команды для просмотра записей в дневнике</A>).


<DL COMPACT>

<DT><KBD>M-x print-buffer</KBD>
<DD>
Выдать распечатку текущего буфера с заголовками, содержащими имя файла и
номер страницы.
<DT><KBD>M-x lpr-buffer</KBD>
<DD>
Выдать распечатку текущего буфера без заголовков страниц.
<DT><KBD>M-x print-region</KBD>
<DD>
Как <CODE>print-buffer</CODE>, но печатать только текущую область.
<DT><KBD>M-x lpr-region</KBD>
<DD>
Как <CODE>lpr-buffer</CODE>, но печатать только текущую область.
</DL>

<P>
<A NAME="IDX2449"></A>
<A NAME="IDX2450"></A>
<A NAME="IDX2451"></A>
<A NAME="IDX2452"></A>
<A NAME="IDX2453"></A>
  Все команды печати (кроме использующих Postscript) передают программе
@command{lpr} дополнительные ключи, базирующиеся на значении переменной
<CODE>lpr-switches</CODE>.  Ее значение должно быть списком строк, причем
каждая строка -- это ключ, начинающийся с <SAMP>`-'</SAMP>.  Например, чтобы
сделать ширину строк равной восьмидесяти столбцам для всех распечаток,
получаемых из Emacs, установите <CODE>lpr-switches</CODE> так:



<PRE>
(setq lpr-switches '("-w80"))
</PRE>

<P>
<A NAME="IDX2454"></A>
  Вы можете указать, какой принтер должен использоваться, установив
переменную <CODE>printer-name</CODE>.


<P>
<A NAME="IDX2455"></A>
<A NAME="IDX2456"></A>
<A NAME="IDX2457"></A>
  Переменная <CODE>lpr-command</CODE> задает имя используемой программы
печати; значение по умолчанию зависит от типа вашей операционной
системы.  На большинстве систем это <CODE>"lpr"</CODE>.  Переменная
<CODE>lpr-headers-switches</CODE> похожим образом задает дополнительные ключи
для создания заголовков страниц.  Переменная <CODE>lpr-add-switches</CODE>
указывает, нужно ли передавать программе печати ключи <SAMP>`-T'</SAMP> и
<SAMP>`-J'</SAMP> (подходящие для @command{lpr}): <CODE>nil</CODE> означает, что
добавлять их не надо.  <CODE>lpr-add-switches</CODE> должна быть равна
<CODE>nil</CODE>, если ваша программа печати не совместима с @command{lpr}.




<H2><A NAME="SEC429" HREF="emacs_toc.html#TOC429">Печать через Postscript</A></H2>

<P>
  Эти команды преобразуют содержимое буфера в Postscript и либо печатают
его, либо оставляют в другом буфере Emacs.


<DL COMPACT>

<DT><KBD>M-x ps-print-buffer</KBD>
<DD>
Выводит распечатку текущего буфера в форме Postscript.
<DT><KBD>M-x ps-print-region</KBD>
<DD>
Выводит распечатку текущей области в форме Postscript.
<DT><KBD>M-x ps-print-buffer-with-faces</KBD>
<DD>
Выводит распечатку текущего буфера в форме Postscript, показывая
использованные в тексте начертания средствами Postscript.
<DT><KBD>M-x ps-print-region-with-faces</KBD>
<DD>
Выводит распечатку текущей области в форме Postscript, показывая
использованные в тексте начертания средствами Postscript.
<DT><KBD>M-x ps-spool-buffer</KBD>
<DD>
Генерирует Postscript для текста текущего буфера.
<DT><KBD>M-x ps-spool-region</KBD>
<DD>
Генерирует Postscript для текущей области.
<DT><KBD>M-x ps-spool-buffer-with-faces</KBD>
<DD>
Генерирует Postscript для текущего буфера, показывая использованные
начертания.
<DT><KBD>M-x ps-spool-region-with-faces</KBD>
<DD>
Генерирует Postscript для текущей области, показывая использованные
начертания.
</DL>

<P>
<A NAME="IDX2458"></A>
<A NAME="IDX2459"></A>
<A NAME="IDX2460"></A>
<A NAME="IDX2461"></A>
  Команды работы с Postscript, <CODE>ps-print-buffer</CODE> и
<CODE>ps-print-region</CODE>, печатают содержимое буфера в форме Postscript.
Одна команда печатает весь буфер, другая -- только область.
Соответствующие команды с окончанием <SAMP>`-with-faces'</SAMP>,
<CODE>ps-print-buffer-with-faces</CODE> и <CODE>ps-print-region-with-faces</CODE>,
используют средства Postscript для передачи начертаний (шрифтов и
цветов) в свойствах печатаемого текста.


<P>
  Если вы используете цветной дисплей, вы можете напечатать буфер,
содержащий код программы, с цветовой подсветкой, включив в этом буфере
режим Font-Lock и вызвав <CODE>ps-print-buffer-with-faces</CODE>.


<P>
<A NAME="IDX2462"></A>
<A NAME="IDX2463"></A>
<A NAME="IDX2464"></A>
<A NAME="IDX2465"></A>
  Команды, чьи имена содержат <SAMP>`spool'</SAMP> на месте <SAMP>`print'</SAMP>,
генерируют вывод Postscript в буфере Emacs, а не посылают его на
принтер.




<H2><A NAME="SEC430" HREF="emacs_toc.html#TOC430">Переменные, управляющие печатью в Postscript</A></H2>

<P>
<A NAME="IDX2466"></A>
<A NAME="IDX2467"></A>
<A NAME="IDX2468"></A>
  Все команды печати через Postscript используют переменные
<CODE>ps-lpr-command</CODE> и <CODE>ps-lpr-switches</CODE>, указывающие, как нужно
печатать.  <CODE>ps-lpr-command</CODE> задает имя запускаемой команды,
<CODE>ps-lpr-switches</CODE> задает ключи командной строки, а
<CODE>ps-printer-name</CODE> задает принтер.  Если вы не установили первые две
переменные сами, они получают свои начальные значения от
<CODE>lpr-command</CODE> и <CODE>lpr-switches</CODE>.  Если <CODE>ps-printer-name</CODE>
равна <CODE>nil</CODE>, используется <CODE>printer-name</CODE>.


<P>
<A NAME="IDX2469"></A>
<A NAME="IDX2470"></A>
  Переменная <CODE>ps-print-header</CODE> контролирует, будут ли эти команды
добавлять строки заголовка для каждой страницы, -- установите ее равной
<CODE>nil</CODE>, чтобы выключить заголовки.  Вы можете отключить обработку
цветов, установив <CODE>ps-print-color-p</CODE> в значение <CODE>nil</CODE>.


<P>
<A NAME="IDX2471"></A>
<A NAME="IDX2472"></A>
  Переменная <CODE>ps-paper-type</CODE> указывает, для какого размера станицы
нужно форматировать; допустимые значения включают <CODE>a4</CODE>, <CODE>a3</CODE>,
<CODE>a4small</CODE>, <CODE>b4</CODE>, <CODE>b5</CODE>, <CODE>executive</CODE>, <CODE>ledger</CODE>,
<CODE>legal</CODE>, <CODE>letter</CODE>, <CODE>letter-small</CODE>, <CODE>statement</CODE>,
<CODE>tabloid</CODE>.  По умолчанию это <CODE>letter</CODE>.  Вы можете определить
дополнительные размеры бумаги, изменяя переменную
<CODE>ps-page-dimensions-database</CODE>.


<P>
<A NAME="IDX2473"></A>
  Переменная <CODE>ps-landscape-mode</CODE> указывает ориентацию текста на
странице.  По умолчанию она равна <CODE>nil</CODE>, что обозначает
"портретный" режим.  Любое отличное от <CODE>nil</CODE> значение задает
"ландшафтный" режим.


<P>
<A NAME="IDX2474"></A>
  Переменная <CODE>ps-number-of-columns</CODE> задает число колонок; она
играет роль и в "портретном", и в "ландшафтном" режиме.  По
умолчанию это 1.


<P>
<A NAME="IDX2475"></A>
<A NAME="IDX2476"></A>
<A NAME="IDX2477"></A>
  Переменная <CODE>ps-font-family</CODE> указывает, какое семейство шрифтов
нужно использовать при печати обычного текста.  Допустимые значения
включают <CODE>Courier</CODE>, <CODE>Helvetica</CODE>, <CODE>NewCenturySchlbk</CODE>,
<CODE>Palatino</CODE> и <CODE>Times</CODE>.  Переменная <CODE>ps-font-size</CODE> задает
размер шрифта для обычного текста.  По умолчанию это 8.5 пунктов.


<P>
  Многие другие переменные для настройки этих команд определены и
описаны в файле на Лиспе <TT>`ps-print.el'</TT>.




<H2><A NAME="SEC431" HREF="emacs_toc.html#TOC431">Сортировка текста</A></H2>
<P>
<A NAME="IDX2478"></A>


<P>
  Emacs предоставляет несколько команд для сортировки текста в буфере.
Все они оперируют с содержимым области (текстом между точкой и меткой).
Эти команды разделяют текст области на большое число <EM>записей
сортировки</EM>, определяют <EM>ключ сортировки</EM> для каждой записи и затем
переставляют записи в порядке, определяемом ключами сортировки.  Записи
располагаются таким образом, чтобы их ключи находились в алфавитном или,
для числовой сортировки, числовом порядке.  При алфавитной сортировке
все буквы верхнего регистра от `A' до `Z' идут перед `а' нижнего
регистра, в соответствии с последовательностью знаков ASCII.


<P>
  Различие команд сортировки состоит в том, как они делят текст на
записи сортировки, и какая часть каждой записи используется в качестве
ключа сортировки.  Большинство команд считают каждую строку отдельной
записью, но некоторые используют в качестве таких записей абзацы или
страницы.  Большинство команд сортировки используют всю запись
сортировки в качестве своего собственного ключа, но некоторые используют
в качестве ключа сортировки только часть записи.


<P>
<A NAME="IDX2479"></A>
<A NAME="IDX2480"></A>
<A NAME="IDX2481"></A>
<A NAME="IDX2482"></A>
<A NAME="IDX2483"></A>
<DL COMPACT>

<DT><KBD>M-x sort-lines</KBD>
<DD>
Разделить область на строки и отсортировать в соответствии с полным
текстом строки.  Числовой аргумент означает сортировку по убыванию.

<DT><KBD>M-x sort-paragraphs</KBD>
<DD>
Разделить область на абзацы и отсортировать, сравнивая текст абзацев
целиком (за исключением пустых строк в начале).  Числовой аргумент
означает сортировку по убыванию.

<DT><KBD>M-x sort-pages</KBD>
<DD>
Разделить область на страницы и отсортировать, сравнивая полный текст
страниц (за исключением пустых строк в начале).  Числовой аргумент
означает, что сортировка производится по убыванию.

<DT><KBD>M-x sort-fields</KBD>
<DD>
Разделить область на строки и отсортировать, сравнивая содержимое одного
поля в каждой строке.  Поля разделяются пропусками, так что первый
отрезок последовательных непробельных знаков в строке составляет поле
1, второй такой отрезок составляет поле 2, и так далее.

Поле, по которому должна производится сортировка, указывается с помощью
числового аргумента: 1 используется для сортировки по полю 1, и так
далее.  Отрицательный аргумент означает отсчет полей справа, а не слева;
то есть минус 1 обозначает сортировку по последнему полю.  Если
содержание полей сортировки в нескольких строках одинаково, эти строки
остаются в том же относительном порядке, в каком они были изначально.

<DT><KBD>M-x sort-numeric-fields</KBD>
<DD>
Эта команда подобна <KBD>M-x sort-fields</KBD>, за исключением того, что для
каждой строки указанное поле превращается в число, и сравниваются уже эти
числа.  <SAMP>`10'</SAMP> предшествует <SAMP>`2'</SAMP>, когда рассматривается как
текст, но следует за <SAMP>`2'</SAMP>, когда рассматривается как число.

<DT><KBD>M-x sort-columns</KBD>
<DD>
Как <KBD>M-x sort-fields</KBD>, за исключением того, что используемый для
сравнения текст получается в пределах каждой строки из фиксированного
диапазона столбцов.  Объяснение приведено ниже.

<DT><KBD>M-x reverse-region</KBD>
<DD>
Обратить порядок строк в области.  Это полезно для сортировки в порядке
убывания по полям или колонкам, так как данные команды сортировки не
имеют средств для этого.
</DL>

<P>
  Например, если буфер содержит такой текст:



<PRE>
On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
whether the file has changed on disk since it was last visited or
saved.  If it has, you are asked to confirm that you want to change
the buffer.
</PRE>

<P>
применение <KBD>M-x sort-lines</KBD> ко всему буферу даст следующее:



<PRE>
On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
whether the file has changed on disk since it was last visited or
</PRE>

<P>
где заглавная <SAMP>`O'</SAMP> идет перед всеми строчными буквами.  Если вы
вместо этого примените <KBD>C-u 2 M-x sort-fields</KBD>, то получите
следующее:



<PRE>
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
On systems where clash detection (locking of files being edited) is
whether the file has changed on disk since it was last visited or
</PRE>

<P>
где ключами сортировки были <SAMP>`Emacs'</SAMP>, <SAMP>`If'</SAMP>, <SAMP>`buffer'</SAMP>,
<SAMP>`systems'</SAMP> и <SAMP>`the'</SAMP>.


<P>
<A NAME="IDX2484"></A>
  <KBD>M-x sort-columns</KBD> требует более подробного объяснения.  Вы
указываете колонки, устанавливая точку на одном столбце, а метку -- на
другом.  Так как это означает, что вы не можете поставить точку или
метку в начале первой строки, с которой должна начаться сортировка, то
эта команда использует необычное определение `области': вся строка с
точкой рассматривается как часть области, и так же все содержимое
строки, в которой находится метка, и все строки между ними.


<P>
  Например, для сортировки таблицы по информации, размещенной в столбцах
с 10 по 15, метку можно поставить в первой строке таблицы в столбце 10,
а точку в столбце 15 в последней строке таблицы и затем запустить
<CODE>sort-columns</CODE>.  Или вы можете поставить метку в столбце 15 в
первой строке, а точку -- в столбце 10 в последней строке.


<P>
  Это можно рассматривать как сортировку прямоугольника, заданного
точкой и меткой, за исключением того, что текст в каждой строке справа и
слева от прямоугольника двигается вместе с текстом внутри
прямоугольника.  See section <A HREF="emacs_14.html#SEC72">Прямоугольники</A>.


<P>
<A NAME="IDX2485"></A>
  Многие команды сортировки игнорируют при сравнениях различие в
регистре букв, если <CODE>sort-fold-case</CODE> не равна <CODE>nil</CODE>.




<H2><A NAME="SEC432" HREF="emacs_toc.html#TOC432">Сужение</A></H2>
<P>
<A NAME="IDX2486"></A>
<A NAME="IDX2487"></A>
<A NAME="IDX2488"></A>
<A NAME="IDX2489"></A>


<P>
  <EM>Сужение</EM> означает сосредоточение на некоторой части буфера, при
котором оставшаяся часть становится временно недоступной.  Та часть, в
которую вы все еще можете попасть, называется <EM>доступной частью</EM>.
Отмена сужения и переход в состояние, когда весь буфер снова становится
доступным, называется <EM>расширением</EM>.  Размер действующего сужения
буфера в какое-либо время называется <EM>ограничением</EM> этого буфера.


<P>
  Сужение может помочь сконцентрироваться на единственной подпрограмме
или абзаце, убирая лишнее.  Оно также может быть использовано для
ограничения диапазона действия команды замены или повторяющегося макроса
клавиатуры.


<DL COMPACT>

<DT><KBD>C-x n n</KBD>
<DD>
Сузить до области между точкой и меткой (<CODE>narrow-to-region</CODE>).
<DT><KBD>C-x n w</KBD>
<DD>
Расширить так, чтобы буфер снова стал полностью доступным
(<CODE>widen</CODE>).
<DT><KBD>C-x n p</KBD>
<DD>
Сузить до текущей страницы (<CODE>narrow-to-page</CODE>).
<DT><KBD>C-x n d</KBD>
<DD>
Сузить до текущего определения функции (<CODE>narrow-to-defun</CODE>).
</DL>

<P>
  Когда вы сделали сужение до части буфера, эта часть -- все, что вы
видите.  Вы не можете видеть остальную часть, в нее невозможно перейти
(команды движения не выйдут за пределы доступной части) и нельзя
изменить ее никаким образом.  Но она не пропала, и если вы сохраняете
файл, то сохранится и недоступная часть текста.  При действии сужения в
строке режима появляется слово <SAMP>`Narrow'</SAMP>.


<P>
<A NAME="IDX2490"></A>
<A NAME="IDX2491"></A>
  Основной командой сужения является <KBD>C-x n n</KBD>
(<CODE>narrow-to-region</CODE>).  Она устанавливает ограничения для текущего
буфера таким образом, что остается доступным только текст текущей
области, но весь текст перед областью и после нее становится
недоступным.  Точка и метка не изменяются.


<P>
<A NAME="IDX2492"></A>
<A NAME="IDX2493"></A>
<A NAME="IDX2494"></A>
<A NAME="IDX2495"></A>
  Еще вы можете использовать <KBD>C-x n p</KBD> (<CODE>narrow-to-page</CODE>) для
сужения до текущей страницы.  See section <A HREF="emacs_26.html#SEC221">Страницы</A>, определение страницы.
<KBD>C-x n d</KBD> (<CODE>narrow-to-defun</CODE>) сужает до определения функции,
содержащего точку (see section <A HREF="emacs_27.html#SEC253">Определения функций</A>).


<P>
<A NAME="IDX2496"></A>
<A NAME="IDX2497"></A>
  Отмена сужения выполняется командой <KBD>C-x n w</KBD> (<CODE>widen</CODE>).  Она
делает весь текст буфера снова доступным.


<P>
  Вы можете получить информацию о том, до какой части сужен буфер,
применив команду <KBD>C-x =</KBD>.  See section <A HREF="emacs_9.html#SEC33">Информация о позиции курсора</A>.


<P>
  Поскольку сужение может легко запутать пользователя, не понимающего
его, команда <CODE>narrow-to-region</CODE> обычно заблокирована.  При попытке
ее использования запрашивается подтверждение и предоставляется
возможность ее включения; если вы задействовали эту команду,
подтверждение больше не требуется.  See section <A HREF="emacs_36.html#SEC467">Блокирование команд</A>.




<H2><A NAME="SEC433" HREF="emacs_toc.html#TOC433">Редактирование текста в две колонки</A></H2>
<P>
<A NAME="IDX2498"></A>
<A NAME="IDX2499"></A>
<A NAME="IDX2500"></A>


<P>
  Режим Two-column позволяет вам удобно редактировать текст в две
колонки.  Он использует два расположенных рядом окна, каждое из которых
показывает свой буфер.


<P>
  Есть два способа войти в двухколоночный режим:


<DL COMPACT>

<DT><KBD><KBD>F2</KBD> 2</KBD> или <KBD>C-x 6 2</KBD>
<DD>
<A NAME="IDX2501"></A>
<A NAME="IDX2502"></A>
<A NAME="IDX2503"></A>
Входит в режим two-column, слева появляется текущий буфер, а справа
появляется буфер, чье имя основано на имени текущего буфера
(<CODE>2C-two-columns</CODE>).  Если правый буфер еще не существует,
изначально он делается пустым; содержимое текущего буфера не изменяется.

Эта команда подходит, если текущий буфер пуст или содержит текст только
одной колонки, и вы хотите добавить вторую.

<DT><KBD><KBD>F2</KBD> s</KBD> or <KBD>C-x 6 s</KBD>
<DD>
<A NAME="IDX2504"></A>
<A NAME="IDX2505"></A>
<A NAME="IDX2506"></A>
Разделяет текущий буфер с текстом в двух колонках на два буфера и
показывает их рядом друг с другом (<CODE>2C-split</CODE>).  Текущий буфер
становится левым буфером, но текст из правой колонки перемещается в
правый буфер.  Текущий столбец определяет точку раздела.  Разделение
начинается от текущей строки и продолжается до конца буфера.

Эта команда полезна, если у вас уже есть буфер с двухколоночным текстом,
и вы хотите временно разделить колонки.

<DT><KBD><KBD>F2</KBD> b <VAR>буфер</VAR> <KBD>RET</KBD></KBD>
<DD>
<DT><KBD>C-x 6 b <VAR>буфер</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX2507"></A>
<A NAME="IDX2508"></A>
<A NAME="IDX2509"></A>
Входит в режим two-column, используя текущий буфер в качестве левого и
буфер <VAR>буфер</VAR> в качестве правого (<CODE>2C-associate-buffer</CODE>).
</DL>

<P>
  <KBD><KBD>F2</KBD> s</KBD> или <KBD>C-x 6 s</KBD> ищет разделитель колонок, который
является строкой, стоящей между двух колонок на каждой строке.  Вы
можете задать ширину разделителя с помощью числового аргумента для
<KBD><KBD>F2</KBD> s</KBD>; столько знаков, стоящих перед точкой, выразят
строку-разделитель.  По умолчанию ширина равна 1, поэтому разделитель
колонок -- это знак перед точкой.


<P>
  Когда строка содержит разделитель на своем месте, <KBD><KBD>F2</KBD> s</KBD>
помещает текст после разделителя в правый буфер и удаляет разделитель.
Строки, не имеющие разделителя колонок, оставляются неразбитыми; они
остаются в левом буфере, а в правый буфер помещается для соответствия
пустая строка.  (Таким образом можно написать строку, которая "проходит
по обеим колонкам в двухколоночном режиме": написать ее в левом буфере
и сделать пустую строку в правом буфере.)


<P>
<A NAME="IDX2510"></A>
<A NAME="IDX2511"></A>
<A NAME="IDX2512"></A>
  Команда <KBD>C-x 6 <KBD>RET</KBD></KBD> или <KBD><KBD>F2</KBD> <KBD>RET</KBD></KBD>
(<CODE>2C-newline</CODE>) вставляет знак новой строки в оба буфера в
соответствующих позициях.  Это самый простой способ добавить новую строку
в двухколоночном тексте, когда вы редактируете его в разных буферах.


<P>
<A NAME="IDX2513"></A>
<A NAME="IDX2514"></A>
<A NAME="IDX2515"></A>
  Когда вы отредактировали оба буфера, как вам хотелось, объедините их с
помощью <KBD><KBD>F2</KBD> 1</KBD> или <KBD>C-x 6 1</KBD> (<CODE>2C-merge</CODE>).  Это
копирует текст из правого буфера как вторую колонку другого буфера.
Чтобы вернуться к редактированию в две колонки, используйте
<KBD><KBD>F2</KBD> s</KBD>.


<P>
<A NAME="IDX2516"></A>
<A NAME="IDX2517"></A>
<A NAME="IDX2518"></A>
  Используйте <KBD><KBD>F2</KBD> d</KBD> или <KBD>C-x 6 d</KBD>, чтобы разъединить два
буфера, оставляя каждый как есть (<CODE>2C-dissociate</CODE>).  Если другой
буфер, не текущий в момент, когда вы набрали <KBD><KBD>F2</KBD> d</KBD>, оказался
пустым, <KBD><KBD>F2</KBD> d</KBD> уничтожает его.




<H2><A NAME="SEC434" HREF="emacs_toc.html#TOC434">Редактирование двоичных файлов</A></H2>

<P>
<A NAME="IDX2519"></A>
<A NAME="IDX2520"></A>
<A NAME="IDX2521"></A>
  Существует специальный основной режим для редактирования двоичных
файлов: режим Hexl.  Чтобы воспользоваться им, вызовите для обращения к
файлу <KBD>M-x hexl-find-file</KBD> вместо <KBD>C-x C-f</KBD>.  Эта команда
преобразует содержимое файла в шестнадцатиричные числа и позволяет вам
редактировать их.  Когда вы сохраняете этот файл, он автоматически
преобразуется обратно в двоичный формат.


<P>
  Вы можете также использовать <KBD>M-x hexl-mode</KBD> для преобразования
существующего буфера в шестнадцатиричный вид.  Это полезно, если вы
обратились к файлу обычным способом и потом обнаружили, что это двоичный
файл.


<P>
  Обычные знаки в режиме Hexl перезаписывают поверх существующего
текста.  Это сделано для уменьшения риска нечаянной потери выравнивания
данных в файле.  Для вставки есть особые команды.  Вот перечень команд
режима Hexl:


<DL COMPACT>

<DT><KBD>C-M-d</KBD>
<DD>
Вставляет байт с введенным десятичным кодом.

<DT><KBD>C-M-o</KBD>
<DD>
Вставляет байт с введенным восьмиричным кодом.

<DT><KBD>C-M-x</KBD>
<DD>
Вставляет байт с введенным шестнадцатиричным кодом.

<DT><KBD>C-x [</KBD>
<DD>
Перемещает на начало 1k-байтной "страницы".

<DT><KBD>C-x ]</KBD>
<DD>
Перемещает на конец 1k-байтной "страницы".

<DT><KBD>M-g</KBD>
<DD>
Перемещает к адресу, заданному шестнадцатиричным числом.

<DT><KBD>M-j</KBD>
<DD>
Перемещает к адресу, заданному десятичным числом.

<DT><KBD>C-c C-c</KBD>
<DD>
Покидает режим Hexl, возвращаясь к тому основному режиму, который был в
этом буфере до того, как вы вызвали <CODE>hexl-mode</CODE>.
</DL>



<H2><A NAME="SEC435" HREF="emacs_toc.html#TOC435">Сохранение сеансов Emacs</A></H2>
<P>
<A NAME="IDX2522"></A>
<A NAME="IDX2523"></A>


<P>
  Вы можете использовать библиотеку Desktop для сохранения состояния
Emacs от одного сеанса к другому.  Сохранение состояния означает, что
Emacs запускается с тем же самым набором буферов, основных режимов,
позиций в буферах и прочим, какие были в предыдущем сеансе Emacs.


<P>
<A NAME="IDX2524"></A>
  Чтобы использовать Desktop, вы должны воспользоваться буфером
Customization (see section <A HREF="emacs_36.html#SEC444">Интерфейс для простой настройки</A>) и установить
<CODE>desktop-enable</CODE> в отличное от <CODE>nil</CODE> значение или добавить
такие строки в ваш файл <TT>`.emacs'</TT>:



<PRE>
(desktop-load-default)
(desktop-read)
</PRE>

<P>
<A NAME="IDX2525"></A>
Первый раз, когда вы сохраняете состояние сеанса Emacs, вы должны
сделать это вручную, с помощью команды <KBD>M-x desktop-save</KBD>.  Как
только вы это сделали, при выходе из Emacs состояние будет сохраняться
снова -- не только в существующем сеансе Emacs, но и во всех
последующих.  Вы также можете записать состояние в любое время не выходя
из Emacs, снова набрав <KBD>M-x desktop-save</KBD>.


<P>
  Чтобы Emacs восстановил состояние предыдущего сеанса, вы обязаны
запустить его из того же каталога, который вы использовали в прошлом
сеансе.  Это необходимо, потому что <CODE>desktop-read</CODE> просматривает в
поисках файла, который она должна прочитать, именно текущий каталог.
Это означает, что вы можете хранить отдельные сохраненные сеансы в
разных каталогах; каталог, в котором вы запускаете Emacs, будет
указывать, какой из сохраненных сеансов вы хотите восстановить.


<P>
<A NAME="IDX2526"></A>
  Переменная <CODE>desktop-files-not-to-save</CODE> говорит, какие файлы
исключаются при сохранении состояния.  Ее значение -- это регулярное
выражение, совпадающее с именами исключаемых файлов.  По умолчанию
исключаются удаленные (полученные по FTP) файлы; потому что повторное к
ним обращение в последующем сеансе может быть медленным.  Если вы хотите
включить эти файлы в сохраненное состояние, установите
<CODE>desktop-files-not-to-save</CODE> равной <CODE>"^$"</CODE>.  See section <A HREF="emacs_19.html#SEC160">Удаленные файлы</A>.




<H2><A NAME="SEC436" HREF="emacs_toc.html#TOC436">Уровни рекурсивного редактирования</A></H2>
<P>
<A NAME="IDX2527"></A>
<A NAME="IDX2528"></A>


<P>
  <EM>Рекурсивное редактирование</EM> -- это ситуация, в которой вы
используете команды Emacs для выполнения произвольного редактирования,
находясь в середине другой команды Emacs.  Например, при наборе команды
<KBD>C-r</KBD> внутри <CODE>query-replace</CODE> происходит вход в рекурсивное
редактирование, где можно изменить текущий буфер.  Выходя из этого
рекурсивного редактирования, вы возвращаетесь в <CODE>query-replace</CODE>.


<P>
<A NAME="IDX2529"></A>
<A NAME="IDX2530"></A>
<A NAME="IDX2531"></A>
  <EM>Выход</EM> из рекурсивного редактирования означает возврат к
незаконченной команде, которая продолжает выполняться.  Выход
производится с помощью команды <KBD>C-M-c</KBD> (<CODE>exit-recursive-edit</CODE>).


<P>
  Вы можете также <EM>прервать</EM> рекурсивное редактирование.  Это похоже
на выход, но при этом происходит также и незамедлительный выход из
незаконченной команды.  Прерывание рекурсивного редактирования
производится по команде <KBD>C-]</KBD> (<CODE>abort-recursive-edit</CODE>).
See section <A HREF="emacs_37.html#SEC476">Выход и аварийное завершение</A>.


<P>
  Строка режима показывает вам, что вы находитесь в рекурсивном
редактировании, при помощи квадратных скобок вокруг круглых скобок,
которые всегда окружают названия основного и второстепенных режимов.
Строка режима каждого окна показывает это таким же образом, поскольку
нахождение в рекурсивном редактировании относится к Emacs в целом, а не
к какому-либо отдельному окну или буферу.


<P>
  Возможно пребывание в рекурсивных редактированиях внутри рекурсивных
редактирований.  Например, после набора команды <KBD>C-r</KBD> в
<CODE>query-replace</CODE> можно набрать команду, которая входит в отладчик.
Это начинает уровень рекурсивного редактирования для отладчика внутри
уровня рекурсивного редактирования для <KBD>C-r</KBD>.  Строки режима
показывают пару квадратных скобок для каждого работающего в данный
момент уровня рекурсивного редактирования.


<P>
  Выход из внутреннего рекурсивного редактирования (например, с помощью
команды <KBD>c</KBD> отладчика) возобновляет команду одним уровнем выше.  По
окончанию этой команды можно использовать <KBD>C-M-c</KBD>, чтобы выйти из
еще одного уровня рекурсивного редактирования, и так далее.  Выход
относится только к самому внутреннему уровню.  Прерывание тоже приводит
к выходу лишь из одного уровня рекурсивного редактирования: происходит
немедленный возврат на уровень команды предыдущего рекурсивного
редактирования.  Если хотите, то можете затем прервать и следующий
уровень.


<P>
  Напротив, команда <KBD>M-x top-level</KBD> прерывает все уровни
рекурсивного редактирования, возвращаясь непосредственно на верхний
командный уровень.


<P>
  Текст, редактируемый внутри режима рекурсивного редактирования, не
обязан быть тем же, что редактируется на верхнем уровне.  Это зависит от
того, для чего предназначалось рекурсивное редактирование.  Если
команда, которая запускает рекурсивное редактирование, выбирает вначале
другой буфер, то он и будет буфером, который рекурсивно редактируется.
В любом случае, внутри рекурсивного редактирования можно переключать
буферы обычным способом (если ключи, переключающие буферы, не
перепривязаны).  Вероятно, можно оставаться внутри рекурсивного
редактирования и до конца сеанса, обращаясь к файлам и делая там все
прочее.  Но время от времени это может приводить к неожиданным
результатам (например, к переполнению стека).  Поэтому не забывайте
прерывать рекурсивное редактирование или выходить из него, если оно вам
больше не нужно.


<P>
  В основном мы стараемся минимизировать использование уровней
рекурсивного редактирования в GNU Emacs.  Это так, потому что они
обязывают вас "возвращаться" в определенном порядке -- от самого
внутреннего уровня к верхнему уровню.  Если возможно, мы представляем
различные виды деятельности в разных буферах, чтобы вы могли
переключаться между ними, как вам нравится.  Некоторые команды
переключают в новый основной режим, который предоставляет команду для
переключения назад.  Эти методы дают вам большую гибкость для возврата к
незаконченным занятиям в том порядке, в каком вы пожелаете.




<H2><A NAME="SEC437" HREF="emacs_toc.html#TOC437">Эмуляция</A></H2>
<P>
<A NAME="IDX2532"></A>
<A NAME="IDX2533"></A>
<A NAME="IDX2534"></A>
<A NAME="IDX2535"></A>


<P>
  GNU Emacs может быть запрограммирован для эмуляции (в большей или
меньшей степени) большинства других редакторов.  Стандартные средства
могут эмулировать следующее:


<DL COMPACT>

<DT>EDT (редактор DEC VMS)
<DD>
<A NAME="IDX2536"></A>
<A NAME="IDX2537"></A>
Эмуляция EDT включается с помощью команды <KBD>M-x edt-emulation-on</KBD>.
Команда <KBD>M-x edt-emulation-off</KBD> восстанавливает обычные для Emacs
привязки.

Большинство команд эмуляции EDT являются ключами вспомогательной
клавиатуры, и большинство стандартных привязок ключей в Emacs остаются
доступными.  Перепривязки при эмуляции EDT выполняются в глобальной
таблице ключей, таким образом, при нахождении в режиме эмуляции EDT нет
проблемы переключения буферов или основных режимов.

<DT>vi (редактор Беркли)
<DD>
<A NAME="IDX2538"></A>
Viper -- новейший эмулятор vi.  Он реализует несколько уровней
эмуляции: уровень 1 ближе всех к vi, тогда как уровень 5 отходит от
строгой эмуляции, чтобы воспользоваться возможностями Emacs.  Чтобы
вызвать Viper, наберите <KBD>M-x viper-mode</KBD>; это проведет вас по
остальному пути и спросит об уровне эмуляции.  See Info file `@external{viper', node `Top'}.

<DT>vi (другой эмулятор)
<DD>
<A NAME="IDX2539"></A>
<KBD>M-x vi-mode</KBD> входит в основной режим, который заменяет прежде
установленный режим.  Все команды vi, которые в настоящем vi входят в
режим "ввода", запрограммированы для возврата в предыдущий основной
режим.  Таким образом, обычный Emacs служит режимом "ввода" для vi.

Поскольку эмуляция vi работает через основные режимы, переключать буфера
в процессе эмуляции нельзя.  Сначала необходимо вернуться в обычный
Emacs.

Если вы планируете часто использовать эмуляцию vi, то, вероятно,
появится желание привязать ключ к команде <CODE>vi-mode</CODE>.

<DT>vi (еще один эмулятор)
<DD>
<A NAME="IDX2540"></A>
<KBD>M-x vip-mode</KBD> вызывает еще один эмулятор vi, про который говорят,
что он соответствует настоящему vi более полно, чем <KBD>M-x vi-mode</KBD>.
Режим "ввода" в этом эмуляторе отличается от обычного Emacs, так что
для возврата в режим эмуляции vi можно использовать <KBD>ESC</KBD>.  Для
возврата из режима эмуляции vi в обычный Emacs необходимо набрать
<KBD>C-z</KBD>.

Этот режим эмуляции не работает через основные режимы, что обеспечивает
возможность различных вариантов переключения буферов внутри эмулятора.
Приписывать ключ команде <CODE>vip-mode</CODE> нет так необходимо, как в
случае <CODE>vi-mode</CODE>, поскольку завершение режима вставки не использует
ее.

@inforef{Top, VIP, @external{vip}}, для получения полной информации.
</DL>



<H2><A NAME="SEC438" HREF="emacs_toc.html#TOC438">Диссошиэйтед Пресс</A></H2>

<P>
<A NAME="IDX2541"></A>
  <KBD>M-x dissociated-press</KBD> -- это команда для перемешивания
текстового файла слово за словом или знак за знаком.  Имея в начале
буфер с нормальным текстом, она формирует крайне забавный вывод.  Ввод
производится из текущего буфера Emacs.  Диссошиэйтед Пресс записывает
свой вывод в буфер с именем <TT>`*Dissociation*'</TT>, при этом, чтобы
облегчить его постепенное чтение, через каждую пару строк (примерно)
содержимое буфера показывается заново.


<P>
  Диссошиэйтед Пресс время от времени спрашивает, продолжать ли
действие.  Для остановки необходимо ответить <KBD>n</KBD>.  Остановить можно
также в любое время с помощью <KBD>C-g</KBD>.  Диссоциированная выдача
сохраняется в буфере <TT>`*Dissosiation*'</TT>, чтобы по желанию можно было
скопировать ее в другое место.


<P>
<A NAME="IDX2542"></A>
  Диссошиэйтед Пресс в процессе работы совершает беспорядочные прыжки из
одной точки буфера в другую.  Для получения правдоподобного вывода, а не
тарабарщины, она соблюдает некоторое перекрытие между концом одного
отрезка последовательности слов или знаков и началом следующего.  Так,
если только что она напечатала слово `президент' и теперь решает
прыгнуть в другую точку файла, то она может заметить `ент' в слове
`пентагон' и продолжить вывод отсюда, выдавая в результате
`президентагон'.<A NAME="DOCF7" HREF="emacs_foot.html#FOOT7">(7)</A>  Наилучшие
результаты получаются на длинных выборках.


<P>
<A NAME="IDX2543"></A>
  Положительный аргумент <KBD>M-x dissociated-press</KBD> велит ей работать
познаково и определяет число перекрывающихся знаков.  Отрицательный
аргумент заставляет ее действовать слово за словом и определяет
количество перекрывающихся слов.  В этом режиме целые слова, а не
знаки, трактуются как переставляемые элементы.  Отсутствие аргумента
эквивалентно аргументу, равному двум.  К сновашему сведению, вывод
осуществляется только в буфер <TT>`*Dissociation*'</TT>.  Буфер, с которого
вы начали, не изменяется.


<P>
<A NAME="IDX2544"></A>
<A NAME="IDX2545"></A>
<A NAME="IDX2546"></A>
  Диссошиэйтед Пресс производит примерно те же результаты, что и
марковская цепь, основанная на частотной таблице, построенной по
выборочному тексту.  Однако, этот метод является независимым,
игноригинальным изобретением.  Диссошиэйтед Пресс повсеметодически
копирует несколько последовательных знаков из выборки от прыжка к
прыжку, тогда как цепь Маркова делала бы случайный выбор для каждого
слова или знака.  В итоге все это работает быстрее и придает результату
более благозвучный вид.


<P>
<A NAME="IDX2547"></A>
<A NAME="IDX2548"></A>
<A NAME="IDX2549"></A>
<A NAME="IDX2550"></A>
<A NAME="IDX2551"></A>
<A NAME="IDX2552"></A>
  Несомнекоторые говорят, что излишне интенсивное использование
Диссошиэйтед Пресс может стать постомехой в вашей реальной работе.
Подчас до уровня безобрагедии.  И избегайте диссошислов в своей
документации, если вы хотите быть для пользователей вполнятными и
правословными.  Позабавьтесь.  Ваши бредложения горячо приветствуются.




<H2><A NAME="SEC439" HREF="emacs_toc.html#TOC439">Другие развлечения</A></H2>
<P>
<A NAME="IDX2553"></A>
<A NAME="IDX2554"></A>
<A NAME="IDX2555"></A>
<A NAME="IDX2556"></A>
<A NAME="IDX2557"></A>
<A NAME="IDX2558"></A>


<P>
  Если вы немного заскучали, можете попробовать <KBD>M-x hanoi</KBD>.  Если
вам очень скучно, то задайте ей численный аргумент.  Если вам
очень-очень скучно, то попробуйте задать аргумент 9.  Откиньтесь на
спинку кресла и наблюдайте.


<P>
<A NAME="IDX2559"></A>
  Если вам хочется больше личного участия, попробуйте команду <KBD>M-x
gomoku</KBD>, которая сыграет с вами в пять-в-ряд.


<P>
<A NAME="IDX2560"></A>
<A NAME="IDX2561"></A>
<A NAME="IDX2562"></A>
  <KBD>M-x blackbox</KBD> и <KBD>M-x mpuz</KBD> -- это две головоломки.
<CODE>blackbox</CODE> предлагает вам определить с помощью томографии положение
объектов внутри черного ящика.  <CODE>mpuz</CODE> показывает задачу на
умножение, где цифры заменены буквами, а как, вы должны догадаться.
Чтобы сделать предположение, наберите букву, а затем цифру, которая, как
вы думаете, обозначена этой буквой.


<P>
<A NAME="IDX2563"></A>
  <KBD>M-x dunnet</KBD> запускает приключенческую игру; это большая
головоломка.


<P>
  Если вас расстроили, запустите знаменитую программу Eliza.  Наберите
просто <KBD>M-x doctor</KBD>.  Каждый ввод заканчивайте двойным набором
<KBD>RET</KBD>.


<P>
<A NAME="IDX2564"></A>
  Когда вам будет не по себе, наберите <KBD>M-x yow</KBD>.
<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_34.html">previous</A>, <A HREF="emacs_36.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
</BODY>
</HTML>
