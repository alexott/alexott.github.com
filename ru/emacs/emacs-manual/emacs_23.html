<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Поддержка разных языков</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_22.html">previous</A>, <A HREF="emacs_24.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC198" HREF="emacs_toc.html#TOC198">Поддержка разных языков</A></H1>
<P>
<A NAME="IDX874"></A>
<A NAME="IDX875"></A>
<A NAME="IDX876"></A>
<A NAME="IDX877"></A>


<P>
<A NAME="IDX878"></A>
<A NAME="IDX879"></A>
<A NAME="IDX880"></A>
<A NAME="IDX881"></A>
<A NAME="IDX882"></A>
<A NAME="IDX883"></A>
<A NAME="IDX884"></A>
<A NAME="IDX885"></A>
<A NAME="IDX886"></A>
<A NAME="IDX887"></A>
<A NAME="IDX888"></A>
<A NAME="IDX889"></A>
<A NAME="IDX890"></A>
<A NAME="IDX891"></A>
  Emacs поддерживает широкий спектр наборов знаков разных языков,
включая европейские варианты латинского алфавита, а также китайскую,
девангари (хинди и маратхи), эфиопскую, греческую, IPA, японскую,
корейскую, лаосскую, русскую, тайскую, тибетскую и вьетнамскую
письменности.  Эти возможности были внесены из измененной версии Emacs,
известной как MULE (от "MULti-lingual Enhancement to GNU
Emacs".@transnote{Многоязыковое расширение GNU Emacs.})




<H2><A NAME="SEC199" HREF="emacs_toc.html#TOC199">Введение в наборы знаков разных языков</A></H2>

<P>
  Пользователи этих систем письма выработали много более или менее
стандартных систем кодирования для хранения файлов.  Внутренне Emacs
использует единую многобайтную кодировку, так что в ней можно
перемешивать знаки из всех этих систем письма в одном буфере или строке.
Эта кодировка представляет каждый знак, не входящий в ASCII, как
последовательность байт в промежутке от 0200 до 0377.  Emacs переводит
из этой многобайтной кодировки в различные другие системы кодирования
при считывании и записи файлов, при обмене данными с подпроцессами и (в
некоторых случаях) в команде <KBD>C-q</KBD> (see section <A HREF="emacs_23.html#SEC204">Однобайтные и многобайтные не-ASCII-знаки</A>).


<P>
<A NAME="IDX892"></A>
<A NAME="IDX893"></A>
  Команда <KBD>C-h h</KBD> (<CODE>view-hello-file</CODE>) выводит файл
<TT>`etc/HELLO'</TT>, который показывает, как сказать "здравствуйте" на
разных языках.  Это иллюстрирует различные виды письменности.


<P>
  Даже в странах, где используются эти знаки, на клавиатурах обычно нет
клавиш для всех из них.  Поэтому Emacs поддерживает различные
<EM>методы ввода</EM>, как правило, один для каждой письменности или языка,
чтобы их было удобно вводить.


<P>
<A NAME="IDX894"></A>
  Префиксный ключ <KBD>C-x <KBD>RET</KBD></KBD> используется для команд, которые
имеют отношение к многобайтным знакам, системам кодирования и методам
ввода.




<H2><A NAME="SEC200" HREF="emacs_toc.html#TOC200">Включение поддержки многобайтных знаков</A></H2>

<P>
  Вы можете включить или выключить поддержку многобайтных знаков либо
для всего Emacs, либо для отдельного буфера.  Когда в буфере выключены
многобайтные знаки, каждый байт в нем представляет один знак, даже коды
от 0200 до 0377.  Старые средства для поддержки европейских наборов
знаков, ISO Latin-1 и ISO Latin-2, работают так же, как они работали в
Emacs 19, и кроме того, работают для других наборов знаков ISO 8859.


<P>
  Однако, чтобы использовать ISO Latin, необязательно выключать
поддержку многобайтных знаков; многобайтный набор знаков Emacs включает
все эти знаки, и Emacs может автоматически переводить из него в коды ISO
и наоборот.


<P>
  Чтобы отредактировать определенный файл в однобайтном представлении,
обратитесь к нему через <CODE>find-file-literally</CODE>.  See section <A HREF="emacs_19.html#SEC110">Обращение к файлам</A>.
Чтобы превратить буфер в многобайтном представлении в однобайтное
представление тех же знаков, проще всего сохранить содержимое этого
буфера в файле, уничтожить его и снова обратиться к этому файлу с помощью
<CODE>find-file-literally</CODE>.  Вы также можете использовать <KBD>C-x
<KBD>RET</KBD> c</KBD> (<CODE>universal-coding-system-argument</CODE>) и указать
<SAMP>`raw-text'</SAMP> в качестве системы кодирования для обращения к файлу или
для его сохранения.  See section <A HREF="emacs_23.html#SEC207">Задание системы кодирования</A>.  Обращение к файлу как
к <SAMP>`raw-text'</SAMP> не выключает преобразование формата, декомпрессию и
автоматический выбор режима, в отличие от <CODE>find-file-literally</CODE>.


<P>
<A NAME="IDX895"></A>
<A NAME="IDX896"></A>
  Чтобы выключить поддержку многобайтных знаков по умолчанию, запустите
Emacs с ключом @option{--unibyte} (see section <A HREF="emacs_38.html#SEC496">Ключи запуска</A>) или установите
переменную среды @env{EMACS_UNIBYTE}.  Вы также можете настроить
параметр <CODE>enable-multibyte-characters</CODE> или, что эквивалентно, прямо
установить переменную <CODE>default-enable-multibyte-characters</CODE> в вашем
файле инициализации, это дает в основном тот же эффект, что и
@option{--unibyte}.


<P>
  Во время инициализации не создаются многобайтные строки из значений
переменных среды, вхождений файла <TT>`/etc/passwd'</TT>, etc., которые
содержат не входящие в ASCII восьмибитные знаки.  Однако, файл
инициализации обычно считывается как многобайтный -- как все файлы на
Лиспе -- даже если задан ключ @option{--unibyte}.  Чтобы избежать
создания многобайтных строк из находящихся в этом файле строк с
не-ASCII-знаками, поместите в его первой строке комментарий с текстом
<SAMP>`-*-unibyte: t;-*-'</SAMP>.  Для файлов инициализации других пакетов,
вроде Gnus, нужно сделать то же самое.


<P>
  В строке режима показано, включена ли поддержка многобайтных знаков в
текущем буфере.  Если она включена, перед двоеточием в начале строки
режима стоят два или более знака (чаще всего два дефиса).  Когда
многобайтные знаки не включены, перед двоеточием есть только один дефис.




<H2><A NAME="SEC201" HREF="emacs_toc.html#TOC201">Языковые среды</A></H2>
<P>
<A NAME="IDX897"></A>


<P>
  Все поддерживаемые наборы знаков допустимы в буферах Emacs, если
включены многобайтные знаки; нет необходимости выбирать конкретный язык,
чтобы увидеть его знаки в буфере Emacs.  Однако, важно выбрать
<EM>языковую среду</EM>, чтобы получить различные установки по умолчанию.
На самом деле языковая среда представляет выбор предпочтительной
письменности (в большей или меньшей степени), а не выбор языка.


<P>
  Языковая среда определяет, какие системы кодирования распознаются при
считывании текста (see section <A HREF="emacs_23.html#SEC206">Распознавание систем кодирования</A>).  Это относится к
файлам, приходящей почте, сетевым новостям и любому другому тексту,
который вы считываете в Emacs.  Она также может задавать систему
кодирования, используемую по умолчанию для создания файла.  Каждая
языковая среда также указывает принимаемый по умолчанию метод ввода.


<P>
<A NAME="IDX898"></A>
  Языковая среда выбирается командой <KBD>M-x set-language-environment</KBD>.
Не имеет значения, какой буфер является текущим во время запуска этой
команды, потому что ее действия применяются глобально ко всему сеансу
Emacs.  Поддерживаемые языковые среды включают:



<BLOCKQUOTE>
<P>
Chinese-BIG5, Chinese-CNS, Chinese-GB, Cyrillic-Alternativnyj,
Cyrillic-ISO, Cyrillic-KOI8, Devanagari, English, Ethiopic, Greek,
Hebrew, Japanese, Korean, Lao, Latin-1, Latin-2, Latin-3, Latin-4,
Latin-5, Thai, Tibetan и Vietnamese.
</BLOCKQUOTE>

<P>
  Некоторые операционные системы позволяют вам указать используемый вами
язык путем установки переменных среды, определяющих вашу местность.
Emacs может обрабатывать один распространенный частный случай: если
название вашей региональной установки для типов знаков содержит строку
<SAMP>`8859-<VAR>n</VAR>'</SAMP>, Emacs автоматически выбирает соответствующую
языковую среду.


<P>
<A NAME="IDX899"></A>
<A NAME="IDX900"></A>
  Чтобы получить сведения об эффектах определенной языковой среды
<VAR>яз-среда</VAR>, используйте команду <KBD>C-h L <VAR>яз-среда</VAR> <KBD>RET</KBD></KBD>
(<CODE>describe-language-environment</CODE>).  Это сообщит вам, для каких
языков полезна данная языковая среда, и перечислит приходящие с ней
наборы знаков, системы кодирования и методы ввода.  Эта команда также
показывает образцы текста, которые иллюстрируют используемые в этой
языковой среде системы письма.  По умолчанию она описывает выбранную
языковую среду.


<P>
<A NAME="IDX901"></A>
  Вы можете настроить для себя любую языковую среду с помощью обычной
ловушки <CODE>set-language-environment-hook</CODE>.  Команда
<CODE>set-language-environment</CODE> запускает эту ловушку после подготовки
новой языковой среды.  Функции этой ловушки могут определить текущую
языковую среду по значению переменной
<CODE>current-language-environment</CODE>.


<P>
<A NAME="IDX902"></A>
  До начала подготовки новой языковой среды, команда
<CODE>set-language-environment</CODE> запускает ловушку
<CODE>exit-language-environment-hook</CODE>.  Эта ловушка полезна для отмены
настроек, сделанных с помощью <CODE>set-language-environment-hook</CODE>.  К
примеру, если вы установили с использованием
<CODE>set-language-environment-hook</CODE> особые привязки ключей для
конкретной языковой среды, вам стоит сделать так, чтобы
<CODE>exit-language-environment-hook</CODE> восстанавливала нормальные
привязки.




<H2><A NAME="SEC202" HREF="emacs_toc.html#TOC202">Методы ввода</A></H2>

<P>
<A NAME="IDX903"></A>
  <EM>Метод ввода</EM> -- это разновидность преобразования знаков,
разработанная специально для интерактивного ввода.  В Emacs, как
правило, каждый язык имеет свой метод ввода; иногда несколько языков, в
которых используются одни и те же знаки, могут разделять один метод
ввода.  Есть немного языков, которые поддерживают несколько методов
ввода.


<P>
  В простейшем случае метод ввода работает через отображение ASCII-букв
в другой алфавит.  Таким способом действуют методы ввода для греческого
и русского.


<P>
  Более мощный способ -- составление: преобразование последовательности
знаков в одну букву.  Составление используется во многих европейских
методах ввода для сознания одной не-ASCII-буквы из последовательности,
состоящей из буквы, за которой идет знак акцента (или наоборот).
Например, некоторые методы ввода преобразуют последовательность <KBD>a'</KBD>
в одну букву с акцентом.  В этих методах ввода нет собственных
специальных команд; вс╠, что они делают, -- компонуют
последовательности печатных знаков.


<P>
  Методы ввода для силлабических систем письма обычно используют
последовательно отображение и затем составление.  Таким способом
работают методы ввода для тайского и корейского.  Сначала буквы
отображаются в символы отдельных звуков или меток тона; затем такие
последовательности, составляющие целый слог, отображаются в один знак
слога.


<P>
  Для китайского и японского требуются более сложные методы.  В
китайских методах ввода вы сначала вводите фонетическое написание
китайского слова (в методе ввода <CODE>chinese-py</CODE>, помимо прочих) или
последовательность частей знака (методы ввода <CODE>chinese-4corner</CODE>,
<CODE>chinese-sw</CODE> и другие).  Поскольку одно фонетическое написание
обычно соответствует многим различным китайским знакам, вы должны
выбрать одну из альтернатив с помощью особых команд Emacs.  Такие ключи,
как <KBD>C-f</KBD>, <KBD>C-b</KBD>, <KBD>C-n</KBD>, <KBD>C-p</KBD>, и цифры имеют в этой
ситуации особые определения, используемые для выбора среди альтернатив.
<KBD>TAB</KBD> выводит буфер, показывающий все возможные варианты.


<P>
   В японских методах ввода вы сначала вводите целое слово, используя
фонетическое написание; потом, когда это слово уже в буфере, Emacs
преобразует его в один или несколько знаков, используя большой словарь.
Одно фонетическое написание соответствует многим по-разному записанным
японским словам, поэтому вы должны выбрать один из них; для циклического
прохода по альтернативам используйте <KBD>C-n</KBD> и <KBD>C-p</KBD>.


<P>
  Иногда полезно остановить действие метода ввода, чтобы только что
введенные вами знаки не сливались с последующими.  Например, в методе
ввода <CODE>latin-1-postfix</CODE> последовательность <KBD>e '</KBD> комбинируется
в <SAMP>`e'</SAMP> с акцентом.  Что если вы хотели ввести их как раздельные
знаки?


<P>
  Один способ -- набрать акцент дважды; это специальное средство для
ввода буквы и акцента раздельно.  Например, <KBD>e ' '</KBD> дает два знака
<SAMP>`e''</SAMP>.  Другой способ -- набрать после <SAMP>`e'</SAMP> еще одну букву,
которая не скомбинируется с ней, и сразу удалить ее.  Например, вы могли
бы набрать <KBD>e e <KBD>DEL</KBD> '</KBD>, чтобы получить раздельные <SAMP>`e'</SAMP> и
<SAMP>`''</SAMP>.


<P>
  Еще один способ, более общий, но не такой легкий для набора, ---
использовать между двумя знаками <KBD>C-\ C-\</KBD>, чтобы предотвратить их
комбинирование.  Это команда <KBD>C-\</KBD> (<CODE>toggle-input-method</CODE>),
примененная дважды.


<P>
  <KBD>C-\ C-\</KBD> особенно полезна в наращиваемом поиске, поскольку она
останавливает ожидание дальнейших знаков для составления и начинает
поиск того, что вы уже набрали.


<P>
<A NAME="IDX904"></A>
<A NAME="IDX905"></A>
  Переменные <CODE>input-method-highlight-flag</CODE> и
<CODE>input-method-verbose-flag</CODE> управляют тем, как методы ввода
поясняют происходящее.  Если <CODE>input-method-highlight-flag</CODE> не равна
<CODE>nil</CODE>, частичная последовательность подсвечивается в буфере.  Если
<CODE>input-method-verbose-flag</CODE> не равна <CODE>nil</CODE>, в эхо-области
показывается список возможных следующих знаков (но не в том случае,
когда вы находитесь в минибуфере).




<H2><A NAME="SEC203" HREF="emacs_toc.html#TOC203">Выбор метода ввода</A></H2>

<DL COMPACT>

<DT><KBD>C-\</KBD>
<DD>
Включает или выключает использование выбранного метода ввода.

<DT><KBD>C-x <KBD>RET</KBD> C-\ <VAR>метод</VAR> <KBD>RET</KBD></KBD>
<DD>
Выбирает новый метод ввода для текущего буфера.

<DT><KBD>C-h I <VAR>метод</VAR> <KBD>RET</KBD></KBD>
<DD>
<DT><KBD>C-h C-\ <VAR>метод</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX906"></A>
<A NAME="IDX907"></A>
<A NAME="IDX908"></A>
Описывает метод ввода <VAR>метод</VAR> (<CODE>describe-input-method</CODE>).  По
умолчанию, она описывает текущий метод ввода (если он есть).  Такое
описание должно давать вам все подробности о том, как использовать любой
конкретный метод ввода.

<DT><KBD>M-x list-input-methods</KBD>
<DD>
Выводит перечень всех поддерживаемых методов ввода.
</DL>

<P>
<A NAME="IDX909"></A>
<A NAME="IDX910"></A>
<A NAME="IDX911"></A>
  Чтобы выбрать метод ввода для текущего буфера, используйте <KBD>C-x
<KBD>RET</KBD> C-\</KBD> (<CODE>set-input-method</CODE>).  Эта команда считывает имя
метода ввода из минибуфера; имя обычно начинается с языковой среды, для
которой этот метод предназначался.  В переменной
<CODE>current-input-method</CODE> записывается, какой метод ввода был выбран.


<P>
<A NAME="IDX912"></A>
<A NAME="IDX913"></A>
  Методы ввода используют для обозначения знаков, не входящих в ASCII,
различные последовательности ASCII-знаков.  Иногда бывает полезно
временно выключить метод ввода.  Чтобы сделать это, наберите <KBD>C-\</KBD>
(<CODE>toggle-input-method</CODE>).  Чтобы опять задействовать метод ввода,
наберите <KBD>C-\</KBD> снова.


<P>
  Если вы напечатаете <KBD>C-\</KBD>, но метод ввода пока не выбран, вас
попросят указать его.  Это имеет тот же эффект, что и использование
<KBD>C-x <KBD>RET</KBD> C-\</KBD> для задания метода ввода.


<P>
<A NAME="IDX914"></A>
  Выбор языковой среды определяет метод ввода, используемый по
умолчанию.  Тогда вы можете выбрать его в текущем буфере, набирая
<KBD>C-\</KBD>.  Переменная <CODE>default-input-method</CODE> задает метод ввода,
принимаемый по умолчанию (<CODE>nil</CODE> означает, что такого нет).


<P>
<A NAME="IDX915"></A>
  Некоторые методы ввода для алфавитных систем письма работают путем
отображения клавиатуры для эмуляции различных раскладок, часто
используемых для этих систем письма.  Как правильно сделать это
отображение, зависит от действительной раскладки вашей клавиатуры.
Чтобы указать ее, используйте команду <KBD>M-x
quail-set-keyboard-layout</KBD>.


<P>
<A NAME="IDX916"></A>
  Чтобы просмотреть перечень всех поддерживаемых методов ввода, наберите
<KBD>M-x list-input-methods</KBD>.  Перечень сообщает сведения о каждом
методе ввода, включая строку, обозначающую этот метод ввода в строке
режима.




<H2><A NAME="SEC204" HREF="emacs_toc.html#TOC204">Однобайтные и многобайтные не-ASCII-знаки</A></H2>

<P>
  Когда включены многобайтные знаки, знаки с кодами от 0240
(восьмиричное) до 0377 (восьмиричное) на самом деле недопустимы в
буфере.  Допустимые печатные знаки, не входящие в ASCII, имеют коды,
начинающиеся от 0400.


<P>
  Если вы набираете самовставляющийся знак в недопустимом диапазоне от
0240 до 0377, Emacs предполагает, что вы намеревались использовать один
из наборов знаков Latin-<VAR>n</VAR>, и преобразует его в код Emacs,
представляющий этот знак Latin-<VAR>n</VAR>.  Вы указываете, <EM>какой</EM>
набор знаков ISO нужно для этого применять, своим выбором языковой среды
(смотрите выше).
Если вы не указали свой выбор, по умолчанию используется Latin-1.


<P>
  То же происходит, когда вы используете <KBD>C-q</KBD> для ввода
восьмиричного кода в этом диапазоне.




<H2><A NAME="SEC205" HREF="emacs_toc.html#TOC205">Системы кодирования</A></H2>
<P>
<A NAME="IDX917"></A>


<P>
  Носители различных языков выработали много более или менее стандартных
систем кодирования для их представления.  Emacs не использует эти
системы кодирования внутренне; вместо этого, при считывании данных он
преобразует их из различных систем кодирования в свою внутреннюю, а при
записи он преобразует данные из внутренней системы кодирования в другие
системы.  Преобразование возможно при считывании и записи файлов,
отправке или получении данных с терминала и при обмене данными с
подпроцессами.


<P>
  Emacs присваивает каждой системе кодирования свое имя.  Большинство
систем кодирования используются для одного языка, и имя такой системы
кодирования начинается с имени языка.  Некоторые системы кодирования
используются для нескольких языков; их имена обычно начинаются с
<SAMP>`iso'</SAMP>.  Есть также специальные системы кодирования
<CODE>no-conversion</CODE>, <CODE>raw-text</CODE> и <CODE>emacs-mule</CODE>, которые не
делают преобразования печатных знаков вообще.


<P>
<A NAME="IDX918"></A>
  Помимо преобразований между разными представлениями не-ASCII-знаков,
система кодирования может производить преобразование последовательности
"конец-строки".  Emacs работает с тремя различными соглашениями о том,
как разделять строки в файле: переводом строки, возвратом каретки и
переводом строки и просто возвратом каретки.


<DL COMPACT>

<DT><KBD>C-h C <VAR>кодирование</VAR> <KBD>RET</KBD></KBD>
<DD>
Описывает систему кодирования <VAR>кодирование</VAR>.

<DT><KBD>C-h C <KBD>RET</KBD></KBD>
<DD>
Описывает систему кодирования, используемую в данный момент.

<DT><KBD>M-x list-coding-systems</KBD>
<DD>
Выводит перечень всех поддерживаемых систем кодирования.
</DL>

<P>
<A NAME="IDX919"></A>
<A NAME="IDX920"></A>
  Команда <KBD>C-h C</KBD> (<CODE>describe-coding-system</CODE>) выводит сведения о
конкретной системе кодирования.  Вы можете задать имя системы
кодирования в качестве аргумента; иначе, с пустым аргументом, она опишет
системы кодирования, выбранные в данный момент для различных целей как в
текущем буфере, так и принимаемые по умолчанию, а также перечень
приоритетов для распознавания систем кодирования (see section <A HREF="emacs_23.html#SEC206">Распознавание систем кодирования</A>).


<P>
<A NAME="IDX921"></A>
  Чтобы вывести перечень всех поддерживаемых систем кодирования,
наберите <KBD>M-x list-coding-systems</KBD>.  Этот перечень дает информацию о
каждой системе кодирования, включая букву, обозначающую ее в строке
режима (see section <A HREF="emacs_6.html#SEC15">Строка режима</A>).


<P>
<A NAME="IDX922"></A>
<A NAME="IDX923"></A>
<A NAME="IDX924"></A>
  Каждая система кодирования из перечисленных в этом списке -- кроме
<CODE>no-conversion</CODE>, что означает не делать никаких преобразований ---
указывает, как преобразовывать печатные знаки и нужно ли это делать, но
оставляет выбор преобразования конца-строки до решения, основанном
на содержимом файла.  Например, если оказалось, что в файле для
разделения строк используется последовательность возврат каретки-перевод
строки, будет использовано преобразование из конца-строки DOS.


<P>
  Каждая из перечисленных систем кодирования имеет три варианта, которые
точно указывают, что делать для преобразования конца-строки:


<DL COMPACT>

<DT><CODE>...-unix</CODE>
<DD>
Не производить преобразования конца-строки; предполагается, что в файле
для разделения строк используется перевод строки.  (Это соглашение
обычно используется в системах Unix и GNU.)

<DT><CODE>...-dos</CODE>
<DD>
Предполагать, что в файле для разделения строк используется возврат
каретки-перевод строки, и делать соответствующее преобразование.  (Это
соглашение обычно используется в системах Microsoft.<A NAME="DOCF5" HREF="emacs_foot.html#FOOT5">(5)</A>)

<DT><CODE>...-mac</CODE>
<DD>
Предполагать, что в файле для разделения строк используется возврат
каретки, и делать соответствующее преобразование.  (Это соглашение
обычно используется в системе Macintosh.)
</DL>

<P>
  Эти варианты систем кодирования опускаются для краткости в выводе
<CODE>list-coding-systems</CODE>, поскольку они полностью предсказуемы.
Например, система кодирования <CODE>iso-latin-1</CODE> имеет варианты
<CODE>iso-latin-1-unix</CODE>, <CODE>iso-latin-1-dos</CODE> и
<CODE>iso-latin-1-mac</CODE>.


<P>
  Система кодирования <CODE>raw-text</CODE> хороша для файлов, которые
содержат в основном ASCII-текст, но могут включать байты со значениями
выше 127, которые не предназначались для кодирования не-ASCII-знаков.  С
<CODE>raw-text</CODE>, Emacs копирует эти байты без изменений и, чтобы они
интерпретировались правильно, устанавливает в текущем буфере
<CODE>enable-multibyte-characters</CODE> равной <CODE>nil</CODE>.  <CODE>raw-text</CODE>
обрабатывает преобразование конца-строки обычным способом, основываясь
на увиденных данных, и имеет три обычных варианта для указания нужного
преобразования конца-строки.


<P>
  В противоположность этому, система кодирования <CODE>no-conversion</CODE> не
задает никакого преобразования кодов знаков вообще -- ни для значений
байт, выходящих за пределы ASCII, ни для конца-строки.  Это полезно для
считывания и записи двоичных файлов, tar-файлов и других, которые нужно
просматривать буквально.  Она тоже устанавливает
<CODE>enable-multibyte-characters</CODE> в значение <CODE>nil</CODE>.


<P>
  Простейший способ отредактировать файл без любых преобразований ---
воспользоваться командой <KBD>M-x find-file-literally</KBD>.  Она использует
<CODE>no-conversion</CODE>, а также подавляет другие средства Emacs, которые
могли бы преобразовать содержимое файла до того, как вы его увидите.
See section <A HREF="emacs_19.html#SEC110">Обращение к файлам</A>.


<P>
  Система кодирования <CODE>emacs-mule</CODE>
полагает, что файл содержит не-ASCII-знаки во внутренней кодировке
Emacs.  Она обрабатывает преобразование конца-строки, основываясь
на увиденных данных, и имеет три обычных варианта для указания нужного
преобразования конца-строки.




<H2><A NAME="SEC206" HREF="emacs_toc.html#TOC206">Распознавание систем кодирования</A></H2>

<P>
  Чаще всего Emacs может распознать, какую систему кодирования он должен
использовать для любого данного файла, -- если вы указали свои
предпочтения.


<P>
  Некоторые системы кодирования могут быть распознаны или выделены по
тому, какие последовательности знаков появляются среди данных.  Однако,
есть системы кодирования, которые не могут быть различены, даже
потенциально.  Например, нет способа отличить Latin-1 от Latin-2; они
используют одни и те же значения байт с разными смыслами.


<P>
  Emacs справляется с такой ситуацией при помощи списка приоритетов
систем кодирования.  Если вы не указали, какую систему кодирования надо
использовать, Emacs во время считывания файла сверяет данные с каждой
системой кодирования, начиная с первой по приоритету и продвигаясь вниз
по списку, пока не найдет систему кодирования, подходящую для этого
файла.  Затем он преобразует содержимое файла, предполагая, что оно
представлено в этой системе кодирования.


<P>
  Список приоритетов систем кодирования зависит от выбранной языковой
среды (see section <A HREF="emacs_23.html#SEC201">Языковые среды</A>).  Например, если вы используете
французский, вы, вероятно, захотите, чтобы Emacs предпочитал Latin-1, а
не Latin-2; а если вы используете чешский -- чтобы предпочтение
отдавалось Latin-2.  Это одна из причин задавать языковую среду.


<P>
<A NAME="IDX925"></A>
  Однако, вы можете детально изменять список приоритетов с помощью
команды <KBD>M-x prefer-coding-system</KBD>.  Эта команда считывает имя
системы кодирования в минибуфере и добавляет ее в начало списка
приоритетов, так, чтобы ей отдавалось предпочтение среди остальных.
Если вы применяете эту команду несколько раз, при каждом использовании в
начало списка приоритетов добавляется один элемент.


<P>
  Если вы используете систему кодирования, которая определяет тип
преобразования последовательности конец-строки, такую как
<CODE>iso-8859-1-dos</CODE>, то это означает, что Emacs должен попытаться
распознать предпочтительно <CODE>iso-8859-1</CODE> и использовать
преобразование конца-строки DOS, если <CODE>iso-8859-1</CODE> была распознана.


<P>
<A NAME="IDX926"></A>
  Иногда имя файла указывает на то, какая система кодирования должна для
него использоваться.  Это соответствие задает переменная
<CODE>file-coding-system-alist</CODE>.  Для добавления элементов к этому
списку есть особая функция, <CODE>modify-coding-system-alist</CODE>.  К
примеру, чтобы все <SAMP>`.txt'</SAMP>-файлы считывались и записывались с
использованием системы кодирования <CODE>china-iso-8bit</CODE>, вы можете
выполнить следующее лисповское выражение:



<PRE>
(modify-coding-system-alist 'file "\\.txt\\'" 'china-iso-8bit)
</PRE>

<P>
Первым аргументом должен быть <CODE>file</CODE>, вторым -- регулярное
выражение, определяющее, к каким файлам это относится, а третий аргумент
говорит, какую систему кодирования применять для этих файлов.


<P>
<A NAME="IDX927"></A>
  Emacs узна╠т, какой вид преобразования конца-строки следует
использовать, основываясь на содержимом файла: если он видит только
возвраты каретки или только последовательности возврат каретки-перевод
строки, то выбирает соответствующее преобразование.  Вы можете подавить
автоматическое использование преобразования конца-строки, установив
переменную <CODE>inhibit-eol-conversion</CODE> в значение <CODE>nil</CODE>.


<P>
<A NAME="IDX928"></A>
  Вы можете указать систему кодирования для конкретного файла, применяя
конструкцию <SAMP>`-*-...-*-'</SAMP> в начале этого файла или в списке
локальных переменных в его конце (see section <A HREF="emacs_36.html#SEC451">Локальные переменные в файлах</A>).  Вы делаете
это, определяя значение для "переменной" с именем <CODE>coding</CODE>.  На
самом деле в Emacs нет переменной <CODE>coding</CODE>; вместо установки
переменной он использует заданную систему кодирования для этого файла.
Например, <SAMP>`-*-mode: C; coding: latin-1;-*-'</SAMP> велит использовать
систему кодирования Latin-1 и режим C.  Если вы явно указали систему
кодирования в файле, она перекрывает <CODE>file-coding-system-alist</CODE>.


<P>
<A NAME="IDX929"></A>
  Переменная <CODE>auto-coding-alist</CODE> -- это самый сильный способ
указать систему кодирования для определенных образцов имен файлов; эта
переменная даже перекрывает теги <SAMP>`-*-coding:-*-'</SAMP> в самом файле.
Emacs использует это средство для tar-файлов и архивов, чтобы избежать
ошибочной интерпретации тега <SAMP>`-*-coding:-*-'</SAMP> в элементе архива как
относящегося ко всему архивному файлу.


<P>
<A NAME="IDX930"></A>
  Когда Emacs выбрал систему кодирования для буфера, он сохраняет ее в
<CODE>buffer-file-coding-system</CODE> и по умолчанию использует эту систему
кодирования для операций, которые записывают этот буфер в файл.  Это
включает команды <CODE>save-buffer</CODE> и <CODE>write-region</CODE>.  Если вы
хотите записывать файлы из этого буфера, используя другую систему
кодирования, вы можете указать для этого файла новую систему кодирования
с помощью <CODE>set-buffer-file-coding-system</CODE> (see section <A HREF="emacs_23.html#SEC207">Задание системы кодирования</A>).


<P>
<A NAME="IDX931"></A>
  Когда вы посылаете сообщение с помощью режима Mail (see section <A HREF="emacs_31.html#SEC339">Посылка почты</A>), у Emacs есть четыре разных способа узнать систему кодирования
для текста сообщения.  Он пробует значение
<CODE>buffer-file-coding-system</CODE>, собственное для этого буфера, если оно
не равно <CODE>nil</CODE>.  Иначе, он использует значение
<CODE>sendmail-coding-system</CODE>, если оно не равно <CODE>nil</CODE>.  Третий
способ -- использовать систему кодирования, принимаемую по умолчанию
для новых файлов, которая управляется вашей языковой средой, если она не
<CODE>nil</CODE>.  Если все три эти значения равны <CODE>nil</CODE>, Emacs кодирует
исходящую почту, используя систему кодирования Latin-1.


<P>
<A NAME="IDX932"></A>
  Когда вы получаете новую почту в Rmail, каждое сообщение автоматически
переводится из той системы кодирования, в которой оно было написано ---
как если бы оно было отдельным файлом.  При этом используется заданный
вами список приоритетов систем кодирования.  Если в сообщении в формате
MIME указан набор знаков, Rmail подчиняется этому указанию, если
<CODE>rmail-decode-mime-charset</CODE> не равна <CODE>nil</CODE>.


<P>
<A NAME="IDX933"></A>
  Для считывания и сохранения самих Rmail-файлов Emacs использует
систему кодирования, задаваемую переменной
<CODE>rmail-file-coding-system</CODE>.  Значение по умолчанию равно
<CODE>nil</CODE>, что означает, что Rmail-файлы не переводятся (они
считываются и сохраняются во внутренней кодировке Emacs).




<H2><A NAME="SEC207" HREF="emacs_toc.html#TOC207">Задание системы кодирования</A></H2>

<P>
  В случаях, когда Emacs не может автоматически подобрать правильную
систему кодирования, вы можете указать ее явно с помощью таких команд:


<DL COMPACT>

<DT><KBD>C-x <KBD>RET</KBD> f <VAR>кодирование</VAR> <KBD>RET</KBD></KBD>
<DD>
Использовать систему кодирования <VAR>кодирование</VAR> для файла, к которому
обращается текущий буфер.

<DT><KBD>C-x <KBD>RET</KBD> c <VAR>кодирование</VAR> <KBD>RET</KBD></KBD>
<DD>
Задает систему кодирования <VAR>кодирование</VAR> для непосредственно
следующей команды.

<DT><KBD>C-x <KBD>RET</KBD> k <VAR>кодирование</VAR> <KBD>RET</KBD></KBD>
<DD>
Использовать систему кодирования <VAR>кодирование</VAR> для ввода с
клавиатуры.

<DT><KBD>C-x <KBD>RET</KBD> t <VAR>кодирование</VAR> <KBD>RET</KBD></KBD>
<DD>
Использовать систему кодирования <VAR>кодирование</VAR> для вывода на
терминал.

<DT><KBD>C-x <KBD>RET</KBD> p <VAR>код-ввода</VAR> <KBD>RET</KBD> <VAR>код-вывода</VAR> <KBD>RET</KBD></KBD>
<DD>
Использовать системы кодирования <VAR>код-ввода</VAR> и <VAR>код-вывода</VAR> для
ввода и вывода подпроцесса текущего буфера.

<DT><KBD>C-x <KBD>RET</KBD> x <VAR>кодирование</VAR> <KBD>RET</KBD></KBD>
<DD>
Использовать систему кодирования <VAR>кодирование</VAR> для передачи
выделений другим программам и получения их из других программ через
оконную систему.

<DT><KBD>C-x <KBD>RET</KBD> X <VAR>кодирование</VAR> <KBD>RET</KBD></KBD>
<DD>
Использовать систему кодирования <VAR>кодирование</VAR> для передачи или
получения <EM>одного</EM> выделения -- следующего -- в оконную систему
или из нее.
</DL>

<P>
<A NAME="IDX934"></A>
<A NAME="IDX935"></A>
  Команда <KBD>C-x <KBD>RET</KBD> f</KBD> (<CODE>set-buffer-file-coding-system</CODE>)
задает систему кодирования файла для текущего буфера -- другими
словами, указывает, какую систему кодирования следует использовать для
сохранения или повторного считывания этого файла.  Вы задаете систему
кодирования в минибуфере.  Так как эта команда применяется только к
файлу, к которому вы уже обратились, она влияет лишь на способ
сохранения этого файла.


<P>
<A NAME="IDX936"></A>
<A NAME="IDX937"></A>
  Другой способ указать систему кодирования для файла -- сделать это во
время обращения.  Сначала используйте команду <KBD>C-x <KBD>RET</KBD> c</KBD>
(<CODE>universal-coding-system-argument</CODE>); эта команда считывает в
минибуфере имя системы кодирования.  После выхода из минибуфера заданная
система кодирования применяется для <EM>непосредственно следующей
команды</EM>.


<P>
  Таким образом, если непосредственно следующей командой будет, скажем,
<KBD>C-x C-f</KBD>, то она считает файл, используя указанную систему
кодирования (и запоминает эту систему кодирования для последующей записи
файла).  Или, если следующей командой будет <KBD>C-x C-w</KBD>, она запишет
файл, используя эту систему кодирования.  Другие команды работы с
файлами, на которые действует заданная система кодирования, включают
<KBD>C-x C-i</KBD> и <KBD>C-x C-v</KBD>, а также варианты <KBD>C-x C-f</KBD> с показом
в другом окне.


<P>
  <KBD>C-x <KBD>RET</KBD> c</KBD> также влияет на программы, начинающие
подпроцессы, включая <KBD>M-x shell</KBD> (see section <A HREF="emacs_35.html#SEC417">Запуск команд оболочки из Emacs</A>).


<P>
  Однако, если непосредственно следующая команда не использует систему
кодирования, то <KBD>C-x <KBD>RET</KBD> c</KBD> в результате не имеет эффекта.


<P>
  Простой способ обратиться к файлу без преобразования предоставляет
команда <KBD>M-x find-file-literally</KBD>.  See section <A HREF="emacs_19.html#SEC110">Обращение к файлам</A>.


<P>
<A NAME="IDX938"></A>
  Переменная <CODE>default-buffer-file-coding-system</CODE> определяет выбор
системы кодирования для вновь создаваемых файлов.  Она применяется,
когда вы обращаетесь к новому файлу или создаете буфер и затем
сохраняете его в файл.  При выборе языковой среды эта переменная как
правило устанавливается в подходящее значение по умолчанию.


<P>
<A NAME="IDX939"></A>
<A NAME="IDX940"></A>
  Команда <KBD>C-x <KBD>RET</KBD> t</KBD> (<CODE>set-terminal-coding-system</CODE>)
задает систему кодирования для терминального вывода.  Если вы зададите
систему кодирования для терминального вывода, все выводимые на терминал
знаки переводятся в эту систему.


<P>
  Это средство полезно для некоторых текстовых терминалов, сделанных с
поддержкой какого-то конкретного языка или набора знаков -- например,
европейских терминалов, поддерживающих один из наборов знаков ISO Latin.
При использовании многобайтного текста вам нужно указать систему
кодирования, чтобы Emacs знал, какие знаки этот терминал может на самом
деле обработать.


<P>
  По умолчанию вывод на терминал не преобразуется совсем, если только
Emacs не может предугадать правильную систему кодирования для вашего
типа терминала.


<P>
<A NAME="IDX941"></A>
<A NAME="IDX942"></A>
  Команда <KBD>C-x <KBD>RET</KBD> k</KBD> (<CODE>set-keyboard-coding-system</CODE>)
задает систему кодирования для ввода с клавиатуры.  Перевод кодов
вводимых с клавиатуры знаков полезен для терминалов, клавиши которых
посылают графические не-ASCII-знаки, например, для некоторых терминалов,
разработанных для кодировки ISO Latin-1 или ее подмножеств.


<P>
  По умолчанию ввод с клавиатуры не переводится.


<P>
  Между использованием системы кодирования для перевода ввода с
клавиатуры и использованием метода ввода есть некое сходство: в обоих
случаях определяются вводимые с клавиатуры последовательности,
превращающиеся с один знак.  Однако, методы ввода разработаны для
удобного интерактивного использования людьми, и переводимые ими
последовательности обычно являются последовательностями печатных
ASCII-знаков.  Системы кодирования как правило переводят
последовательности неграфических знаков.


<P>
<A NAME="IDX943"></A>
<A NAME="IDX944"></A>
<A NAME="IDX945"></A>
<A NAME="IDX946"></A>
  Команда <KBD>C-x <KBD>RET</KBD> x</KBD> (<CODE>set-selection-coding-system</CODE>)
задает систему кодирования для передачи выделенного текста оконной
системе и для получения текста выделений, сделанных в других
приложениях.  Эта команда относится ко всем будущим выделениям, пока вы
не отмените это, снова применив эту команду.  Команда <KBD>C-x <KBD>RET</KBD>
X</KBD> (<CODE>set-next-selection-coding-system</CODE>) задает систему кодирования
для следующего выделения, сделанного в Emacs или считанного Emacs.


<P>
<A NAME="IDX947"></A>
<A NAME="IDX948"></A>
  Команда <KBD>C-x <KBD>RET</KBD> p</KBD>
(<CODE>set-buffer-process-coding-system</CODE>) задает систему кодирования для
ввода и вывода подпроцесса.  Эта команда относится к текущему буферу;
как правило, каждый подпроцесс имеет собственный буфер, следовательно,
вы можете указывать перекодировку ввода и вывода процесса, давая эту
команду в соответствующем буфере.


<P>
  По умолчанию ввод и вывод процессов не переводится совсем.


<P>
<A NAME="IDX949"></A>
  Переменная <CODE>file-name-coding-system</CODE> задает систему кодирования,
используемую для кодирования имен файлов.  Если вы установите ее равной
имени системы кодирования (это лисповский символ или строка), Emacs
станет кодировать имена файлов при всех файловых операциях, используя
эту систему кодирования.  Это позволяет использовать в именах файлов
не-ASCII-знаки, или по крайней мере те не-ASCII-знаки, которые могут
быть закодированы текущей системой кодирования.


<P>
  Если <CODE>file-name-coding-system</CODE> равна <CODE>nil</CODE>, Emacs использует
систему кодирования по умолчанию, определяемую языковой средой.  В
языковой среде, принимаемой по умолчанию, любые знаки в именах файлов,
не входящие в ASCII, никак особенно не кодируются; они появляются в
файловой системе во внутреннем представлении Emacs.


<P>
  <STRONG>Внимание:</STRONG> если вы измените <CODE>file-name-coding-system</CODE>
(или языковую среду) в середине сеанса Emacs, вы можете столкнуться с
проблемами, если вы уже обратились к файлам, чьи имена были закодированы
с использованием старой системы кодирования и не могут быть представлены
(или кодируются иначе) в новой системе кодирования.  Если вы попытаетесь
сохранить один из таких буферов под именем файла, к которому он
обращается, может быть использовано неправильное имя или может
возникнуть ошибка.  Если случается такая проблема, используйте <KBD>C-x
C-w</KBD>, чтобы задать для этого буфера новое имя файла.




<H2><A NAME="SEC208" HREF="emacs_toc.html#TOC208">Наборы шрифтов</A></H2>
<P>
<A NAME="IDX950"></A>


<P>
  Шрифт X Windows обычно определяет начертание для одного алфавита или
письменности.  Поэтому для отображения полного спектра всех систем
письма, которые поддерживает Emacs, необходимо множество шрифтов.  В
Emacs такое множество называется <EM>набором шрифтов</EM>.  Набор шрифтов
определяется как список шрифтов, каждый из которых предназначается для
работы с одним диапазоном кодов знаков.


<P>
  Каждый набор шрифтов имеет имя, как и отдельный шрифт.  Доступные
шрифты определяются X-сервером; наборы шрифтов определяются внутри
самого Emacs.  Как только вы определили набор шрифтов, вы можете
использовать его в Emacs, указывая его имя в любом контексте, где вы
могли бы написать один шрифт.  Разумеется, наборы шрифтов Emacs могут
содержать только те шрифты, которые поддерживаются X-сервером; если
некоторые знаки появляются на экране как пустые прямоугольники, это
означает, что в используемом наборе шрифтов нет шрифта для этих знаков.


<P>
  Emacs создает два набора шрифтов автоматически: <EM>стандартный набор
шрифтов</EM> и <EM>стартовый набор шрифтов</EM>.  Стандартный набор шрифтов
скорее всего содержит шрифты для широкого спектра знаков, не входящих в
ASCII; однако, по умолчанию Emacs использует не его.  (По умолчанию
Emacs старается найти шрифт, которые имеет жирный и курсивный варианты.)
Вы можете указать, что нужно использовать стандартный набор шрифтов, с
помощью ключа @option{-fn} или с помощью X-ресурса <SAMP>`Font'</SAMP>
(see section <A HREF="emacs_38.html#SEC503">Ключи для задания шрифта</A>).  Например,



<PRE>
emacs -fn fontset-standard
</PRE>

<P>
  Набор шрифтов не обязан задавать шрифт для каждого кода.  Если набор
шрифтов не определяет шрифт для некоторого знака, или его он определяет
шрифт, которого нет в вашей системе, то он не может правильно отобразить
этот знак.  Вместо этого знака будет показан пустой прямоугольник.


<P>
<A NAME="IDX951"></A>
  Высота и ширина набора шрифтов определяются ASCII-знаками (то есть
шрифтами, используемыми в этом наборе для ASCII-знаков).  Если другой
шрифт в этом наборе имеет иную высоту или ширину, то знаки, приписанные
к этому шрифту, обрезаются до размера набора шрифтов.  Если
<CODE>highlight-wrong-size-font</CODE> отлична от <CODE>nil</CODE>, то вокруг знаков
с неправильным размером еще выводится прямоугольник.




<H2><A NAME="SEC209" HREF="emacs_toc.html#TOC209">Определение наборов шрифтов</A></H2>

<P>
<A NAME="IDX952"></A>
<A NAME="IDX953"></A>
  Emacs создает стандартный набор шрифтов автоматически в соответствии с
<CODE>standard-fontset-spec</CODE>.  Именем этого набора является



<PRE>
-*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard
</PRE>

<P>
или просто <SAMP>`fontset-standard'</SAMP> для краткости.


<P>
  Жирный, курсивный и жирный курсивный варианты стандартного набора
шрифтов создаются автоматически.  Их имена имеют <SAMP>`bold'</SAMP> вместо
<SAMP>`medium'</SAMP>, или <SAMP>`i'</SAMP> вместо <SAMP>`r'</SAMP> или и то, и другое.


<P>
<A NAME="IDX954"></A>
  Если вы задали ASCII-шрифт по умолчанию с помощью ресурса <SAMP>`Font'</SAMP>
или аргумента @option{-fn}, Emacs автоматически генерирует из него набор
шрифтов.  Это <EM>стартовый набор шрифтов</EM>, и его имя ---
<CODE>fontset-startup</CODE>.  Emacs делает это, заменяя в имени шрифта поля
<VAR>foundry</VAR>, <VAR>family</VAR>, <VAR>add_style</VAR> и <VAR>average_width</VAR> на
<SAMP>`*'</SAMP>, заменяя <VAR>charset_registry</VAR> на <SAMP>`fontset'</SAMP>, а поле
<VAR>charset_encoding</VAR> -- на <SAMP>`startup'</SAMP> и используя затем
полученную строку для задания набора шрифтов.


<P>
  К примеру, если вы запустили Emacs таким образом:



<PRE>
emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"
</PRE>

<P>
Emacs генерирует следующий набор шрифтов и использует его для первого
фрейма:



<PRE>
-*-*-medium-r-normal-*-14-140-*-*-*-*-fontset-startup
</PRE>

<P>
  В X-ресурсе <SAMP>`Emacs.Font'</SAMP> вы можете указывать набор шрифтов,
точно так же, как и обычное имя шрифта.  Но будьте внимательны и не
задавайте набор шрифтов в ресурсе с символами подстановки, как
<SAMP>`Emacs*Font'</SAMP>, -- такая спецификация применяется для различных
целей, например для меню, а меню не может обращаться с наборами
шрифтов.


<P>
  Вы можете определить дополнительные наборы шрифтов, используя
X-ресурсы с именами <SAMP>`Fontset-<VAR>n</VAR>'</SAMP>, где <VAR>n</VAR> -- число,
отсчитываемое от нуля.  Значение этого ресурса должно иметь такую форму:



<PRE>
<VAR>шаблон-шрифта</VAR>, [<VAR>имя-кодировки</VAR>:<VAR>имя-шрифта</VAR>]...
</PRE>

<P>
<VAR>шаблон-шрифта</VAR>, кроме двух последних полей, должен иметь форму
стандартного имени X-шрифта.  Два последних поля должны иметь вид
<SAMP>`fontset-<VAR>псевдоним</VAR>'</SAMP>.


<P>
  У набора шрифтов есть два имени, одно длинное, а другое короткое.
Длинное имя -- это <VAR>шаблон-шрифта</VAR>.  Короткое имя -- это
<SAMP>`fontset-<VAR>псевдоним</VAR>'</SAMP>.  Вы можете ссылаться на набор шрифтов по
любому из этих имен.


<P>
  Конструкция <SAMP>`<VAR>кодировка</VAR>:<VAR>шрифт</VAR>'</SAMP> определяет, какой шрифт
должен использоваться (в этом наборе) для одного конкретного набора
знаков.  Здесь <VAR>кодировка</VAR> -- это имя набора знаков, а <VAR>шрифт</VAR>
--- это используемый для него шрифт.  При определении одного набора
шрифтов вы можете применять эту конструкцию любое число раз.


<P>
@hyphenation{зна-че-ния}
  Для остальных наборов знаков Emacs выбирает шрифт, основываясь на
<VAR>шаблоне-шрифта</VAR>.  Он заменяет <SAMP>`fontset-<VAR>псевдоним</VAR>'</SAMP> на
значения, описывающие набор знаков.  Для шрифта знаков ASCII,
<SAMP>`fontset-<VAR>псевдоним</VAR>'</SAMP> заменяется на <SAMP>`ISO8859-1'</SAMP>.


<P>
  Кроме того, когда несколько последовательных полей являются символами
подстановки, Emacs сжимает их в один символ.  Это делается для
предотвращения использования автоматически масштабированных шрифтов.
Шрифты, получаемые масштабированием более крупного шрифта, непригодны
для редактирования, а масштабирование мелкого шрифта бессмысленно,
потому что мелкий шрифт лучше использовать с его собственным размером,
что Emacs и делает.


<P>
  Таким образом, если <VAR>шаблон-шрифта</VAR> задан так:



<PRE>
-*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24
</PRE>

<P>
то спецификация шрифта для ASCII-знаков была бы такой:



<PRE>
-*-fixed-medium-r-normal-*-24-*-ISO8859-1
</PRE>

<P>
а спецификация шрифта для китайских знаков GB2312 такой:



<PRE>
-*-fixed-medium-r-normal-*-24-*-gb2312*-*
</PRE>

<P>
  У вас может не оказаться китайских шрифтов, соответствующих приведенной
выше спецификации.  Большинство дистрибутивов X Windows включают только
китайские шрифты с <SAMP>`song ti'</SAMP> или <SAMP>`fangsong ti'</SAMP> в поле
<VAR>family</VAR>.  В таком случае <SAMP>`Fontset-<VAR>n</VAR>'</SAMP> можно задать таким
образом:



<PRE>
Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
        chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*
</PRE>

<P>
Тогда спецификации всех шрифтов, кроме китайских GB2312, будут иметь
<SAMP>`fixed'</SAMP> в поле <VAR>family</VAR>, а спецификации для китайских знаков
GB2312 несут в поле <VAR>family</VAR> символ подстановки <SAMP>`*'</SAMP>.


<P>
<A NAME="IDX955"></A>
  Функция, которая обрабатывает значение ресурса, определяющего набор
шрифтов, и создает этот набор, называется
<CODE>create-fontset-from-fontset-spec</CODE>.  Вы также можете вызывать эту
функцию явно, чтобы сгенерировать набор шрифтов.


<P>
  See section <A HREF="emacs_38.html#SEC503">Ключи для задания шрифта</A>, для большей информации об именовании шрифтов в X.




<H2><A NAME="SEC210" HREF="emacs_toc.html#TOC210">Поддержка однобайтных европейских знаков</A></H2>

<P>
<A NAME="IDX956"></A>
<A NAME="IDX957"></A>
<A NAME="IDX958"></A>
<A NAME="IDX959"></A>
<A NAME="IDX960"></A>
  Наборы знаков ISO 8859 Latin-<VAR>n</VAR> определяют коды знаков в
диапазоне от 160 до 255 для обращения с акцентированными буквами и
знаками препинания, необходимыми в различных европейских языках.  Если
вы выключите поддержку многобайтных знаков, Emacs все же сможет работать
с <EM>одной</EM> из этих кодировок.  Чтобы указать, <EM>какие</EM> из этих
кодов следует использовать, вызовите <KBD>M-x set-language-environment</KBD> и
задайте подходящую языковую среду, такую как <SAMP>`Latin-<VAR>n</VAR>'</SAMP>.


<P>
  Для получения большей информации об однобайтном режиме смотрите
section <A HREF="emacs_23.html#SEC200">Включение поддержки многобайтных знаков</A>.  В частности, обратите внимание на
то, что ваши файлы инициализации считываются как однобайтные, если они
содержат не-ASCII-знаки.


<P>
<A NAME="IDX961"></A>
  Emacs может также отображать такие знаки, при условии, что они
поддерживаются терминалом или шрифтом.  Это работает автоматически.
Или, если вы используете оконную систему, Emacs может отображать
однобайтные знаки через наборы шрифтов, показывая в действительности
эквивалентные многобайтные знаки в соответствии с языковой средой.
Чтобы затребовать это, установите переменную
<CODE>unibyte-display-via-language-environment</CODE> в отличное от <CODE>nil</CODE>
значение.


<P>
<A NAME="IDX962"></A>
  Если ваш терминал не поддерживает набор знаков Latin-1, Emacs может
отображать их как ASCII-последовательности, которые по крайней мере дают
вам ясное представление о том, что это за знаки.  Чтобы сделать так,
загрузите библиотеку <CODE>iso-ascii</CODE>.  Могут быть реализованы похожие
библиотеки и для других наборов знаков Latin-<VAR>n</VAR>, но пока их у нас
нет.


<P>
<A NAME="IDX963"></A>
<A NAME="IDX964"></A>
  Обычно не входящие в ISO-8859 знаки (между 128 и 159 включительно)
отображаются как восьмиричные управляющие последовательности.  Вы можете
изменить это для нестандартных `расширенных' версий наборов знаков
ISO-8859, используя функцию <CODE>standard-display-8bit</CODE> из библиотеки
<CODE>disp-table</CODE>.


<P>
  Есть три разных способа вводить однобайтные не-ASCII-знаки:



<UL>
<LI>

Если ваша клавиатура может генерировать коды знаков от 128 и выше,
представляющие знаки, не входящие в ASCII, выполните следующее
выражение, чтобы Emacs смог их понимать:


<PRE>
(set-input-mode (car (current-input-mode))
                (nth 1 (current-input-mode))
                0)
</PRE>

<LI>

Вы можете использовать метод ввода для выбранной языковой среды.
See section <A HREF="emacs_23.html#SEC202">Методы ввода</A>.  Когда вы используете метод ввода в однобайтном
буфере, задаваемые с его помощью знаки переводятся в однобайтное
представление.

<A NAME="IDX965"></A>
<A NAME="IDX966"></A>
<LI>

Для ввода печатных знаков Latin-1 вы можете использовать <KBD>C-x 8</KBD> как
префикс "составления".  <KBD>C-x 8</KBD> удобен для вставки (в минибуфере,
а также в остальных буферах), для поиска и во всех других контекстах,
где допускаются последовательности знаков.  

<KBD>C-x 8</KBD> работает путем загрузки библиотеки <CODE>iso-transl</CODE>.  Когда
эта библиотека загружена, клавиша-модификатор <KBD>ALT</KBD>, если она у вас
есть, служит для той же цели, что и <KBD>C-x 8</KBD>; используйте <KBD>ALT</KBD>
вместе со знаком акцента, чтобы модифицировать следующую букву.  Кроме
того, если у вас есть залипающие клавиши для генерации акцентов Latin-1,
то они тоже определены для компоновки со следующим знаком, если
<CODE>iso-transl</CODE> загружена.
</UL>

<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_22.html">previous</A>, <A HREF="emacs_24.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">_uacct = "UA-78697-3"; urchinTracker(); </script></body>
</HTML>
