<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Команды для естественных языков</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_25.html">previous</A>, <A HREF="emacs_27.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC217" HREF="emacs_toc.html#TOC217">Команды для естественных языков</A></H1>
<P>
<A NAME="IDX1003"></A>
<A NAME="IDX1004"></A>


<P>
  Термин <EM>текст</EM> имеет два широко распространенных значения в нашей
области компьютерной науки.  Одно -- это данные, которые являются
последовательностью знаков.  Любой файл, который вы редактируете при
помощи Emacs, -- это текст в этом смысле слова.  Другое значение более
узкое: последовательность знаков на естественном языке, предназначенная
для чтения людьми (возможно после обработки форматированием), в
противоположность программам или командам для программы.


<P>
  В естественных языках приняты стилистические и синтаксические
условности, которые могут поддерживаться или выгодно использоваться
командами редактирования: это условности, включающие использование слов,
предложений, абзацев и прописных букв.  Данная глава описывает команды
Emacs для всех этих вещей.  Существуют также команды для
<EM>заполнения</EM>, что означает перестройку строк абзацев таким образом,
чтобы они были приблизительно равной длины.  Команды для перемещения или
уничтожения слов, предложений и абзацев, предназначенные в первую
очередь для редактирования текста, часто бывают полезными и для
редактирования программ.


<P>
  Emacs имеет несколько основных режимов для редактирования текста на
естественном языке.  Если файл содержит несложный чистый текст,
используйте режим Text, который быстро настраивает Emacs на
синтаксические условности текста.  Режим Outline предоставляет особые
команды для действий с со структурированным текстом.
See section <A HREF="emacs_26.html#SEC229">Режим Outline</A>.


<P>
  Для текста, который содержит встроенные команды для программ
форматирования, Emacs имеет другие основные режимы, свой для каждого
формата.  Таким образом, для ввода в TeX вы должны использовать режим
TeX (see section <A HREF="emacs_26.html#SEC234">Режим TeX</A>).
Для ввода в nroff -- режим Nroff.


<P>
  Вместо использования программы форматирования, вы можете редактировать
форматированный текст в стиле WYSIWYG ("what you see is what you
get")@transnote{Что вы видите, то и получаете.} с помощью режима
Enriched.  Тогда форматирование появляется на экране в Emacs во время
редактирования.
See section <A HREF="emacs_26.html#SEC239">Редактирование форматированного текста</A>.




<H2><A NAME="SEC218" HREF="emacs_toc.html#TOC218">Слова</A></H2>
<P>
<A NAME="IDX1005"></A>
<A NAME="IDX1006"></A>


<P>
  В Emacs существуют команды для передвижения по словам или воздействия
на них.  По соглашению, все ключи для этого являются Meta-знаками.


<DL COMPACT>

<DT><KBD>M-f</KBD>
<DD>
Перейти вперед через слово (<CODE>forward-word</CODE>).
<DT><KBD>M-b</KBD>
<DD>
Перейти назад через слово (<CODE>backward-word</CODE>).
<DT><KBD>M-d</KBD>
<DD>
Уничтожить вперед все вплоть до конца слова (<CODE>kill-word</CODE>).
<DT><KBD>M-<KBD>DEL</KBD></KBD>
<DD>
Уничтожить назад все вплоть до начала слова (<CODE>backward-kill-word</CODE>).
<DT><KBD>M-@</KBD>
<DD>
Пометить конец следующего слова (<CODE>mark-word</CODE>).
<DT><KBD>M-t</KBD>
<DD>
Переставить два слова или перенести одно слово через другие слова
(<CODE>transpose-words</CODE>).
</DL>

<P>
  Заметьте, как эти ключи образуют ряд, который соответствует ключам,
работающим со знаками: <KBD>C-f</KBD>, <KBD>C-b</KBD>, <KBD>C-d</KBD>, <KBD>DEL</KBD> и
<KBD>C-t</KBD>.  <KBD>M-@</KBD> соответствует <KBD>C-@</KBD>, которая иначе
называется <KBD>C-<KBD>SPC</KBD></KBD>.


<P>
<A NAME="IDX1007"></A>
<A NAME="IDX1008"></A>
<A NAME="IDX1009"></A>
<A NAME="IDX1010"></A>
  Команды <KBD>M-f</KBD> (<CODE>forward-word</CODE>) and <KBD>M-b</KBD>
(<CODE>backward-word</CODE>) передвигают вперед или назад через слова.  Таким
образом, эти Meta-знаки аналогичны <KBD>C-f</KBD> и <KBD>C-b</KBD>, которые
передвигают через одиночные знаки в тексте.  Аналогия распространяется
на числовые аргументя, которые служат счетчиками повторов.  <KBD>M-f</KBD> с
отрицательным аргументом передвигает назад, а <KBD>M-b</KBD> с отрицательным
аргументом передвигает вперед.  Движение вперед останавливается сразу
после последней буквы слова, тогда как движение назад останавливается
сразу перед первой буквой.


<P>
<A NAME="IDX1011"></A>
<A NAME="IDX1012"></A>
  <KBD>M-d</KBD> (<CODE>kill-word</CODE>) уничтожает слово после точки.  Точнее,
она уничтожает все от точки до того места, куда переместила бы команда
<KBD>M-f</KBD>.  Таким образом, если точка находится в середине слова,
<KBD>M-d</KBD> уничтожает только часть слова после точки.  Если между точкой
и следующим словом находятся какие-то знаки препинания, то они
уничтожаются вместе со словом.  (Если вы хотите уничтожить только
следующее слово, но не уничтожать знаки препинания перед ним, то просто
сделайте <KBD>M-f</KBD>, чтобы перейти на конец, и уничтожьте слово в
обратном направлении при помощи <KBD>M-<KBD>DEL</KBD></KBD>.)  <KBD>M-d</KBD> трактует
аргументы точно так же, как <KBD>M-f</KBD>.


<P>
<A NAME="IDX1013"></A>
<A NAME="IDX1014"></A>
  <KBD>M-<KBD>DEL</KBD></KBD> (<CODE>backward-kill-word</CODE>) уничтожает слово перед
точкой.  Она уничтожает все от точки назад к тому месту, куда
передвинула бы <KBD>M-b</KBD>.  Если точка находится после пробела в
<SAMP>`FOO, BAR'</SAMP>, то уничтожается <SAMP>`FOO, '</SAMP>.  (Если вы хотите
уничтожить просто <SAMP>`FOO'</SAMP>, сделайте <KBD>M-b M-d</KBD> вместо
<KBD>M-<KBD>DEL</KBD></KBD>.)


<P>
<A NAME="IDX1015"></A>
<A NAME="IDX1016"></A>
  <KBD>M-t</KBD> (<CODE>transpose-words</CODE>) меняет местами слово, стоящее перед
точкой или содержащее ее, со следующим словом.  Разграничительные
знаки между словами не сдвигаются.  Например, <SAMP>`FOO, BAR'</SAMP>
превращается в <SAMP>`BAR, FOO'</SAMP>, а не в <SAMP>`BAR FOO,'</SAMP>.  Для
более подробной информации о перестановках и аргументах команд
перестановки смотрите section <A HREF="emacs_18.html#SEC105">Перестановка текста</A>.


<P>
<A NAME="IDX1017"></A>
<A NAME="IDX1018"></A>
  Чтобы подействовать на следующие <VAR>n</VAR> слов с помощью операции,
которая применяется между точкой и меткой, вы можете либо установить
метку в точке и затем передвинуть точку через слова, либо использовать
команду <KBD>M-@</KBD> (<CODE>mark-word</CODE>), которая не перемещает точку, но
устанавливает метку туда, куда ее передвинула бы команда <KBD>M-f</KBD>.
<KBD>M-@</KBD> принимает числовой аргумент, который говорит, через сколько
слов нужно поместить метку.  В режиме Transient Mark эта команда
активизирует метку.


<P>
  Понятие о синтаксисе у команд, работающих со словами, полностью
управляется синтаксической таблицей.  Любой знак может быть объявлен,
например, как разделитель слов.  See section <A HREF="emacs_36.html#SEC469">Синтаксическая таблица</A>.




<H2><A NAME="SEC219" HREF="emacs_toc.html#TOC219">Предложения</A></H2>
<P>
<A NAME="IDX1019"></A>


<P>
  Команды Emacs для действий над предложениями и абзацами в большинстве
своем приданы Meta-ключам, чтобы они были подобны командам работы со
словами.


<DL COMPACT>

<DT><KBD>M-a</KBD>
<DD>
Перейти назад к началу предложения (<CODE>backward-sentence</CODE>).
<DT><KBD>M-e</KBD>
<DD>
Перейти вперед к концу предложения (<CODE>forward-sentence</CODE>).
<DT><KBD>M-k</KBD>
<DD>
Уничтожить вперед до конца предложения (<CODE>kill-sentence</CODE>).
<DT><KBD>C-x <KBD>DEL</KBD></KBD>
<DD>
Уничтожить все в обратном направлении до начала предложения
(<CODE>backward-kill-sentence</CODE>).
</DL>

<P>
<A NAME="IDX1020"></A>
<A NAME="IDX1021"></A>
<A NAME="IDX1022"></A>
<A NAME="IDX1023"></A>
  Команды <KBD>M-a</KBD> и <KBD>M-e</KBD> (<CODE>backward-sentence</CODE> и
<CODE>forward-sentence</CODE>) передвигают точку к началу и к концу текущего
предложения, соответственно.  Они выбраны так, чтобы напоминать
<KBD>C-a</KBD> и <KBD>C-e</KBD>, которые сдвигают к концу и началу строки.  В
отличие от них, <KBD>M-a</KBD> и <KBD>M-e</KBD> при повторении или с заданными
числовыми аргументами передвигают через последовательные предложения.


<P>
  Перемещение назад через предложение помещает точку непосредственно
перед первым знаком этого предложения; перемещение вперед помещает
точку сразу после знака препинания, завершающего предложение.  Ни одна
из этих команд не перемещает через пропуски на границах предложений.


<P>
<A NAME="IDX1024"></A>
<A NAME="IDX1025"></A>
<A NAME="IDX1026"></A>
<A NAME="IDX1027"></A>
  Точно так же, как <KBD>C-a</KBD> и <KBD>C-e</KBD> имеют соответствующую им
команду уничтожения <KBD>C-k</KBD>, так и <KBD>M-a</KBD> и <KBD>M-e</KBD> имеют
соответствующую команду уничтожения <KBD>M-k</KBD> (<CODE>kill-sentence</CODE>),
которая уничтожает все от точки до конца предложения.  С аргументом,
равным минус единице, она уничтожает в обратном направлении до начала
предложения.  Большие аргументы служат для подсчета повторов.  Есть
также особая команда <KBD>C-x <KBD>DEL</KBD></KBD> (<CODE>backward-kill-sentence</CODE>)
для уничтожения в обратном направлении к началу предложения.  Она
удобна, когда вы меняете свое решение в процессе сочинения текста.


<P>
  Команды работы с предложениями предполагают, что вы следуете
соглашению американских машинисток -- ставить в конце предложения два
пробела; они считают предложение оконченным, если там есть знаки
<SAMP>`.'</SAMP>, <SAMP>`?'</SAMP> или <SAMP>`!'</SAMP>, за которыми следует конец строки или
два пробела; в середине допустимо любое число знаков <SAMP>`)'</SAMP>, <SAMP>`]'</SAMP>
или <SAMP>`"'</SAMP>.  Предложение также начинается или кончается, если
начинается или кончается абзац.


<P>
<A NAME="IDX1028"></A>
  Переменная <CODE>sentence-end</CODE> управляет распознаванием конца
предложения.  Это регулярное выражение, которое соответствует последним
нескольким знакам предложения вместе с пробелами, следующими за
предложением.  Его нормальное значение таково:



<PRE>
"[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"
</PRE>

<P>
Этот пример объясняется в разделе о регулярных выражениях.
See section <A HREF="emacs_17.html#SEC95">Синтаксис регулярных выражений</A>.


<P>
  Если вы хотите использовать между предложениями только один пробел,
вам нужно установить <CODE>sentence-end</CODE> в такое значение:



<PRE>
"[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*"
</PRE>

<P>
Вам нужно также установить переменную <CODE>sentence-end-double-space</CODE>
равной <CODE>nil</CODE>, чтобы команды заполнения ожидали и оставляли в конце
предложений только один пробел.  Заметьте, что при этом невозможно
отличить точки, завершающие предложения, и точек в сокращениях.




<H2><A NAME="SEC220" HREF="emacs_toc.html#TOC220">Абзацы</A></H2>
<P>
<A NAME="IDX1029"></A>
<A NAME="IDX1030"></A>
<A NAME="IDX1031"></A>
<A NAME="IDX1032"></A>
<A NAME="IDX1033"></A>


<P>
  Команды Emacs для работы с абзацами -- это также Meta-ключи.


<DL COMPACT>

<DT><KBD>M-{</KBD>
<DD>
Перейти назад к началу предыдущего абзаца (<CODE>backward-paragraph</CODE>).
<DT><KBD>M-}</KBD>
<DD>
Переместиться вперед к концу следующего абзаца (<CODE>forward-paragraph</CODE>).
<DT><KBD>M-h</KBD>
<DD>
Поставить точку и метку вокруг этого или следующего абзаца
(<CODE>mark-paragraph</CODE>).
</DL>

<P>
  <KBD>M-{</KBD> двигает точку в начало текущего или предыдущего абзаца, в
то время как <KBD>M-}</KBD> двигает ее к концу текущего или следующего
абзаца.  Абзацы разделяются пустыми строками и строками команд
форматирования текста, которые в свою очередь не являются частью
какого-либо абзаца.  В режиме Fundamental, но не в режиме Text, строка с
отступом также начинает новый абзац.  (Если перед абзацем стоит пустая
строка, данные команды считают эту пустую строку началом абзаца.)


<P>
  В основных режимах для программ, абзацы начинаются и кончаются только
пустыми строками.  Это делает команды для абзацев по-прежнему удобными,
даже хотя абзацев как таковых нет.


<P>
  Когда имеется префикс заполнения, абзацы ограничиваются всеми
строками, которые не начинаются с этого префикса.  See section <A HREF="emacs_26.html#SEC222">Заполнение текста</A>.


<P>
<A NAME="IDX1034"></A>
<A NAME="IDX1035"></A>
  Когда вы захотите оперировать с абзацем, вы можете использовать
команду <KBD>M-h</KBD> (<CODE>mark-paragraph</CODE>), чтобы установить вокруг него
область.  Таким образом, например, <KBD>M-h C-w</KBD> уничтожает абзац вокруг
или после точки.  Команда <KBD>M-h</KBD> ставит точку в начале абзаца,
содержащего точку, и метку в его конце.  В режиме Transient Mark она
активизирует метку.  Если точка находится между абзацами (в области
пустых строк или на границе), то точкой и меткой окружается абзац,
следующий за точкой.  Если первой строке абзаца предшествуют пустые
строки, то одна из этих пустых строк включается в область.


<P>
<A NAME="IDX1036"></A>
<A NAME="IDX1037"></A>
  Точным определением границ абзаца управляют две переменные:
<CODE>paragraph-separate</CODE> и <CODE>paragraph-start</CODE>.  Значение
<CODE>paragraph-start</CODE> -- это регулярное выражение, которое должно
соответствовать любой строке, которая либо начинает, либо разделяет
абзацы.  Значение <CODE>paragraph-separate</CODE> -- это еще одно регулярное
выражение, которое должно соответствовать только строкам, которые
разделяют абзац, но не являются частью какого-либо абзаца (например,
пустые строки).  Строки, которые начинают новый абзац и содержатся в
нем, должны соответствовать только <CODE>paragraph-start</CODE>, но не
<CODE>paragraph-separate</CODE>.  Например, в режиме Fundamental,
<CODE>paragraph-start</CODE> равна <CODE>"[ <TT>\</TT>t<TT>\</TT>n<TT>\</TT>f]"</CODE>, а
<CODE>paragraph-separate</CODE> -- это <CODE>"[ <TT>\</TT>t<TT>\</TT>f]*$"</CODE>.


<P>
  Обычно желательно, чтобы границы страниц разделяли абзацы.  Значения
по умолчанию этих переменных распознают обычный разделитель страниц.




<H2><A NAME="SEC221" HREF="emacs_toc.html#TOC221">Страницы</A></H2>

<P>
<A NAME="IDX1038"></A>
<A NAME="IDX1039"></A>
  Очень часто файлы представляются разделенными на <EM>страницы</EM> с
помощью знаков <EM>прогона (или перевода) страницы</EM> (ASCII
Control-L, восьмиричный код 014).  Когда вы печатаете файл, этот знак
принудительно разбивает страницу; таким образом, каждая страница файла
будет начинаться на новом листе бумаги.  Большинство команд Emacs
рассматривают знак-разделитель страниц точно так же, как любые другие
знаки: вы можете вставить их при помощи <KBD>C-q C-l</KBD> или удалить с
помощью <KBD>DEL</KBD>.  Таким образом, вы свободны в выборе, делить на
страницы ваш файл или нет.  Однако, из-за того, что деление на страницы
часто является смысловым делением файла, то предусмотрены команды для
перемещения по страницам и для действий над ними.


<DL COMPACT>

<DT><KBD>C-x [</KBD>
<DD>
Сместить точку к предыдущей странице (<CODE>backward-page</CODE>).
<DT><KBD>C-x ]</KBD>
<DD>
Сместить точку к следующей странице (<CODE>forward-page</CODE>).
<DT><KBD>C-x C-p</KBD>
<DD>
Поставить точку и метку по краям этой (или другой) страницы
(<CODE>mark-page</CODE>).
<DT><KBD>C-x l</KBD>
<DD>
Сосчитать строки в этой странице (<CODE>count-lines-page</CODE>).
</DL>

<P>
<A NAME="IDX1040"></A>
<A NAME="IDX1041"></A>
<A NAME="IDX1042"></A>
<A NAME="IDX1043"></A>
  Команда <KBD>C-x [</KBD> (<CODE>backward-page</CODE>) двигает точку к позиции
непосредственно после предыдущего разделителя страницы.  Если точка уже
находится сразу после разделителя, то команда пропускает эту страницу и
останавливается на предшествующей ей.  Числовой аргумент служит в
качестве счетчика повторов.  Команда <KBD>C-x ]</KBD> (<CODE>forward-page</CODE>)
передвигает точку вперед, пропуская следующий разделитель страниц.


<P>
<A NAME="IDX1044"></A>
<A NAME="IDX1045"></A>
  Команда <KBD>C-x C-p</KBD> (<CODE>mark-page</CODE>) ставит точку в начале текущей
страницы, а метку в ее конце.  Разделитель страниц в конце включается в
область (метка следует за ним).  Разделитель страниц в начале не
включается (точка следует за ним).  <KBD>C-x C-p C-w</KBD> дает удобный
способ уничтожить страницу или переместить ее в другое место.  Если вы
сдвинитесь к разделителю еще одной страницы с помощью <KBD>C-x [</KBD> и
<KBD>C-x ]</KBD>, а затем восстановите уничтоженную страницу, все страницы
будут снова правильно разграничины.  <KBD>C-x C-p</KBD> включает в область
только разделитель следующей страницы именно для этого.


<P>
  Числовой аргумент для <KBD>C-x C-p</KBD> используется для указания
страницы, к которой необходимо отправиться, относительно текущей.  Ноль
означает текущую страницу.  Единица означает следующую страницу, а
-1 -- предыдущую.


<P>
<A NAME="IDX1046"></A>
<A NAME="IDX1047"></A>
  Команда <KBD>C-x l</KBD> (<CODE>count-lines-page</CODE>) хороша для принятия
решения, где разорвать страницу на две.  Она печатает в эхо-области
общее число строк в текущей странице и затем делит ее на те, которые
предшествуют текущей строке, и на те, что следуют за ней, как в примере:



<PRE>
Page has 96 (72+25) lines@transnote{Страница содержит 96 (72+25) строк.}
</PRE>

<P>
Заметьте, что значение суммы на единицу меньше; это верно, если точка не
стоит в начале строки.


<P>
<A NAME="IDX1048"></A>
  Переменная <CODE>page-delimiter</CODE> говорит, где начинается страница.  Ее
значение -- это регулярное выражение, соответствующее началу строки,
которая разделяет страницы.  Обычное значение этой переменной равно
<CODE>"^<TT>\</TT>f"</CODE>, что соответствует знаку перевода страницы в начале
строки.




<H2><A NAME="SEC222" HREF="emacs_toc.html#TOC222">Заполнение текста</A></H2>
<P>
<A NAME="IDX1049"></A>


<P>
  <EM>Заполнение</EM> текста означает разбиение его на строки определенной
длины.  Emacs может делать заполнение двумя способами.  В режиме Auto
Fill, вставка текста с помощью самовставляющихся знаков также
автоматически заполняет его.  Есть также явные команды для заполнения,
которые вы можете использовать, когда редактирование текста оставляет
его незаполненным.  Когда вы редактируете форматированный текст, вы
можете задать стиль заполнения каждого фрагмента (see section <A HREF="emacs_26.html#SEC239">Редактирование форматированного текста</A>).




<H3><A NAME="SEC223" HREF="emacs_toc.html#TOC223">Режим Auto Fill</A></H3>
<P>
<A NAME="IDX1050"></A>
<A NAME="IDX1051"></A>
<A NAME="IDX1052"></A>


<P>
  Режим <EM>Auto Fill</EM> -- это второстепенный режим, в котором строки
обрываются автоматически, когда становятся слишком длинными.  Разрыв
происходит только тогда, когда вы набираете <KBD>SPC</KBD> или <KBD>RET</KBD>.


<DL COMPACT>

<DT><KBD>M-x auto-fill-mode</KBD>
<DD>
Включение и выключение режима Auto Fill.
<DT><KBD><KBD>SPC</KBD></KBD>
<DD>
<DT><KBD><KBD>RET</KBD></KBD>
<DD>
В режиме Auto Fill прерывает строку, если это нужно.
</DL>

<P>
<A NAME="IDX1053"></A>
  <KBD>M-x auto-fill-mode</KBD> включает режим Auto Fill, если он был
отключен, или выключает, если он был включен.  С положительным
аргументом она всегда включает режим Auto Fill, а отрицательным ---
всегда отключает.  Вы можете видеть, когда режим Auto Fill действует, по
присутствию слова <SAMP>`Fill'</SAMP> в строке режима внутри круглых скобок.
Режим Auto Fill -- второстепенный режим, включаемый или выключаемый для
каждого буфера отдельно.  See section <A HREF="emacs_36.html#SEC441">Второстепенные режимы</A>.


<P>
  В режиме Auto Fill строки автоматически разрываются на пробелах, когда
они становятся длиннее желаемой величины.  Прерывание и перерасположение
строки происходит, только когда вы набираете <KBD>SPC</KBD> или <KBD>RET</KBD>.
Если вы хотите вставить пробел или знак новой строки с запретом
прерывания строки, наберите <KBD>C-q <KBD>SPC</KBD></KBD> или <KBD>C-q C-j</KBD>
(напомним, что знак новой строки -- это на самом деле control-J).
<KBD>C-o</KBD> также вставляет новую строку без прерывания строки.


<P>
  Режим Auto Fill хорошо работает с режимами для языков
программирования, так как он делает в новых строках отступ с помощью
<KBD>TAB</KBD>.  Если строка, заканчивающаяся комментарием, получилась
слишком длинной, то текст комментария разбивается на две строки.
Возможно, в конце первой строки и в начале второй вставятся новые
ограничители комментариев, таким образом, чтобы каждая строка стала
отдельным комментарием; этим выбором управляет переменная
<CODE>comment-multi-line</CODE> (see section <A HREF="emacs_27.html#SEC267">Управление комментариями</A>).


<P>
  Адаптивное заполнение (смотрите следующий раздел) работает с режимом
Auto Fill так же, как с явными командами заполнения.  Оно автоматически
берет префикс заполнения из второй или первой строки абзаца.


<P>
  Режим Auto Fill не перезаполняет целые абзацы; он может прерывать
строки, но не может их объединять.  Таким образом, редактирование в
середине абзаца может привести к созданию абзаца, который неправильно
заполнен.  Простейшим способом сделать абзац снова правильно заполненным
обычно служит применение явных команды заполнения.


<P>
  Многие пользователи любят режим Auto Fill и хотят использовать его во
всех текстовых файлах.  Раздел о файлах инициализации рассказывает, как
устроить, чтобы это было для вас постоянным.  See section <A HREF="emacs_36.html#SEC470">Файл инициализации, <TT>`~/.emacs'</TT></A>.




<H3><A NAME="SEC224" HREF="emacs_toc.html#TOC224">Явные команды заполнения</A></H3>

<DL COMPACT>

<DT><KBD>M-q</KBD>
<DD>
Заполнить текущий абзац (<CODE>fill-paragraph</CODE>).
<DT><KBD>C-x f</KBD>
<DD>
Установить столбец заполнения (<CODE>set-fill-column</CODE>).
<DT><KBD>M-x fill-region</KBD>
<DD>
Заполнить каждый абзац в области (<CODE>fill-region</CODE>).
<DT><KBD>M-x fill-region-as-paragraph</KBD>
<DD>
Заполнить область, рассматривая ее как один абзац.
<DT><KBD>M-s</KBD>
<DD>
Отцентрировать строку.
</DL>

<P>
<A NAME="IDX1054"></A>
<A NAME="IDX1055"></A>
  Чтобы перезаполнить один абзац, используйте команду <KBD>M-q</KBD>
(<CODE>fill-paragraph</CODE>).  Она действует на абзац, в котором находится
точка, или на абзац после точки, если она стоит между абзацами.
Перезаполнение работает путем удаления всех разрывов строк и вставки
новых в тех местах, где это требуется.


<P>
<A NAME="IDX1056"></A>
  Чтобы перезаполнить много абзацев, используйте <KBD>M-x fill-region</KBD>,
которая делит область на абзацы и заполняет каждый из них.


<P>
<A NAME="IDX1057"></A>
  Команды <KBD>M-q</KBD> и <CODE>fill-region</CODE> используют для нахождения
границ абзаца тот же самый критерий, что и <KBD>M-h</KBD> (see section <A HREF="emacs_26.html#SEC220">Абзацы</A>).
Для большего контроля, вы можете использовать <KBD>M-x
fill-region-as-paragraph</KBD>, которая перезаполняет все между точкой и
меткой.  Эта команда удаляет в области все пустые строки, поэтому
отдельные блоки текста в результате объединяются в один блок.


<P>
<A NAME="IDX1058"></A>
  Числовой аргумент для <KBD>M-q</KBD> приводит к тому, что помимо
заполнения, текст еще и <EM>выравнивается</EM>.  Это значит, что
вставляются дополнительные пробелы, чтобы правый край строки попадал
точно в столбец заполнения.  Чтобы уничтожить дополнительные пробелы,
используйте <KBD>M-q</KBD> без аргумента.  (Аналогично и для
<CODE>fill-region</CODE>.)  Другой способ управлять выравниванием или выбрать
другие стили заполнения состоит в применении свойства текста
<CODE>justification</CODE>; смотрите section <A HREF="emacs_26.html#SEC246">Выравнивание в форматированном тексте</A>.


<P>
<A NAME="IDX1059"></A>
<A NAME="IDX1060"></A>
<A NAME="IDX1061"></A>
  Команда <KBD>M-s</KBD> (<CODE>center-line</CODE>) центрирует текущую строку в
пределах текущего столбца заполнения.  С аргументом <VAR>n</VAR>, она
центрирует несколько строк отдельно и переходит через них.


<P>
<A NAME="IDX1062"></A>
<A NAME="IDX1063"></A>
<A NAME="IDX1064"></A>
  Максимальная ширина строки для заполнения содержится в переменной
<CODE>fill-column</CODE>.  Изменение значения <CODE>fill-column</CODE> делает ее
локальной для текущего буфера; до этого момента действует значение по
умолчанию.  Изначально оно равно 70.  See section <A HREF="emacs_36.html#SEC450">Локальные переменные</A>.
Наилегчайший способ установить <CODE>fill-column</CODE> -- использовать
команду <KBD>C-x f</KBD> (<CODE>set-fill-column</CODE>).  Запущенная с числовым
аргументом, она использует его в качестве нового столбца заполнения.
Просто с <KBD>C-u</KBD> в качестве аргумента, она устанавливает
<CODE>fill-column</CODE> соответственно текущей горизонтальной позиции точки.


<P>
  Команды Emacs обычно рассматривают точку, за которой следуют два
пробела или перевод строки, как конец предложения; точка, после которой
идет только один пробел, указывает на сокращение и не является концом
предложения.  Чтобы сохранить разграничение между двумя этими вариантами
использования точки, команды заполнения не обрывают строку после точки,
за которой идет только один пробел.


<P>
<A NAME="IDX1065"></A>
  Если переменная <CODE>sentence-end-double-space</CODE> равна <CODE>nil</CODE>, то
команды заполнения ожидают и оставляют в конце предложений только один
пробел.  Обычно эта переменная равна <CODE>t</CODE>, поэтому команды
заполнения настаивают на постановке двух пробелах в конце предложения,
как объяснено выше.  See section <A HREF="emacs_26.html#SEC219">Предложения</A>.


<P>
<A NAME="IDX1066"></A>
  Если переменная <CODE>colon-double-space</CODE> не равна <CODE>nil</CODE>, команды
заполнения ставят после двоеточия два пробела.




<H3><A NAME="SEC225" HREF="emacs_toc.html#TOC225">Префикс заполнения</A></H3>

<P>
<A NAME="IDX1067"></A>
  Чтобы заполнить абзац, в котором каждая строка начинается с особого
маркера (который может несколькими пробелами, что дает абзац с
отступом), используйте так называемый <EM>префикс заполнения</EM>.  Префикс
заполнения -- это цепочка знаков, с которой, по предположению Emacs,
начинается каждая строка, и которая не включается в заполнение.  Вы
можете задать префикс заполнения явно; кроме того, Emacs может вычислять
его автоматически (see section <A HREF="emacs_26.html#SEC226">Адаптивное заполнение</A>).


<DL COMPACT>

<DT><KBD>C-x .</KBD>
<DD>
Установить префикс заполнения (<CODE>set-fill-prefix</CODE>).
<DT><KBD>M-q</KBD>
<DD>
Заполнить абзац с текущим префиксом заполнения (<CODE>fill-paragraph</CODE>).
<DT><KBD>M-x fill-individual-paragraphs</KBD>
<DD>
Заполнить область, рассматривая каждое изменение отступа как начало
нового абзаца.
<DT><KBD>M-x fill-nonuniform-paragraphs</KBD>
<DD>
Заполнить область, считая началом нового абзаца только
строки-разделители абзацев.
</DL>

<P>
<A NAME="IDX1068"></A>
<A NAME="IDX1069"></A>
  Чтобы задать префикс заполнения, передвиньтесь к строке, которая
начинается с желаемого префикса, поставьте точку в конец префикса и
дайте команду <KBD>C-x .</KBD> (<CODE>set-fill-prefix</CODE>).  После
<KBD>C-x</KBD> стоит точка.  Чтобы выключить префикс заполнения, определите
пустой префикс: наберите <KBD>C-x .</KBD>, когда точка находится в
начале строки.


<P>
  Когда префикс заполнения в действии, команды заполнения уничтожают его
в каждой строке перед заполнением и вставляют его в каждую строку после
заполнения.  Режим Auto Fill также автоматически вставляет в каждую
вновь созданную строку префикс заполнения.  Команда <KBD>C-o</KBD> вставляет
в созданные ей строки префикс заполнения, когда вы используете ее в
начале строки (see section <A HREF="emacs_9.html#SEC31">Пустые строки</A>).  С другой стороны, команда
<KBD>M-^</KBD> уничтожает префикс (если он есть) после удаляемого перевода
строки (see section <A HREF="emacs_25.html#SEC213">Отступы</A>).


<P>
  Например, если <CODE>fill-column</CODE> равна 40 и вы установили префикс
заполнения равным <SAMP>`;; '</SAMP>, то <KBD>M-q</KBD> в таком тексте:



<PRE>
;; Это пример
;; абзаца внутри
;; комментария в стиле Лиспа.
</PRE>

<P>
дает следующее:



<PRE>
;; Это пример абзаца внутри комментария
;; в стиле Лиспа.
</PRE>

<P>
  Строки, не начинающиеся с префикса заполнения, рассматриваются как
начинающие абзац и в <KBD>M-q</KBD>, и в командах работы с абзацами; это дает
хорошие результаты для абзацев с висящим отступом (все строки, кроме
первой, имеют отступ).  Строки, ставшие пустыми или имеющими отступ
после удаления префикса, также разделяют или начинают абзац; это именно
то, что вы хотите, если вы пишете комментарии, состоящие из нескольких
абзацев, с ограничителем комментария на каждой строке.


<P>
<A NAME="IDX1070"></A>
  Вы можете использовать <KBD>M-x fill-individual-paragraphs</KBD>, чтобы
установить префикс заполнения для каждого абзаца автоматически.  Эта
команда делит область на абзацы, считая любое изменение величины отступа
началом нового абзаца, и заполняет каждый из этих абзацев.  Таким
образом, все строки одного "абзаца" имеют одинаковый отступ.  Именно
этот отступ служит префиксом заполнения для каждого абзаца.


<P>
<A NAME="IDX1071"></A>
  <KBD>M-x fill-nonuniform-paragraphs</KBD> -- это похожая команда, которя
делит область на абзацы другим способом.  Она рассматривает только
строки-разделители абзацев (как определено <CODE>paragraph-separate</CODE>) в
качестве начинающих новый абзац.  Поскольку это означает, что строки
одного абзаца могут иметь разный отступ, в качестве префикса заполнения
используется отступ наименьшего среди всех строк этого абзаца размера.
Это дает хорошие результаты для стилей, в которых первая строка абзаца
имеет больший или меньший отступ, чем остальная часть абзаца.


<P>
<A NAME="IDX1072"></A>
  Префикс заполнения хранится в переменной <CODE>fill-prefix</CODE>.  Ее
значение -- это либо строка, либо <CODE>nil</CODE>, когда префикса заполнения
нет.  В каждом буфере для этой переменной есть свое значение; ее
изменение воздействует только на текущий буфер, но имеется и значение по
умолчанию, которое вы также можете изменить.  See section <A HREF="emacs_36.html#SEC450">Локальные переменные</A>.


<P>
  Свойство текста <CODE>indentation</CODE> предоставляет другой способ
управления величиной отступа абзаца.  See section <A HREF="emacs_26.html#SEC245">Отступы в форматированном тексте</A>.




<H3><A NAME="SEC226" HREF="emacs_toc.html#TOC226">Адаптивное заполнение</A></H3>

<P>
<A NAME="IDX1073"></A>
  Команды заполнения могут в некоторых случаях автоматически вычислять
подходящий для абзаца префикс заполнения: пропуски или определенная
пунктуация в начале строки распространяются на все строки абзаца.


<P>
  Если в абзаце есть две или более строки, префикс заполнения берется из
второй, но только если он также появляется и в первой.


<P>
  Если в абзаце есть только одна строка, команды заполнения <EM>могут</EM>
взять префикс из этой строки.  Здесь сложно принять решение, потому что
в таком случае разумными могут оказаться три варианта:



<UL>
<LI>

Использовать префикс первой строки для всех строк этого абзаца.

<LI>

Сделать в последующих строках отступ из пропусков таким образом, чтобы
они выровнялись по тексту, следующему после префикса на первой, но не
копировать в действительности префикс первой строки.

<LI>

Не предпринимать никаких особенных действий для второй и последующих
строк.
</UL>

<P>
  Все три этих стиля форматирования применяются часто.  Поэтому команды
заполнения пятаются выяснить, какой бы вам понравился, основываясь на
появляющемся префиксе и на основном режиме.  Как это делается, описано
ниже.


<P>
<A NAME="IDX1074"></A>
  Если префикс, обнаруженный на первой строке, соответствует регулярному
выражению <CODE>adaptive-fill-first-line-regexp</CODE>, или он оказался
последовательностью, начинающей комментарий (это зависит от основнего
режима), то для заполнения абзаца используется этот найденный префикс,
при условии, что он не будет действовать как начало абзаца в следующих
строках.


<P>
  Иначе, найденный префикс преобразуется в эквивалентное число пробелов,
и в качестве префикса заполнения для оставшихся строк используются эти
пробелы, при условии, что они не будут действовать как начало абзаца в
следующих строках.


<P>
  В режиме Text и в других режимах, где абзацы разделяются только
пустыми строками и переводами страницы, префикс, выбираемый адаптивным
заполнением, никогда не ведет себя как начало абзаца, поэтому он всегда
может использоваться для заполнения.


<P>
<A NAME="IDX1075"></A>
<A NAME="IDX1076"></A>
  Переменная <CODE>adaptive-fill-regexp</CODE> определяет, какие виды начала
строки могут служить префиксом заполнения: используются любые знаки в
начале строки, соответствующие этому регулярному выражению.  Если вы
установите переменную <CODE>adaptive-fill-mode</CODE> равной <CODE>nil</CODE>,
префикс заполнения никогда не выбирается автоматически.


<P>
<A NAME="IDX1077"></A>
  Вы можете задать более сложные методы автоматического выбора префикса
заполнения, установив переменную <CODE>adaptive-fill-function</CODE> в
значение функции.  Эта функция вызывается, когда точка находится с
левого края строки, и она должна вернуть подходящий префикс заполнения.
Если она возвращет <CODE>nil</CODE>, это означает, что она не увидела в этой
строке префикс заполнения.




<H2><A NAME="SEC227" HREF="emacs_toc.html#TOC227">Команды преобразования регистра</A></H2>
<P>
<A NAME="IDX1078"></A>
<A NAME="IDX1079"></A>


<P>
  В Emacs есть команды для перевода одиночных слов или любого
произвольного текста в верхний или в нижний регистр.


<DL COMPACT>

<DT><KBD>M-l</KBD>
<DD>
Перевести следующее слово в нижний регистр (<CODE>downcase-word</CODE>).
<DT><KBD>M-u</KBD>
<DD>
Перевести следующее слово в верхний регистр (<CODE>upcase-word</CODE>).
<DT><KBD>M-c</KBD>
<DD>
Сделать первую букву следующего слова заглавной, а остальные ---
строчными (<CODE>capitalize-word</CODE>).
<DT><KBD>C-x C-l</KBD>
<DD>
Перевести область в нижний регистр (<CODE>downcase-region</CODE>).
<DT><KBD>C-x C-u</KBD>
<DD>
Перевести область в верхний регистр (<CODE>upcase-region</CODE>).
</DL>

<P>
<A NAME="IDX1080"></A>
<A NAME="IDX1081"></A>
<A NAME="IDX1082"></A>
<A NAME="IDX1083"></A>
<A NAME="IDX1084"></A>
<A NAME="IDX1085"></A>
<A NAME="IDX1086"></A>
<A NAME="IDX1087"></A>
<A NAME="IDX1088"></A>
  Команды преобразования слов наиболее полезны.  <KBD>M-l</KBD>
(<CODE>downcase-word</CODE>) переводит слово после точки в нижний регистр,
передвигая точку за него.  Таким образом, повторение <KBD>M-l</KBD> переводит
последующие слова.  <KBD>M-u</KBD> (<CODE>upcase-word</CODE>) переводит все слово в
прописные буквы, в то время как <KBD>M-c</KBD> (<CODE>capitalize-word</CODE>)
ставит первую букву слова в верхнем регистре, а остальные -- в нижнем
регистре.  Все эти команды переводят несколько слов за один раз, если им
придать аргумент.  Они особенно удобны для перевода большого объема
текста, набранного полностью в верхнем регистре, в смешанный регистр,
потому что вы можете двигаться по тексту, используя <KBD>M-l</KBD>, <KBD>M-u</KBD>
или <KBD>M-c</KBD>, когда это необходимо, и используя иногда <KBD>M-f</KBD>, чтобы
пропустить слово.


<P>
  Когда задан отрицательный аргумент, команды перевода регистра в словах
применяются к соответствующему числу слов перед точкой, не сдвигая ее
саму.  Это удобно, когда вы только что набрали слово в неправильном
регистре: вы можете дать команду перевода регистра и продолжать набор.


<P>
  Если команда перевода регистра в словах дается в середине слова, то
она применяется только к части слова, которая следует за точкой.  Это
очень похоже на то, что делает <KBD>M-d</KBD> (<CODE>kill-word</CODE>).  С
отрицательным аргументом, перевод регистра применяется только к части
слова перед точкой.


<P>
<A NAME="IDX1089"></A>
<A NAME="IDX1090"></A>
<A NAME="IDX1091"></A>
<A NAME="IDX1092"></A>
  Другие команды перевода регистра -- это <KBD>C-x C-u</KBD>
(<CODE>upcase-region</CODE>) и <KBD>C-x C-l</KBD> (<CODE>downcase-region</CODE>), которые
переводят все между точкой и меткой в заданный регистр.  Точка и метка
не сдвигаются.


<P>
  Команды перевода регистра в области, <CODE>upcase-region</CODE> и
<CODE>downcase-region</CODE>, обычно заблокированы.  Это означает, что они
запрашивают подтверждение, если вы пытаетесь их использовать.  При
подтверждении вы можете включить эти команды, тогда они больше не будут
запрашивать подтверждения.  See section <A HREF="emacs_36.html#SEC467">Блокирование команд</A>.




<H2><A NAME="SEC228" HREF="emacs_toc.html#TOC228">Режим Text</A></H2>
<P>
<A NAME="IDX1093"></A>
<A NAME="IDX1094"></A>
<A NAME="IDX1095"></A>


<P>
  Когда вы редактируете текстовые файлов на естественном языке, вам
будет удобнее воспользоваться режимом Text, а не Fundamental.  Чтобы
войти в режим Text, наберите <KBD>M-x text-mode</KBD>.


<P>
  В режиме Text абзацы разделяются только пустыми строками и
разделителями страниц.  В результате абзацы могут иметь отступ, и
адаптивное заполнение может определить, какой отступ должен
использоваться для заполнения абзаца.  See section <A HREF="emacs_26.html#SEC226">Адаптивное заполнение</A>.


<P>
<A NAME="IDX1096"></A>
  В режиме Text <KBD>TAB</KBD> запускает функцию <CODE>indent-relative</CODE>
(see section <A HREF="emacs_25.html#SEC213">Отступы</A>), чтобы вам было удобно делать отступ как в предыдущей
строке.  Когда в предыдущей строке нет отступа, <CODE>indent-relative</CODE>
запускает <CODE>tab-to-tab-stop</CODE>, которая использует устанавливаемые
вами позиции табуляции (see section <A HREF="emacs_25.html#SEC215">Позиции табуляции</A>).


<P>
  Режим Text выключает средства, связанные с комментариями, кроме тех
случаев, когда вы явно вызовете их.  Он изменяет синтаксическую таблицу
таким образом, что точки не рассматриваются как часть слова, тогда как
знак забоя, подчеркивание и апострофы считаются таковыми.


<P>
<A NAME="IDX1097"></A>
<A NAME="IDX1098"></A>
<A NAME="IDX1099"></A>
  Если вы делаете отступ в первой строке абзаца, вам нужно использовать
режим Paragraph-Indent Text вместо режима Text.  В этом режиме вам не
обязательно ставить между абзацами пустые строки, потому что отступа в
первой строке достаточно для начала нового абзаца; однако, абзацы, в
которых каждая строка имеет отступ, не поддерживаются.  Чтобы войти в
этот режим, используйте <KBD>M-x paragraph-indent-text-mode</KBD>.


<P>
<A NAME="IDX1100"></A>
  Режим Text и все режимы, основанные на нем, определяют
<KBD>M-<KBD>TAB</KBD></KBD> как команду <CODE>ispell-complete-word</CODE>, которая
производит завершение части слова перед точкой в данном буфере,
используя орфографический словарь как пространство возможных слов.
See section <A HREF="emacs_18.html#SEC107">Поиск и исправление орфографических ошибок</A>.


<P>
<A NAME="IDX1101"></A>
  Вход в режим Text запускает ловушку <CODE>text-mode-hook</CODE>.  Другие
основные режимы, родственные с режимом Text, также запускают эту ловушку
и потом свои ловушки; к ним относятся режим Paragraph-Indent Text, режим
Nroff, режим TeX, режим Outline и режим Mail.  Функции ловушки
<CODE>text-mode-hook</CODE> могут проверить значение <CODE>major-mode</CODE>, чтобы
узнать, в какой из этих режимов вы на самом деле входите.
See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.




<H2><A NAME="SEC229" HREF="emacs_toc.html#TOC229">Режим Outline</A></H2>
<P>
<A NAME="IDX1102"></A>
<A NAME="IDX1103"></A>
<A NAME="IDX1104"></A>
<A NAME="IDX1105"></A>


<P>
<A NAME="IDX1106"></A>
<A NAME="IDX1107"></A>
<A NAME="IDX1108"></A>
  Режим Outline -- это основной режим, очень похожий на режим Text, но
предназначенный для редактирования структурированного текста.  Он
позволяет вам делать части текста временно невидимыми, так что вы можете
видеть просто просмотреть структуру текста.  Наберите <KBD>M-x
outline-mode</KBD>, чтобы включить режим Outline в текущем буфере.


<P>
  Когда режим Outline делает строку невидимой, эта строка не появляется
на экране.  Экран имеет точно такой же вид, как если бы невидимая строка
была удалена, за исключением того, что в конце предыдущей видимой строки
появляется многоточие (только одно, независимо от того, сколько
невидимых строк следует дальше).


<P>
  Команды редактирования, работающие со строками, такие как <KBD>C-n</KBD> и
<KBD>C-p</KBD>, трактуют текст невидимой строки как часть предыдущей видимой.
Уничтожение полной видимой строки, включая ограничивающий ее знак
новой строки, на самом деле уничтожает вместе с ней все следующие
невидимые строки.


<P>
  Второстепенный режим Outline предоставляет те же команды, что и
основной режим Outline, но вы можете использовать его совместно с
другими основными режимами.  Чтобы включить второстепенный режим Outline
в текущем буфере, наберите <KBD>M-x outline-minor-mode</KBD>.  Вы также
можете указать это в тексте файла с помощью локальной переменной в форме
<SAMP>`mode: outline-minor'</SAMP> (see section <A HREF="emacs_36.html#SEC451">Локальные переменные в файлах</A>).


<P>
<A NAME="IDX1109"></A>
  Основной режим, режим Outline, предоставляет особые привязки ключей на
префиксе <KBD>C-c</KBD>.  Второстепенный режим Outline предоставляет похожие
привязки с <KBD>C-c @</KBD> в качестве префикса; это нужно, чтобы уменьшить
риск конфликта со специальными командами основного режима.
(Используемый префикс управляется переменной
<CODE>outline-minor-mode-prefix</CODE>.)


<P>
<A NAME="IDX1110"></A>
  При входе в режим Outline запускается ловушка <CODE>text-mode-hook</CODE>
сразу после ловушки <CODE>outline-mode-hook</CODE> (see section <A HREF="emacs_36.html#SEC449">Ловушки</A>).




<H3><A NAME="SEC230" HREF="emacs_toc.html#TOC230">Формат схем текста</A></H3>

<P>
<A NAME="IDX1111"></A>
<A NAME="IDX1112"></A>
  Режим Outline предполагает, что строки в буфере делятся на два типа:
<EM>строки заголовка</EM> и <EM>строки тела</EM>.  Строки заголовка
представляет тему в схеме текста.  Они начинаются с одной или более
звездочек; число звездочек определяет глубину заголовка в структуре
текста.  Таким образом, строка заголовка с одной звездочкой -- это
основная тема; все строки заголовка с двумя звездочками между этой
строкой и следующей строкой заголовка с одной звездочкой являются ее
подтемами и так далее.  Любая строка, которая не является строкой
заголовка, -- это строка тела.  Строки тела относятся к предшествующей
строке заголовка.  Вот пример:



<PRE>
* Еда
Это тело, которое
говорит что-то о еде.

** Вкусная еда
Это тело заголовка второго уровня.

** Противная еда
Здесь тоже могло бы
быть тело на
нескольких строках.

*** Общепит

* Приют
Еще одна тема первого уровня со своей строкой заголовка.
</PRE>

<P>
  Строка заголовка вместе со всеми последующими строками тела в
совокупности называются <EM>вхождением</EM>.  Строка заголовка вместе со
всеми следующими более глубокими заголовками и их строками тела
называется <EM>поддеревом</EM>.


<P>
<A NAME="IDX1113"></A>
     Вы можете настроить критерий для различения строк заголовка,
установив переменную <CODE>outline-regexp</CODE>.  Любая строка, чье начало
содержит совпадение с этим регулярным выражением, рассматривается как
строка заголовка.  Соответствия, которые начинаются с середины строки
(не в начале), не рассматриваются.  Длина текста соответствия определяет
уровень заголовка: более длинное соответствие создает глубже вложенный
уровень.  Например, если программа форматирования имеет команды
<SAMP>`@chapter'</SAMP>, <SAMP>`@section'</SAMP> и <SAMP>`@subsection'</SAMP> для деления
документа на главы и разделы, вы можете сделать эти строки
воспринимаемыми в качестве строк заголовка, установив
<CODE>outline-regexp</CODE> равной <SAMP>`"@chap\\|@\\(sub\\)*section"'</SAMP>.
Обратите внимание на хитрость: слова <SAMP>`chapter'</SAMP> и <SAMP>`section'</SAMP>
имеют равную длину, но определив регулярное выражение как совпадающее
только с <SAMP>`chap'</SAMP>, мы гарантируем, что длина текста, соответствующего
заголовку главы, будет короче; таким образом, режим Outline будет знать,
что разделы содержатся в главах.  Это работает, если никакая другая
команда не начинается с <SAMP>`@chap'</SAMP>.


<P>
<A NAME="IDX1114"></A>
  Есть возможность изменить правило подсчета уровня строк заголовка,
путем установки переменной <CODE>outline-level</CODE>.  Значение
<CODE>outline-level</CODE> должно быть функцией, не принимающей аргументов и
возвращающей номер уровня текущего заголовка.  Некоторые основные
режимы, например режимы C, Nroff и Emacs Lisp, устанавливают эту
переменную, чтобы ими можно было пользоваться со второстепенным режимом
Outline.




<H3><A NAME="SEC231" HREF="emacs_toc.html#TOC231">Команды перемещения по структуре</A></H3>

<P>
  Режим Outline предоставляет особые команды перемещения, которые
передвигают назад и вперед по строкам заголовков.


<DL COMPACT>

<DT><KBD>C-c C-n</KBD>
<DD>
Передвинуть точку к следующей видимой строке заголовка
(<CODE>outline-next-visible-heading</CODE>).
<DT><KBD>C-c C-p</KBD>
<DD>
Передвинуть точку к предыдущей видимой строке заголовка
(<CODE>outline-previous-visible-heading</CODE>).
<DT><KBD>C-c C-f</KBD>
<DD>
Передвинуть точку к следующей видимой строке заголовка того же уровня,
что и строка, на которой находится точка
(<CODE>outline-forward-same-level</CODE>).
<DT><KBD>C-c C-b</KBD>
<DD>
Передвинуть точку к предыдущей видимой строке заголовка этого же уровня
(<CODE>outline-backward-same-level</CODE>).
<DT><KBD>C-c C-u</KBD>
<DD>
Передвинуть точку назад к видимой строке заголовка более низкого уровня
(<CODE>outline-up-heading</CODE>).
</DL>

<P>
<A NAME="IDX1115"></A>
<A NAME="IDX1116"></A>
<A NAME="IDX1117"></A>
<A NAME="IDX1118"></A>
  <KBD>C-c C-n</KBD> (<CODE>outline-next-visible-heading</CODE>) переходит вниз на
следующую строку заголовка.  <KBD>C-c C-p</KBD>
(<CODE>outline-previous-visible-heading</CODE>) передвигает аналогично, но
назад.  Обе принимают числовой аргумент как счетчик повторов.  Имена
этих команд подчеркивают, что невидимые заголовки пропускаются, но это
на самом деле не специальная особенность.  Все команды редактирования,
которые просматривают строки, игнорируют невидимые строки автоматически.


<P>
<A NAME="IDX1119"></A>
<A NAME="IDX1120"></A>
<A NAME="IDX1121"></A>
<A NAME="IDX1122"></A>
<A NAME="IDX1123"></A>
<A NAME="IDX1124"></A>
  Более мощные команды движения понимают уровневую структуру заголовков.
<KBD>C-c C-f</KBD> (<CODE>outline-forward-same-level</CODE>) и <KBD>C-c C-b</KBD>
(<CODE>outline-backward-same-level</CODE>) передвигают от одной строки
заголовка к другой видимой строке заголовка той же самой глубины в
структуре.  <KBD>C-c C-u</KBD> (<CODE>outline-up-heading</CODE>) передвигает назад
к другому заголовку, который имеет меньшую глубину вложенности.




<H3><A NAME="SEC232" HREF="emacs_toc.html#TOC232">Команды управления видимостью структуры</A></H3>

<P>
  Чтобы сделать строки видимыми или невидимыми, используются другие
специальные команды режима Outline.  Все их имена начинаются либо с
<CODE>hide</CODE>, либо с <CODE>show</CODE>.  Большинство из них составляют пары
противоположностей.  Они не могут быть отменены; вместо этого вы можете
произвести отмену безотносительно к видимости текста.  Изменение
видимости строк просто не записывается механизмом отмены.


<DL COMPACT>

<DT><KBD>C-c C-t</KBD>
<DD>
Сделать все строки тела в буфере невидимыми (<CODE>hide-body</CODE>).
<DT><KBD>C-c C-a</KBD>
<DD>
Сделать все строки в буфере видимыми (<CODE>show-all</CODE>).
<DT><KBD>C-c C-d</KBD>
<DD>
Сделать все под этим заголовком невидимым, но не сам этот заголовок
(<CODE>hide-subtree</CODE>).
<DT><KBD>C-c C-s</KBD>
<DD>
Сделать все под этим заголовком видимым, включая тело, подзаголовки и их
тела (<CODE>show-subtree</CODE>).
<DT><KBD>C-c C-l</KBD>
<DD>
Сделать тело этой строки заголовка и все его подзаголовки невидимыми
(<CODE>hide-leaves</CODE>).
<DT><KBD>C-c C-k</KBD>
<DD>
Сделать все подзаголовки этого заголовка видимыми на всех уровнях
(<CODE>show-branches</CODE>).
<DT><KBD>C-c C-i</KBD>
<DD>
Сделать непосредственные подзаголовки (на один уровень вниз) этого
заголовка видимыми (<CODE>show-children</CODE>).
<DT><KBD>C-c C-c</KBD>
<DD>
Сделать тело этого заголовка невидимым (<CODE>hide-entry</CODE>).
<DT><KBD>C-c C-e</KBD>
<DD>
Сделать тело этого заголовка видимым (<CODE>show-entry</CODE>).
<DT><KBD>C-c C-q</KBD>
<DD>
Скрыть все, кроме <VAR>n</VAR> верхних уровней строк заголовков
(<CODE>hide-sublevels</CODE>).
<DT><KBD>C-c C-o</KBD>
<DD>
Скрыть все, кроме заголовка или тела, в котором находится точка, и
заголовков, ведущих отсюда к верхнему уровню структуры
(<CODE>hide-other</CODE>).
</DL>

<P>
<A NAME="IDX1125"></A>
<A NAME="IDX1126"></A>
<A NAME="IDX1127"></A>
<A NAME="IDX1128"></A>
  Две команды, которые строго противоположны, -- это <KBD>C-c C-c</KBD>
(<CODE>hide-entry</CODE>) и <KBD>C-c C-e</KBD> (<CODE>show-entry</CODE>).  Они
применяются, когда точка расположена на заголовке, и относятся только к
строкам тела этого заголовка.  Подтемы и их тела не затрагиваются.


<P>
<A NAME="IDX1129"></A>
<A NAME="IDX1130"></A>
<A NAME="IDX1131"></A>
<A NAME="IDX1132"></A>
<A NAME="IDX1133"></A>
  Две более мощные противоположности -- это <KBD>C-c C-d</KBD>
(<CODE>hide-subtree</CODE>) и <KBD>C-c C-s</KBD> (<CODE>show-subtree</CODE>).  Обе
предполагают использование, когда точка находится на заголовке, и обе
применяются ко всем строкам <EM>поддерева</EM> этого заголовка: его телу,
всем его подзаголовкам, как прямым, так и косвенным, и всем их телам.
Другими словами, поддерево содержит все, что следует за этим заголовком,
вплоть до (но не включая) следующего заголовка того же самого или более
высокого ранга.


<P>
<A NAME="IDX1134"></A>
<A NAME="IDX1135"></A>
<A NAME="IDX1136"></A>
<A NAME="IDX1137"></A>
  Промежуточное состояние между видимым и невидимым поддеревом -- это
когда видимы все подзаголовки, но не видимо ни одно тело.  Для
осуществления этого есть две команды, в зависимости от того, хотите ли
вы скрыть тела или сделать видимыми подзаголовки.  Это <KBD>C-c C-l</KBD>
(<CODE>hide-leaves</CODE>) и <KBD>C-c C-k</KBD> (<CODE>show-branches</CODE>).


<P>
<A NAME="IDX1138"></A>
<A NAME="IDX1139"></A>
   Команда <KBD>C-c C-i</KBD> (<CODE>show-children</CODE>) немного слабее
<KBD>show-branches</KBD>.  Она делает видимыми только непосредственные
подзаголовки -- те, что на один уровень ниже.  Более глубокие
подзаголовки остаются невидимыми, если они были таковыми.


<P>
<A NAME="IDX1140"></A>
<A NAME="IDX1141"></A>
<A NAME="IDX1142"></A>
<A NAME="IDX1143"></A>
  Две команды производят действие, охватывающее весь файл.  <KBD>C-c
C-t</KBD> (<CODE>hide-body</CODE>) делает все строки тела невидимыми, так что вы
видите просто схему текста.  <KBD>C-c C-a</KBD> (<CODE>show-all</CODE>) делает все
строки видимыми.  Эти команды могут рассматриваться как пара
противоположных, хотя <KBD>C-c C-a</KBD> применяется не только к строкам
тела.


<P>
<A NAME="IDX1144"></A>
<A NAME="IDX1145"></A>
  Команда <KBD>C-c C-q</KBD> (<CODE>hide-sublevels</CODE>) скрывает все заголовки,
кроме заголовков верхнего уровня.  С числовым аргументом <VAR>n</VAR>, она
скрывает все, кроме строк заголовков <VAR>n</VAR> верхних уровней.


<P>
<A NAME="IDX1146"></A>
<A NAME="IDX1147"></A>
  Команда <KBD>C-c C-o</KBD> (<CODE>hide-other</CODE>) скрывает все, кроме
заголовка или текста тела, в котором находится точка, и их родителей
(заголовков, ведущих отсюда к верхнему уровню структуры).


<P>
  Использование многоточий в конце видимых строк может быть отключено
путем установки <CODE>selective-display-ellipses</CODE> равной <CODE>nil</CODE>.
Тогда не будет явного указания на существование невидимых строк.


<P>
  Когда наращиваемый поиск находит текст, который скрыт режимом Outline,
он делает эту часть буфера видимой.  Если вы выйдите из поиска в этой
позиции, текст останется видимым.




<H3><A NAME="SEC233" HREF="emacs_toc.html#TOC233">Просмотр одной схемы в нескольких видах</A></H3>

<P>
<A NAME="IDX1148"></A>
<A NAME="IDX1149"></A>
<A NAME="IDX1150"></A>
<A NAME="IDX1151"></A>
  Вы можете просмотреть два вида одной схемы одновременно в разных
окнах.  Чтобы сделать так, вы должны создать косвенный буфер, используя
<KBD>M-x make-indirect-buffer</KBD>.  Первый аргумент этой команды -- это
имя существующего буфера Outline, а второй аргумент -- это имя, которое
будет использоваться для нового косвенного буфера.  See section <A HREF="emacs_20.html#SEC168">Косвенные буферы</A>.


<P>
@hyphenation{соз-дай-те} 
  Когда косвенный буфер создан, вы можете показать его в окне, как
обычно, с помощью <KBD>C-x 4 b</KBD> или других команд Emacs.  Команды режима
Outline для показа или скрывания частей текста действуют в каждом буфере
независимо; в результате каждый буфер может иметь свой вид.  Если вы
хотите получить более двух видов одной и той же схемы, создайте
дополнительные косвенные буферы.




<H2><A NAME="SEC234" HREF="emacs_toc.html#TOC234">Режим TeX</A></H2>
<P>
<A NAME="IDX1152"></A>
<A NAME="IDX1153"></A>
<A NAME="IDX1154"></A>
<A NAME="IDX1155"></A>
<A NAME="IDX1156"></A>
<A NAME="IDX1157"></A>
<A NAME="IDX1158"></A>
<A NAME="IDX1159"></A>
<A NAME="IDX1160"></A>
<A NAME="IDX1161"></A>


<P>
  TeX -- это мощная программа компьютерного набора, написанная
Дональдом Кнутом.  Он также является свободным программным продуктом,
как и GNU Emacs.  LaTeX -- это упрощенный формат ввода для TeX,
реализованный на макросах TeX.  Он распространяется вместе с TeX.
SliTeX -- это особая форма LaTeX.


<P>
  В Emacs есть специальный режим TeX для редактирования входных
TeX-файлов.  Он предусматривает средства для проверки
сбалансированности ограничителей и для вызова TeX для всего файла или
его части.


<P>
<A NAME="IDX1162"></A>
  Режим TeX имеет три варианта: режим Plain TeX, режим LaTeX и
режим SliTeX (три этих основных режима отличающихся друг от друга
лишь слегка).  Они предназначены для редактирования трех различных
входных форматов.  Команда <KBD>M-x tex-mode</KBD> проверяет содержимое
буфера, чтобы определить, не является ли это входом для LaTeX или
SliTeX; если это так, она выбирает подходящий режим.  Если содержимое
файла не оказалось ни LaTeX, ни SliTeX, она выбирает режим TeX.
Если содержимого файла оказалось недостаточно для определения формата,
то используется режим, задаваемый переменной <CODE>tex-default-mode</CODE>.


<P>
  Когда <KBD>M-x tex-mode</KBD> делает неправильное предположение, вы можете
использовать команды <KBD>M-x plain-tex-mode</KBD>, <KBD>M-x latex-mode</KBD> и
<KBD>M-x slitex-mode</KBD> для явного выбора конкретного варианта режима
TeX.




<H3><A NAME="SEC235" HREF="emacs_toc.html#TOC235">Команды редактирования режима TeX</A></H3>

<P>
  Здесь перечислены специальные команды, предусмотренные в режиме TeX
для редактирования текста файла.


<DL COMPACT>

<DT><KBD>"</KBD>
<DD>
Вставить согласно контексту либо <SAMP>`"'</SAMP>, либо <SAMP>`"'</SAMP>, либо
<SAMP>`"'</SAMP> (<CODE>tex-insert-quote</CODE>).
<DT><KBD>C-j</KBD>
<DD>
Вставить разрыв абзаца (два перевода строки) и проверить предыдущий
абзац на несбалансированные фигурные скобки или знаки доллара
(<CODE>tex-terminate-paragraph</CODE>).
<DT><KBD>M-x tex-validate-region</KBD>
<DD>
Проверить каждый абзац в буфере на несбалансированные фигурные скобки
или знаки доллара.
<DT><KBD>C-c {</KBD>
<DD>
Вставить <SAMP>`{}'</SAMP> и расположить точку между ними
(<CODE>tex-insert-braces</CODE>).
<DT><KBD>C-c }</KBD>
<DD>
Перейти вперед за следующую непарную закрывающую фигурную скобку
(<CODE>up-list</CODE>).
</DL>

<P>
<A NAME="IDX1163"></A>
<A NAME="IDX1164"></A>
   Знак <SAMP>`"'</SAMP> обычно не используется в TeX; мы используем
<SAMP>`"'</SAMP>, чтобы открыть кавычки, и <SAMP>`"'</SAMP>, чтобы закрыть.  Чтобы
облегчить редактирование с учетом этого соглащения о форматировании,
режим TeX заменяет обычное значение клавиши <KBD>"</KBD> на команду,
вставляющую пару одиночных простых или обратных кавычек
(<CODE>tex-insert-quote</CODE>).  Если говорить точно, эта команда вставляет
<SAMP>`"'</SAMP> после пропуска или открывающей фигурной скобки, <SAMP>`"'</SAMP> после
обратной косой черты и <SAMP>`"'</SAMP> после всех остальных знаков.


<P>
  Если вам нужен знак <SAMP>`"'</SAMP> сам по себе в необычном контексте,
используйте для его вставки <KBD>C-q</KBD>.  Также, <KBD>"</KBD> c числовым
аргументом всегда вставляет указанное число знаков <SAMP>`"'</SAMP>.  Вы
можете выключить средство раскрытия <KBD>"</KBD>, убрав эту привязку из
локальной раскладки (see section <A HREF="emacs_36.html#SEC456">Настройка привязок ключей</A>).


<P>
  Знак <SAMP>`$'</SAMP> имеет в режиме TeX особый синтаксический код, который
перетендует на понимание способа, которым ограничители математической
моды TeX соответствуют друг другу.  Когда вы вводите <SAMP>`$'</SAMP>,
который используется для выхода из математической моды, на секунду
отображается позиция парного <SAMP>`$'</SAMP>, который вводил в математическую
моду.  Это то же самое средство, которое показывает открывающую фигурную
скобку, соответствующую вставленной закрывающей.  Однако, нет способа
узнать, является ли <SAMP>`$'</SAMP> входом или выходом из математической моды;
поэтому когда вы вводите <SAMP>`$'</SAMP>, который входит в математическую моду,
показывается позиция предыдущего <SAMP>`$'</SAMP>, как если бы она была они
составляли пару, даже если фактически они не относятся друг к другу.


<P>
<A NAME="IDX1165"></A>
<A NAME="IDX1166"></A>
<A NAME="IDX1167"></A>
<A NAME="IDX1168"></A>
  TeX использует фигурные скобки как ограничители, которые обязаны
составлять пары.  Некоторые пользователи предпочитают поддерживать
фигурные скобки все время сбалансированными, а не вставлять их по
отдельности.  Используйте <KBD>C-c {</KBD> (<CODE>tex-insert-braces</CODE>), чтобы
вставить пару фигурных скобок.  Эта команда оставляет точку между двумя
этими скобками, чтобы вы могли вставить текст внутрь.  Потом используйте
команду <KBD>C-c }</KBD> (<CODE>up-list</CODE>), чтобы перейти вперед через
закрывающую фигурную скобку.


<P>
<A NAME="IDX1169"></A>
<A NAME="IDX1170"></A>
<A NAME="IDX1171"></A>
  Существуют две команды для контроля соответствия фигурных скобок.
<KBD>C-j</KBD> (<CODE>tex-terminate-paragraph</CODE>) проверяет абзац перед точкой
и вставляет два ограничителя новой строки для начала нового абзаца.
Если будет найдено какое-то несоответствие, она напечатает сообщение в
эхо-области.  <KBD>M-x tex-validate-region</KBD> проверяет область, абзац за
абзацем.  Ошибки перечисляются в буфере <TT>`*Occur*'</TT>, и вы можете
использовать в нем <KBD>C-c C-c</KBD> или <KBD>Mouse-2</KBD>, чтобы перейти к
конкретному несоответствию.


<P>
  Заметьте, что команды Emacs подсчитывают в режиме TeX не только
фигурные скобки, но и квадратные и круглые.  Для проверки синтаксиса
TeX это не совсем корректно.  Тем не менее, круглые и квадратные
скобки, скорее всего, используются в тексте в качестве парных
разделителей, и будет полезно, если различные команды движения и
автоматического показа пар будут с ними работать.




<H3><A NAME="SEC236" HREF="emacs_toc.html#TOC236">Команды редактирования режима LaTeX</A></H3>

<P>
  Режим LaTeX и его вариация, режим SliTeX, предоставляют
несколько дополнительных возможностей, не относящихся к plain TeX.


<DL COMPACT>

<DT><KBD>C-c C-o</KBD>
<DD>
Вставляет <SAMP>`\begin'</SAMP> и <SAMP>`\end'</SAMP> для блока LaTeX и помещает точку
на строке между ними (<CODE>tex-latex-block</CODE>).
<DT><KBD>C-c C-e</KBD>
<DD>
Закрывает самый внутренний еще не закрытый блок LaTeX
(<CODE>tex-close-latex-block</CODE>).
</DL>

<P>
<A NAME="IDX1172"></A>
<A NAME="IDX1173"></A>
<A NAME="IDX1174"></A>
  В LaTeX для группировки блоков текста используются команды
<SAMP>`\begin'</SAMP> и <SAMP>`\end'</SAMP>.  Чтобы вставить <SAMP>`\begin'</SAMP> и парную
<SAMP>`\end'</SAMP> (на новой строке после <SAMP>`\begin'</SAMP>), используйте <KBD>C-c
C-o</KBD> (<CODE>tex-latex-block</CODE>).  Между двумя этими строками вставляется
пустая строка, и на ней оставляется точка.  При вводе типа блока вы
можете использовать завершение; чтобы задать имена дополнительных типов
блоков, установите переменную <CODE>latex-block-names</CODE>.  Например,
добавить <SAMP>`theorem'</SAMP>, <SAMP>`corollary'</SAMP> и <SAMP>`proof'</SAMP> можно таким
образом:



<PRE>
(setq latex-block-names '("theorem" "corollary" "proof"))
</PRE>

<P>
<A NAME="IDX1175"></A>
<A NAME="IDX1176"></A>
  Во входном тексте LaTeX команды <SAMP>`\begin'</SAMP> и <SAMP>`\end'</SAMP> должны
соответствовать друг другу.  Вы можете использовать <KBD>C-c C-e</KBD>
(<CODE>tex-close-latex-block</CODE>), чтобы автоматически вставить
<SAMP>`\end'</SAMP>, соответствующую последней <SAMP>`\begin'</SAMP>, оставшей без пары.
Эта команда делает для <SAMP>`\end'</SAMP> отступ в соответствии с ее
<SAMP>`\begin'</SAMP>.  Если точка находится в начале строки, она вставляет
после <SAMP>`\end'</SAMP> новую строку,




<H3><A NAME="SEC237" HREF="emacs_toc.html#TOC237">Команды печати для TeX</A></H3>

<P>
  Вы можете вызвать TeX как подчиненный процесс Emacs либо для всего
содержимого буфера, либо только на область, за один раз.  Запуск TeX
таким способом только в одной главе дает удобный метод увидеть, как
выглядят ваши изменения, не тратя время на форматирование всего файла.


<DL COMPACT>

<DT><KBD>C-c C-r</KBD>
<DD>
Вызвать TeX для текущей области вместе с заголовоком буфера
(<CODE>tex-region</CODE>).
<DT><KBD>C-c C-b</KBD>
<DD>
Вызывать TeX для всего текущего буфера (<CODE>tex-buffer</CODE>).
<DT><KBD>C-c <KBD>TAB</KBD></KBD>
<DD>
Вызывать BibTeX для текущего файла (<CODE>tex-bibtex-file</CODE>).
<DT><KBD>C-c C-f</KBD>
<DD>
Вызывать TeX для текущего файла (<CODE>tex-file</CODE>).
<DT><KBD>C-c C-l</KBD>
<DD>
Переместить центр окна, показывающего вывод подчиненного TeX, чтобы
можно было увидеть последнюю строку (<CODE>tex-recenter-output-buffer</CODE>).
<DT><KBD>C-c C-k</KBD>
<DD>
Уничтожить подпроцесс TeX (<CODE>tex-kill-job</CODE>).
<DT><KBD>C-c C-p</KBD>
<DD>
Печатать вывод из последней команды <KBD>C-c C-r</KBD>, <KBD>C-c C-b</KBD> или
<KBD>C-c C-f</KBD> (<CODE>tex-print</CODE>).
<DT><KBD>C-c C-v</KBD>
<DD>
Запустить предварительный просмотр вывода последней команды <KBD>C-c
C-r</KBD>, <KBD>C-c C-b</KBD> или <KBD>C-c C-f</KBD> (<CODE>tex-view</CODE>).
<DT><KBD>C-c C-q</KBD>
<DD>
Показать очередь принтера (<CODE>tex-show-print-queue</CODE>).
</DL>

<P>
<A NAME="IDX1177"></A>
<A NAME="IDX1178"></A>
<A NAME="IDX1179"></A>
<A NAME="IDX1180"></A>
<A NAME="IDX1181"></A>
<A NAME="IDX1182"></A>
<A NAME="IDX1183"></A>
<A NAME="IDX1184"></A>
  Вы можете пропустить текущий буфер через подчиненный TeX с помощью
<KBD>C-c C-b</KBD> (<CODE>tex-buffer</CODE>).  Отформатированный вывод появляется
во временном файле; чтобы напечатать его, наберите <KBD>C-c C-p</KBD>
(<CODE>tex-print</CODE>).  Потом вы можете использовать <KBD>C-c C-q</KBD>
(<CODE>tex-show-printer-queue</CODE>), чтобы увидеть, как скоро ваш вывод
будет напечатан.  Если ваш терминал может показывать выходные файлы
TeX, вы можете просмотреть вывод на терминале с помощью команды
<KBD>C-c C-v</KBD> (<CODE>tex-view</CODE>).


<P>
<A NAME="IDX1185"></A>
<A NAME="IDX1186"></A>
  Вы можете указать каталог для запуска TeX, установив переменную
<CODE>tex-directory</CODE>.  Значением по умолчанию является <CODE>"."</CODE>.  Если
переменная среды @env{TEXINPUTS} содержит относительные имена каталогов,
или ваши файлы содержат команды <SAMP>`\input'</SAMP> с относительными именами,
то <CODE>tex-directory</CODE> <EM>должна</EM> быть равна <CODE>"."</CODE>, или вы
получите неправильные результаты.  В противном случае, можно без
опасения задать какой-то другой каталог, например, <CODE>"/tmp"</CODE>.


<P>
<A NAME="IDX1187"></A>
<A NAME="IDX1188"></A>
<A NAME="IDX1189"></A>
<A NAME="IDX1190"></A>
<A NAME="IDX1191"></A>
<A NAME="IDX1192"></A>
  Если вы хотите указать, какие команды оболочки нужно использовать в
подчиненном процессе TeX, вы можете сделать это установкой значений
переменных <CODE>tex-run-command</CODE>, <CODE>latex-run-command</CODE>,
<CODE>slitex-run-command</CODE>, <CODE>tex-dvi-print-command</CODE>,
<CODE>tex-dvi-view-command</CODE> и <CODE>tex-show-queue-command</CODE>.  Вы
<EM>обязаны</EM> установить значение <CODE>tex-dvi-view-command</CODE> для
вашего конкретного терминала; эта переменная не имеет значения по
умолчанию.  Другие переменные имеют значения по умолчанию, которые могут
подойти (а могут и не подойти) для вашей системы.


<P>
  Обычно имя файла, передаваемое этим командам, пишется в конце
командной строки: например, <SAMP>`latex <VAR>имя-файла</VAR>'</SAMP>.  Однако в
некоторых случаях имя файла должно быть вставлено в команду; это может
понадобиться, к примеру, когда вам нужно предоставить имя файла в
качестве аргумента команде, чей вывод направляется другой программе.  Вы
можете указать, в какое место следует подставить имя файла, с помощью
знака <SAMP>`*'</SAMP> в командной строке.  Например,



<PRE>
(setq tex-dvi-print-command "dvips -f * | lpr")
</PRE>

<P>
<A NAME="IDX1193"></A>
<A NAME="IDX1194"></A>
<A NAME="IDX1195"></A>
<A NAME="IDX1196"></A>
  Терминальный вывод TeX, включающий все сообщения об ошибках,
появляется в буфере с именем <TT>`*tex-shell*'</TT>.  Если TeX получил
ошибку, вы можете переключиться в этот буфер и подать ему какой-то ввод
(это работает как в режиме Shell, see section <A HREF="emacs_35.html#SEC419">Интерактивная подчиненная оболочка</A>).  Без
переключения в этот буфер, вы можете прокрутить его с помощью <KBD>C-c
C-l</KBD> так, что последняя строчка в нем станет видимой.


<P>
  Наберите <KBD>C-c C-k</KBD> (<CODE>tex-kill-job</CODE>), чтобы уничтожить процесс
TeX, если вы понимаете, что его вывод уже бесполезен.  Использование
<KBD>C-c C-b</KBD> или <KBD>C-c C-r</KBD> также уничтожает любой работающий
процесс TeX.


<P>
<A NAME="IDX1197"></A>
<A NAME="IDX1198"></A>
  Вы также можете пропустить произвольную область через подчиненный
TeX, набрав <KBD>C-c C-r</KBD> (<CODE>tex-region</CODE>).  Однако, это
ненадежно, потому что большинство входных файлов TeX содержат в
начале команды, устанавливающие какие-то параметры и определяющие
макросы, без которых дальнейшая часть файла не отформатируется
правильно.  Для того, чтобы решить эту проблему, <KBD>C-c C-r</KBD> позволяет
вам обозначить часть файла как содержащую важные команды; она
вставляется перед заданной областью как часть ввода TeX.
Обозначенная часть файла называется <EM>заголовком</EM>.


<P>
<A NAME="IDX1199"></A>
  Чтобы обозначить границы заголовка в режиме Plain TeX, вы
вставляете в файл две специальные строки.  Вставьте <SAMP>`%**start of
header'</SAMP> перед заголовком и <SAMP>`%*end of header'</SAMP> после него.  Обе
должны появиться полностью на одной строке, но перед ними или после них
допускается другой текст.  Строки, содержащие эти фразы, включаются в
заголовок.  Если <SAMP>`%**start of header'</SAMP> не появится в пределах первых
100 строк буфера, <KBD>C-c C-r</KBD> предполагает, что заголовка нет.


<P>
  В режиме LaTeX заголовок начинается с команды <SAMP>`\documentstyle'</SAMP>
и заканчивается командой <SAMP>`\begin{document}'</SAMP>.  LaTeX требует,
чтобы вы использовали эти команды в любом случае, так что для
определения заголовка не требуется делать ничего особенного.


<P>
<A NAME="IDX1200"></A>
<A NAME="IDX1201"></A>
  Команды (<CODE>tex-buffer</CODE>) и (<CODE>tex-region</CODE>) делают свою работу
во временном каталоге, и им недоступны вспомогательные файлы, нужные
TeX для перекрестных ссылок; эти команды в общем случае не подходят
для обработки окончательной копии, в которой все перекрестные ссылки
должны быть правильными.


<P>
  Когда вам нужны вспомогательные файлы для перекрестных ссылок,
используйте <KBD>C-c C-f</KBD> (<CODE>tex-file</CODE>), которая запускает TeX
для файла текущего буфера в каталоге этого файла.  Перед запуском TeX
она предлагает сохранить все измененные буферы.  В общем случае, вы
должны использовать (<CODE>tex-file</CODE>) дважды, чтобы получить правильные
перекрестные ссылки.


<P>
<A NAME="IDX1202"></A>
  Значение переменной <CODE>tex-start-options-string</CODE> задает ключи для
запуска TeX.  Значение по умолчанию велит TeX работать в
безостановочном режиме.  Чтобы запустить TeX интерактивно, установите
эту переменную равной <CODE>""</CODE>.


<P>
<A NAME="IDX1203"></A>
  Большие документы TeX часто разбивают на несколько файлов -- один
главный плюс подфайлы.  Запуск TeX для подфайла как правило не
сработает; вы должны запускать его для главного файла.  Чтобы сделать
<CODE>tex-file</CODE> полезной при редактировании подфайла, вы можете
установить переменную <CODE>tex-main-file</CODE> равной имени главного файла.
Тогда <CODE>tex-file</CODE> запустит TeX для этого файла.


<P>
  Наиболее удобный способ использования <CODE>tex-main-file</CODE> -- указать
ее в перечне локальных переменных в каждом из подфайлов.
See section <A HREF="emacs_36.html#SEC451">Локальные переменные в файлах</A>.


<P>
<A NAME="IDX1204"></A>
<A NAME="IDX1205"></A>
<A NAME="IDX1206"></A>
  С LaTeX-файлами вы можете использовать BibTeX, чтобы обработать
вспомогательные файлы для файла текущего буфера.  BibTeX находит
библиографические цитаты в базе данных и подготавливает процитированные
ссылки для раздела библиграфии.  Команда <KBD>C-c TAB</KBD>
(<CODE>tex-bibtex-file</CODE>) запускает команду оболочки
(<CODE>tex-bibtex-command</CODE>), чтобы получить <SAMP>`.bbl'</SAMP>-файл для файла
текущего буфера.  Вообще говоря, вам нужно сначала сделать <KBD>C-c C-f</KBD>
(<CODE>tex-file</CODE>), чтобы получить <SAMP>`.aux'</SAMP>-файл, затем сделать
<KBD>C-c TAB</KBD> (<CODE>tex-bibtex-file</CODE>) и после этого повторить <KBD>C-c
C-f</KBD> (<CODE>tex-file</CODE>) еще раз, чтобы сгенерировать правильные
перекрестные ссылки.


<P>
<A NAME="IDX1207"></A>
<A NAME="IDX1208"></A>
<A NAME="IDX1209"></A>
<A NAME="IDX1210"></A>
<A NAME="IDX1211"></A>
  При входе в любую разновидность режима TeX запускаюся ловушки
<CODE>text-mode-hook</CODE> и <CODE>tex-mode-hook</CODE>.  Затем запускаюся
<CODE>plain-tex-mode-hook</CODE> или <CODE>latex-mode-hook</CODE>, что подходит.
Для SliTeX-файлов запускается ловушка <CODE>slitex-mode-hook</CODE>.  При
старте оболочки TeX запускается <CODE>tex-shell-hook</CODE>.
See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.




<H2><A NAME="SEC238" HREF="emacs_toc.html#TOC238">Режим Nroff</A></H2>

<P>
<A NAME="IDX1212"></A>
<A NAME="IDX1213"></A>
  Режим Nroff -- это режим, похожий на режим Text, но модифицированный
для управления командами nroff, присутствующими в тексте.  Вызовите
<KBD>M-x nroff-mode</KBD>, чтобы войти в этот режим.  Он отличается от режима
Text только несколькими возможностями.  Все строки команд nroff
считаются разделителем абзацев, так что заполнение никогда не исказит
команды nroff.  Страницы разделяются командами <SAMP>`.bp'</SAMP>.  Комментарии
начинаются с обратной косой черты и двойных кавычек.  Также
предусмотрены три специальные команды, которых нет в режиме Text:


<P>
<A NAME="IDX1214"></A>
<A NAME="IDX1215"></A>
<A NAME="IDX1216"></A>
<A NAME="IDX1217"></A>
<A NAME="IDX1218"></A>
<A NAME="IDX1219"></A>
<DL COMPACT>

<DT><KBD>M-n</KBD>
<DD>
Перейти на начало следующей строки, которая не является командой nroff
(<CODE>forward-text-line</CODE>).  Аргумент служит счетчиком повторов.
<DT><KBD>M-p</KBD>
<DD>
Похожа на <KBD>M-n</KBD>, но сдвигает вверх (<CODE>backward-text-line</CODE>).
<DT><KBD>M-?</KBD>
<DD>
Напечатать в эхо-области число текстовых строк (строк, которые не
являются командами nroff) в текущей области (<CODE>count-text-lines</CODE>).
</DL>

<P>
<A NAME="IDX1220"></A>
  Другое свойство режима Nroff -- это то, что вы можете включать режим
Electric Nroff.  Это второстепенный режим, который вы можете включать
или выключать при помощи <KBD>M-x electric-nroff-mode</KBD>
(see section <A HREF="emacs_36.html#SEC441">Второстепенные режимы</A>).  Если этот режим включен, то каждый
раз, когда вы набираете <KBD>RET</KBD> для окончания строки, которая содержит
команду nroff, открывающую некоторый вид группы, в следующую строку
автоматически вставляется соответствующая закрывающая группу команда
nroff.  Например, если вы находитесь в начале строки и наберете
<KBD>. ( b <KBD>RET</KBD></KBD>, то в новую строку, следующую за точкой,
будет вставлена соответствующая команда <SAMP>`.)b'</SAMP>.


<P>
  Если с режимом Nroff вы используете второстепенный режим Outline
(see section <A HREF="emacs_26.html#SEC229">Режим Outline</A>), строками заголовков будут строки вида <SAMP>`.H'</SAMP>
с последующим числом (уровнем заголовка).


<P>
<A NAME="IDX1221"></A>
  Вход в режим Nroff запускает ловушку <CODE>text-mode-hook</CODE>, а затем
ловушку <CODE>nroff-mode-hook</CODE> (see section <A HREF="emacs_36.html#SEC449">Ловушки</A>).




<H2><A NAME="SEC239" HREF="emacs_toc.html#TOC239">Редактирование форматированного текста</A></H2>

<P>
<A NAME="IDX1222"></A>
<A NAME="IDX1223"></A>
<A NAME="IDX1224"></A>
<A NAME="IDX1225"></A>
<A NAME="IDX1226"></A>
  <EM>Режим Enriched</EM> -- это второстепенный режим для редактирования
файлов, которые содержат форматированный текст в стиле WYSIWYG, как в
текстовом процессоре.  На данный момент форматированный текст в режиме
Enriched может задавать шрифты, цвета, подчеркивание, поля и типы
заполнения и выравнивания.  В будущем мы планируем реализовать также и
другие возможности для форматирования.


<P>
  Режим Enriched -- это второстепенный режим (see section <A HREF="emacs_36.html#SEC441">Второстепенные режимы</A>).  Как правило он используется вместе с режимом Text
(see section <A HREF="emacs_26.html#SEC228">Режим Text</A>).  Однако, вы можете также использовать его и с
другими основными режимами, такими как режим Outline и режим
Paragraph-Indent Text.


<P>
  Потенциально Emacs может сохранять файлы с форматированным текстом во
многих форматах.  На текущий момент реализован только один формат:
<EM>text/enriched</EM>, который определяется протоколом MIME.  @xref{Format Conversion,, Format Conversion, @external{elisp}, the Emacs Lisp
Reference Manual}, для получения подробностей о том, как Emacs
распознает и пребразует форматы файлов.


<P>
  Дистрибутив Emacs содержит файл с форматированным текстом, который
может служить примером.  Он называется <TT>`etc/enriched.doc'</TT>.  Этот
файл содержит образцы, иллюстрирующие все возможности, описанные в этом
разделе.  В нем также есть перечень идей для будущих улучшений.




<H3><A NAME="SEC240" HREF="emacs_toc.html#TOC240">Запрос на редактирование форматированного текста</A></H3>

<P>
  Когда вы обращаетесь к файлу, который был сохранен в формате
text/enriched, Emacs автоматически преобразует информацию о
форматировании из этого файла во внутренний формат Emacs (свойства
текста) и включает режим Enriched.


<P>
<A NAME="IDX1227"></A>
  Чтобы создать новый файл с форматированным текстом, обратитесь сначала
к несуществующему файлу, а перед тем как начать редактирование наберите
<KBD>M-x enriched-mode</KBD>.  Эта команда включает режим Enriched.  Делайте
это до того, как вы начнете вставлять текст, чтобы вставляемый текст
наверняка обрабатывался правильно.


<P>
  В более общем виде, команда <CODE>enriched-mode</CODE> включает режим
Enriched, если он был выключен, и выключает его, если он был включен.
Запущенная с числовым аргументом, эта команда включает режим Enriched,
если аргумент положителен, и выключает в противном случае.


<P>
  Когда вы сохраняете буфер при задействованном режиме Enriched, Emacs
автоматически преобразует текст к формату text/enriched во время записи
в файл.  Когда вы снова обратитесь к этому файлу, Emacs автоматически
распознает формат, преобразует текст обратно и снова включит режим
Enriched.


<P>
<A NAME="IDX1228"></A>
  Обычно после обращения к файлу в формате text/enriched, Emacs
перезаполняет каждый абзац так, чтобы он умещался по заданному правому
полю.  Вы можете выключить это перезаполнение, чтобы сэкономить время,
установив переменную <CODE>enriched-fill-after-visiting</CODE> в значение
<CODE>nil</CODE> или <CODE>ask</CODE>.


<P>
  Однако, при обращении к файлу, записанному в формате Enriched, нет
нужды в перезаполнении, поскольку Emacs сохраняет установки правого поля
вместе с текстом.


<P>
<A NAME="IDX1229"></A>
  Делая добавления к <CODE>enriched-translations</CODE>, вы можете вносить
пометки для сохранения дополнительных свойств текста, которые Emacs
обычно не сохраняет.  Заметьте, что стандарт text/enriched требует,
чтобы имена всех нестандартных пометок начинались с <SAMP>`x-'</SAMP>, например
<SAMP>`x-read-only'</SAMP>.  Это позволяет быть уверенным в том, что они не
будут конфликтовать со стандартными пометками, добавленными позже.




<H3><A NAME="SEC241" HREF="emacs_toc.html#TOC241">Жесткие и гибкие переводы строк</A></H3>
<P>
<A NAME="IDX1230"></A>
<A NAME="IDX1231"></A>
<A NAME="IDX1232"></A>


<P>
  Emacs различает в форматированном тексте два разных вида переводов
строк: <EM>жесткие</EM> и <EM>гибкие</EM>.


<P>
  Жесткие переводы строк используются для разделения абзацев, или
пунктов перечня, или везде, где строка должна всегда разрываться вне
зависимости от полей.  Команды <KBD>RET</KBD> (<CODE>newline</CODE>) и <KBD>C-o</KBD>
(<CODE>open-line</CODE>) вставляют жесткие переводы строк.


<P>
  Гибкие переводы строк применяются для того, чтобы уместить текст в
пределы полей.  Все команды заполнения, включая Auto Fill, вставляют
гибкие переводы строк, и они удаляют всегда только гибкие переводы
строк.


<P>
  Хотя жесткие и гибкие переводы строк выглядят одинаково, важно помнить
об их различии.  Не используйте <KBD>RET</KBD>, чтобы разорвать строку в
середине заполненного абзаца, или иначе вы получите жесткие переводы
строк, которые послужат барьером последующему заполнению.  Вместо этого
позвольте разбивать строки режиму Auto Fill, чтобы при изменении текста
или полей Emacs мог правильно перезаполнить строки.  See section <A HREF="emacs_26.html#SEC223">Режим Auto Fill</A>.


<P>
  С другой стороны, в таблицах и перечнях, где строки должны всегда
оставаться такими, как вы их набрали, вы можете использовать для
завершения строк <KBD>RET</KBD>.  Для таких строк вы также можете установить
стиль выравнивания в <CODE>unfilled</CODE>.  See section <A HREF="emacs_26.html#SEC246">Выравнивание в форматированном тексте</A>.




<H3><A NAME="SEC242" HREF="emacs_toc.html#TOC242">Редактирование информации о формате</A></H3>

<P>
  Есть два способа изменить информацию о формате для файла с
форматированным текстом: командами клавиатуры или с помощью мыши.


<P>
  Простейший способ добавить свойства к вашему документу ---
воспользоваться меню Text Properties.  Вы можете попасть в это меню
двумя путями: из меню Edit в полоске меню или с помощью <KBD>C-mouse-2</KBD>
(прижмите клавишу <KBD>CTRL</KBD> и нажмите среднюю кнопку мыши).


<P>
  Большинство пунктов из меню Text Properties ведут к другим подменю.
Подменю описаны в последующих разделах.  Некоторые пункты запускают
команды непосредственно:


<DL COMPACT>

<DT><CODE>Remove Properties</CODE>
<DD>
<A NAME="IDX1233"></A>
 
Удаляет из области все свойства текста, с которыми работает меню Text
Properties (<CODE>facemenu-remove-props</CODE>).

<A NAME="IDX1234"></A>
<DT><CODE>Remove All</CODE>
<DD>
Удаляет <EM>все</EM> свойства текста из области
(<CODE>facemenu-remove-all</CODE>).

<A NAME="IDX1235"></A>
<DT><CODE>List Properties</CODE>
<DD>
Перечисляет все свойства текста для знака после точки
(<CODE>list-text-properties-at</CODE>).

<DT><CODE>Display Faces</CODE>
<DD>
Показывает перечень всех определенных начертаний.

<DT><CODE>Display Colors</CODE>
<DD>
Показывает перечень всех определенных цветов.
</DL>



<H3><A NAME="SEC243" HREF="emacs_toc.html#TOC243">Начертания в форматированном тексте</A></H3>
<P>
 
  В подменю Faces перечислены разные начертания Emacs, включая
<CODE>bold</CODE>, <CODE>italic</CODE> и <CODE>underline</CODE>.  Выбор одного из них
добавляет это начертание к области.  See section <A HREF="emacs_22.html#SEC189">Использование разных начертаний</A>.  Вы также можете
задать начертания с помощью таких команд клавиатуры:


<DL COMPACT>

<DT><KBD>M-g d</KBD>
<DD>
<A NAME="IDX1236"></A>
 <A NAME="IDX1237"></A>
 
Говорит, что область или следующий вставленный знак должны появиться в
начертании <CODE>default</CODE> (<CODE>facemenu-set-default</CODE>).
<A NAME="IDX1238"></A>
<A NAME="IDX1239"></A>
<DT><KBD>M-g b</KBD>
<DD>
Говорит, что область или следующий вставленный знак должны появиться в
начертании <CODE>bold</CODE> (<CODE>facemenu-set-bold</CODE>).
<A NAME="IDX1240"></A>
<A NAME="IDX1241"></A>
<DT><KBD>M-g i</KBD>
<DD>
Говорит, что область или следующий вставленный знак должны появиться в
начертании <CODE>italic</CODE> (<CODE>facemenu-set-italic</CODE>).
<A NAME="IDX1242"></A>
<A NAME="IDX1243"></A>
<DT><KBD>M-g l</KBD>
<DD>
Говорит, что область или следующий вставленный знак должны появиться в
начертании <CODE>bold-italic</CODE> (<CODE>facemenu-set-bold-italic</CODE>).
<A NAME="IDX1244"></A>
<A NAME="IDX1245"></A>
<DT><KBD>M-g u</KBD>
<DD>
Говорит, что область или следующий вставленный знак должны появиться в
начертании <CODE>underline</CODE> (<CODE>facemenu-set-underline</CODE>).
<A NAME="IDX1246"></A>
<A NAME="IDX1247"></A>
<DT><KBD>M-g o <VAR>начертание</VAR> <KBD>RET</KBD></KBD>
<DD>
Говорит, что область или следующий вставленный знак должны появиться в
заданном <VAR>начертании</VAR> (<CODE>facemenu-set-face</CODE>).
</DL>

<P>
  Если вы используете эти команды с префиксным аргументом -- или, в
режиме Transient Mark, если область не активна -- то они задают
начертание для следующего самовставляющегося ввода.  See section <A HREF="emacs_13.html#SEC57">Режим Transient Mark</A>.  Это относится как к командам клавиатуры, так и к командам меню.


<P>
  Режим Enriched определяет два дополнительных начертания: <CODE>fixed</CODE>
и <CODE>excerpt</CODE>.  Они соответствуют кодам, используемым в формате
файлов text/enriched.


<P>
  Начертание <CODE>excerpt</CODE> предназначено для цитат.  Оно совпадает с
начертанием <CODE>italic</CODE>, если вы его не перенастроили
(see section <A HREF="emacs_36.html#SEC447">Настройка начертаний</A>).


<P>
  Начертание <CODE>fixed</CODE> означает "Использовать для этой части текста
равноширинный шрифт".  В настоящее время Emacs поддерживает только
равноширинные шрифты; следовательно, пометка <CODE>fixed</CODE> пока не так
необходима.  Однако, в будущих версиях Emacs мы планируем реализовать
поддержку шрифтов переменной ширины, и другие системы, способные
отображать формат text/enriched, могут не использовать по умолчанию
равноширинный шрифт.  Поэтому если вы хотите, чтобы какая-то часть
текста появлялась именно с равноширинным шрифтом, вам следут задать для
этой части начертание <CODE>fixed</CODE>.


<P>
  Начертание <CODE>fixed</CODE> обычно определено так, что для него
используется другой шрифт, отличающийся от шрифта по умолчанию.  Однако,
на разных системах установлены разные шрифты, поэтому вам может
понадобиться настроить это.


<P>
  Если ваш терминал не умеет отображать разные начертания, у вас не
получится их увидеть, но вы все же сможете редактировать документы,
содержащие их.  Вы даже сможете добавить в текст начертания и цвета.
Они станут видимы, когда файл будут просматривать на терминале, который
способен их отобразить.




<H3><A NAME="SEC244" HREF="emacs_toc.html#TOC244">Цвета в форматированном тексте</A></H3>

<P>
  Вы можете указать цвета букв и фона для фрагментов текста.  Есть меню
для задания цвета текста и меню для задания цвета фона.  Оба меню цветов
перечисляют все цвета, которые вы использовали в режиме Enriched в
текущем сеансе Emacs.


<P>
  Если вы задаете цвет с префиксным аргументом -- или, в режиме
Transient Mark, если область не активна -- то этот цвет применяется для
самовставляемого ввода.  See section <A HREF="emacs_13.html#SEC57">Режим Transient Mark</A>.  В противном случае эта
команда относится к области.


<P>
  Оба меню цветов содержат дополнительный пункт: <SAMP>`Other'</SAMP>.  Вы
можете использовать этот пункт для задания цвета, который не перечислен
в меню; имя цвета считывается в минибуфере.  Чтобы просмотреть перечень
доступных цветов и их имена, используйте пункт <SAMP>`Display Colors'</SAMP> в
меню Text Properties (see section <A HREF="emacs_26.html#SEC242">Редактирование информации о формате</A>).


<P>
  Любой цвет, заданный таким способом или упомянутый в считанном файле с
форматированным текстом, добавляется в оба меню цветов и сохраняется там
на протяжении всего сеанса Emacs.


<P>
<A NAME="IDX1248"></A>
<A NAME="IDX1249"></A>
  Для задания цветов нет привязок ключей, но вы можете указывать их при
помощи расширенных команд <KBD>M-x facemenu-set-foreground</KBD> и <KBD>M-x
facemenu-set-background</KBD>.  Обе эти команды считывают имя цвета в
минибуфере.




<H3><A NAME="SEC245" HREF="emacs_toc.html#TOC245">Отступы в форматированном тексте</A></H3>

<P>
  При редактировании форматированного текста вы можете задать различные
величины отступа для правого или левого края целого абзаца или его
части.  Указанные вам поля автоматически учитываются команды Emacs для
заполнения (see section <A HREF="emacs_26.html#SEC222">Заполнение текста</A>) и разрыва строк.


<P>
  Подменю Indentation предоставляет удобный интерфейс для указания этих
свойств.  Оно содержит четыре пункта:


<DL COMPACT>

<DT><CODE>Indent More</CODE>
<DD>
<A NAME="IDX1250"></A>
 <A NAME="IDX1251"></A>
 
Увеличивает отступ области на 4 столбца (<CODE>increase-left-margin</CODE>).
В режиме Enriched эта команда также доступна на <KBD>C-x <KBD>TAB</KBD></KBD>;
если вы предоставите числовой аргумент, то он говорит, сколько столбцов
нужно добавить к полю (отрицательный аргумент уменьшает число столбцов).

<DT><CODE>Indent Less</CODE>
<DD>
Удаляет 4 столбца отступа из области.

<DT><CODE>Indent Right More</CODE>
<DD>
Сужает область, делая с правого края отступ в 4 столбца.

<DT><CODE>Indent Right Less</CODE>
<DD>
Удаляет 4 столбца отступа с правого края.
</DL>

<P>
  Вы можете использовать эти команды несколько раз для увеличения или
уменьшения величины отступа.


<P>
  Наиболее частый способ применения этих команд -- изменять отступ
целого абзаца.  Однако это не единственное их применение.  Вы можете
поменять размеры полей в любой точке; новые значения проявляются в конце
этой строки (для правого поля) или в начале следующей (для левого поля).


<P>
  Это позволяет форматировать абзацы с <EM>висящими отступами</EM>, что
означает, что отступ первой строки меньше отступа последующих строк.
Чтобы установить висящий отступ, увеличьте отступ области, начинающейся
после первого слова абзаца и продолжающейся до его конца.


<P>
  Отступ в первой строке абзаца делается проще.  Установите поле для
всего абзаца там, где вы хотели бы видеть его для тела абзаца, а затем
увеличьте отступ первой строки, добавив пробелы или знаки табуляции.


<P>
  Иногда в результате редактирования заполнение абзаца сбивается ---
части абзаца могут выйти за левые или правые поля.  Когда такое
происходит, воспользуйтесь <KBD>M-q</KBD> (<CODE>fill-paragraph</CODE>), чтобы
перезаполнить этот абзац.


<P>
<A NAME="IDX1252"></A>
  Число столбцов, которые добавляют или удаляют из отступа эти команды,
задается переменной <CODE>standard-indent</CODE>.  Ее значение равно по
умолчанию четырем.  Общее правое поле, принимаемое по умолчанию для
режима Enriched, контролируется переменной <CODE>fill-column</CODE>, как
обычно.


<P>
  Префикс заполнения, если он задан, действует совместно с указанным
отступом абзаца: <KBD>C-x .</KBD> не включает пропуск из указанного отступа в
новое значение префикса заполнения, а команды заполнения ищут префикс
заполнения в каждой строке после отступа.  See section <A HREF="emacs_26.html#SEC225">Префикс заполнения</A>.




<H3><A NAME="SEC246" HREF="emacs_toc.html#TOC246">Выравнивание в форматированном тексте</A></H3>

<P>
  При редактировании форматированного текста вы можете задавать
различные стили выравнивания абзацев.  Указанный вами стиль
автоматически учитывается командами Emacs для заполнения.


<P>
  Подменю Justification предоставляет удобный интерфейс для указания
стиля выравнивания.  Оно содержит пять пунктов:


<DL COMPACT>

<DT><CODE>Flush Left</CODE>
<DD>
Это наиболее распространенный стиль выравнивания (по крайней мере для
английского языка).  Строки выравниваются по левому полю, но оставляются
неровными с правого края.

<DT><CODE>Flush Right</CODE>
<DD>
Это выравнивает каждую строку по правому полю.  Если необходимо, слева
добавляются пробелы и знаки табуляции, чтобы правые концы строк
выстраивались в линию.

<DT><CODE>Full</CODE>
<DD>
Это выравнивает текст по обоим концам строк.  Выровненный таким образом
текст смотрится красиво в печатной книге, где все пробелы можно
настроить одинаково, но смотрится не так хорошо с равноширинным шрифтом
на экране.  Возможно, будущие версии Emacs позволят настраивать ширину
пробелов в строке, чтобы достичь элегантного выравнивания.

<DT><CODE>Center</CODE>
<DD>
Это центрирует каждую строку между текущими полями.

<DT><CODE>None</CODE>
<DD>
Это выключает заполнение полностью.  Каждая строка будет оставаться
такой, как вы ее написали; функции заполнения и автоматического
заполнения не будут иметь эффекта в тексте с такой установкой.  Вы все
же можете делать отступ слева.  В незаполненных областях все переводы
строк считаются жесткими (see section <A HREF="emacs_26.html#SEC241">Жесткие и гибкие переводы строк</A>) .
</DL>

<P>
  В режиме Enriched вы также можете задавать стиль выравнивания с
клавиатуры, используя префиксный знак <KBD>M-j</KBD>:


<DL COMPACT>

<DT><KBD>M-j c</KBD>
<DD>
<A NAME="IDX1253"></A>
 <A NAME="IDX1254"></A>
 <A NAME="IDX1255"></A>
 
<DT><KBD>M-S</KBD>
<DD>
Центрирует область (<CODE>set-justification-center</CODE>).
<A NAME="IDX1256"></A>
<A NAME="IDX1257"></A>
<DT><KBD>M-j u</KBD>
<DD>
Делает область невыровненной (<CODE>set-justification-none</CODE>).
<A NAME="IDX1258"></A>
<A NAME="IDX1259"></A>
<DT><KBD>M-j l</KBD>
<DD>
Выравнивает область слева (<CODE>set-justification-left</CODE>).
<A NAME="IDX1260"></A>
<A NAME="IDX1261"></A>
<DT><KBD>M-j r</KBD>
<DD>
Выравнивает область справа (<CODE>set-justification-right</CODE>).
<A NAME="IDX1262"></A>
<A NAME="IDX1263"></A>
<DT><KBD>M-j f</KBD>
<DD>
Выравнивает область полностью (<CODE>set-justification-full</CODE>).
</DL>

<P>
  Стили выравнивания применяются к целым абзацам.  Все команды для
изменения выравнивания действуют на абзац, содержащий точку, или, если
область активна, на все абзацы, пересекающиеся с областью.


<P>
<A NAME="IDX1264"></A>
  Стиль выравнивания по умолчанию задается переменной
<CODE>default-justification</CODE>.  Ее значением должен быть один из символов
<CODE>left</CODE>, <CODE>right</CODE>, <CODE>full</CODE>, <CODE>center</CODE> или <CODE>none</CODE>.




<H3><A NAME="SEC247" HREF="emacs_toc.html#TOC247">Установка других свойств текста</A></H3>

<P>
  Меню Other Properties позволяет вам добавлять или удалять три других
полезных свойства текста: <CODE>read-only</CODE>, <CODE>invisible</CODE> и
<CODE>intangible</CODE>.  Свойство <CODE>intangible</CODE> запрещает движение точки
внутри этого текста, свойство текста <CODE>invisible</CODE> делает текст
невидимым, а свойство <CODE>read-only</CODE> запрещает изменение текста.


<P>
  Для добавления каждого из этих особых свойств к области есть пункт
меню.  Последний пункт меню, <SAMP>`Remove Special'</SAMP>, удаляет все эти
особые свойства из текста области.


<P>
  На данный момент свойства <CODE>invisible</CODE> и <CODE>intangible</CODE>
<EM>не</EM> сохраняются в формате text/enriched.  Свойство
<CODE>read-only</CODE> сохраняется, но оно не входит в стандарт формата
text/enriched, поэтому другие редакторы могут его игнорировать.




<H3><A NAME="SEC248" HREF="emacs_toc.html#TOC248">Принудительное включение режима Enriched</A></H3>

<P>
  Обычно Emacs знает, когда вы редактируете форматированный текст,
поскольку он распознает специальные пометки, использованные в файле, к
которому вы обратились.  Однако, бывают ситуации, в которых вы должны
предпринять особые меры, чтобы преобразовать содержимое файла или
включить режим Enriched:



<UL>
<LI>

Когда вы обращаетесь к файлу, который был создан каким-то другим
редактором, Emacs может не распознать этот файл как отфоратированный в
text/enriched.  В таком случае, когда вы обращаетесь к файлу, вы увидите
команды форматирования, а не форматированный текст.  Наберите <KBD>M-x
format-decode-buffer</KBD>, чтобы перевести их.

<LI>

Когда вы <EM>вставляете</EM> файл в буфер, а не обращаетесь к нему.  Emacs
делает необходимые преобразования вставляемого текста, но не включает
режим Enriched.  Если вы хотите сделать это, введите <KBD>M-x
enriched-mode</KBD>.
</UL>

<P>
  Команда <CODE>format-decode-buffer</CODE> переводит текст из различных
форматов во внутренний формат Emacs.  Она просит вас указать формат, из
которого делать преобразование; однако, как правило вы можете просто
нажать <KBD>RET</KBD>, что велит Emacs предположить формат самому.


<P>
<A NAME="IDX1265"></A>
  Если вы хотите просмотреть на текст в text/enriched-файле буквально,
как последовательность знаков, а не как форматированный текст,
воспользуйтесь командой <KBD>M-x find-file-literally</KBD>.  Она обращается к
файлу, как и <CODE>find-file</CODE>, но не производит преобразование формата.
Она также подавляет преобразование кодов знаков (see section <A HREF="emacs_23.html#SEC205">Системы кодирования</A>) и автоматическую распаковку (see section <A HREF="emacs_19.html#SEC159">Доступ к сжатым файлам</A>).  Чтобы
выключить преобразование формата, но позволить перевод кодов знаков
и/или автоматическую распаковку, если она нужна, используйте
<CODE>format-find-file</CODE> с подходящими аргументами.
<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_25.html">previous</A>, <A HREF="emacs_27.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
</BODY>
</HTML>
