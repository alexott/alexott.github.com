<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Уничтожение и перемещение текста</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_13.html">previous</A>, <A HREF="emacs_15.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC62" HREF="emacs_toc.html#TOC62">Уничтожение и перемещение текста</A></H1>

<P>
  <EM>Уничтожение</EM> означает стирание текста и запись его в <EM>список
уничтожений</EM>, из которого он может быть получен с помощью
<EM>восстановления</EM>.  Некоторые системы, ставшие недавно популярными,
используют для обозначения этих операций термины "вырезка" и
"вставка".


<P>
  Самый распространенный способ переноса или копирования текста в Emacs
--- сначала уничтожить его, а потом восстановить в одном или нескольких
местах.  Это очень надежно, так как все уничтоженные за последнее время
куски текста запоминаются.  И это удобно, так как многочисленные команды
для уничтожения синтаксических единиц могут быть также использованы и
для их перемещения.  Но есть и другие способы копирования текста для
особых целей.


<P>
  Emacs хранит единый для всех буферов список уничтожений, так что вы
можете уничтожить текст в одном буфере и восстановить его в другом.




<H2><A NAME="SEC63" HREF="emacs_toc.html#TOC63">Удаление и уничтожение</A></H2>

<P>
<A NAME="IDX286"></A>
<A NAME="IDX287"></A>
<A NAME="IDX288"></A>
  Большинство команд, которые стирают текст из буфера, сохраняют его в
списке уничтожений, чтобы вы могли перенести или скопировать его в
другие части буфера.  Эти команды известны как команды
<EM>уничтожения</EM>.  Остальные команды, стирающие текст, не записывают
его в список уничтожений; они известны как команды <EM>удаления</EM>.
(Такое отличие делается только для стирания текста в буфере).  Если вы
уничтожили или удалили текст по ошибке, вы можете использовать команду
<KBD>C-x u</KBD> (<CODE>undo</CODE>) для отмены изменений (see section <A HREF="emacs_9.html#SEC28">Отмена сделанных изменений</A>).


<P>
  Команды удаления включают <KBD>C-d</KBD> (<CODE>delete-char</CODE>) и <KBD>DEL</KBD>
(<CODE>delete-backward-char</CODE>), которые удаляют только один знак за один
раз, и те команды, которые удаляют только пробелы или ограничители новой
строки.  Команды, которые могут уничтожить существенное количество
нетривиальных данных, обычно являются командами уничтожения.  Имена
команд и их описания используют слова <SAMP>`kill'</SAMP> и <SAMP>`delete'</SAMP>, чтобы
пояснять что они делают.




<H3><A NAME="SEC64" HREF="emacs_toc.html#TOC64">Удаление</A></H3>
<P>
<A NAME="IDX289"></A>
<A NAME="IDX290"></A>
<A NAME="IDX291"></A>
<A NAME="IDX292"></A>
<A NAME="IDX293"></A>


<DL COMPACT>

<DT><KBD>C-d</KBD>
<DD>
Удалить следующий знак (<CODE>delete-char</CODE>).
<DT><KBD><KBD>DEL</KBD></KBD>
<DD>
Удалить предыдущий знак (<CODE>delete-backward-char</CODE>).
<DT><KBD>M-\</KBD>
<DD>
Удалить все пробелы и табуляцию вокруг точки
(<CODE>delete-horizontal-space</CODE>).
<DT><KBD>M-<KBD>SPC</KBD></KBD>
<DD>
Удалить пробелы и табуляцию вокруг точки, оставляя один пробел
(<CODE>just-one-space</CODE>).
<DT><KBD>C-x C-o</KBD>
<DD>
Удалить  пустые  строки  вокруг  текущей  строки
(<CODE>delete-blank-lines</CODE>).
<DT><KBD>M-^</KBD>
<DD>
Объединить две строки, удаляя находящийся между ними ограничитель новой
строки и любой отступ, следующий за ним (<CODE>delete-indentation</CODE>).
</DL>

<P>
  Самые основные команды удаления -- это <KBD>C-d</KBD> (<CODE>delete-char</CODE>)
и <KBD>DEL</KBD> (<CODE>delete-backward-char</CODE>).  <KBD>C-d</KBD> удаляет знак
после точки, над которым находится курсор.  Точка не передвигается.
<KBD>DEL</KBD> удаляет знак перед курсором и передвигает точку назад.
Ограничитель новой строки может быть удален точно также, как и любой
другой знак в буфере.  Удаление ограничителя новой строки объединяет
две строки.  Фактически <KBD>C-d</KBD> и <KBD>DEL</KBD> не всегда являются
командами удаления; если им дать аргумент, они уничтожают, так как этим
способом они могут стереть уже более одного знака.


<P>
<A NAME="IDX294"></A>
<A NAME="IDX295"></A>
<A NAME="IDX296"></A>
<A NAME="IDX297"></A>
  Другие команды удаления -- это те, что удаляют только пробельные
знаки: пробелы, табуляцию и ограничители новых строк.  <KBD>M-\</KBD>
(<CODE>delete-horizontal-space</CODE>) удаляет все пробелы и символы табуляции
перед и после точки.  <KBD>M-<KBD>SPC</KBD></KBD> (<CODE>just-one-space</CODE>) делает
то же самое, но оставляет одиночный пробел после точки, независимо от
количества пробелов, существовавших прежде (даже если оно было равно
нулю).


<P>
  <KBD>C-x C-o</KBD> (<CODE>delete-blank-lines</CODE>) уничтожает все пустые строки
после текущей строки.  Если текущая строка пустая, то также уничтожает
все пустые строки, предшествующие текущей строке (оставляя одну пустую
строку, текущую).


<P>
  <KBD>M-^</KBD> (<CODE>delete-indentation</CODE>) объединяет текущую строку и
предшествующую ей, удаляя ограничитель новой строки и все окружающие
пробелы, обычно оставляя одиночный пробел.  See section <A HREF="emacs_25.html#SEC213">Отступы</A>.




<H3><A NAME="SEC65" HREF="emacs_toc.html#TOC65">Уничтожение строк</A></H3>

<DL COMPACT>

<DT><KBD>C-k</KBD>
<DD>
Уничтожить остаток строки, либо одну или несколько строк
(<CODE>kill-line</CODE>).
</DL>

<P>
<A NAME="IDX298"></A>
<A NAME="IDX299"></A>
  Простейшей командой уничтожения является <KBD>C-k</KBD>.  Если она дается в
начале строки, то уничтожает весь текст на строке, оставляя ее пустой.
Если команда дана на пустой строке, то уничтожает всю строку, включая ее
ограничитель.  Чтобы уничтожить непустую строку целиком, перейдите в ее
начало и нажмите <KBD>C-k</KBD> дважды.


<P>
  В более общем виде, <KBD>C-k</KBD> уничтожает все от точки вплоть до конца
строки, если это не происходит в конце строки.  В этом случае она
уничтожает ограничитель новой строки, следующий за строкой, таким
образом происходит слияние следующей строки с текущей.  При решении
вопроса о том, какой случай применять, невидимые пробелы и табуляция в
конце строки игнорируются, так, если точка выглядит стоящей в конце
строки, вы можете быть уверены, что <KBD>C-k</KBD> уничтожит перевод строки.


<P>
  Если <KBD>C-k</KBD> будет присвоен положительный аргумент, она уничтожит
ровно столько строк вместе со следующими за ними ограничителями (однако,
текст на текущей строке перед точкой сохраняется).  С отрицательным
аргументом -<VAR>n</VAR> она уничтожает <VAR>n</VAR> строк, предшествующих
текущей (вместе с текстом на текущей строке перед точкой).  Таким
образом, <KBD>C-u - 2 C-k</KBD> в начале строки уничтожает две предыдущие
строки.


<P>
  <KBD>C-k</KBD> с аргументом, равным нулю, уничтожает текст перед точкой на
текущей строке.


<P>
<A NAME="IDX300"></A>
  Если переменная <CODE>kill-whole-line</CODE> не равна <CODE>nil</CODE>, <KBD>C-k</KBD>
в самом начале строки уничтожает всю эту строку, включая последующий
перевод строки.  Эта переменная обычно равна <CODE>nil</CODE>.




<H3><A NAME="SEC66" HREF="emacs_toc.html#TOC66">Другие команды уничтожения</A></H3>
<P>
<A NAME="IDX301"></A>
<A NAME="IDX302"></A>


<DL COMPACT>

<DT><KBD>C-w</KBD>
<DD>
Уничтожить  область  (от  точки  до  метки) (<CODE>kill-region</CODE>).
<DT><KBD>M-d</KBD>
<DD>
Уничтожить слово (<CODE>kill-word</CODE>).  See section <A HREF="emacs_26.html#SEC218">Слова</A>.
<DT><KBD>M-<KBD>DEL</KBD></KBD>
<DD>
Уничтожить предыдущее слово (<CODE>backward-kill-word</CODE>).
<DT><KBD>C-x <KBD>DEL</KBD></KBD>
<DD>
Уничтожить назад до начала предложения (<CODE>backward-kill-sentence</CODE>).
See section <A HREF="emacs_26.html#SEC219">Предложения</A>.
<DT><KBD>M-k</KBD>
<DD>
Уничтожить до конца предложения (<CODE>kill-sentence</CODE>).
<DT><KBD>C-M-k</KBD>
<DD>
Уничтожить s-выражение (<CODE>kill-sexp</CODE>).  See section <A HREF="emacs_27.html#SEC251">Списки и s-выражения</A>.
<DT><KBD>M-z <VAR>знак</VAR></KBD>
<DD>
Уничтожить вплоть до следующего появления <VAR>знака</VAR>
(<CODE>zap-to-char</CODE>).
</DL>

<P>
  <KBD>C-w</KBD> (<CODE>kill-region</CODE>) -- очень распространенная команда
уничтожения, которая уничтожает все между точкой и меткой.  С помощью
этой команды вы можете уничтожить любую непрерывную последовательность
знаков, если сначала установите метку в одном ее конце и отправитесь в
другой конец.


<P>
<A NAME="IDX303"></A>
<A NAME="IDX304"></A>
  Удобный способ уничтожения -- это уничтожение скомбинированное с
поиском: <KBD>M-z</KBD> (<CODE>zap-to-char</CODE>) считывает знак и уничтожает от
точки вплоть до следующего появления этого знака (и включая его) в
буфере.  Числовой аргумент действует как счетчик повторов.
Отрицательный аргумент означает поиск в обратную сторону и уничтожение
текста перед точкой.


<P>
  Могут уничтожаться другие синтаксические единицы: слова, с помощью
<KBD>M-<KBD>DEL</KBD></KBD> и <KBD>M-d</KBD> (see section <A HREF="emacs_26.html#SEC218">Слова</A>); s-выражения, с помощью
<KBD>C-M-k</KBD> (see section <A HREF="emacs_27.html#SEC251">Списки и s-выражения</A>); и предложения, с помощью <KBD>C-x
<KBD>DEL</KBD></KBD> и <KBD>M-k</KBD> (see section <A HREF="emacs_26.html#SEC219">Предложения</A>).


<P>
  Вы можете использовать команды уничтожения в буферах, доступных только
для чтения.  На самом деле они не изменяют буфер и подают звуковой
сигнал, чтобы предупредить вас об этом, но они действительно копируют
текст, который вы попытались уничтожить, в список уничтожений, так что
вы можете восстановить его в других буферах.  Большинство команд
уничтожения передвигают точку по тексту, который они копируют таким
способом, поэтому последовательные команды уничтожения, как обычно,
создают единое вхождение в списке уничтожений.




<H2><A NAME="SEC67" HREF="emacs_toc.html#TOC67">Восстановление</A></H2>
<P>
<A NAME="IDX305"></A>
<A NAME="IDX306"></A>
<A NAME="IDX307"></A>
<A NAME="IDX308"></A>
<A NAME="IDX309"></A>


<P>
  <EM>Восстановление</EM> возвращает обратно текст, который был ранее
уничтожен.  Это то же самое, что в других системах называется
"вставкой".  Обычный способ копирования или перемещения текста ---
уничтожить его, а затем восстановить один или несколько раз.


<DL COMPACT>

<DT><KBD>C-y</KBD>
<DD>
Восстановить последний уничтоженный текст (<CODE>yank</CODE>).
<DT><KBD>M-y</KBD>
<DD>
Заменить только что восстановленный текст предшествующим куском
уничтоженного текста (<CODE>yank-pop</CODE>).
<DT><KBD>M-w</KBD>
<DD>
Сохранить область как последний уничтоженный текст без фактического
уничтожения (<CODE>kill-ring-save</CODE>).
<DT><KBD>C-M-w</KBD>
<DD>
Добавить следующее уничтожение к последнему куску уничтоженного текста
(<CODE>append-next-kill</CODE>).
</DL>



<H3><A NAME="SEC68" HREF="emacs_toc.html#TOC68">Список уничтожений</A></H3>

<P>
  Весь уничтоженный текст записывается в <EM>кольцевой список
уничтожений</EM>, список блоков текста, который был уничтожен.  Существует
только один список уничтожений, используемый во всех буферах, таким
образом вы можете уничтожить текст в одном буфере и восстановить его в
другом.  Это обычный способ перемещения текста из одного файла в другой.
(See section <A HREF="emacs_14.html#SEC71">Накопление текста</A>, для получения информации о других способах).


<P>
<A NAME="IDX310"></A>
<A NAME="IDX311"></A>
  Команда <KBD>C-y</KBD> (<CODE>yank</CODE>) вновь вставляет текст, уничтоженный
самым последним.  Она оставляет курсор в конце текста, метка
устанавливается в его начале.  See section <A HREF="emacs_13.html#SEC55">Пометка и область</A>.


<P>
  <KBD>C-u C-y</KBD> оставляет курсор перед текстом и устанавливает метку
после него.  Это происходит, только если аргумент задан с помощью просто
<KBD>C-u</KBD>.  Любой другой вид аргумента, включая <KBD>C-u</KBD> и цифры,
обозначают восстановление уничтоженного ранее (see section <A HREF="emacs_14.html#SEC70">Восстановление ранее уничтоженного</A>).


<P>
<A NAME="IDX312"></A>
<A NAME="IDX313"></A>
  Если вы хотите скопировать блок текста, вы можете использовать
<KBD>M-w</KBD> (<CODE>kill-ring-save</CODE>), которая копирует область в список
уничтожений без удаления его из буфера.  Это приблизительный эквивалент
<KBD>C-w</KBD>, за которой следует <KBD>C-x u</KBD>, за исключением того, что
<KBD>M-w</KBD> не изменяет историю восстановлений и не изменяет на время
экран.




<H3><A NAME="SEC69" HREF="emacs_toc.html#TOC69">Добавление уничтожений</A></H3>

<P>
<A NAME="IDX314"></A>
<A NAME="IDX315"></A>
  Обычно каждая команда уничтожения добавляет новый блок в список
уничтожений.  Однако, две или более команды уничтожения подряд
объединяют текст в единый элемент, так что одиночная <KBD>C-y</KBD> возьмет
весь его обратно таким, каким он был перед уничтожением.


<P>
  Таким образом, если вы хотите восстановить текст как одно целое, вы не
должны уничтожать весь этот текст одной командой; вы можете продолжать
уничтожение строки за строкой или слова за словом до тех пор, пока не
уничтожите весь текст полностью, и вы можете получить его обратно сразу
целиком.


<P>
  Команды, которые уничтожают текст вперед от точки, добавляют
уничтоженное в конец предыдущего уничтоженного текста.  Команды, которые
уничтожают назад от точки, добавляют это в начало.  Таким образом, любая
последовательность смешанных команд уничтожения перед точкой и после нее
объединяет весь уничтоженный текст в один элемент без переупорядочения.
Числовой аргумент не прерывает последовательность добавления
уничтожений.  Например, предположим, что буфер содержит такой текст:



<PRE>
Это пример строки -!-с образцом текста.
</PRE>

<P>
с точкой, показанной как -!-.  Если вы наберете <KBD>M-d
M-<KBD>DEL</KBD> M-d M-<KBD>DEL</KBD></KBD>, уничтожая по очереди вперед и назад, то в
конце получите <SAMP>`пример строки с образцом'</SAMP> в качестве одного
вхождения в списке уничтожений и <SAMP>`Это  текста.'</SAMP> в буфере.
(Обратите внимание на двойной пробел, который вы можете очистить с
помощью <KBD>M-<KBD>SPC</KBD></KBD> или <KBD>M-q</KBD>.)


<P>
  Другой способ уничтожить тот же текст -- переместиться назад на два
слова с помощью <KBD>M-b M-b</KBD> и уничтожить все четыре слова вперед
командой <KBD>C-u M-d</KBD>.  Это дает такой же результат в буфере и в списке
уничтожений.  <KBD>M-f M-f C-u M-<KBD>DEL</KBD></KBD> уничтожает тот же текст,
проходя все время назад; и опять результат будет тем же.  Текст в
элементе списка уничтожений всегда имеет тот же порядок, что он имел в
буфере до того, как вы его уничтожили.


<P>
<A NAME="IDX316"></A>
<A NAME="IDX317"></A>
  Если команда уничтожения отделена от предыдущей другими командами (не
просто числовым аргументом), то она начинает новый элемент в списке
уничтожений.  Но вы можете заставить эту команду уничтожения добавлять
текст к предыдущему элементу, набрав перед ней команду <KBD>C-M-w</KBD>
(<CODE>append-next-kill</CODE>).  <KBD>C-M-w</KBD> приказывает следующей команде,
если это команда уничтожения, добавить уничтоженный ею текст к
последнему уничтоженному тексту вместо того, чтобы начинать новый
элемент.  С помощью <KBD>C-M-w</KBD> вы можете уничтожить несколько отдельных
кусков текста и накопить их для дальнейшего восстановления в одном
месте.


<P>
  Команда уничтожения, следующая после <KBD>M-w</KBD>, не добавляет к тексту,
который <KBD>M-w</KBD> скопировала в список уничтожений.




<H3><A NAME="SEC70" HREF="emacs_toc.html#TOC70">Восстановление ранее уничтоженного</A></H3>

<P>
<A NAME="IDX318"></A>
<A NAME="IDX319"></A>
<A NAME="IDX320"></A>
  Для того чтобы вернуть уничтоженный текст, который уже не является
последним уничтоженным, используйте команду <KBD>M-y</KBD> (<CODE>yank-pop</CODE>).
Она берет прежде восстановленный текст, и заменяет его текстом более
раннего уничтожения.  Так, чтобы вернуть текст, предшествующий
последнему уничтоженному, сначала используйте <KBD>C-y</KBD>, чтобы
восстановить последнее уничтожение, а затем <KBD>M-y</KBD>, чтобы заменить
его предыдущим.  <KBD>M-y</KBD> может использоваться только после <KBD>C-y</KBD>
или другой <KBD>M-y</KBD>.


<P>
  <KBD>M-y</KBD> можно понимать в терминах указателя на "последнее
восстановление", который указывает на элемент в списке уничтожения.
Каждый раз, когда вы уничтожаете, указатель на "последнее
восстановление" передвигается в последний созданный элемент в начале
списка.  <KBD>C-y</KBD> восстанавливает элемент, на который ссылается
указатель "последнего восстановления".  <KBD>M-y</KBD> двигает указатель на
"последнее восстановление" к другому элементу, и текст в буфере
соответственно изменяется.  Достаточное количество команд <KBD>M-y</KBD>
может переместить указатель к любому элементу в списке, таким образом,
вы можете получить любой элемент в буфере.  Когда наконец указатель
достигает последнего элемента списка, следующая команда <KBD>M-y</KBD> снова
помещает его на первый элемент.


<P>
  <KBD>M-y</KBD> двигает указатель на "последнее восстановление" по списку,
но это не меняет порядок элементов, которые всегда идут от самого
последнего уничтожения до самого старого, которое еще хранится.


<P>
  <KBD>M-y</KBD> может получить числовой аргумент, который говорит, на
сколько элементов вперед продвинуть указатель на "последнее
восстановление".  Отрицательный аргумент двигает этот указатель по
направлению к началу списка; от начала списка он двигает к последнему
элементу и продолжает движение вперед оттуда.


<P>
  Как только искомый текст помещен в буфер, вы можете прекратить
запускать команды <KBD>M-y</KBD>, и текст останется там.  Это просто копия
элемента списка уничтожения, поэтому редактирование его в буфере не
изменяет содержимое этого списка.  До тех пор, пока не делается новое
уничтожение, указатель на "последнее восстановление" остается в том же
самом месте в списке уничтожений, таким образом, повторение <KBD>C-y</KBD>
восстановит еще одну копию того же самого старого уничтожения.


<P>
  Если вы знаете, сколько команд <KBD>M-y</KBD> необходимо набрать, чтобы
найти интересующий вас текст, вы можете восстановить этот текст за один
шаг, используя <KBD>C-y</KBD> с числовым аргументом.  <KBD>C-y</KBD> с аргументом
восстанавливает текст, записанный в списке уничтожения на заданное число
элементов назад.  Таким образом, <KBD>C-u 2 C-y</KBD> достает следующий за
последним блок уничтоженного текста.  Это эквивалентно <KBD>C-y M-y</KBD>.
<KBD>C-y</KBD> c числовым аргументом начинает подсчет от указателя на
"последнее восстановление" и устанавливает этот указатель на элемент,
который эта команда восстанавливает.


<P>
<A NAME="IDX321"></A>
  Длина списка уничтожений управляется переменной <CODE>kill-ring-max</CODE>;
не может быть записано больше блоков текста, чем определено этой
величиной.


<P>
<A NAME="IDX322"></A>
  Действительное содержимое списка уничтожений хранится в переменной
<CODE>kill-ring</CODE>; вы можете просмотреть все содержимое списка
уничтожений с помощью команды <KBD>C-h v kill-ring</KBD>.




<H2><A NAME="SEC71" HREF="emacs_toc.html#TOC71">Накопление текста</A></H2>
<P>
<A NAME="IDX323"></A>
<A NAME="IDX324"></A>
<A NAME="IDX325"></A>
<A NAME="IDX326"></A>


<P>
<A NAME="IDX327"></A>
  Обычно мы копируем или переносим текст путем его уничтожения и
восстановления, но существуют и другие способы, удобные для копирования
одного блока текста во многие места или для копирования многих
рассеянных блоков текста в одно место.  Чтобы скопировать один блок во
много мест, запишите его в регистр (see section <A HREF="emacs_15.html#SEC73">Регистры</A>).  Здесь мы
описываем команды для накопления разбросанных кусков текста в буфер или
в файл.


<DL COMPACT>

<DT><KBD>M-x append-to-buffer</KBD>
<DD>
Добавить область в заданный буфер после точки.
<DT><KBD>M-x prepend-to-buffer</KBD>
<DD>
Добавить область в заданный буфер перед точкой.
<DT><KBD>M-x copy-to-buffer</KBD>
<DD>
Копировать область в заданный буфер, удаляя старое содержимое буфера.
<DT><KBD>M-x insert-buffer</KBD>
<DD>
Вставить содержимое заданного буфера в текущий буфер в точке.
<DT><KBD>M-x append-to-file</KBD>
<DD>
Добавить область в конец заданного файла.
</DL>

<P>
  Для накопления текста в буфере используется <KBD>M-x
append-to-buffer</KBD>.  Она считывает имя буфера, а затем вставляет в этот
буфер копию области.  Если буфер с таким именем не существует, то
<CODE>append-to-buffer</CODE> создаст его.  Текст вставляется в то место в
этом буфере, где находится точка.  Если вы использовали этот буфер для
редактирования, скопированный текст вставляется в середину текста, где
оказалась точка.


<P>
  Точка в этом буфере остается в конце копируемого текста, таким
образом, последовательное использование <CODE>append-to-buffer</CODE>
накапливает текст в заданном буфере в том же самом порядке, в котором
части были скопированы.  Строго говоря, <CODE>append-to-buffer</CODE> не
всегда добавляет к тексту, уже находящемуся в буфере -- она добавляет,
если точка находится в конце этого буфера.  Однако, если
<CODE>append-to-buffer</CODE> является единственной командой, которую вы
используете для изменения буфера, точка всегда расположена в конце.


<P>
  <KBD>M-x prepend-to-buffer</KBD> подобна <CODE>append-to-buffer</CODE> за
исключением того, что точка в другом буфере остается перед скопированным
текстом, таким образом, последовательное применение этой команды
добавляет текст в обратном порядке.  <KBD>M-x copy-to-buffer</KBD> действует
так же, за исключением того, что любой существующий текст в другом
буфере удаляется, так что в буфере остается лишь вновь скопированный
текст.


<P>
  Чтобы вернуть накопленный текст из другого буфера, используйте команду
<KBD>M-x insert-buffer</KBD>; она также принимает имя буфера как
аргумент. Эта команда вставляет копию текста из буфера с заданным именем
в выбранный буфер.  Или вы можете выбрать другой буфер для
редактирования, возможно, перемещая впоследствии текст из него путем
уничтожения.  See section <A HREF="emacs_20.html#SEC162">Использование множества буферов</A>, для получения базовой информации о буферах.


<P>
  Вместо накопления текста внутри буфера Emacs вы можете добавить текст
непосредственно в файл с помощью команды <KBD>M-x append-to-file</KBD>,
которая использует имя файла в качестве аргумента.  Она добавляет текст
области в конец заданного файла.  Файл на диске изменяется сразу.


<P>
  Вы должны использовать <CODE>append-to-file</CODE> только с файлами, к
которым вы <EM>не</EM> обращаетесь из Emacs.  Использование этой команды
для файла, к которому обратились из Emacs, может изменить файл без
ведома Emacs, что может привести к потере некоторых результатов вашего
редактирования.




<H2><A NAME="SEC72" HREF="emacs_toc.html#TOC72">Прямоугольники</A></H2>
<P>
<A NAME="IDX328"></A>
<A NAME="IDX329"></A>
<A NAME="IDX330"></A>
@hyphenation{пря-мо-уголь-ни-ка пря-мо-уголь-ник пря-мо-уголь-ни-ки 
  пря-мо-уголь-ни-ков}


<P>
  Команды для прямоугольников работают с прямоугольными областями
текста: всеми знаками между определенной парой столбцов в определенном
диапазоне строк.  Эти команды предназначены для уничтожения
прямоугольников, восстановления уничтоженных прямоугольников, их
очистки, заполнения пробелами или текстом, или удаления.  Команды для
прямоугольников полезны для работы с текстом в многоколоночных форматах
и для приведения текста к такому формату или извлечения из него.


<P>
  Когда вам нужно задать прямоугольник для команды, которая будет с ним
работать, вы делаете это, устанавливая метку в одном углу и точку в
противоположном.  Прямоугольник, описанный таким образом, называется
<EM>областью-прямоугольником</EM>, так как вы управляете им почти так же,
как и областью.  Но помните, что данная комбинация значений точки и
метки может быть интерпретирована и как область, и как прямоугольник в
зависимости от команды, которая их использует.


<P>
  Если точка и метка находятся на одном столбце, то прямоугольник,
который они ограничивают, пуст.  Если они находятся на одной строке, то
прямоугольник имеет высоту в одну строку.  Эта несимметричность между
строками и столбцами происходит из того, что точка (и метка)
располагается между двух столбцов, но внутри строки.


<DL COMPACT>

<DT><KBD>C-x r k</KBD>
<DD>
Уничтожить текст области-прямоугольника, сохраняя его содержимое в
качестве "последнего уничтоженного прямоугольника"
(<CODE>kill-rectangle</CODE>).
<DT><KBD>C-x r d</KBD>
<DD>
Удалить текст области-прямоугольника (<CODE>delete-rectangle</CODE>).
<DT><KBD>C-x r y</KBD>
<DD>
Восстановить последний уничтоженный прямоугольник, помещая его верхний
левый угол в точке (<CODE>yank-rectangle</CODE>).
<DT><KBD>C-x r o</KBD>
<DD>
Вставить пустое место, заполняя пространство области-прямоугольника
(<CODE>open-rectangle</CODE>).  Предыдущее содержимое области-прямоугольника
выталкивается вправо.
<DT><KBD>M-x clear-rectangle</KBD>
<DD>
Очистить область-прямоугольник, заменяя ее содержимое пробелами.
<DT><KBD>M-x delete-whitespace-rectangle</KBD>
<DD>
Удалить пробельные знаки в каждой строке заданного прямоугольника,
начиная с его самого левого столбца.
<DT><KBD>C-x r t <VAR>строка</VAR> <KBD>RET</KBD></KBD>
<DD>
Вставить <VAR>строку</VAR> в каждую строку области-прямоугольника
(<CODE>string-rectangle</CODE>).
</DL>

<P>
  Операции, работающие с прямоугольниками, делятся на два класса:
команды удаления и вставки прямоугольников и команды для пустых
прямоугольников.


<P>
<A NAME="IDX331"></A>
<A NAME="IDX332"></A>
<A NAME="IDX333"></A>
<A NAME="IDX334"></A>
  Существует два способа избавиться от текста в прямоугольнике: вы
можете сбросить (удалить) его или записать его как "последний
уничтоженный" прямоугольник.  Для этого используются две команды
<KBD>C-x r d</KBD> (<CODE>delete-rectangle</CODE>) и <KBD>C-x r k</KBD>
(<CODE>kill-rectangle</CODE>).  В обоих случаях часть каждой строки, которая
попала внутрь границ прямоугольника, удаляется, заставляя последующий
текст в строке (если он существует) сдвигаться влево.


<P>
  Заметьте, что "уничтожение" прямоугольника не есть уничтожение в
обычном понимании; этот прямоугольник хранится не в списке уничтожений,
а в специальном месте, которое в состоянии записать только самое
последнее уничтожение прямоугольника.  Это происходит из-за того, что
восстановление прямоугольника настолько отличается от восстановления
линейного текста, что для этого должны использоваться другие команды
восстановления, и в этом случае трудно приписать смысл команде, выдающей
более ранние уничтожения.


<P>
<A NAME="IDX335"></A>
<A NAME="IDX336"></A>
  Чтобы вставить последний уничтоженный прямоугольник, наберите <KBD>C-x
r y</KBD> (<CODE>yank-rectangle</CODE>).  Восстановление прямоугольника -- это
противоположность уничтожения.  Левый верхний угол задается положением
точки.  Туда помещается первая строка прямоугольника, вторая строка
прямоугольника помещается в позиции точки, но строкой ниже, и так далее.
Число затронутых строк определяется высотой записанного прямоугольника.


<P>
  Вы можете превратить списки из одной колонки в списки из двух колонок,
используя уничтожение и восстановление прямоугольников; уничтожьте
вторую половину списка как прямоугольник и затем восстановите его рядом
с первой строчкой списка.  See section <A HREF="emacs_35.html#SEC433">Редактирование текста в две колонки</A>, другой способ
редактировать двухколоночный текст.


<P>
  Прямоугольники также могут быть скопированы в регистры и из регистров
с помощью <KBD>C-x r r <VAR>r</VAR></KBD> и <KBD>C-x r i <VAR>r</VAR></KBD>.
See section <A HREF="emacs_15.html#SEC76">Запись прямоугольников в регистры</A>.


<P>
<A NAME="IDX337"></A>
<A NAME="IDX338"></A>
<A NAME="IDX339"></A>
  Есть две команды для работы с пустыми прямоугольниками: <KBD>M-x
clear-rectangle</KBD>, чтобы расписать пробелами существующий текст, и
<KBD>C-x r o</KBD> (<CODE>open-rectangle</CODE>), чтобы вставить пустой
прямоугольник.  Очистка прямоугольника эквивалентна его удалению с
последующей вставкой на его место пустого прямоугольника такого же
размера.


<P>
<A NAME="IDX340"></A>
  Команда <KBD>M-x delete-whitespace-rectangle</KBD> удаляет горизонтальное
пустое пространство, начиная с определенного столбца.  Это относится к
каждой строке в прямоугольнике, а столбец задается левым краем
прямоугольника.  Правый край прямоугольника не имеет значения для этой
команды.


<P>
<A NAME="IDX341"></A>
<A NAME="IDX342"></A>
  Команда <KBD>C-x r t</KBD> (<CODE>M-x string-rectangle</CODE>) замещает
прямоугольник заданной строкой (вставляя ее один раз в каждую строку).
Ширина строки не обязана совпадать с шириной прямоугольника.  Если
ширина строки меньше, текст после прямоугольника смещается влево; если
строка шире прямоугольника, текст после него смещается вправо.


<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_13.html">previous</A>, <A HREF="emacs_15.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
</BODY>
</HTML>
