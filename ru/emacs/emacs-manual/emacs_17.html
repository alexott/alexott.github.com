<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Поиск и замена</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_16.html">previous</A>, <A HREF="emacs_18.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC89" HREF="emacs_toc.html#TOC89">Поиск и замена</A></H1>
<P>
<A NAME="IDX428"></A>
<A NAME="IDX429"></A>


<P>
  Как и в других редакторах, в Emacs есть команды для поиска случаев
появления какой-нибудь строки.  Основная команда поиска необычна тем,
что она является <EM>наращиваемой</EM>; она начинает поиск до того, как вы
закончили набор строки поиска.  Существуют также команды и для
ненаращиваемого поиска, более похожие на аналогичные команды в других
редакторах.


<P>
  Кроме обычной команды <CODE>replace-string</CODE>, которая находит все
случаи появления одной строки и заменяет их другой, Emacs имеет более
сложную команду замены, названную <CODE>query-replace</CODE>, которая
запрашивает в интерактивном режиме, в каких случаях надо произвести
замену.




<H2><A NAME="SEC90" HREF="emacs_toc.html#TOC90">Наращиваемый поиск</A></H2>

<P>
<A NAME="IDX430"></A>
  Наращиваемый поиск начинается, как только вы набрали первый знак
строки поиска.  По мере того, как вы набираете строку поиска, Emacs
показывает вам, где эта строка (в том виде, в каком вы ее уже набрали)
может быть найдена.  Когда вы набрали достаточно знаков, чтобы
определить желаемое место, вы можете остановиться.  В зависимости от
того, что вы собираетесь делать потом, вам может понадобиться, а может и
не понадобиться прекратить поиск явно с помощью <KBD>RET</KBD>.


<DL COMPACT>

<DT><KBD>C-s</KBD>
<DD>
Наращиваемый поиск вперед (<CODE>isearch-forward</CODE>).
<DT><KBD>C-r</KBD>
<DD>
Наращиваемый поиск в обратном направлении (<CODE>isearch-backward</CODE>).
</DL>

<P>
<A NAME="IDX431"></A>
<A NAME="IDX432"></A>
  <KBD>C-s</KBD> начинает наращиваемый поиск.  <KBD>C-s</KBD> считывает знаки с
клавиатуры и располагает курсор в первом месте появления знаков, которые
вы набрали.  Если вы наберете <KBD>C-s</KBD> и затем <KBD>F</KBD>, то курсор
встанет справа после первой найденной <SAMP>`F'</SAMP>.  Наберите <KBD>О</KBD>, и
увидите, что курсор встал за первой найденной <SAMP>`FO'</SAMP>.  После еще
одной <KBD>О</KBD> курсор встанет за первой <SAMP>`FOO'</SAMP>, находящейся за
местом, с которого вы начали поиск.  На каждом шаге текст буфера,
совпадающий со строкой поиска, подсвечивается, если терминал может это
сделать; текущая строка поиска обновляется на каждом шаге в эхо-области.


<P>
  Если вы сделали ошибку в наборе строки поиска, то вы можете сбросить
знаки с помощью <KBD>DEL</KBD>.  Каждый <KBD>DEL</KBD> отменяет последний знак
строки поиска.  Этого не происходит до тех пор, пока Emacs не будет
готов считать следующий вводимый знак; сначала знак, который вы хотите
сбросить, должен быть либо найден, либо нет.  Если же вы не хотите
ждать, пока это произойдет, используйте <KBD>C-g</KBD> так, как описано ниже.


<P>
  Когда вы будете удовлетворены достигнутым местом, вы можете набрать
<KBD>RET</KBD>, что остановит поиск, оставляя курсор там, куда его поместила
команда поиска.  Любая команда, не имеющая специального значения при
поиске, также останавливает поиск и затем выполняется сама.  Таким
образом, набор <KBD>C-a</KBD> привел бы к выходу из поиска и затем передвинул
бы курсор в начало строки.  <KBD>RET</KBD> необходим только в том случае,
если следующая команда, которую вы хотите набрать, является печатным
знаком, <KBD>DEL</KBD>, <KBD>RET</KBD> или другим управляющим знаком, имеющим
особое значение во время работы поиска (<KBD>C-q</KBD>, <KBD>C-w</KBD>, <KBD>C-r</KBD>,
<KBD>C-s</KBD>, <KBD>C-y</KBD>, <KBD>M-y</KBD>, <KBD>M-r</KBD> или <KBD>M-s</KBD>).


<P>
  Иногда вы ищете слово <SAMP>`FOO'</SAMP> и находите его, но это не то, что вам
нужно.  Было второе <SAMP>`FOO'</SAMP>, о котором вы забыли, находящееся перед
тем, которое вы ищете.  В этом случае наберите <KBD>C-s</KBD> еще раз, чтобы
продвинуться к следующему появлению строки поиска.  Это можно
проделывать неограниченное число раз.  Если вы проскочили, то можете
отменить некоторые число знаков <KBD>C-s</KBD> с помощью <KBD>DEL</KBD>.


<P>
  После выхода из поиска вы можете снова искать ту же самую строку,
просто набрав <KBD>C-s C-s</KBD>: первый <KBD>C-s</KBD> -- это ключ, который
запускает наращиваемый поиск, а второй <KBD>C-s</KBD> означает "повтор
поиска".


<P>
  Чтобы вы могли снова использовать более ранние строки поиска,
существует <EM>список поиска</EM>.  Команды <KBD>M-p</KBD> и <KBD>M-n</KBD>
передвигают по списку, чтобы вы могли подобрать нужную строку для
повторного поиска.  Эти команды оставляют выбранную строку поиска в
минибуфере, где вы можете ее отредактировать.  Для завершения
редактирования и начала поиска наберите <KBD>C-s</KBD> или <KBD>C-r</KBD>.


<P>
  Если ваша строка вообще не найдена, то эхо-область говорит
<SAMP>`Failing I-Search'</SAMP>.  Курсор располагается после того места, где
Emacs нашел из вашей строки вс╠, что смог.  Таким образом, если вы ищете
<SAMP>`FOOT'</SAMP>, а такой строки нет, вы можете увидеть курсор после
<SAMP>`FOO'</SAMP> в слове <SAMP>`FOOL'</SAMP>.  С этого места вы можете сделать
несколько вещей.  Если ваша строка неправильно набрана, вы можете что-то
стереть из нее и исправить.  Если вы довольны найденным местом, вы
можете набрать <KBD>RET</KBD> или любую другую команду Emacs, чтобы "принять
то, что предложил этот поиск", или вы можете набрать <KBD>C-g</KBD>, что
уничтожит из строки поиска знаки, которые не были найдены (<SAMP>`Т'</SAMP> в
<SAMP>`FOOT'</SAMP>), оставляя те, что нашлись (<SAMP>`FOO'</SAMP> в <SAMP>`FOOT'</SAMP>).
Второй <KBD>C-g</KBD> в этом месте отменяет поиск полностью, возвращая точку
туда, где она была, когда поиск начался.


<P>
  Если строка поиска содержит заглавную букву, то поиск производится с
учетом регистра.  Если вы удалите заглавные буквы из строки поиска, эта
особенность исчезает.  See section <A HREF="emacs_17.html#SEC96">Поиск и регистр букв</A>.


<P>
  Если поиск был неудачным и вы просите повторить его, набирая <KBD>C-s</KBD>
еще раз, то он начинается снова с начала буфера.  Повторение неудачного
поиска в обратном направлении при помощи команды <KBD>C-r</KBD> начинает
новый поиск с конца.  Такой поиск называется <EM>круговым</EM>.  Как только
это произошло, в подсказке поиска появляется слово <SAMP>`Wrapped'</SAMP>.  Если
вы пройдете через точку, где начался поиск, это слово заменяется на
<SAMP>`Overwrapped'</SAMP>, что означает, что вы снова проходите через уже
виденные вами совпадения.


<P>
<A NAME="IDX433"></A>
  Знак "выхода" <KBD>C-g</KBD> поступает во время поиска особым образом.
Что именно он делает, зависит от статуса поиска.  Если поиск нашел то,
что вы хотели, и ожидает ввода, то <KBD>C-g</KBD> полностью отменяет поиск.
Курсор возвращается туда, откуда вы начали поиск.  Если <KBD>C-g</KBD>
набирается, когда в строке поиска есть ненайденные знаки -- Emacs все
еще ищет их, или он не смог их найти -- тогда эти ненайденные знаки
сбрасываются из строки поиска.  Сброс этих знаков делает поиск успешным,
и он ждет дальнейшего ввода, таким образом, второй <KBD>C-g</KBD> отменит
поиск полностью.


<P>
  Чтобы найти символ перевода строки, введите <KBD>C-j</KBD>.  Для поиска
другого управляющего знака, такого как control-S или возврат каретки, вы
должны отменить их специальное значение, набирая перед ними <KBD>C-q</KBD>.
Эта функция <KBD>C-q</KBD> аналогична ее назначению как команды для вставки
(see section <A HREF="emacs_9.html#SEC25">Вставка текста</A>): она заставляет трактовать следующий знак так,
как в этом контексте трактовался бы любой "обычный" знак.  Вы также
можете задать знак по его восьмиричному коду: введите <KBD>C-q</KBD> и затем
последовательность восьмиричных цифр.


<P>
  Вы можете изменить направление поиска на обратное при помощи
<KBD>C-r</KBD>.  Вам следует поступить так, если поиск оказался неудачным,
потому что место, с которого вы его начали, находилось слишком близко к
концу файла.  Повторение <KBD>C-r</KBD> продолжает поиск следующих случаев
появления в обратном порядке, а <KBD>C-s</KBD> начинает поиск опять вперед.
<KBD>C-r</KBD> в поиске может быть отменена при помощи <KBD>DEL</KBD>.


<P>
<A NAME="IDX434"></A>
<A NAME="IDX435"></A>
  Если вы заранее знаете, что вам нужно вести поиск в обратном порядке,
то чтобы начать поиск, вы можете использовать <KBD>C-r</KBD> вместо
<KBD>C-s</KBD>, так как <KBD>C-r</KBD> также является ключом, запускающим команду
(<CODE>isearch-backward</CODE>) для поиска в обратном порядке.  Обратный поиск
находит совпадения, которые расположены перед начальной точкой, так же
как поиск вперед находит совпадения, начинающиеся после точки, где поиск
начался.


<P>
  Знаки <KBD>C-y</KBD> и <KBD>C-w</KBD> могут использоваться в наращиваемом
поиске для захвата текста из буфера в строку поиска.  Это делает удобным
поиск другого случая появления того текста, который находится в точке.
<KBD>C-w</KBD> копирует слово после точки в строку поиска, продвигая точку
вперед через это слово.  Следующая команда <KBD>C-s</KBD> для повторения
поиска будет затем искать строку, включающую это слово.  <KBD>C-y</KBD>
подобна <KBD>C-w</KBD>, только копирует в строку поиска весь остаток текущей
строки.  И <KBD>C-y</KBD>, и <KBD>C-w</KBD> преобразуют копируемый текст к нижнему
регистру, если поиск сейчас ведется без учета регистра; таким образом
поиск остается регистронезависимым.


<P>
  Команда <KBD>M-y</KBD> копирует в строку поиска текст из списка
уничтожений.  Она использует тот же текст, который был бы восстановлен
командой <KBD>C-y</KBD>.  See section <A HREF="emacs_14.html#SEC67">Восстановление</A>.


<P>
  Когда вы выходите из наращиваемого поиска, метка устанавливается в то
место, где точка <EM>была</EM> до начала поиска.  Это удобно для возврата
к этому месту.  В режиме Transient Mark наращиваемый поиск устанавливает
метку, не активизируя ее, если только метка уже не активна.


<P>
<A NAME="IDX436"></A>
  Чтобы настроить специальные знаки, которые понимает наращиваемый
поиск, измените их привязки в таблице ключей <CODE>isearch-mode-map</CODE>.
Для получения перечня привязок посмотрите документацию на
<CODE>isearch-mode</CODE> с помощью <KBD>C-h f isearch-mode <KBD>RET</KBD></KBD>.




<H3><A NAME="SEC91" HREF="emacs_toc.html#TOC91">Наращиваемый поиск на медленном терминале</A></H3>

<P>
  Наращиваемый поиск на медленных терминалах использует модифицированный
способ отображения, который разработан так, чтобы занимать как можно
меньше времени.  Вместо показа буфера в каждом месте, до которого
добрался поиск, он создает новое окно, состоящее из одиночной строки, и
использует его для показа найденной строки.  Это окно из одной строки
вступает в игру, как только точка выходит за пределы текста, который уже
находится на экране.


<P>
  Когда вы прерываете поиск, однострочное окно убирается.  Только в этот
момент Emacs перерисовывает окно, в котором производился поиск, чтобы
отобразить новое положение точки.


<P>
<A NAME="IDX437"></A>
  Такой стиль отображения используется, когда скорость терминала в бодах
меньше или равна значению переменной <CODE>search-slow-speed</CODE>, чье
начальное значение равно 1200.


<P>
<A NAME="IDX438"></A>
  Количество строк, показываемых при поиске на медленном терминале,
управляется переменной <CODE>search-slow-window-lines</CODE>.  Ее обычное
значение равно единице.




<H2><A NAME="SEC92" HREF="emacs_toc.html#TOC92">Ненаращиваемый поиск</A></H2>
<P>
<A NAME="IDX439"></A>


<P>
  В Emacs также есть удобные команды ненаращиваемого поиска, которые
требуют от вас полностью набрать строку поиска до начала работы.


<DL COMPACT>

<DT><KBD>C-s <KBD>RET</KBD> <VAR>строка</VAR> <KBD>RET</KBD></KBD>
<DD>
Поиск заданной <VAR>строки</VAR>.
<DT><KBD>C-r <KBD>RET</KBD> <VAR>строка</VAR> <KBD>RET</KBD></KBD>
<DD>
Поиск <VAR>строки</VAR> в обратном направлении.
</DL>

<P>
  Чтобы начать ненаращиваемый поиск, наберите сначала <KBD>C-s
<KBD>RET</KBD></KBD>.  Эта команда входит в минибуфер для считывания строки
поиска; ограничьте эту строку с помощью <KBD>RET</KBD>, и поиск начнется.
Если строка не будет найдена, команда поиска выдает ошибку.


<P>
  Способ работы <KBD>C-s <KBD>RET</KBD></KBD> заключается в следующем: <KBD>C-s</KBD>
запускает наращиваемый поиск, который специально запрограммирован так,
что запускает ненаращиваемый поиск, если заданный вами аргумент является
пустым.  (Такой пустой аргумент в других случаях был бы бесполезен).
<KBD>C-r <KBD>RET</KBD></KBD> работает аналогично.


<P>
  Однако, запрошенный с помощью <KBD>C-s <KBD>RET</KBD></KBD> ненаращиваемый поиск
не запускает непосредственно <CODE>search-forward</CODE>.  Первым делом
проверяется, не будет ли следующим знаком <KBD>C-w</KBD>, что запустит поиск
слов.


<P>
<A NAME="IDX440"></A>
<A NAME="IDX441"></A>
  Прямой и обратный ненаращиваемый поиск осуществляются командами
<CODE>search-forward</CODE> и <CODE>search-backward</CODE>.  Эти команды могут быть
привязаны к ключам обычным способом.  Возможность их запуска через
наращиваемый поиск имеет исторические причины и, помимо этого,
существует для того, чтобы вам не нужно было находить для них подходящие
последовательности ключей.




<H2><A NAME="SEC93" HREF="emacs_toc.html#TOC93">Поиск слов</A></H2>
<P>
<A NAME="IDX442"></A>


<P>
  Поиск по словам применяется для отыскания последовательности слов
независимо от того, как эти слова разделены.  Более подробно, вы
набираете строку из нескольких слов, используя для их разделения
одиночные пробелы, и эта строка может быть найдена, даже если в
оригинале слова разделены несколькими пробелами, переводами строки, либо
любыми знаками препинания.


<P>
  Поиск слов полезен при редактировании печатных документов,
подготовленных в программах для форматирования текста.  Если вы
редактируете, просматривая уже напечатанную, отформатированную версию,
то вы не можете сказать, где прерывается строка в исходом файле.  При
помощи же поиска слова вы можете искать, не имея этой информации.


<DL COMPACT>

<DT><KBD>C-s <KBD>RET</KBD> C-w <VAR>слова</VAR> <KBD>RET</KBD></KBD>
<DD>
Ищет <VAR>слова</VAR>, игнорируя пунктуацию между ними.
<DT><KBD>C-r <KBD>RET</KBD> C-w <VAR>слова</VAR> <KBD>RET</KBD></KBD>
<DD>
Ищет <VAR>слова</VAR> в обратном направлении, игнорируя пунктуацию между
ними.
</DL>

<P>
  Поиск слов -- это специальный случай ненаращиваемого поиска, и он
вызывается с помощью <KBD>C-s <KBD>RET</KBD> C-w</KBD>.  За этим следует строка
поиска, которая всегда должна быть ограничена <KBD>RET</KBD>.  Будучи
ненаращиваемым, поиск не начинается до тех пор, пока аргумент не
завершен.  Этот поиск работает путем создания регулярного выражения и
его поиска; смотрите section <A HREF="emacs_17.html#SEC94">Поиск регулярного выражения</A>.


<P>
  Для обратного поиска слов используйте <KBD>C-r <KBD>RET</KBD> C-w</KBD>.


<P>
<A NAME="IDX443"></A>
<A NAME="IDX444"></A>
  Прямой и обратный поиск слов реализован в командах
<CODE>word-search-forward</CODE> и <CODE>word-search-backward</CODE>.  Эти команды
могут быть привязаны к ключам обычным способом.  Возможность их запуска
через наращиваемый поиск существует по историческим причинам и для того,
чтобы вам не нужно было находить для них подходящие последовательности
ключей.




<H2><A NAME="SEC94" HREF="emacs_toc.html#TOC94">Поиск регулярного выражения</A></H2>
<P>
<A NAME="IDX445"></A>
<A NAME="IDX446"></A>


<P>
  <EM>Регулярное выражение</EM> (<EM>regexp</EM>, если кратко) -- это
образец, который обозначает набор строк, возможно, и неограниченный
набор.  В GNU Emacs вы можете искать следующее совпадение с регулярным
выражением как наращиваемым способом, так и простым.


<P>
<A NAME="IDX447"></A>
<A NAME="IDX448"></A>
<A NAME="IDX449"></A>
<A NAME="IDX450"></A>
  Наращиваемый поиск регулярного выражения производится набором
<KBD>C-M-s</KBD> (<CODE>isearch-forward-regexp</CODE>).  Эта команда считывает
наращиваемую строку поиска, так же, как <KBD>C-s</KBD>, но трактует ее как
регулярное выражение, а не ищет в тексте буфера точное совпадение.
Каждый раз, когда вы добавляете текст в строку поиска, вы делаете
регулярное выражение длиннее, и ищется уже новое регулярное выражение.
Вызов <KBD>C-s</KBD> с префиксным аргументом (значение не играет роли) ---
это другой способ произвести прямой поиск регулярного выражения.  Чтобы
запустить поиск регулярного выражения в обратном направлении,
используйте <KBD>C-M-r</KBD> (<CODE>isearch-backward-regexp</CODE>) или <KBD>C-r</KBD> с
префиксным аргументом.


<P>
  Все управляющие знаки, которые делают специальные вещи в рамках
обыкновенного наращиваемого поиска, имеют те же самые функции и в
наращиваемом поиске регулярного выражения.  Набор <KBD>C-s</KBD> или
<KBD>C-r</KBD> немедленно после начала поиска восстанавливает последнее
регулярное выражение, использованное для наращиваемого поиска
регулярного выражения; это говорит о том, что наращиваемый поиск
регулярного выражения и строки имеют независимые значения по умолчанию.
Они также имеют раздельные списки поиска, доступ к которым вы можете
получить с помощью <KBD>M-p</KBD> и <KBD>M-n</KBD>.


<P>
  Если при наращиваемом поиске регулярного выражения вы наберете
<KBD>SPC</KBD>, он будет совпадать с произвольной последовательностью
пробельных знаков, включая переводы строк.  Если вам нужен только один
пробел, введите <KBD>C-q <KBD>SPC</KBD></KBD>.


<P>
  Обратите внимание, добавление знаков к регулярному выражению при
наращиваемом поиске может вернуть курсор назад и начать поиск снова.
Например, если вы искали <SAMP>`foo'</SAMP> и добавляете <SAMP>`\|bar'</SAMP>, курсор
вернется назад, если первый <SAMP>`bar'</SAMP> предшествовал первому <SAMP>`foo'</SAMP>.


<P>
<A NAME="IDX451"></A>
<A NAME="IDX452"></A>
   Ненаращиваемый поиск регулярного выражения осуществляется функциями
<CODE>re-search-forward</CODE> и <CODE>re-search-backward</CODE>.  Вы можете
запустить их с помощью <KBD>M-x</KBD>, или привязать их к ключам или вызывать
через наращиваемый поиск регулярного выражения с помощью <KBD>C-M-s
<KBD>RET</KBD></KBD> и <KBD>C-M-r <KBD>RET</KBD></KBD>.


<P>
  Если вы используете команды наращиваемого поиска регулярного выражения
с префиксным аргументом, они производят обычный поиск строки, как
<CODE>isearch-forward</CODE> и <CODE>isearch-backward</CODE>.  See section <A HREF="emacs_17.html#SEC90">Наращиваемый поиск</A>.




<H2><A NAME="SEC95" HREF="emacs_toc.html#TOC95">Синтаксис регулярных выражений</A></H2>
<P>
<A NAME="IDX453"></A>


<P>
  Регулярные выражения имеют синтаксис, в котором несколько знаков
служат специальными конструкциями, а остальные -- это
<EM>обыкновенные</EM> знаки.  Обыкновенный знак -- это простое регулярное
выражение, которое соответствует этому знаку и никакому больше.
Специальными знаками являются <SAMP>`$'</SAMP>, <SAMP>`^'</SAMP>, <SAMP>`.'</SAMP>, <SAMP>`*'</SAMP>,
<SAMP>`+'</SAMP>, <SAMP>`?'</SAMP>, <SAMP>`['</SAMP>, <SAMP>`]'</SAMP> и <SAMP>`\'</SAMP>.  Любые другие знаки,
появляющиеся в регулярном выражении, являются обыкновенными, если только
им не предшествует <SAMP>`\'</SAMP>.


<P>
  Например, <SAMP>`f'</SAMP> -- это неспециальный знак, значит он обыкновенный,
поэтому <SAMP>`f'</SAMP> -- это регулярное выражение, которое соответствует
строке <SAMP>`f'</SAMP> и никакой другой.  (Оно <EM>не</EM> соответствует строке
<SAMP>`ff'</SAMP>).  Аналогично, <SAMP>`о'</SAMP> -- это регулярное выражение, которое
соответствует только <SAMP>`о'</SAMP>.  (Когда различия в регистре игнорируются,
эти регулярные выражения также совпадают с <SAMP>`F'</SAMP> и <SAMP>`O'</SAMP>, но мы
рассматриваем это как обобщение понятия "та же строка", а не как
исключение.)


<P>
  Любые два регулярных выражения <VAR>a</VAR> и <VAR>b</VAR> могут быть сцеплены.
Результатом является регулярное выражение, совпадающее со строкой, в
которой <VAR>a</VAR> соответствует некоторому началу этой строки, а <VAR>b</VAR>
соответствует остатку строки.


<P>
  В качестве простого примера мы можем сцепить регулярные выражения
<SAMP>`f'</SAMP> и <SAMP>`o'</SAMP>, чтобы получить регулярное выражение <SAMP>`fo'</SAMP>,
которое соответствует только строке <SAMP>`fo'</SAMP>.  Пока все просто.  Чтобы
сделать что-то нетривиальное, вам необходимо использовать один из
специальных знаков.  Здесь представлен их перечень.


<DL COMPACT>

<DT><KBD>. (Точка)</KBD>
<DD>
является специальным знаком, который соответствует любому одиночному
знаку, за исключением перевода строки.  Используя конкатенацию
(сцепление), вы можете составить регулярное выражение, подобное
<SAMP>`a.b'</SAMP>, которое соответствует любой трехзнаковой строке,
начинающейся с <SAMP>`a'</SAMP> и кончающейся на <SAMP>`b'</SAMP>.

<DT><KBD>*</KBD>
<DD>
сама по себе не является конструкцией; это постфиксный оператор, который
означает, что предыдущее регулярное выражение должно быть повторено
столько раз, сколько это возможно.  Таким образом, <SAMP>`o*'</SAMP>
соответствует любому числу букв <SAMP>`o'</SAMP> (включая нуль).

<SAMP>`*'</SAMP> всегда относится к <EM>наименьшему</EM> возможному предыдущему
выражению.  Таким образом, <SAMP>`fo*'</SAMP> содержит повторяющуюся <SAMP>`о'</SAMP>, а
не <SAMP>`fo'</SAMP>.  Оно совпадает с <SAMP>`f'</SAMP>, <SAMP>`fo'</SAMP>, <SAMP>`foo'</SAMP> и так
далее.

Конструкция <SAMP>`*'</SAMP> обрабатывается путем сопоставления с наибольшим
количеством повторений, которое сразу может быть найдено.  Затем
продолжается сравнение с остатком шаблона.  Если оно прошло неудачно, то
происходит перебор с возвратом.  Некоторые из совпадений с конструкцией
с модификатором <SAMP>`*'</SAMP> сбрасываются, чтобы дать возможность поиска
соответствия для остатка структуры.  Например, сравнивая <SAMP>`ca*ar'</SAMP> со
строкой <SAMP>`caaar'</SAMP>, <SAMP>`a*'</SAMP> сначала ставится в соответствие со всеми
тремя <SAMP>`а'</SAMP>, но остаток шаблона -- это <SAMP>`ar'</SAMP>, а в этом случае
для подбора остается только <SAMP>`r'</SAMP>, поэтому эта попытка неудачна.
Следующий вариант -- это поставить в соответствие с <SAMP>`а*'</SAMP> только
две буквы <SAMP>`а'</SAMP>.  При таком выборе остаток регулярного выражения
успешно соответствует строке.

<DT><KBD>+</KBD>
<DD>
это такой же постфиксный оператор, как и <SAMP>`*'</SAMP>, за исключением того,
что он требует, чтобы предшествующее ему выражение сопоставлялось по
крайней мере один раз.  Так например, <SAMP>`ca+r'</SAMP> будет соответствовать
строкам <SAMP>`car'</SAMP> и <SAMP>`caaar'</SAMP>, но не строке <SAMP>`cr'</SAMP>, тогда как
<SAMP>`ca*r'</SAMP> соответствует всем трем строкам.

<DT><KBD>?</KBD>
<DD>
постфиксный оператор, как и <SAMP>`*'</SAMP>, но он может соответствовать
предшествующему выражению либо один раз, либо ни одного.  Например,
<SAMP>`ca?r'</SAMP> будет соответствовать <SAMP>`car'</SAMP> или <SAMP>`cr'</SAMP> и ничему
больше.

<DT><KBD>[ ... ]</KBD>
<DD>
это <EM>набор знаков</EM>, который начинается <SAMP>`['</SAMP> и завершается
<SAMP>`]'</SAMP>.  В простейшем случае совпадающий набор формируют знаки между
этими скобками.

Таким образом, <SAMP>`[ad]'</SAMP> соответствует либо одной <SAMP>`a'</SAMP>, либо
одному <SAMP>`d'</SAMP>, а <SAMP>`[ad]*'</SAMP> соответствует любой строке, составленной
просто из <SAMP>`а'</SAMP> и <SAMP>`d'</SAMP> (включая пустую строку), из всего этого
следует, что <SAMP>`c[ad]*r'</SAMP> соответствует <SAMP>`cr'</SAMP>, <SAMP>`car'</SAMP>,
<SAMP>`cdr'</SAMP>, <SAMP>`caddaar'</SAMP> и так далее.

Вы также можете включить в множество знаков интервалы, написав два
знака, разделенные <SAMP>`-'</SAMP>; таким образом, <SAMP>`[a-z]'</SAMP> соответствует
любой строчной букве ASCII.  Интервалы могут быть свободно перемешаны с
отдельными знаками, как в <SAMP>`[a-z$%.]'</SAMP>, что соответствует любой
строчной букве ASCII, или <SAMP>`$'</SAMP>, или <SAMP>`%'</SAMP> или точке.

Заметим, что специальные знаки регулярных выражений внутри такого
множества больше не являются специальными.  Внутри знакового множества
существуют совершенно другой набор специальных знаков: <SAMP>`]'</SAMP>,
<SAMP>`-'</SAMP> и <SAMP>`^'</SAMP>.

Чтобы включить в знаковый набор <SAMP>`]'</SAMP>, вы должны поставить его
первым.  Например, <SAMP>`[]а]'</SAMP> соответствует <SAMP>`]'</SAMP> или <SAMP>`а'</SAMP>.
Чтобы включить <SAMP>`-'</SAMP>, напишите <SAMP>`-'</SAMP> первым или последним знаком в
наборе или поместите его после указания интервала.  Таким образом,
<SAMP>`[]-]'</SAMP> соответствует <SAMP>`]'</SAMP> и <SAMP>`-'</SAMP>.

Чтобы включить в набор знак <SAMP>`^'</SAMP>, пишите его где угодно, но не
первым.

Если вы задаете интервал при поиске без учета регистра, вы должны либо
написать оба конца интервала заглавными буквами, либо оба строчными,
либо оба они не должны быть буквами.  Поведение интервала с концами,
заданными в разных регистрах, определено плохо и может быть изменено в
будущих версиях Emacs.

<DT><KBD>[^ ... ]</KBD>
<DD>
<SAMP>`[^'</SAMP> начинает <EM>дополнительный набор знаков</EM>, который
соответствует любому знаку, исключая описанные в нем.  Таким образом,
<SAMP>`[^a-z0-9A-Z]'</SAMP> соответствует всем знакам, <EM>исключая</EM> буквы и
цифры.

<SAMP>`^'</SAMP> не является специальным в наборе знаков, если он не стоит
первым.  Знак, следующий за <SAMP>`^'</SAMP>, трактуется так, как если бы он
был первым (иными словами, <SAMP>`-'</SAMP> и <SAMP>`]'</SAMP> здесь не являются
специальными).

Дополнительный набор знаков может соответствовать знаку новой
строки, если он не упоминается как один из несовпадающих знаков.  Это
противоречит способу обработки регулярных выражений в таких программах,
как @command{grep}.

<DT><KBD>^</KBD>
<DD>
это специальный знак, который соответствует пустой строке, но только в
начале строки сопоставляемого текста.  В противном случае, сравнение не
удастся.  Таким образом, <SAMP>`^foo'</SAMP> соответствует <SAMP>`foo'</SAMP>, которая
встречена в начале строки.

<DT><KBD>$</KBD>
<DD>
подобен <SAMP>`^'</SAMP>, но сравнение происходит только в конце строки.  Таким
образом, <SAMP>`xx*$'</SAMP> соответствует строке из одного или более <SAMP>`x'</SAMP> в
конце строки.

<DT><KBD>\</KBD>
<DD>
имеет две функции: отменяет особый смысл специальных знаков (включая
<SAMP>`\'</SAMP>) и вводит дополнительные специальные конструкции.

Так как <SAMP>`\'</SAMP> отменяет особый смысл специальных знаков, то
<SAMP>`\$'</SAMP> -- это регулярное выражение, которое соответствует только
<SAMP>`$'</SAMP>, а <SAMP>`\['</SAMP> -- регулярное выражение, которое соответствует
только <SAMP>`['</SAMP>, и так далее.
</DL>

<P>
Замечание: для исторической совместимости специальные знаки трактуются
как обычные знаки, если они находятся в контексте, в котором их
специальный смысл не имеет значения.  Например, <SAMP>`*foo'</SAMP> трактует
<SAMP>`*'</SAMP> как обыкновенный, так как не существует предыдущего выражения,
на которое может подействовать <SAMP>`*'</SAMP>.  Плохо быть зависимым от этого
правила; лучше всегда явно отменять особый смысл специальных знаков
независимо того, где они находятся.


<P>
В большинстве случаев <SAMP>`\'</SAMP>, за которым следует любой знак,
соответствует только этому знаку.  Однако, существует несколько
исключений: двухзнаковые последовательности, начинающиеся с <SAMP>`\'</SAMP>,
имеющие особый смысл.  Второй знак в такой последовательности всегда
обычный, когда встречается сам по себе.  Здесь представлена таблица
конструкций с <SAMP>`\'</SAMP>.


<DL COMPACT>

<DT><KBD>\|</KBD>
<DD>
описывает альтернативу.  Два регулярных выражения <VAR>a</VAR> и <VAR>b</VAR> с
<SAMP>`\|'</SAMP> между ними формируют выражение, которое соответствует любому
из них в отдельности: либо <VAR>a</VAR>, либо <VAR>b</VAR>.  Это работает так:
сначала пробуется <VAR>a</VAR>, и если соответствие не найдено, пробуется
<VAR>b</VAR>.

Таким образом, <SAMP>`foo\|bar'</SAMP> соответствует либо <SAMP>`foo'</SAMP>, либо
<SAMP>`bar'</SAMP>, но не другой строке.

<SAMP>`\|'</SAMP> применяется к самым большим охватывающим выражениям.  Только
охватывающие скобки <SAMP>`\( ... \)'</SAMP> могут ограничить группирующую
силу <SAMP>`\|'</SAMP>.

Существует возможность полного обратного восстановления для обработки
многократных использований <SAMP>`\|'</SAMP>.

<DT><KBD>\( ... \)</KBD>
<DD>
группирующая конструкция, которая служит для трех целей:


<OL>
<LI>

Чтобы отделить набор альтернатив <SAMP>`\|'</SAMP> от других операций.  Таким
образом, <SAMP>`\(foo\|mar\)x'</SAMP> соответствует либо <SAMP>`foox'</SAMP>, либо
<SAMP>`marx'</SAMP>.

<LI>

Чтобы ограничить сложное выражение для действия постфиксных операторов
<SAMP>`*'</SAMP>, <SAMP>`+'</SAMP> и <SAMP>`?'</SAMP>.  Таким образом, <SAMP>`ba\(na\)*'</SAMP>
соответствует <SAMP>`bananana'</SAMP> и так далее с любым (нулевым или большим)
числом строк <SAMP>`na'</SAMP>.

<LI>

Чтобы отметить соответствующую подстроку для будущей ссылки.
</OL>

Это последнее применение не является следствием идеи ограничения группы;
это отдельное свойство, которое определено как второе значение той же
самой конструкции <SAMP>`\( ... \)'</SAMP>.  На практике между этими двумя
значениями не оказывается противоречий.

<DT><KBD>\<VAR>n</VAR></KBD>
<DD>
соответствует тексту, совпавшему с <VAR>n</VAR>-ным появлением конструкции
<SAMP>`\( ... \)'</SAMP>.

После конца конструкции <SAMP>`\( ... \)'</SAMP> сопоставление запоминает
начало и конец текста, совпавшего с этой конструкцией.  Затем, позднее в
регулярном выражении, вы можете использовать <SAMP>`\'</SAMP>, за которым
следует цифра <VAR>n</VAR>, чтобы сказать: "сопоставить с том же текстом,
который совпал с <VAR>n</VAR>-ным появлением конструкции <SAMP>`\( ...
\)'</SAMP>".

Строкам, соответствующим первым девяти конструкциями <SAMP>`\( ...
\)'</SAMP>, появляющимся в регулярном выражении, присваиваются номера от 1 до
9 в том порядке, в каком в регулярном выражении появились открывающие
скобки.  Конструкции от <SAMP>`\1'</SAMP> до <SAMP>`\9'</SAMP> могут использоваться для
ссылки на текст конструкции <SAMP>`\( ... \)'</SAMP> с этим номером.

Например, <SAMP>`\(.*\)\1'</SAMP> соответствует любой строке, не содержащей
знаков перевода строки, которая состоит из двух одинаковых половин.
<SAMP>`\(.*\)'</SAMP> соответствует первой половине, которая может быть любой,
но <SAMP>`\1'</SAMP>, что идет следом, должна соответствовать точно такому же
тексту.

Если для какой-нибудь конструкции <SAMP>`\( ... \)'</SAMP> найдено более
одного соответствия (что может легко произойти, если за ней следует
<SAMP>`*'</SAMP>), то запоминается только последнее совпадение.

<DT><KBD>\`</KBD>
<DD>
соответствует пустой строке, но только в начале буфера или строки, где
происходит поиск.

<DT><KBD>\'</KBD>
<DD>
соответствует пустой строке, но только в конце буфера или строки, где
происходит поиск.

<DT><KBD>\=</KBD>
<DD>
соответствует пустой строке, но только в точке.

<DT><KBD>\b</KBD>
<DD>
соответствует пустой строке, если эта конструкция находится в начале или
конце слова.  Таким образом, <SAMP>`\bfoo\b'</SAMP> соответствует любому
появлению <SAMP>`foo'</SAMP> как отдельного слова.  <SAMP>`bballs?\b'</SAMP>
соответствует <SAMP>`ball'</SAMP> или <SAMP>`balls'</SAMP> как отдельным словам.

<SAMP>`\b'</SAMP> находит соответствие в начале или конце буфера, независимо от
того, какой текст идет далее.

<DT><KBD>\B</KBD>
<DD>
соответствует пустой строке, если только она находится <EM>не</EM> в
начале или конце слова.

<DT><KBD>\&#60;</KBD>
<DD>
соответствует пустой строке, если она находится в начале слова.
<SAMP>`\&#60;'</SAMP> находит соответствие в начале буфера, но только если затем
идет знак, являющийся частью слова.

<DT><KBD>\&#62;</KBD>
<DD>
соответствует пустой строке, если она находится в конце слова.
<SAMP>`\&#62;'</SAMP> находит соответствие в конце буфера, но только если буфер
завершается знаком, являющимся частью слова.

<DT><KBD>\w</KBD>
<DD>
соответствует любому знаку, являющемуся частью слова.  Какие именно это
знаки, определяет синтаксическая таблица.  See section <A HREF="emacs_36.html#SEC469">Синтаксическая таблица</A>.

<DT><KBD>\W</KBD>
<DD>
соответствует любому знаку, не являющемуся частью слова.

<DT><KBD>\s<VAR>c</VAR></KBD>
<DD>
соответствует любому знаку, чей синтаксис определяется кодом <VAR>c</VAR>.
Здесь <VAR>c</VAR> -- это знак, который представляет собой синтаксический
код, например, это <SAMP>`w'</SAMP> для части слова, <SAMP>`-'</SAMP> для пробельных
знаков, <SAMP>`('</SAMP> для открывающей скобки, и так далее.  Вы можете
обозначить пробельный знак (который может быть переводом строки) либо
как <SAMP>`-'</SAMP>, либо одним пробелом.

<DT><KBD>\S<VAR>c</VAR></KBD>
<DD>
соответствует любому знаку, чей синтаксис не определяется кодом
<VAR>c</VAR>.
</DL>

<P>
  Конструкции, имеющие отношение к словам и синтаксису, управляются
установками в синтаксической таблице (see section <A HREF="emacs_36.html#SEC469">Синтаксическая таблица</A>).


<P>
  Далее представлено сложное регулярное выражение, используемое Emacs
для распознавания конца предложения вместе с любыми пробельными
знаками, которые идут следом.  Оно дано в синтаксисе Лиспа, чтобы дать
вам возможность отличить пробелы от знаков табуляции.  В синтаксисе
Лиспа, константная строка начинается и заканчивается двойными кавычками.
<SAMP>`\"'</SAMP> обозначает двойные кавычки как часть регулярного выражения,
<SAMP>`\\'</SAMP> обозначает обратную косую черту, <SAMP>`\t'</SAMP> обозначает знак
табуляции, а <SAMP>`\n'</SAMP> -- знак новой строки.



<PRE>
"[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"
</PRE>

<P>
Здесь последовательно содержатся четыре части: набор знаков,
соответствующий точке, <SAMP>`?'</SAMP> или <SAMP>`!'</SAMP>; набор знаков,
соответствующий парным квадратным скобкам, кавычкам или круглым скобкам,
повторяемым любое число раз; альтернатива, заключенная в скобки с
обратными косыми чертами, которая соответствует концу строки, табуляции
или двум пробелам; и набор знаков, соответствующий любым пробельным
знакам, повторяющимся любое число раз.


<P>
  Чтобы ввести это регулярное выражение интерактивно, вы напечатали бы
<KBD>TAB</KBD>, чтобы получить знак табуляции, и <KBD>C-j</KBD>, чтобы получить
знак перевода строки.  Вы также печатали бы одиночные обратные косые
черты как есть, а не дублировали бы их в соответствии с синтаксисом
Лиспа.




<H2><A NAME="SEC96" HREF="emacs_toc.html#TOC96">Поиск и регистр букв</A></H2>

<P>
<A NAME="IDX454"></A>
  Все виды наращиваемого поиска в Emacs обычно игнорируют регистр
текста, в котором происходит поиск, если вы задали текст в нижнем
регистре.  Таким образом, если вы запросили поиск <SAMP>`foo'</SAMP>, то
совпадениями считаются и <SAMP>`Foo'</SAMP>, и <SAMP>`foo'</SAMP> .  Регулярные
выражения, и в частности наборы знаков, также включаются в это правило:
<SAMP>`[aB]'</SAMP> соответствовало бы <SAMP>`a'</SAMP>, или <SAMP>`A'</SAMP>, или <SAMP>`b'</SAMP> или
<SAMP>`B'</SAMP>.


<P>
  Заглавная буква в любом месте строки наращиваемого поиска делает этот
поиск регистрозависимым.  Таким образом, поиск <SAMP>`Foo'</SAMP> не найдет
<SAMP>`foo'</SAMP> или <SAMP>`FOO'</SAMP>.  Это применяется также и к поиску регулярного
выражения.  Этот эффект исчезает, если вы удалили заглавные буквы из
строки поиска.


<P>
   Если вы установите переменную <CODE>case-fold-search</CODE> равной
<CODE>nil</CODE>, все буквы должны будут совпадать точно, включая регистр.
Эта переменная своя для каждого буфера; ее изменение затрагивает только
текущий буфер, но существует значение по умолчанию, которое вы тоже
можете изменить.  See section <A HREF="emacs_36.html#SEC450">Локальные переменные</A>.  Эта переменная
применяется также и к ненаращиваемому поиску, включая те его
разновидности, которые осуществляются командами замены (see section <A HREF="emacs_17.html#SEC97">Команды замены</A>)
и командами поиска в истории минибуфера (see section <A HREF="emacs_10.html#SEC44">История минибуфера</A>).




<H2><A NAME="SEC97" HREF="emacs_toc.html#TOC97">Команды замены</A></H2>
<P>
<A NAME="IDX455"></A>
<A NAME="IDX456"></A>
<A NAME="IDX457"></A>
<A NAME="IDX458"></A>


<P>
  Глобальные команды поиска и замены не нужны в Emacs так часто, как в
других редакторах<A NAME="DOCF3" HREF="emacs_foot.html#FOOT3">(3)</A>, но они доступны.  Кроме простой команды <KBD>M-x
replace-string</KBD>, которая аналогична такой же команде в большинстве
редакторов, существует команда <KBD>M-x query-replace</KBD>, которая для
каждого появления образца спрашивает вас, надо ли его заменять.


<P>
  Команды замены обычно работают с текстом от точки до конца буфера;
однако, в режиме Transient Mark они действуют на область, когда метка
активна.  Все команды замены заменяют одну строку (или регулярное
выражение) одной строкой замены.  Можно выполнить параллельно несколько
замен, используя команду <CODE>expand-region-abbrevs</CODE>
(see section <A HREF="emacs_29.html#SEC329">Управление расшифровкой сокращения</A>).




<H3><A NAME="SEC98" HREF="emacs_toc.html#TOC98">Безусловная замена</A></H3>
<P>
<A NAME="IDX459"></A>
<A NAME="IDX460"></A>


<DL COMPACT>

<DT><KBD>M-x replace-string <KBD>RET</KBD> <VAR>строка</VAR> <KBD>RET</KBD> <VAR>новая-строка</VAR> <KBD>RET</KBD></KBD>
<DD>
Заменяет каждое вхождение <VAR>строки</VAR> на <VAR>новую-строку</VAR>.
<DT><KBD>M-x replace-regexp <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD> <VAR>новая-строка</VAR> <KBD>RET</KBD></KBD>
<DD>
Заменяет каждое совпадение с <VAR>regexp</VAR> на <VAR>новую-строку</VAR>.
</DL>

<P>
  Чтобы заменить каждый случай вхождения <SAMP>`foo'</SAMP> после точки на
<SAMP>`bar'</SAMP>, используется команда <KBD>M-x replace-string</KBD> с двумя
аргументами <SAMP>`foo'</SAMP> и <SAMP>`bar'</SAMP>.  Замещение происходит только в
тексте после точки, так, если вы хотите охватить весь буфер, вы должны
сначала отправиться в его начало.  Все экземпляры вплоть до конца буфера
будут заменены; чтобы ограничиться заменой в части буфера, сузьте его до
этой части перед выполнением замены (see section <A HREF="emacs_35.html#SEC432">Сужение</A>).  В режиме
Transient Mark, если область активна, замена ограничена этой областью
(see section <A HREF="emacs_13.html#SEC57">Режим Transient Mark</A>).


<P>
  Когда вы выходите из <CODE>replace-string</CODE>, точка остается на месте
последней замены.  Значение точки в момент, когда была запущена команда
<CODE>replace-string</CODE>, запоминается в списке пометок.  <KBD>C-u
C-<KBD>SPC</KBD></KBD> перемещает вас обратно.


<P>
  Числовой аргумент ограничивает замену совпадениями, которые окружены
ограничителями слов.  Значение аргумента роли не играет.




<H3><A NAME="SEC99" HREF="emacs_toc.html#TOC99">Замена регулярных выражений</A></H3>

<P>
  Команда <KBD>M-x replace-string</KBD> заменяет точные совпадения с
одиночной строкой.  Аналогичная команда <CODE>replace-regexp</CODE> замещает
любое совпадение с заданным образцом.


<P>
  В <CODE>replace-regexp</CODE>, <VAR>новая-строка</VAR> не обязательно должна быть
константой: она может ссылаться на все или часть того, что соответствует
регулярному выражению <VAR>regexp</VAR>.  <SAMP>`\&#38;'</SAMP> в <VAR>новой-строке</VAR>
означает полный замещаемый текст.  <SAMP>`\<VAR>n</VAR>'</SAMP>, где <VAR>n</VAR> -- это
цифра, означает то, что было поставлено в соответствие <VAR>n</VAR>-ной
заключенной в скобки группе в регулярном выражении <VAR>regexp</VAR>.  Чтобы
включить в новый текст знак <SAMP>`\'</SAMP>, вы должны ввести <SAMP>`\\'</SAMP>.
Например,



<PRE>
M-x replace-regexp <KBD>RET</KBD> c[ad]+r <KBD>RET</KBD> \&#38;-safe <KBD>RET</KBD>
</PRE>

<P>
заменит (например) <SAMP>`cadr'</SAMP> на <SAMP>`cadr-safe'</SAMP> и <SAMP>`cddr'</SAMP> на
<SAMP>`cddr-safe'</SAMP>.



<PRE>
M-x replace-regexp <KBD>RET</KBD> \(c[ad]+r\)-safe <KBD>RET</KBD> \1 <KBD>RET</KBD>
</PRE>

<P>
делает обратное преобразование.




<H3><A NAME="SEC100" HREF="emacs_toc.html#TOC100">Команды замены и регистр букв</A></H3>

<P>
  Если первый аргумент в команде замены набран в нижнем регистре, во
время поиска вхождений для замены регистр игнорируется -- при условии,
что <CODE>case-fold-search</CODE> не равна <CODE>nil</CODE>.  Если
<CODE>case-fold-search</CODE> установлена в значение <CODE>nil</CODE>, регистр
учитывается во всех типах поиска.


<P>
<A NAME="IDX461"></A>
  Кроме того, когда аргумент <VAR>новая-строка</VAR> весь или частично
написан строчными буквами, команды замены пытаются сохранить образец
использования регистра в каждом вхождении.  Таким образом, команда



<PRE>
M-x replace-string <KBD>RET</KBD> foo <KBD>RET</KBD> bar <KBD>RET</KBD>
</PRE>

<P>
заменяет <SAMP>`foo'</SAMP> в нижнем регистре на <SAMP>`bar'</SAMP> в нижнем регистре,
<SAMP>`FOO'</SAMP> в верхнем регистре на <SAMP>`BAR'</SAMP>, а <SAMP>`Foo'</SAMP> с первой
заглавной буквой на <SAMP>`Bar'</SAMP>.  (Три эти альтернативы: все строчные
буквы, все заглавные и первая заглавная -- единственные варианты,
которые может распознать <CODE>replace-string</CODE>.)


<P>
  Если в строке подстановки использованы буквы верхнего регистра, то они
остаются такими при каждой вставке этого текста.  Если буквы верхнего
регистра используются в первом аргументе, то второй аргумент всегда
вставляется в том виде, в котором он дан, без изменения регистра.
Аналогично, если переменная <CODE>case-replace</CODE> или
<CODE>case-fold-search</CODE> установлена равной <CODE>nil</CODE>, замещение
происходит без изменения регистра.




<H3><A NAME="SEC101" HREF="emacs_toc.html#TOC101">Замена с подтверждением</A></H3>
<P>
<A NAME="IDX462"></A>


<DL COMPACT>

<DT><KBD>M-% <VAR>строка</VAR> <KBD>RET</KBD> <VAR>новая-строка</VAR> <KBD>RET</KBD></KBD>
<DD>
<DT><KBD>M-x query-replace <KBD>RET</KBD> <VAR>строка</VAR> <KBD>RET</KBD> <VAR>новая-строка</VAR> <KBD>RET</KBD></KBD>
<DD>
Заменяет некоторые вхождения <VAR>строки</VAR> на <VAR>новую-строку</VAR>.
<DT><KBD>C-M-% <VAR>regexp</VAR> <KBD>RET</KBD> <VAR>новая-строка</VAR> <KBD>RET</KBD></KBD>
<DD>
<DT><KBD>M-x query-replace-regexp <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD> <VAR>новая-строка</VAR> <KBD>RET</KBD></KBD>
<DD>
Заменяет некоторые совпадения с <VAR>regexp</VAR> на <VAR>новую-строку</VAR>.
</DL>

<P>
<A NAME="IDX463"></A>
<A NAME="IDX464"></A>
  Если вы хотите заменить только некоторые экземпляры <SAMP>`foo'</SAMP> на
<SAMP>`bar'</SAMP>, но не все, вы не можете использовать обыкновенную
<CODE>replace-string</CODE>.  Вместо этого используется <KBD>M-%</KBD>
(<CODE>query-replace</CODE>).  Эта команда находит экземпляры <SAMP>`foo'</SAMP> один
за другим, отображает каждый экземпляр и спрашивает вас, надо ли его
заменять.  Числовой аргумент говорит <CODE>query-replace</CODE>, что нужно
рассматривать лишь те экземпляры, которые окружены знаками-разделителями
слов.  Эта команда сохраняет регистр так же, как и
<CODE>replace-string</CODE>, при условии, что <CODE>case-replace</CODE> не равна
<CODE>nil</CODE>, как это обычно и бывает.


<P>
<A NAME="IDX465"></A>
<A NAME="IDX466"></A>
  За исключением запроса подтверждения, <CODE>query-replace</CODE> работает
точно так же, как <CODE>replace-string</CODE>, а <CODE>query-replace-regexp</CODE>
--- как <CODE>replace-regexp</CODE>.  Эта команда запускается при помощи
<KBD>C-M-%</KBD>.


<P>
  Когда вам показывают вхождение <VAR>строки</VAR> или совпадение с
регулярным выражением <VAR>regexp</VAR>, вы можете набрать следующее:


<DL COMPACT>

<DT><KBD><KBD>SPC</KBD></KBD>
<DD>
чтобы заменить это вхождение на <VAR>новую-строку</VAR>.

<DT><KBD><KBD>DEL</KBD></KBD>
<DD>
чтобы перейти к следующему вхождению, не заменяя это.

<DT><KBD>, (Запятая)</KBD>
<DD>
чтобы заменить это вхождение и показать результат.  Затем у вас
запрашивают ввод еще одного знака, чтобы узнать, что делать дальше.
Так как замена уже произведена, то <KBD>DEL</KBD> и <KBD>SPC</KBD> в этой ситуации
эквивалентны; обе переходят к следующему вхождению.

Вы можете набрать в этом месте <KBD>C-r</KBD> (смотрите ниже), чтобы изменить
замененный текст.  Вы можете также набрать <KBD>C-x u</KBD>, чтобы отменить
сделанную замену; эта команда выходит из <CODE>query-replace</CODE>, так что
если вы хотите делать дальнейшие замены, вы должны использовать <KBD>C-x
<KBD>ESC</KBD> <KBD>ESC</KBD> <KBD>RET</KBD></KBD>, чтобы запустить замену заново
(see section <A HREF="emacs_10.html#SEC45">Повтор команд минибуфера</A>).

<DT><KBD><KBD>RET</KBD></KBD>
<DD>
чтобы выйти без осуществления дальнейших замен.

<DT><KBD>. (Точка)</KBD>
<DD>
чтобы заменить этот экземпляр и затем выйти без продолжения поиска
следующих вхождений.

<DT><KBD>!</KBD>
<DD>
чтобы заменить все оставшиеся экземпляры без повторных запросов.

<DT><KBD>^</KBD>
<DD>
чтобы вернуться к положению предыдущего вхождения (или к тому, что им
было), если вы изменили его по ошибке.  Это делается при помощи
выталкивания из списка пометок.  Можно использовать только один <SAMP>`^'</SAMP>
подряд, так как во время работы <CODE>query-replace</CODE> хранится только
одна предыдущая позиция замены.

<DT><KBD>C-r</KBD>
<DD>
чтобы войти в новый уровень рекурсивного редактирования, в том случае,
когда экземпляр нуждается скорее в редактировании, чем просто в замене
его <VAR>новой-строкой</VAR>.  Когда вы сделаете это, выйдите из этого уровня
рекурсивного редактирования, набрав <KBD>C-M-c</KBD>, чтобы перейти к
следующему вхождению.  See section <A HREF="emacs_35.html#SEC436">Уровни рекурсивного редактирования</A>.

<DT><KBD>C-w</KBD>
<DD>
чтобы удалить это вхождение и потом войти в новый уровень рекурсивного
редактирования, как в <KBD>C-r</KBD>.  Используйте рекурсивное редактирование
для вставки текста и замены удаленного вхождения <VAR>строки</VAR>.  Когда вы
закончите, выйдите из этого уровня рекурсивного редактирования с помощью
<KBD>C-M-c</KBD>, чтобы перейти к следующему вхождению.

<DT><KBD>C-l</KBD>
<DD>
чтобы восстановить изображение экрана.  Потом вы должны набрать еще один
знак, чтобы указать, что делать с этим вхождением.

<DT><KBD>C-h</KBD>
<DD>
чтобы просмотреть сообщение, резюмирующее эти варианты.  Потом вы должны
набрать еще один знак, чтобы указать, что делать с этим вхождением.
</DL>

<P>
  Некоторые другие знаки являются синонимами перечисленных выше:
<KBD>y</KBD>, <KBD>n</KBD> и <KBD>q</KBD> эквивалентны <KBD>SPC</KBD>, <KBD>DEL</KBD> и
<KBD>RET</KBD>.


<P>
  Кроме этих знаков, любой другой выходит из <CODE>query-replace</CODE> и
снова считывается как часть последовательности ключей.  Таким образом,
если вы напечатаете <KBD>C-k</KBD>, она выйдет из <CODE>query-replace</CODE> и
уничтожит текст до конца строки.


<P>
  Чтобы перезапустить <CODE>query-replace</CODE>, когда вы уже из нее вышли,
используйте <KBD>C-x <KBD>ESC</KBD> <KBD>ESC</KBD></KBD>, которая повторит
<CODE>query-replace</CODE>, так как она использовала минибуфер для чтения
аргументов.  See section <A HREF="emacs_9.html#SEC35">Повторение команды</A>.


<P>
  Смотрите также section <A HREF="emacs_33.html#SEC380">Преобразование имен файлов в Dired</A>, чтобы узнать о
командах Dired для переименования, копирования или создания ссылок на
файлы путем замены в их именах совпадений с регулярным выражением.




<H2><A NAME="SEC102" HREF="emacs_toc.html#TOC102">Другие команды поиска в цикле</A></H2>

<P>
  Здесь представлены некоторые другие команды, которые находят
совпадения с регулярными выражениями.  Все они действуют от точки до
конца буфера, и все они игнорируют при сопоставлении регистр, если
образец не содержит заглавных букв, а <CODE>case-fold-search</CODE> отлична от
<CODE>nil</CODE>.


<P>
<A NAME="IDX467"></A>
<A NAME="IDX468"></A>
<A NAME="IDX469"></A>
<A NAME="IDX470"></A>
<A NAME="IDX471"></A>
<A NAME="IDX472"></A>
<A NAME="IDX473"></A>


<DL COMPACT>

<DT><KBD>M-x occur <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Выводит перечень, показывающий каждую строку буфера, которая содержит
совпадение с <VAR>regexp</VAR>.  Числовой аргумент задает число строк
контекста, которые должны быть напечатаны перед и после каждой
сравниваемой строки; значений по умолчанию -- не печатать контекст.
Чтобы ограничить поиск частью буфера, сузьтесь до этой части
(see section <A HREF="emacs_35.html#SEC432">Сужение</A>).

<A NAME="IDX474"></A>
Буфер <TT>`*Occur*'</TT>, в который записывается вывод, служит в качестве
меню для поиска вхождений в их оригинальном контексте.  Щелкните
<KBD>Mouse-2</KBD> на вхождении, перечисленном в <TT>`*Occur*'</TT>, или
поместите там точку и нажмите <KBD>RET</KBD>; это переключит в буфер, где
делался поиск, и переместит точку к оригиналу выбранного вхождения.

<DT><KBD>M-x list-matching-lines</KBD>
<DD>
Синоним для <KBD>M-x occur</KBD>.

<DT><KBD>M-x count-matches <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Печатает число совпадений с <VAR>regexp</VAR> после точки.

<DT><KBD>M-x flush-lines <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Удаляет каждую строку, следующую после точки и содержащую совпадение с
<VAR>regexp</VAR>.

<DT><KBD>M-x keep-lines <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Удаляет каждую строку, следующую после точки и <EM>не</EM> содержащую
совпадение с <VAR>regexp</VAR>.
</DL>

<P>
  Кроме того, вы можете использовать из Emacs программу @command{grep}
для поиска совпадений с регулярным выражением в группе файлов, а затем
обратиться к найденным совпадениям последовательно или в произвольном
порядке.  See section <A HREF="emacs_28.html#SEC313">Поиск с Grep под Emacs</A>.
<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_16.html">previous</A>, <A HREF="emacs_18.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
</BODY>
</HTML>
