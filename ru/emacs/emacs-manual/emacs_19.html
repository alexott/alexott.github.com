<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Работа с файлами</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_18.html">previous</A>, <A HREF="emacs_20.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC108" HREF="emacs_toc.html#TOC108">Работа с файлами</A></H1>
<P>
<A NAME="IDX502"></A>


<P>
  Операционная система хранит постоянные даные в именованных
<EM>файлах</EM>.  Поэтому большая часть текста, который вы редактируете в
Emacs, приходит из файлов и в конечном итоге записывается в файл.


<P>
 Чтобы редактировать файл, вы должны велеть Emacs считать его и
подготовить буфер, содержащий копию текста файла.  Это называется
<EM>обращением</EM> к файлу.  Команды редактирования применяются
непосредственно к тексту в буфере, то есть к копии внутри Emacs.  Ваши
изменения появляются в самом файле, только когда вы <EM>сохраните</EM>
буфер в файле.


<P>
  Кроме обращения к файлам и их сохранения Emacs может удалять,
копировать, переименовывать и добавлять в файлы и работать с каталогами
файлов.




<H2><A NAME="SEC109" HREF="emacs_toc.html#TOC109">Имена файлов</A></H2>
<P>
<A NAME="IDX503"></A>


<P>
  Большинство команд Emacs, которые оперируют с файлами, требуют от вас
указания имени файла.  (Запись и восстановление являются исключением;
буферу известно, какое имя файла используется для них.)  Имена файлов
задаются с использованием минибуфера (see section <A HREF="emacs_10.html#SEC36">Минибуфер</A>).  Вы можете
использовать <EM>завершение</EM> для облегчения написания длинных имен
файлов. See section <A HREF="emacs_10.html#SEC39">Завершение</A>.


<P>
  Для большинства операций существует <EM>имя файла по умолчанию</EM>,
которое будет использовано, если вы наберете просто <KBD>RET</KBD>, вводя
пустой аргумент.  Обычно имя файла по умолчанию -- это имя файла,
находящегося в текущем буфере, что упрощает действия над этим файлом с
помощью любых файловых команд Emacs.


<P>
<A NAME="IDX504"></A>
  Каждый буфер имеет свой каталог по умолчанию, обычно тот же самый, что
и каталог файла, к которому обращается этот буфере.  Когда вы вводите
имя файла, не указывая каталог, он использует каталог по умолчанию.
Если вы зададите каталог в относительной форме, с помощью имени, которое
не начинается с косой черты, оно интерпретируется по отношению к
каталогу по умолчанию.  Каталог по умолчанию хранится в переменной
<CODE>default-directory</CODE>, которая имеет свое собственное значение в
каждом буфере.


<P>
  Например, если по умолчанию имя файла -- <TT>`/u/rms/gnu/gnu.tasks'</TT>,
то каталогом по умолчанию будет <TT>`u/rms/gnu/'</TT>.  Если вы наберете
просто <SAMP>`foo'</SAMP>, не описывая каталог, то это будет сокращением для
<TT>`/u/rms/gnu/foo'</TT>.  <TT>`../.login'</TT> будет соответствовать
<TT>`/u/rms/.login'</TT>.  <TT>`new/foo'</TT> обозначает файл с именем
<TT>`/u/rms/gnu/new/foo'</TT>.


<P>
<A NAME="IDX505"></A>
<A NAME="IDX506"></A>
  Команда <KBD>M-x pwd</KBD> печатает каталог по умолчанию для текущего
буфера, а команда <KBD>M-x cd</KBD> устанавливает его (значение считывается в
минибуфере).  Каталог по умолчанию в буфере изменяется только тогда,
когда используется команда <KBD>cd</KBD>.  Каталог по умолчанию для буфера,
обращающегося к файлу, инициализируется по каталогу файла, к которому он
обратился.  Если буфер создается произвольным образом с помощью <KBD>C-x
b</KBD>, его каталог по умолчанию копируется из того буфера, который был
текущим в тот момент.


<P>
<A NAME="IDX507"></A>
  Каталог по умолчанию фактически появляется в минибуфере, когда
минибуфер становится активным для чтения имени файла.  Это служит двум
целям: чтобы <EM>показать</EM> вам, что имеется по умолчанию, так что вы
можете набрать соответствующее имя файла и с определенностью узнать, что
это будет значить, и чтобы позволить вам <EM>отредактировать</EM> каталог
по умолчанию и задать другой каталог.  Эта подстановка каталога по
умолчанию не делается, если переменная <CODE>insert-default-directory</CODE>
установлена равной <CODE>nil</CODE>.


<P>
  Заметим, что законно набирать полное имя файла после того, как вы
войдете в минибуфер, игнорируя присутствие имени каталога по умолчанию
как части текста.  Окончательное содержание минибуфера может казаться
неправильным, но на самом деле это не так.  Например, если сначала
минибуфер содержал <SAMP>`/usr/tmp/'</SAMP>, и вы добавили <SAMP>`/x1/rms/foo'</SAMP>,
вы получите <SAMP>`/usr/tmp//x1/rms/foo'</SAMP>; но Emacs игнорирует все до того
места, где встречены две косые черты подряд; в результате получается
<SAMP>`/x1/rms/foo'</SAMP>.  See section <A HREF="emacs_10.html#SEC37">Минибуфер для имен файлов</A>.


<P>
  Литера <SAMP>`$'</SAMP> в имени файла используется для подстановки переменных
среды.  Например, если вы применили команду оболчки <SAMP>`export
FOO=rms/hacks'</SAMP> для установки переменной среды с именем @env{FOO}, то вы
можете использовать <TT>`/u/$FOO/test.c'</TT> или <TT>`/u/${FOO}/test.c'</TT>
в качестве сокращения для <TT>`/u/rms/hacks/test.c'</TT>.  Имя переменной
среды состоит из всех букв и цифр после <SAMP>`$'</SAMP>; или оно может быть
заключено в фигурные скобки после <SAMP>`$'</SAMP>.  Заметьте, что команды
оболочки, которые устанавливают переменные среды, повлияют на Emacs,
только если они были выполнены до запуска Emacs.


<P>
  Чтобы получить доступ к файлу, содержащему в имени знак <SAMP>`$'</SAMP>,
напечатайте <SAMP>`$$'</SAMP>.  Эта пара превращается в один <SAMP>`$'</SAMP>, в то
время как для одиночного <SAMP>`$'</SAMP> делается подстановка переменной.  Или
вы можете отменить особый смысл всех знаков в имени файла с помощью
последовательности <SAMP>`/:'</SAMP> (see section <A HREF="emacs_19.html#SEC161">Буквальные имена файлов</A>).


<P>
<A NAME="IDX508"></A>
  Лисповская функция, которая производит подстановку, называется
<CODE>substitute-in-file-name</CODE>.  Подстановка выполняется только для имен
файлов, считываемых как таковые с использованием минибуфера.


<P>
  Вы можете включать в имена файлов знаки, не входящие в ASCII, если
установите переменную <CODE>file-name-coding-system</CODE> в отличное от
<CODE>nil</CODE> значение.  See section <A HREF="emacs_23.html#SEC207">Задание системы кодирования</A>.




<H2><A NAME="SEC110" HREF="emacs_toc.html#TOC110">Обращение к файлам</A></H2>
<P>
<A NAME="IDX509"></A>


<DL COMPACT>

<DT><KBD>C-x C-f</KBD>
<DD>
Обратиться к файлу (<CODE>find-file</CODE>).
<DT><KBD>C-x C-r</KBD>
<DD>
Обратиться к файлу для просмотра, не допуская его изменения
(<CODE>find-file-read-only</CODE>).
<DT><KBD>C-x C-v</KBD>
<DD>
Обратиться к другому файлу, вместо последнего посещенного
(<CODE>find-alternate-file</CODE>).
<DT><KBD>C-x 4 f</KBD>
<DD>
Обратиться к файлу в другом окне (<CODE>find-file-other-window</CODE>).
Не меняет текущее окно.
<DT><KBD>C-x 5 f</KBD>
<DD>
Обратиться к файлу в другом фрейме (<CODE>find-file-other-frame</CODE>).
Не изменяет то, что отображется в выбранном фрейме.
<DT><KBD>M-x find-file-literally</KBD>
<DD>
Обратиться к файлу без преобразования его содержимого.
</DL>

<P>
<A NAME="IDX510"></A>
<A NAME="IDX511"></A>
<A NAME="IDX512"></A>
  <EM>Обращение</EM> к файлу означает копирование его содержимого в буфер
Emacs, где вы можете его редактировать.  Emаcs создает новый буфер для
каждого файла, к которому вы обращаетесь.  Мы говорим, что этот буфер
обращается к файлу, для хранения которого он был создан.  Emacs создает
имя буфера из имени файла, отбрасывая каталог и сохраняя просто
собственно имя.  Например, файл с именем <TT>`/usr/rms/emacs.tex'</TT>
получит буфер с именем <TT>`emacs.tex'</TT>.  Если буфер с таким именем уже
существует, то создается уникальное имя путем добавления <SAMP>`&#60;2&#62;'</SAMP>,
<SAMP>`&#60;3&#62;'</SAMP> и так далее; при этом используется наименьший номер,
создающий еще не используемое имя.


<P>
  Строка режима каждого окна показывает имя буфера, который отражен в
этом окне, таким образом вы всегда можете сказать, какой буфер
редактируете.


<P>
  Все изменения, сделанные при помощи команд редактирования, делаются в
буфере Emacs.  Они не влияют на файл, к которому вы обратились, или на
любое другое постоянное место, пока вы не <EM>сохранили</EM> буфер.
Сохранение буфера означает, что Emacs записывает текущее содержимое
этого буфера в файл, к которому он обращался.  See section <A HREF="emacs_19.html#SEC111">Сохранение файлов</A>.


<P>
<A NAME="IDX513"></A>
  Если буфер содержит изменения, которые не были сохранены, то о буфере
говорится, что он <EM>изменен</EM> (или <EM>модифицирован</EM>).  Это важно,
так как это подразумевает, что какие-то изменения потеряюся, если буфер
не будет сохранен.  Если буфер изменен, около левого края строка режима
показываются две звездочки.


<P>
<A NAME="IDX514"></A>
<A NAME="IDX515"></A>
  Чтобы обратиться к файлу, используйте команду <KBD>C-x C-f</KBD>
(<CODE>find-file</CODE>).  После нее введите имя файла, который вы хотите
посетить, ограниченное <KBD>RET</KBD>.


<P>
  Имя файла считывается с использованием минибуфера (see section <A HREF="emacs_10.html#SEC36">Минибуфер</A>)
с использованием значений по умолчанию и завершением стандартным
способом (see section <A HREF="emacs_19.html#SEC109">Имена файлов</A>).  Пока вы находитесь в минибуфере, вы
можете прервать выполнение <KBD>C-x C-f</KBD>, набрав <KBD>C-g</KBD>.


<P>
  Подтверждением того, что <KBD>C-x C-f</KBD> завершилась удачно, служит
появление нового текста на экране и нового имени буфера в строке режима.
Если указанный файл не существует и не может быть создан или считан,
тогда возникает ошибка.  Сообщение о ней печатается в эхо-области.


<P>
  Если вы обращаетесь к файлу, который уже существует в Emacs, <KBD>C-x
C-f</KBD> не создает другой копии.  Она выбирает существующий буфер,
содержащий этот файл.  Однако, перед этим она проверяет, не изменился ли
сам файл с тех пор, как вы обратились к нему или записали его в прошлый
раз.  Если файл был изменен, то будет напечатано предостерегающее
сообщение.  See section <A HREF="emacs_19.html#SEC116">Защита от одновременного редактирования</A>.


<P>
<A NAME="IDX516"></A>
  А что если вы захотите создать новый файл?  Просто обратитесь к нему.
Emacs печатает в эхо-области <SAMP>`(New File)'</SAMP>, но в других отношениях
ведет себя так же, как, если бы вы обратились бы к существующему пустому
файлу.  Если вы сделаете любые изменения и запишете их, то файл будет
создан.


<P>
  Emacs узна╠т из содержимого файла, какое соглашение используется в нем
для разделения строк -- перевод строки (используемый в GNU/Linux и
Unix), возврат каретки и перевод строки (используемые в системах
Microsoft) или просто возврат каретки (используемый на Macintosh) -- и
автоматически преобразует содержимое к обычному формату Emacs, в котором
строки разделяются знаками перевода строки.  Это часть общего средства
преобразования системы кодирования (see section <A HREF="emacs_23.html#SEC205">Системы кодирования</A>), и это
позволяет редактировать файлы, перенесенные с различных операционных
систем с одинаковым удобством.  Если вы изменили текст и сохранили файл,
Emacs производит обратное преобразование, заменяя переводы строки на
возврат каретки и перевод строки или просто возврат каретки, если это
необходимо.


<P>
<A NAME="IDX517"></A>
  Если указанный вами файл фактически является каталогом, то <KBD>C-x
C-f</KBD> вызывает Dired, броузер каталогов Emacs, чтобы вы могли
"редактировать" содержимое этого каталога (see section <A HREF="emacs_33.html#SEC371">Dired, редактор каталогов</A>).  Dired
предоставляет удобный способ удаления, просмотра или обработки файлов в
каталоге.  Однако, если переменная <CODE>find-file-run-dired</CODE> равна
<CODE>nil</CODE>, попытка обратиться к каталогу будет считаться ошибкой.


<P>
  Если заданное вами имя файла содержит символы подстановки, Emacs
обращается ко всем файлам, соответствующим этому имени.
See section <A HREF="emacs_19.html#SEC161">Буквальные имена файлов</A>, если вы хотите обратиться к файлу, чье
имя в самом деле содержит символы подстановки.


<P>
  Если операционная система не позволяет вам изменять файл, к которому
вы обращаетесь, Emacs делает буфер доступным только для чтения, так что
у вас не получится внести изменения, которые будет проблематично
впоследствии сохранить.  Вы можете сделать буфер доступным для записи с
помощью <KBD>C-x C-q</KBD> (<CODE>vc-toggle-read-only</CODE>).  See section <A HREF="emacs_20.html#SEC165">Разнообразные операции над буфером</A>.


<P>
<A NAME="IDX518"></A>
<A NAME="IDX519"></A>
  Иногда вы можете захотеть обратиться к файлу в режиме только чтения,
чтобы защититься от случайного внесения изменений; делайте это,
обращаясь к файлу с помощью команды <KBD>C-x C-r</KBD>
(<CODE>find-file-read-only</CODE>).


<P>
<A NAME="IDX520"></A>
<A NAME="IDX521"></A>
  Если вы обратились к несуществующему файлу неумышленно (так как вы
набрали неправильное имя файла), используйте команду <KBD>C-x C-v</KBD>
(<CODE>find-alternate-file</CODE>), чтобы обратиться к файлу, который вам
нужен на самом деле.  <KBD>C-x C-v</KBD> подобна <KBD>C-x C-f</KBD>, но уничтожает
текущий буфер (после того, как сначала предложит записать его, если он
изменен).  При считывании нового имени файла она вставляет полное имя
текущего файла, оставляя точку сразу после имени каталога; это удобно,
если вы сделали небольшую ошибку, когда вводили имя файла.


<P>
  Если вы обращаетесь к файлу, который существует, но не может быть
прочитан, <KBD>C-x C-f</KBD> выдает ошибку.


<P>
<A NAME="IDX522"></A>
<A NAME="IDX523"></A>
  <KBD>C-x 4 f</KBD> (<CODE>find-file-other-window</CODE>) похожа на <KBD>C-x C-f</KBD>,
но буфер, содержащий описанный файл, выбирается в другом окне.  Окно,
которое было выбранно до вызова <KBD>C-x 4 f</KBD>, продолжает показывать тот
же буфер, который уже показывался.  Если эта команда используется, когда
существует только одно окно, то это окно делится на два, одно из которых
продолжает показывать то же, что и прежде, а другое показывает новый
затребованный файл.  See section <A HREF="emacs_21.html#SEC169">Множество окон</A>.


<P>
<A NAME="IDX524"></A>
<A NAME="IDX525"></A>
  <KBD>C-x 5 f</KBD> (<CODE>find-file-other-frame</CODE>) аналогична этой команде,
но открывает новый фрейм или делает видимым любой существующий фрейм,
показывающий искомый файл.  Это возможно, только если вы пользуетесь
оконной системой.  See section <A HREF="emacs_22.html#SEC176">Фреймы и X Windows</A>.


<P>
<A NAME="IDX526"></A>
  Если вы хотите отредактировать файл как последовательность знаков без
особой перекодировки или преобразования, используйте команду <KBD>M-x
find-file-literally</KBD>.  Она обращается к файлу, как <KBD>C-x C-f</KBD>, но не
делает преобразования формата (see section <A HREF="emacs_26.html#SEC239">Редактирование форматированного текста</A>),
преобразования знаковых кодов (see section <A HREF="emacs_23.html#SEC205">Системы кодирования</A>) или
автоматической распаковки (see section <A HREF="emacs_19.html#SEC159">Доступ к сжатым файлам</A>).  Если вы уже
обращаетесь к этому же файлу обычным способом (не буквально), эта
команда спросит вас, обратиться ли к нему в этот раз буквально.


<P>
<A NAME="IDX527"></A>
<A NAME="IDX528"></A>
  Две переменные-ловушки позволяют расширениям изменять способ обращения
к файлам.  Обращение к несуществуещему файлу запускает функции в списке
<CODE>find-file-not-found-hooks</CODE>; значение этой переменной -- список
функций, и эти функции вызываются одна за другой до тех пор, пока одна
из них не вернет отличное от <CODE>nil</CODE> значение.  Любое обращение к
файлу, существующему или нет, предполагает, что <CODE>find-file-hooks</CODE>
содержит список функций, и вызывает их все одну за другой.  В обоих
случаях функции вызываются без аргументов.  Первой применяется
переменная <CODE>find-file-not-found-hooks</CODE>.  Эти переменные <EM>не</EM>
нормальные ловушки, и для обозначения этого их имена заканчиваются на
<SAMP>`-hooks'</SAMP>, а не на <SAMP>`-hook'</SAMP>.  See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.


<P>
  Есть несколько способов автоматически указать основной режим для
редактирования файла (see section <A HREF="emacs_24.html#SEC212">Как выбираются основные режимы</A>) и установить локальные
переменные, определенные для этого файла (see section <A HREF="emacs_36.html#SEC451">Локальные переменные в файлах</A>).




<H2><A NAME="SEC111" HREF="emacs_toc.html#TOC111">Сохранение файлов</A></H2>

<P>
  <EM>Сохранение</EM> буфера в Emacs означает запись его содержимого
обратно в файл, к которому этот буфер обращается.


<DL COMPACT>

<DT><KBD>C-x C-s</KBD>
<DD>
Сохранить текущий буфер в файле, к которому этот буфер обращается
(<CODE>save-buffer</CODE>).
<DT><KBD>C-x s</KBD>
<DD>
Сохранить некоторые или все буферы в их соответствующих файлах
(<CODE>save-some-buffers</CODE>).
<DT><KBD>M-~</KBD>
<DD>
Забыть, что текущий буфер был изменен (<CODE>not-modified</CODE>).
<DT><KBD>C-x C-w</KBD>
<DD>
Сохранить текущий буфер в заданный файл (<CODE>write-file</CODE>).
<DT><KBD>M-x set-visited-file-name</KBD>
<DD>
Изменить имя файла, под которым текущий буфер будет сохраняться.
</DL>

<P>
<A NAME="IDX529"></A>
<A NAME="IDX530"></A>
  Если вы хотите сохранить файл и сделать его изменения постоянными,
наберите <KBD>C-x C-s</KBD> (<CODE>save-buffer</CODE>).  После того, как запись
закончится, <KBD>C-x C-s</KBD> печатает сообщение подобное этому:



<PRE>
Wrote /u/rms/gnu/gnu.tasks
</PRE>

<P>
Если же выбранный буфер не модифицирован (в нем не было сделано
изменений с тех пор, как он был создан или последний раз записан), его
запись не делается, так как это не имеет смысла.  Вместо этого, <KBD>C-x
C-s</KBD> печатает такое сообщение в эхо-области:



<PRE>
(No changes need to be saved)
</PRE>

<P>
<A NAME="IDX531"></A>
<A NAME="IDX532"></A>
  Команда <KBD>C-x s</KBD> (<CODE>save-some-buffers</CODE>) предлагает записать
какие-либо или все измененные буферы.  Она спрашивает вас, что нужно
сделать с каждым буфером.  Возможные варианты ответа аналогичны
вариантам для <CODE>query-replace</CODE>:


<DL COMPACT>

<DT><KBD>y</KBD>
<DD>
Сохранить этот буфер и спрашивать об остальных.
<DT><KBD>n</KBD>
<DD>
Не сохранять этот буфер, но спрашивать об остальных.
<DT><KBD>!</KBD>
<DD>
Сохранить этот буфер и все остальные без дальнейших вопросов.
<DT><KBD><KBD>RET</KBD></KBD>
<DD>
Прервать <CODE>save-some-buffers</CODE> и больше ничего не записывать.
<DT><KBD>.</KBD>
<DD>
Сохранить этот буфер и выйти из <CODE>save-some-buffers</CODE>, не спрашивая
об остальных буферах.
<DT><KBD>C-r</KBD>
<DD>
Просмотреть буфер, о котором вас спросили в данный момент.  Когда вы
выйдите из режима View, вы снова попадаете в <CODE>save-some-buffers</CODE>,
которая продолжает задавать вам вопросы.
<DT><KBD>C-h</KBD>
<DD>
Показать справочное сообщение о этих вариантах ответа.
</DL>

<P>
  <KBD>C-x C-c</KBD>, последовательность ключей для выхода из Emacs, вызывает
<CODE>save-some-buffers</CODE> и, следовательно, задает эти же вопросы.


<P>
<A NAME="IDX533"></A>
<A NAME="IDX534"></A>
  Если вы изменили буфер, но не хотите записывать изменения, вы должны
предпринять некоторые действия, чтобы предотвратить это.  Иначе каждый
раз, когда вы используете <KBD>C-x s</KBD> или <KBD>C-x C-c</KBD>, вы можете по
ошибке его записать.  С одной стороны, вы можете набрать <KBD>M-~</KBD>
(<CODE>not-modified</CODE>), что сбрасывает показатель измененности буфера.
Если вы сделаете так, то ни одна из команд записи не будет думать, что
буфер нужно сохранять.  (<SAMP>`~'</SAMP> часто используется как математический
символ для обозначения отрицания, таким образом, последовательность
<KBD>M-~</KBD> -- это мета-отрицание).  Вы могли бы также использовать
<CODE>set-visited-file-name</CODE> (смотрите ниже), чтобы пометить буфер, как
обратившийся к файлу с другим именем, который не использовался для
чего-то важного.  С другой стороны, вы можете отменить все изменения,
сделанные с тех пор, когда к файлу обратились, или он был записан, с
помощью повторного считывания текста из файла.  Это называется
<EM>возвращением</EM> к прежнему состоянию.  See section <A HREF="emacs_19.html#SEC117">Возвращение буфера</A>.  Вы могли
бы также отменить все изменения, повторяя команду отмены <KBD>C-x u</KBD>
достаточно долго; но возвращение проще.


<P>
<A NAME="IDX535"></A>
  <KBD>M-x set-visited-file-name</KBD> заменяет имя файла, к которому
обращается текущий буфер.  Она считывает новое имя файла, используя
минибуфер.  Затем соответственно изменяется имя буфера (если новое имя
уже не используется).  <CODE>set-visited-file-name</CODE> не записывает буфер
в новый вызванный файл, она просто меняет записи внутри Emacs на случай
последующего сохранения.  Она так же помечает буфер как "измененный",
так что <KBD>C-x C-s</KBD> <EM>будет</EM> его сохранять.


<P>
<A NAME="IDX536"></A>
<A NAME="IDX537"></A>
  Если вы хотите пометить буфер как обращающийся к другому файлу и
сразу его записать, используйте <KBD>C-x C-w</KBD> (<CODE>write-file</CODE>).  Это
совершенно точный эквивалент <CODE>set-visited-file-name</CODE>, за которым
следует <KBD>C-x C-s</KBD>.  Использование <KBD>C-x C-s</KBD> в буфере, который не
обращался к файлу, имеет то же самое действие, что и <KBD>C-x C-w</KBD>; то
есть, она считывает имя файла, метит буфер как обращающийся к этому
файлу и записывает его туда.  По умолчанию имя файла в буфере, который
не обращался к файлу, составляется из имени буфера и каталога по
умолчанию для этого буфера.


<P>
  Если новое имя файла подразумевает основной режим, то <KBD>C-x C-w</KBD> в
большинстве случаев переключает в этот режим.  Команда
<CODE>set-visited-file-name</CODE> ведет себя так же.  See section <A HREF="emacs_24.html#SEC212">Как выбираются основные режимы</A>.


<P>
  Если Emacs собирается записать файл и видит, что дата последней версии
на диске не соответствует тому, что он последний раз читал или
записывал, то он ставит вас в известность об этом факте, так как это,
возможно, выявляет проблему, вызванную одновременным редактированием, и
требует вашего незамедлительного внимания.  See section <A HREF="emacs_19.html#SEC116">Защита от одновременного редактирования</A>.


<P>
<A NAME="IDX538"></A>
  Если переменная <CODE>require-final-newline</CODE> не равна <CODE>nil</CODE>,
Emacs ставит ограничитель строки в конец каждого файла, который не
закончивается им, каждый раз, когда файл сохраняется или записывается.
По умолчанию эта переменная равна <CODE>nil</CODE>.




<H3><A NAME="SEC112" HREF="emacs_toc.html#TOC112">Резервные файлы</A></H3>
<P>
<A NAME="IDX539"></A>
<A NAME="IDX540"></A>
<A NAME="IDX541"></A>
<A NAME="IDX542"></A>


<P>
 В большинстве операционных систем переписывание файла автоматически
разрушает все сведения о том, что этот файл содержал раньше.  Таким
образом, запись файла из Emacs отбрасывает старое содержимое файла ---
или может отбросить, если перед фактической записью Emacs
предусмотрительно не скопирует старое содержимое в другой файл,
называемый <EM>резервным</EM>.


<P>
  Для большинства файлов решение о создании резервных копий определяется
переменной <CODE>make-backup-files</CODE>.  На большинстве операционных систем
ее значение по умолчанию равно <CODE>t</CODE>, что велит Emacs создавать
резервные файлы.


<P>
  Для файлов, находящихся под контролем системы управления версиями
(see section <A HREF="emacs_19.html#SEC123">Управление версиями</A>), это определяется переменной
<CODE>vc-make-backup-files</CODE>.  По умолчанию она равна <CODE>nil</CODE>, так как
резервные копии излишни, раз вы записываете все предыдущие версии в
системе управления версиями.  See section <A HREF="emacs_19.html#SEC153">Управление рабочими файлам в VC</A>.


<P>
  Существующее по умолчанию значение переменной
<CODE>backup-enable-predicate</CODE> запрещает записывать резервные копии для
файлов из каталога <TT>`/tmp'</TT>.


<P>
@hyphenation{ре-зерв-ный}
  По вашему выбору Emacs может сохранять либо только один резервный
файл, либо несколько нумерованных резервных файлов для каждого файла,
который вы редактировали.


<P>
  Emacs создает резервный файл только первый раз, когда файл
записывается из одного буфера.  Вне зависимости от того, сколько раз вы
записывали файл, его резервная копия продолжает содержать то, что было в
файле перед обращением.  Обычно это означает, что резервный файл
содержит то, что было в файле перед текущим сеансом редактирования;
однако, если вы уничтожите буфер, а затем обратитесь к файлу снова, то
при следующем сохранении будет создан новый резервный файл.


<P>
  Вы также можете явно запросить создание еще одной резервной копии из
буфера, даже если буфер был уже сохранен хотя бы раз.  Если вы сохраните
буфер с помощью <KBD>C-u C-x C-s</KBD>, записанная таким способом версия
станет резервной, если вы сохраните буфер снова.  <KBD>C-u C-u C-x C-s</KBD>
сохраняет буфер, но сначала переносит старое содержимое файла в новый
резервный файл.  <KBD>C-u C-u C-u C-x C-s</KBD> делает и то, и другое: она
создает резервную копию старого содержимого и готовится сделать еще одну
из вновь сохраненного содержимого, если вы сохраните буфер опять.




<H4><A NAME="SEC113" HREF="emacs_toc.html#TOC113">Одиночные или нумерованные резервные файлы</A></H4>

<P>
  Если вы решили держать единственный резервный файл (что принимается по
умолчанию), то его имя составляется путем добавления <SAMP>`~'</SAMP> к имени
редактируемого файла, таким образом, резервный файл для <TT>`eval.c'</TT>
назывался бы <TT>`eval.c~'</TT>.


<P>
  Если вы захотите иметь серию пронумерованных резервных файлов, то их
имена создаются путем добавления <SAMP>`.~'</SAMP>, номера и другой <SAMP>`~'</SAMP> к
исходному имени файла.  Таким образом, резервные копии файла
<TT>`eval.c'</TT> будут называться <TT>`eval.c.~1~'</TT>, <TT>`eval.c.~2~'</TT> и
так далее, проходя через такие имена, как <TT>`eval.c.~259~'</TT> и выше.


<P>
  Если защита запрещает вам записывать резервные файлы под обычными
именами, то они записываются как <TT>`%backup%~'</TT> в вашем начальном
каталоге.  Может существовать только один такой файл, поэтому доступна
только резервная копия, сделанная самой последней.


<P>
<A NAME="IDX543"></A>
  Выбор единственного резервного файла или нескольких управляется
переменной <CODE>version-control</CODE>.  Ее возможные значения:


<DL COMPACT>

<DT><CODE>t</CODE>
<DD>
Создавать нумерованные резервные файлы.
<DT><CODE>nil</CODE>
<DD>
Создавать нумерованные резервные файлы для файлов, которые уже имеют
нумерованные файлы.  Иначе создавать один резервный файл.
<DT><CODE>never</CODE>
<DD>
Никогда не создавать нумерованные файлы, всегда делать одиночный
резервный файл.
</DL>

<P>
Вы можете установить <CODE>version-control</CODE> локально в отдельном буфере,
для управления созданием резервных копий файла этого буфера.  Например,
режим Rmail локально устанавливает <CODE>version-control</CODE> на
<CODE>never</CODE>, чтобы быть уверенным, что для Rmail-файла существует
только один резервный файл.  See section <A HREF="emacs_36.html#SEC450">Локальные переменные</A>.


<P>
<A NAME="IDX544"></A>
Если вы установите переменную среды @env{VERSION_CONTROL}, чтобы указать
различным утилитам GNU, что делать с резервными файлами, Emacs также
подчиняется ей, устанавливая соответственно во время запуска переменную
Лиспа <CODE>version-control</CODE>.  Если значение этой переменной среды равно
<SAMP>`t'</SAMP> или <SAMP>`numbered'</SAMP>, то <CODE>version-control</CODE> становится
равной <CODE>t</CODE>; если это значение равно <SAMP>`nil'</SAMP> или <SAMP>`existing'</SAMP>,
то <CODE>version-control</CODE> становится <CODE>nil</CODE>; если это <SAMP>`never'</SAMP>
или <SAMP>`simple'</SAMP>, то <CODE>version-control</CODE> устанавливается в значение
<CODE>never</CODE>.




<H4><A NAME="SEC114" HREF="emacs_toc.html#TOC114">Автоматическое удаление резервных файлов</A></H4>

<P>
  Чтобы предотвратить неограниченное потребление пространства на диске,
Emacs может удалять пронумерованные резервные версии файлов
автоматически.  Обычно Emacs хранит только несколько первых и несколько
последних резервных файлов, уничтожая все находящиеся между ними.  Это
происходит каждый раз, когда создается новый резервный файл.


<P>
<A NAME="IDX545"></A>
<A NAME="IDX546"></A>
  Двумя переменными, контролирующими удаление, являются
<CODE>kept-old-versions</CODE> и <CODE>kept-new-versions</CODE>.  Их значения ---
это, соответственно, номер самой старой резервной копии файла
(наименьший номер), которая должна быть сохранена, и номер самой
последней копии (наибольший номер), которая должна сохраняться каждый
раз, когда создается новая копия.  Помните, что эти значения
используются сразу после того, как создастся новая резервная копия;
вновь созданная копия включается в счетчик <CODE>kept-new-version</CODE>.  По
умолчанию обе переменные равны 2.


<P>
<A NAME="IDX547"></A>
  Если <CODE>delete-old-versions</CODE> не равна <CODE>nil</CODE>, то излишек
средних версий уничтожается безропотно.  Если же она <CODE>nil</CODE>, как по
умолчанию, тогда вас спрашивают, должен ли быть уничтожен излишек
промежуточных версий.


<P>
 Команда Dired <KBD>.</KBD> (точка) также может быть использована для
удаления старых версий.  See section <A HREF="emacs_33.html#SEC374">Удаление файлов с помощью  Dired</A>.




<H4><A NAME="SEC115" HREF="emacs_toc.html#TOC115">Копирование vs. переименование</A></H4>

<P>
  Резервные файлы могут быть созданы с помощью копирования старого файла
или с помощью его переименования.  Эти варианты различаются, когда
старый файл имеет несколько имен.  Если старый файл переименовывается в
резервный, тогда очередные имена становятся именами для резервного
файла.  Если вместо этого старый файл копируется, то очередные имена
остаются именами для файла, который вы редактируете, и содержание,
доступное по этим именам, будет новым содержанием.


<P>
  Метод создания резервных файлов также может затронуть владельцев и
группы владельцев файлов.  Если используется копирование, то они не
изменяются.  Если используется переименование, то вы становитесь
владельцем файла, и устанавливается группа по умолчанию (различные
операционные системы используют различные значения по умолчанию для
группы).


<P>
  Изменение владельца обычно является хорошей идеей, поскольку тогда
всегда видно, кто последним редактировал файл.  Кроме того, владельцы
резервных копий показывают, кто сделал эти версии.  Иногда существует
файл, чей владелец не должен изменяться; хорошая идея для таких файлов
--- включить локальные списки переменных для установки
<CODE>backup-by-copying-when-mismatch</CODE> (see section <A HREF="emacs_36.html#SEC451">Локальные переменные в файлах</A>).


<P>
<A NAME="IDX548"></A>
<A NAME="IDX549"></A>
<A NAME="IDX550"></A>
  Выбор переименования или копирования управляется тремя переменными.
По умолчанию делается переименование.  Если переменная
<CODE>backup-by-coping</CODE> -- не <CODE>nil</CODE>, то используется копирование.
В противном случае, если переменная <CODE>backup-by-copying-when-linked</CODE>
не равна <CODE>nil</CODE>, то делается копирование для файлов, которые имеют
несколько имен, но может все же делаться переименование, когда
редактируемый файл имеет только одно имя.  Если переменная
<CODE>backup-by-copying-when-mismatch</CODE> -- не <CODE>nil</CODE>, тогда, если
переименование привело бы к изменению владельца файла или группы, то
делается копирование.  <CODE>backup-by-copying-when-mismatch</CODE> по
умолчанию равна <CODE>t</CODE>, если вы запустили Emacs как привилегированный
пользователь.


<P>
@hyphenation{соз-да-ет}
  Когда файл находится под управлением системы контроля версий
(see section <A HREF="emacs_19.html#SEC123">Управление версиями</A>), Emacs обычно не создает резервных копий
как обычно.  Но извлечение и фиксирование отчасти подобны созданию
резервных копий.  Они похожи, к сожалению, и тем, что как правило
разрушают жесткие ссылки, разъединяя имя файла, к которому вы
обратились, и все другие имена этого же файла.  Это не вина Emacs ---
это делает система управления версиями.




<H3><A NAME="SEC116" HREF="emacs_toc.html#TOC116">Защита от одновременного редактирования</A></H3>

<P>
<A NAME="IDX551"></A>
<A NAME="IDX552"></A>
<A NAME="IDX553"></A>
  Одновременное редактирование случается, когда два пользователя
обращаются к одному и тому же файлу, оба делают изменения и затем оба
сохраняют их.  Если никого не проинформировали о том, что это случилось,
то пользователь, сохранивший свои изменения первым, может позднее
обнаружить, что его изменения пропали.


<P>
  В некоторых системах Emacs сразу замечает, если второй пользователь
начинает изменять файл, и выдает немедленное предостережение.  На всех
системах Emacs делает проверку, когда вы записываете файл, и выдает
предупреждение, если вы собираетесь затереть изменения другого
пользователя.  Вы можете предотвратить потерю чужой работы, предприняв
необходимые действия вместо сохранения файла.


<P>
<A NAME="IDX554"></A>
<A NAME="IDX555"></A>
  Когда вы делаете первую модификацию в буфере Emacs, который обращается
к файлу, Emacs записывает, что вы <EM>захватили</EM> этот файл.  (Он делает
это, создавая символьную ссылку с другим именем в том же каталоге.)
Захват отменяется, когда вы запишете изменения.  Идея состоит в том, что
файл захвачен всегда, когда в буфере, который к нему обращается, есть
несохраненные изменения.


<P>
<A NAME="IDX556"></A>
  Если вы начнете изменять буфер, когда файл, к которому он обращается,
захвачен кем-то еще, это приведет к <EM>столкновению</EM>, и Emacs спросит
вас, что делать, вызвав лисповскую функцию <CODE>ask-user-about-lock</CODE>.
Вы можете переопределить эту функцию для своих нужд.  Стандартное
определение этой функции задает вам вопрос и принимает три возможных
ответа:


<DL COMPACT>

<DT><KBD>s</KBD>
<DD>
Перехватить захват.  Тот пользователь, кто уже редактировал файл, теряет
захват, а вы его приобретаете.
<DT><KBD>p</KBD>
<DD>
Продолжать.  Идти дальше и редактировать файл, несмотря на то, что он
кем-то захвачен.
<DT><KBD>q</KBD>
<DD>
Выйти.  Это приводит к ошибке (<CODE>file-locked</CODE>), а изменения, которые
вы пытались сделать в буфере, в действительности не будут иметь места.
</DL>

<P>
  Заметим, что захват работает на основе имени файла; если файл имел
несколько имен, Emacs не осознает, что два имени -- это один и тот же
файл, и не может предупредить двух пользователей о попытке
редактирования одного и того же файла под разными именами.  Однако,
основание захвата на именах означает, что Emacs может блокировать
редактирование новых файлов, которые фактически не существуют, пока их
не запишут.


<P>
  Некоторые системы не сконфигурированы так, чтобы позволить Emacs
сделать захваты.  В таких случаях Emacs не может определить опасность
заранее, но он по-прежнему может обнаружить столкновение, когда вы
пытаетесь сохранить файл и затереть чьи-то чужие изменения.


<P>
  Если в Emacs или в операционной системе случается фатальный сбой, это
может оставить файлы захвата, которые уже потеряли актуальность.
Поэтому вы можете иногда получить предупреждение о мнимых столкновениях.
Когда вы обнаружите, что столконение ложно, просто используйте <KBD>p</KBD>,
чтобы велеть Emacs продолжать.


<P>
  Каждый раз, когда Emacs записывает буфер, он сначала сверяет дату
последней модификации файла, существующего на диске, чтобы увидеть, что
она не изменялась с тех самых пор, как к файлу обращались или его
записывали последний раз.  Если дата не совпадает, то это означает, что
изменения были произведены в файле каким-то другим способом, и что эти
изменения могут быть потеряны, если Emacs сохранит буфер на самом деле.
Чтобы предотвратить это, Emacs печатает предостерегающее сообщение и
запрашивает перед записью подтверждение.  Иногда вы знаете, почему файл
был изменен, и знаете, что это не имеет значения; в этом случае вы
можете ответить <KBD>yes</KBD> и продолжить редактирование.  В противном
случае, вы должны отменить запись с помощью <KBD>C-g</KBD> и исследовать
ситуацию.


<P>
  Первое, что вы должны сделать, когда пришло извещение об одновременном
редактировании, -- распечатать каталог с помощью <KBD>C-u C-x C-d</KBD>
(see section <A HREF="emacs_19.html#SEC156">Каталоги файлов</A>).  Это покажет вам текущего автора.  Вы должны будете
попытаться связаться и предупредить его, чтобы он не продолжал
редактирование.  Чаще всего, следующий шаг -- записать содержимое
вашего буфера Emacs под другим именем и использовать @command{diff},
чтобы сравнить два файла.




<H2><A NAME="SEC117" HREF="emacs_toc.html#TOC117">Возвращение буфера</A></H2>
<P>
<A NAME="IDX557"></A>
<A NAME="IDX558"></A>


<P>
  Если вы сделали обширные изменения в файле, а затем изменили ваше
мнение о них, то вы можете от них избавиться, считав предыдущую версию
этого файла.  Чтобы сделать это, используйте <KBD>M-x revert-buffer</KBD>,
она действует в текущем буфере.  Так как от безусловного возврата буфера
может пропасть много работы, вы должны подтвердить эту команду вводом
<KBD>yes</KBD>.


<P>
  <CODE>revert-buffer</CODE> сохраняет точку на том же самом расстоянии
(измеренном в знаках) от начала файла.  Если файл был отредактирован
только слегка, то после возвращения вы очутитесь примерно в той же части
текста, в которой и были.  Если вы сделали кардинальные изменения, то то
же самое значение точки в старом файле может ссылаться на совершенно
другой кусок текста.


<P>
  Возвращение помечает буфер как "неизмененный" до тех пор, пока не
будут сделаны другие изменения.


<P>
  Некоторые виды буферов, чье содержимое отражает отличные от файлов
данные, такие как буферы Dired, также могут быть возвращены.  Для них
возвращение означает повторное считываение их содержимого из
соответствующей базы данных.  Буферы, созданные явно с помощью <KBD>C-x
b</KBD>, не могут быть возвращены; <CODE>revert-buffer</CODE> сообщает об ошибке,
когда ее просят сделать это.


<P>
<A NAME="IDX559"></A>
  Когда вы редактируете файл, который изменяется часто и автоматически
--- например, протокол вывода от еще работающего процесса -- может
оказаться удобным, если бы Emacs возвращал файл без подтверждения всякий
раз, когда вы снова обращаетесь к этому файлу с помощью <KBD>C-x C-f</KBD>.


<P>
  Чтобы запросить такое поведение, установите переменную
<CODE>revert-without-query</CODE> равной списку регулярных выражений.  Когда
имя файла соответствует одному из этих регулярных выражений,
<CODE>find-file</CODE> и <CODE>revert-buffer</CODE> будут возвращать его
автоматически, если он изменился -- при условии, что сам буфер не был
модифицирован.  (Если вы редактировали текст, сбрасывать ваши изменения
будет нехорошо.)




<H2><A NAME="SEC118" HREF="emacs_toc.html#TOC118">Самосохранение: защита от гибели</A></H2>
<P>
<A NAME="IDX560"></A>
<A NAME="IDX561"></A>
<A NAME="IDX562"></A>
<A NAME="IDX563"></A>


<P>
  Emacs время от времени (основываясь на подсчете нажатых вами клавиш)
записывает все посещенные файлы без запроса.  Это называется
<EM>самосохранением</EM>.  Оно убережет вас от потери большого количества
работы, если система рухнет.


<P>
  Когда Emacs определяет, что пришло время для самосохранения, то каждый
буфер рассматривается и записывается, если для него включено
самосохранение, и он изменялся с тех пор, как последний раз был
самосохранен.  Во время самосохранения в эхо-области отображается
сообщение <SAMP>`Auto-saving...'</SAMP>, если какой-либо файл действительно
сохраняется.  Ошибки, появляющиеся во время самосохранения,
отлавливаются так, что они не мешают выполнению набранных вами команд.




<H3><A NAME="SEC119" HREF="emacs_toc.html#TOC119">Файлы для самосохранения</A></H3>

<P>
  Самосохранение обычно не записывает в файлы, к которым вы обратились,
так как может быть очень нежелательно записывать программу, которая
находится в несогласованном состоянии, когда вы сделали половину
планируемых изменений.  Вместо этого самосохранение делается в другой
файл, который называется <EM>файлом для самосохранения</EM>, а посещенный
файл изменяется только тогда, когда вы явно потребуете записать его
(например, с помощью <KBD>C-x C-s</KBD>).


<P>
  Обычно имя файла для самосохранения создается добавлением знака
<SAMP>`#'</SAMP> перед и после имени файла, к которому вы обратились.  Таким
образом, буфер, обращающийся к файлу <TT>`foo.c'</TT>, будет самосохранен в
файл <TT>`#foo.c#'</TT>.  Большинство буферов, которые не обращались к
файлам, самосохраняются, только если вы явно потребуете этого; когда они
автоматически записываются, имя файла для самосохранения создается
добавлением к имени буфера знаков <SAMP>`#%'</SAMP> в начале и <SAMP>`#'</SAMP> в конце.
Например, буфер <TT>`*mail*'</TT>, в котором вы составляете отправляемые
сообщения, самосохраняется в файл с именем <TT>`#%*mail*#'</TT>.  Имена
файлов для самосохранения конструируются таким образом, если вы не
перепрограммируете часть Emacs, чтобы делалось что-то иное (функции
<CODE>make-auto-save-file-name</CODE> и <CODE>auto-save-file-name-p</CODE>).  Имя
файла, которое будет использоваться для самосохранения в буфере,
составляется, когда в этом буфере включается самосохранение.


<P>
  Когда вы удаляете значительную часть текста большого буфера,
самосохранение в нем временно выключается.  Это делается по той причине,
что если вы удалили текст неумышленно, самосохраненный файл может
оказаться для вас полезнее, если удаленный текст все еще остается в нем.
Чтобы после этого снова разрешить самосохранение, запишите буфер
командой <KBD>C-x C-s</KBD> или используйте <KBD>C-u 1 M-x auto-save</KBD>.


<P>
<A NAME="IDX564"></A>
  Если вы хотите, чтобы в файле, к которому вы обратились, выполнялось
самосохранение, установите переменную <CODE>auto-save-visited-file-name</CODE>
в отличное от <CODE>nil</CODE> значение.  В этом режиме в действительности нет
различий между самосохранением и явным сохранением.


<P>
<A NAME="IDX565"></A>
  Файл самосохранений удаляется, когда вы записываете содержимое буфера
в файл, к которому он обращался.  Чтобы воспрепятствовать этому,
установите переменную <CODE>delete-auto-save-files</CODE> равной <CODE>nil</CODE>.
Изменение имени посещенного файла с помощью <KBD>C-x C-w</KBD> или
<CODE>set-visited-file-name</CODE> переименовывает файл для самосохранения,
чтобы он соответствовал имени нового посещенного файла.




<H3><A NAME="SEC120" HREF="emacs_toc.html#TOC120">Управление самосохранением</A></H3>

<P>
<A NAME="IDX566"></A>
<A NAME="IDX567"></A>
  Каждый раз, когда вы обращаетесь к файлу, для буфера этого файла
включается самосохранение, если переменная <CODE>auto-save-default</CODE> не
равна <CODE>nil</CODE> (но не в пакетном режиме; see section <A HREF="emacs_8.html#SEC22">Вход и выход из Emacs</A>).  По
умолчанию эта переменная равна <CODE>t</CODE>, поэтому включенное
самосохранение -- это обычное состояние буферов, работающих с файлами.
Самосохранение может включаться или выключаться для любого существующего
буфера с помощью команды <KBD>M-x auto-save-mode</KBD>.  Подобно другим
командам второстепенных режимов, <KBD>M-x auto-save-mode</KBD> включает
самосохранение при положительном аргументе и выключает, когда аргумент
равен нулю или отрицателен; без аргумента она переключает режим.


<P>
<A NAME="IDX568"></A>
  Emacs производит самосохранение периодически, основываясь на подсчете
числа знаков, набранных вами с того момента, как самосохранение было
сделано в последний раз.  Переменная <CODE>auto-save-interval</CODE>
определяет, сколько знаков приходится между двумя самосохранениями.  По
умолчанию она равна 300.


<P>
<A NAME="IDX569"></A>
  Самосохранение также производится, когда вы перестаете печатать на
некоторое время.  Переменная <CODE>auto-save-timeout</CODE> говорит, сколько
секунд должен ждать Emacs то того, как сделать самосохранение (а также,
возможно, и сборку мусора).  (Действительный период времени больше, если
теущий буфер велик; это эвристика, цель которой -- не мешать вам, когда
вы редактируете длинные буферы, самосохранение в которых занимает
заметное время.)  Самосохранение во время периодов бездействия выполняет
две задачи: во-первых, оно гарантирует, что ваша работа сохраняется,
если вы отошли на некоторое время от терминала; во-вторых, оно может
позволить избежать самосохранения в то время, когда вы на самом деле
печатаете.


<P>
  Emacs также выполняет самосохранение, когда получает фатальную ошибку.
Это включает уничтожение задания Emacs с помощью команды оболочки, как
<SAMP>`kill %emacs'</SAMP>, или в результате разъединения телефонной линии или
связи по сети.


<P>
<A NAME="IDX570"></A>
  Вы можете явно запросить самосохранение с помощью команды <KBD>M-x
do-auto-save</KBD>.




<H3><A NAME="SEC121" HREF="emacs_toc.html#TOC121">Восстановление данных из самосохранения</A></H3>

<P>
<A NAME="IDX571"></A>
  Вы можете использовать содержимое файла самосохранения для
восстановления потерянных данных, запустив команду <KBD>M-x recover-file
<KBD>RET</KBD> <VAR>файл</VAR> <KBD>RET</KBD></KBD>.  Эта команда обращается к <VAR>файлу</VAR> и
затем (после вашего подтверждения) переписывает содержание из его
самосохраненного файла <TT>`#<VAR>файл</VAR>#'</TT>.  Вы можете потом сохранить
этот буфер при помощи <KBD>C-x C-s</KBD>, чтобы поместить восстановленный
текст в сам <VAR>файл</VAR>.  Например, чтобы восстановить файл <TT>`foo.c'</TT>
из его файла для самосохранения <TT>`#foo.c#'</TT>, сделайте следующее:



<PRE>
M-x recover-file <KBD>RET</KBD> foo.c <KBD>RET</KBD>
yes <KBD>RET</KBD>
C-x C-s
</PRE>

<P>
  Перед тем как запросить у вас подтверждение, <KBD>M-x recover-file</KBD>
показывает распечатку каталога, описывающую заданный файл и файл
самосохранения, так что вы можете сравнить их размеры и даты.  Если файл
для самосохранения старше, то <KBD>M-x recover-file</KBD> не предлагает его
считывать.


<P>
<A NAME="IDX572"></A>
  Если Emacs или комьютер потерпели крах, вы можете восстановить все
файлы, которые вы редактировали, из их самосохраненных файлов при помощи
команды <KBD>M-x recover-session</KBD>.  Она сначала показывает перечень
записанных прерванных сеансов.  Переместите точку к нужной вам и
наберите <KBD>C-c C-c</KBD>.


<P>
  Затем <CODE>recover-session</CODE> спрашивает о каждом файле, который
редактировался во время этого сеанса, нужно ли его восстанавливать.
Если вы отвечаете <KBD>y</KBD>, она вызывает <CODE>recover-file</CODE>.  Эта
команда работает обычным способом: показывает даты оригинального файла и
его самосохраненной версии и спрашивает еще раз, нужно ли его
восстанавливать.


<P>
  Когда <CODE>recover-session</CODE> завершается, все файлы, которые вы решили
восстановить, присутствуют в буферах Emacs.  Теперь вам нужно их
сохранить.  Только это -- их сохранение -- обновляет сами файлы.


<P>
<A NAME="IDX573"></A>
  Прерванные сеансы записываются для последующего восстановления в
файлах с именами <TT>`~/.saves-<VAR>pid</VAR>-<VAR>машина</VAR>'</TT>.  Часть
<SAMP>`~/.saves'</SAMP> этих имен получается из знаечения
<CODE>auto-save-list-file-prefix</CODE>.  Вы можете сделать так, чтобы записи
о сеансах держались в другом месте, устанавливая эту переменную в вашем
файле <TT>`.emacs'</TT>, но вам также придется переопределить
<CODE>recover-session</CODE>, чтобы она искала в новом месте.  Если в файле
<TT>`.emacs'</TT> вы установите <CODE>auto-save-list-file-prefix</CODE> равной
<CODE>nil</CODE>, сеансы не будут записываться для восстановления.




<H2><A NAME="SEC122" HREF="emacs_toc.html#TOC122">Псевдонимы файлов</A></H2>

<P>
  Символьные ссылки и жесткие ссылки позволяют одному и тому же файлу
иметь несколько имен.  Жесткие ссылки -- это альтернативные имена,
ссылающиеся непосредственно на файл; все имена одинаково правильны, и ни
одно из них не является предпочтительным.  Напротив, символьные ссылки
--- это вид определенных псевдонимов: когда файл <TT>`foo'</TT> является
символьной ссылкой на <TT>`bar'</TT>, вы можете использовать оба имени, но
действительным именем будет <TT>`bar'</TT>, тогда как <TT>`foo'</TT> -- это
просто псевдоним.  Более сложные ситуации возникают, когда символьные
ссылки указывают на каталоги.


<P>
  Если вы обращаетесь к одному и тому же файлу по двум именам, Emacs
обычно создает два разных буфера, но предупреждает вас об этой ситуации.


<P>
<A NAME="IDX574"></A>
  Если вы хотите избежать обращения к одному и тому же файлу в двух
буферах под разными именами, установите переменную
<CODE>find-file-existing-other-name</CODE> в отличное от <CODE>nil</CODE> значение.
Тогда <CODE>find-file</CODE> использует существующий буфер, обращающийся к
этому файлу, независимо от того, какое имя вы зададите.


<P>
<A NAME="IDX575"></A>
<A NAME="IDX576"></A>
<A NAME="IDX577"></A>
  Если переменная <CODE>find-file-visit-truename</CODE> не равна <CODE>nil</CODE>,
то для буферов записывается <EM>истинные имена</EM> файлов (получаемые
заменой всех символьных ссылок на их целевые имена), а не имена,
заданные вами.  Установка <CODE>find-file-visit-truename</CODE> также
подразумевает действие <CODE>find-file-existing-other-name</CODE>.




<H2><A NAME="SEC123" HREF="emacs_toc.html#TOC123">Управление версиями</A></H2>
<P>
<A NAME="IDX578"></A>


<P>
  <EM>Системы управления версиями</EM> -- это пакеты, которые могут
записывать несколько версий исходного файла, обычно сохраняя
неизменившиеся части этого файла только один раз.  Системы управления
версиями также записывают сведения об истории, такие как время создания
каждой версии, имя ее создателя и описание изменений в этой версии.


<P>
  Интерфейс Emacs для управления версиями называется VC.  Его команды
работают с тремя системами управления версиями -- RCS, CVS и SCCS.
Проект GNU рекомендует RCS и CVS, которые являются свободными
программами, и их можно получить от Фонда Свободного Программного
Обеспечения.




<H3><A NAME="SEC124" HREF="emacs_toc.html#TOC124">Введение в управление версиями</A></H3>

<P>
  VC позволяет вам использовать системы управления версиями из Emacs,
хорошо интегрируя операции по управлению версиями и редактирование.  VC
предоставляет обобщенный интерфейс к управлению версиями, так что вы
можете использовать его одним методом независимо от того, какую систему
вы применяете.


<P>
  Этот раздел предоставляет общий обзор управления версиями и описывает
системы управления версиями, которые поддерживает VC.  Вы можете
пропустить этот раздел, если знакомы с системой управления версиями,
которую хотите использовать.




<H4><A NAME="SEC125" HREF="emacs_toc.html#TOC125">Поддерживаемые системы управления версиями</A></H4>

<P>
<A NAME="IDX579"></A>
<A NAME="IDX580"></A>
  На данный момент VC работает с тремя разными системами управления
версиями или "постпроцессорами": RCS, CVS и SCCS.


<P>
  RCS -- это свободная система управления версиями, ее можно получить
от Фонда Свободного Программного Обеспечения.  Вероятно, это наиболее
развитый из поддерживаемых постпроцессоров, и команды VC концептуально
ближе всего к RCS.  Почти все, что вы можете делать с RCS, можно сделать
через VC.


<P>
<A NAME="IDX581"></A>
  CVS построена поверх RCS и расширяет возможности RCS, позволяя более
сложное управление выпусками и разработку многими пользователями.  VC
поддерживает основные операции редактирования под CVS, но для некоторых
менее частых задач вам все же понадобится вызывать CVS из командной
строки.  Заметьте, что до использования CVS вы должны настроить
репозиторий, но это слишком сложная тема, чтобы ее здесь рассматривать.


<P>
<A NAME="IDX582"></A>
  SCCS -- это несвободная, но широко используемая система управления
версиями.  По возможностям это самая слабая из трех систем,
поддерживаемых VC.  VC компенсирует отсутствие некоторых средств в SCCS
(снимков, например), реализуя их сама, но некоторые другие возможности
VC, такие как множественные ветви, недоступны при использовании SCCS.
Вам стоит применять SCCS, только если по какой-то причине вы не можете
воспользоваться RCS.




<H4><A NAME="SEC126" HREF="emacs_toc.html#TOC126">Концепции управления версиями</A></H4>

<P>
<A NAME="IDX583"></A>
<A NAME="IDX584"></A>
   Когда файл помещен под контроль системы управления версиями, мы
говорим, что он <EM>зарегистрирован</EM> в этой системе.  Для каждого
зарегистрированного файла есть соответствующий <EM>мастер-файл</EM>,
который представляет текущее состояние файла и историю его изменений ---
достаточную для реконструкции текущей или любой более ранней версии.
Обычно в мастер-файле также сохранены <EM>журнальные записи</EM> для каждой
версии, описывающие словами, что было изменено в этой версии.


<P>
<A NAME="IDX585"></A>
<A NAME="IDX586"></A>
  Файл, сопровождаемый управлением версий, иногда называется
<EM>рабочим файлом</EM>, соответствующим его мастер-файлу.  Вы редактируете
рабочий файл и делаете в нем изменения, как вы делали бы йдля обычного
файла.  (В SCCS и RCS вы должны <EM>блокировать</EM> файл перед тем, как
начать его редактировать.)  После того, как вы сделали некоторые
изменения, вы <EM>фиксируете</EM> этот файл, что записывает эти изменения в
мастер-файле вместе с журнальной записью для них.


<P>
  В CVS обычно бывает много рабочих файлов, соответствующих одному
мастер-файлу -- часто у каждого пользователя есть своя копия.  Таким
способом можно использовать и RCS, но это не обычный метод ее
применения.


<P>
<A NAME="IDX587"></A>
  В системе управления версиями как правило есть некий механизм для
координирования пользователей, которые хотят редактировать один и тот же
файл.  Один из способов -- <EM>блокирование</EM> (аналогичное
блокированию, которое Emacs применяет для отслеживания попыток
одновременного редактирования файла, но отличающееся от него).  Другой
метод -- объединение ваших изменений с изменениями другого человека при
их фиксировании.


<P>
  При управлении версиями с блокированием, рабочие файлы обычно доступны
только для чтения, так что вы не можете их изменить.  Вы просите систему
управления версиями сделать файл записываемым, блокируя его; в одно
время это может сделать только один пользователь.  Когда вы фиксируете
ваши изменения, это разблокирует файл, и он снова становится доступным
только для чтения.  Это позволяет другим пользователям заблокировать
этот файл и делать дальнейшие изменения.  SCCS всегда использует
блокирование, и RCS обычно тоже.


<P>
  Для RCS есть другая альтернатива -- позволить каждому пользователю
изменять рабочий файл в любое время.  В таком режиме в блокировании нет
нужды, но оно позволяется; запись новой версии по-прежнему производится
путем фиксирования.


<P>
  CVS обычно позволяет каждому пользователю изменять свою собственную
копию рабочего файла в любое время, но требует объединения с версиями
других пользователей во время фиксирования.  Однако, CVS тоже можно
настроить так, чтобы она требовала блокирования.  (see section <A HREF="emacs_19.html#SEC152">Параметры для постпроцессора VC</A>).




<H3><A NAME="SEC127" HREF="emacs_toc.html#TOC127">Управление версиями и строка режима</A></H3>

<P>
  Когда вы обращаетесь к файлу, который находится под контролем системы
управления версиями, Emacs показывает это в строке режима.  Например,
<SAMP>`RCS-1.3'</SAMP> говорит, что для этого файла используется RCS, а текущая
версия -- 1.3.


<P>
  Знак между именем постпроцессора и номером версии показывает статус
этого файла в системе управления версиями.  Дефис <SAMP>`-'</SAMP> говорит, что
рабочий файл не заблокирован (если блокирование используется) или не
изменен (если блокирование не используется).  Знак <SAMP>`:'</SAMP> показывает,
что файл блокирован или изменен.  Если файл блокировал какой-то другой
пользователь (скажем, <SAMP>`jim'</SAMP>), это отображается как
<SAMP>`RCS:jim:1.3'</SAMP>.




<H3><A NAME="SEC128" HREF="emacs_toc.html#TOC128">Основы редактирования с управлением версиями</A></H3>

<P>
  Основная команда VC -- это команда общего назначения, которая либо
блокирует, либо фиксирует файл в зависимости от ситуации.


<DL COMPACT>

<DT><KBD>C-x C-q</KBD>
<DD>
<DT><KBD>C-x v v</KBD>
<DD>
Делает следующую логическую операцию управления версиями для этого
файла.
</DL>

<P>
<A NAME="IDX588"></A>
<A NAME="IDX589"></A>
<A NAME="IDX590"></A>
<A NAME="IDX591"></A>
  Строго говоря, команда для этого называется <CODE>vc-next-action</CODE>, она
привязана к <KBD>C-x v v</KBD>.  Однако, обычное значение <KBD>C-x C-q</KBD> ---
делать буферы, предназначенные только для чтения, доступными для записи
или наоборот; мы расширили ее так, чтобы она правильно делала это же для
файлов, находящихся под контролем системы управления версиями, производя
подходящие операции.  Когда вы набираете <KBD>C-x C-q</KBD> в
зарегистрированнм файле, она ведет себя, как <KBD>C-x v v</KBD>.


<P>
  Точное действие этой команды зависит от состояния файла и от того,
использует ли система управления версиями блокирование или нет.  SCCS и
RCS обычно используют блокирование; CVS обычно не использует.




<H4><A NAME="SEC129" HREF="emacs_toc.html#TOC129">Основы управления версиями с блокированием</A></H4>

<P>
  Если для файла применяется блокирование (как в в случае с SCCS и RCS в
режиме по умолчанию), <KBD>C-x C-q</KBD> может либо блокировать файл, либо
зафиксировать его:



<UL>
<LI>

Если файл не заблокирован, <KBD>C-x C-q</KBD> блокирует его и делает
доступным для записи, чтобы вы могли его изменять.

<LI>

Если файл заблокирован вами и содержит изменения, <KBD>C-x C-q</KBD>
фиксирует эти изменения.  Для этого она сначала считывает журнальную
запись новой версии.  See section <A HREF="emacs_19.html#SEC131">Буфер журнальной записи</A>.

<LI>

Если файл заблокирован вами, но не содержит изменений с тех пор, как вы
его блокировали, <KBD>C-x C-q</KBD> снимает блокировку и делает файл опять
доступным только для чтения.

<LI>

Если файл заблокирован кем-то еще, <KBD>C-x C-q</KBD> спрашивает вас, хотите
ли вы "украсть блокировку" у этого пользователя.  Если вы ответите да,
то файл становится блокированным вами, но человеку, который раньше
заблокировал его, посылается сообщение, чтобы проинформировать о
случившемся.
</UL>

<P>
  Эти правила применимы также, когда вы используете CVS в блокирующем
режиме, за исключением того, что там нет такого понятия, как перехват
блокировки.




<H4><A NAME="SEC130" HREF="emacs_toc.html#TOC130">Основы управления версиями без блокирования</A></H4>

<P>
  Когда блокирования нет -- по умолчанию в CVS -- рабочие файлы всегда
доступны для записи; вам не нужно ничего делать перед тем, как начать
редактирование.  Индикатором статуса в строке режима служит <SAMP>`-'</SAMP>,
если файл не изменен; он заметяется на <SAMP>`:'</SAMP>, как только вы
сохраняете любые изменения в рабочем файле.


<P>
  Вот что делает <KBD>C-x C-q</KBD> при использовании CVS:



<UL>
<LI>

Если какой-то другой пользователь зафиксировал свои изменения в
мастер-файле, Emacs спрашивает вас, хотите ли вы влить эти изменения в
ваш рабочий файл (see section <A HREF="emacs_19.html#SEC142">Объединение ветвей</A>).  Вы обязаны сделать это до того,
как сможете зафиксировать свои собственные изменения.

<LI>

Если в мастер-файле нет изменений, но вы модификацировали ваш рабочий
файл, <KBD>C-x C-q</KBD> фиксирует ваши изменения.  Для этого она сначала
считывает журнальную запись для новой версии.  See section <A HREF="emacs_19.html#SEC131">Буфер журнальной записи</A>.

<LI>

Если файл не изменен, <KBD>C-x C-q</KBD> ничего не делает.
</UL>

<P>
  Эти правила применимы также и в том случае, если вы используете RCS в
режиме, когда она не требует блокирования, за исключением того, что
автоматическое объединение с мастер-файлом не реализовано.  К сожалению,
это означает, что вас не информируют, если еще один пользователь
зафиксировал изменения в том же файле после того, как вы начали
редактирование, и когда это происходит, его изменения в результате
исчезнут в вашей зафиксированной версии (хотя они останутся в
мастер-файле, так что не окажутся полностью потерянными).  Поэтому вы
должны убедиться, что текущая версия осталась неизмененной перед тем как
фиксировать свои изменения.  Мы надеемся устранить этот риск и
предоставить автоматическое объединение для RCS в будущей версии Emacs.


<P>
  Кроме того, даже в этом режиме RCS блокирование возможно, хоть и
необязательно; <KBD>C-x C-q</KBD> в неизмененном файле блокирует этот файл,
так же, как с RCS в обычном (блокирующем) режиме.




<H4><A NAME="SEC131" HREF="emacs_toc.html#TOC131">Буфер журнальной записи</A></H4>

<P>
  Когда вы фиксируете изменения, <KBD>C-x C-q</KBD> сначала считывает
журнальную запись.  Она поднимает буфер с именем <TT>`*VC-Log*'</TT>, в
котором вы вводите журнальную запись.  Когда вы завершили, нажмите
<KBD>C-c C-c</KBD> в буфере <TT>`*VC-Log*'</TT>.  Только тогда происходит
действительное фиксирование.


<P>
  Чтобы прервать фиксирование, просто <STRONG>не</STRONG> набирайте <KBD>C-c
C-c</KBD> в этом буфере.  Вы можете переключать буферы и делать другое
редактирование.  Пока вы не пытаетесь зафиксировать другой файл, запись,
которую вы редактировали, остается в буфере <TT>`*VC-Log*'</TT>, и вы можете
в любое время вернуться в этот буфер и завершить фиксирование.


<P>
  Если вы модифицируете несколько исходных файлов с одной целью, часто
бывает удобно указать одинаковую журнальную запись для многих файлов.
Чтобы сделать так, используйте историю предыдущих журнальных записей.
Предназначенные для этого команды <KBD>M-n</KBD>, <KBD>M-p</KBD>, <KBD>M-s</KBD> и
<KBD>M-r</KBD> работают так же, как команды истории минибуфера (за
исключением того, что они применяются вне минибуфера).


<P>
<A NAME="IDX592"></A>
  Каждый раз, когда вы фиксируете файл, буфер журнальной записи
помещается в режим VC Log, что влечет запуск двух ловушек:
<CODE>text-mode-hook</CODE> и <CODE>vc-log-mode-hook</CODE>.  See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.




<H3><A NAME="SEC132" HREF="emacs_toc.html#TOC132">Просмотр и сравнение старых версий</A></H3>

<P>
  Одна из удобных возможностей систем управления версиями ---
возможность просмотра любой версии файла или сравнения двух версий.


<DL COMPACT>

<DT><KBD>C-x v ~ <VAR>версия</VAR> <KBD>RET</KBD></KBD>
<DD>
Показывает заданную <VAR>версию</VAR> файла, к которому вы обратились, в
отдельном буфере.

<DT><KBD>C-x v =</KBD>
<DD>
Сравнивает текущее содержимое буфера с последней зафиксированной версией
этого файла.

<DT><KBD>C-u C-x v = <VAR>файл</VAR> <KBD>RET</KBD> <VAR>старая-вер</VAR> <KBD>RET</KBD> <VAR>новая-вер</VAR> <KBD>RET</KBD></KBD>
<DD>
Сравнивает две заданные версии <VAR>файла</VAR>.

<DT><KBD>C-x v g</KBD>
<DD>
Выводит результат команды CVS annotate с использованием разных цветов.
</DL>

<P>
<A NAME="IDX593"></A>
<A NAME="IDX594"></A>
  Чтобы просмотреть старую версию in toto, обратитесь к файлу и наберите
<KBD>C-x v ~ <VAR>версия</VAR> <KBD>RET</KBD></KBD> (<CODE>vc-version-other-window</CODE>).
Это поместит текст указанной <VAR>версии</VAR> в файл с именем
<TT>`<VAR>имя-файла</VAR>.~<VAR>версия</VAR>~'</TT> и обратится к нему в новом буфере
в отдельном окне.  (В RCS, вы также можете выбрать старый буфер и
создать из него новую ветвь.  See section <A HREF="emacs_19.html#SEC139">Множество ветвей файла</A>.)


<P>
<A NAME="IDX595"></A>
<A NAME="IDX596"></A>
  Но обычно более удобно сравнивать две версии файла с помощью команды
<KBD>C-x v =</KBD> (<CODE>vc-diff</CODE>).  Просто <KBD>C-x v =</KBD> сравнивает текущее
содержимое буфера (сохраняя его в файл, если требуется) с последней
зафиксированной версией этого файла.  <KBD>C-u C-x v =</KBD> с числовым
аргументом считывает имя файла и номера двух версий, а затем сравнивает
эти версии указанного файла.


<P>
  Если вы зададите вместо зарегистрированного файла имя каталога, эта
команда сравнивает заданные версии всех зарегистрированных файлов в этом
каталоге и его подкаталогах.


<P>
  Вы можете задать зафиксированную версию числом; пустой ввод обозначает
текущее содержимое рабочего файла (оно может отличаться от всех
зафиксированных версий).  Вы также можете задать вместо одного или обоих
номеров версий имя снимка (see section <A HREF="emacs_19.html#SEC144">Снимки</A>).


<P>
  Эта команда работает путем запуска утилиты @command{diff}, передавая
ей аргументы из переменной <CODE>diff-switches</CODE>.  Она показывает вывод в
особом буфере в другом окне.  В отличие от команды <KBD>M-x diff</KBD>,
<KBD>C-x v =</KBD> не пытается определить позиции различий в старой и новой
версиях.  Так делается, потому что как правило одна или обе версии не
существуют в момент сравнения в виде файлов; они существуют только в
записях в мастер-файле.  See section <A HREF="emacs_19.html#SEC157">Сравнение файлов</A>, для получения большей
информации о <KBD>M-x diff</KBD>.


<P>
<A NAME="IDX597"></A>
<A NAME="IDX598"></A>
  Для файлов, управляемых CVS, вы можете посмотреть результат команды
CVS annotate с использованием разных цветов для улучшения внешнего вида.
Используйте для этого команду <KBD>M-x vc-annotate</KBD>.  Красным
обозначается новое, синим -- старое, а промежуточные цвета обозначают
промежуточные версии.  Префиксный аргумент <VAR>n</VAR> задает коэффициент
растяжения по временной шкале; он говорит, что каждый цвет покрывает в
<VAR>n</VAR> раз больший период времени.




<H3><A NAME="SEC133" HREF="emacs_toc.html#TOC133">Второстепенные команды VC</A></H3>

<P>
  Этот раздел объясняет второстепенные команды VC; те, что вы могли бы
использовать раз в день.




<H4><A NAME="SEC134" HREF="emacs_toc.html#TOC134">Регистрирование файла для управления версиями</A></H4>

<P>
<A NAME="IDX599"></A>
<A NAME="IDX600"></A>
  Вы можете поместить любой файл под контроль системы управления
версиями, просто обратясь к нему и набрав затем <KBD>C-x v i</KBD>
(<CODE>vc-register</CODE>).


<DL COMPACT>

<DT><KBD>C-x v i</KBD>
<DD>
Регистрирует файл в системе управления версиями.
</DL>

<P>
<A NAME="IDX601"></A>
  Чтобы зарегистрировать файл, Emacs должен выбрать, какую систему
управления версиями для него использовать.  Вы можете указать свой выбор
явно, устанавливая <CODE>vc-default-back-end</CODE> в значения <CODE>RCS</CODE>,
<CODE>CVS</CODE> или <CODE>SCCS</CODE>.  Иначе, если есть подкаталог с именем
<TT>`RCS'</TT>, <TT>`SCCS'</TT> или <TT>`CVS'</TT>, Emacs использует соответствующую
систему управления версиями.  В отсутствие каких-либо указаний, по
умолчанию выбирается RCS, если в системе установлена RCS, иначе SCCS.


<P>
  Если применяется блокирование, <KBD>C-x v i</KBD> оставляет файл
неблокированным и запрещает в запись.  Наберите <KBD>C-x C-q</KBD>, если вы
хотите начать в нем редактирование.  После регистрирования с
использованием CVS вы должны зафиксировать изменения, набрав <KBD>C-x
C-q</KBD>.


<P>
<A NAME="IDX602"></A>
  Первоначальной версии вновь зарегистрированного файла присваивается
номер 1.1, по умолчанию.  Вы можете задать другое значение по умолчанию,
устанавливая переменную <CODE>vc-default-init-version</CODE>, или вы можете
дать <KBD>C-x v i</KBD> числовой аргумент; тогда она считывает номер версии
для этого конкретного файла в минибуфере.


<P>
<A NAME="IDX603"></A>
  Если <CODE>vc-initial-comment</CODE> отлична от <CODE>nil</CODE>, <KBD>C-x v i</KBD>
считывает начальный комментарий, описывающий предназначение данного
исходного файла.  Начальный комментарий считывается так же, как
журнальные записи (see section <A HREF="emacs_19.html#SEC131">Буфер журнальной записи</A>).




<H4><A NAME="SEC135" HREF="emacs_toc.html#TOC135">Команды VC для выяснения статуса файла</A></H4>

<DL COMPACT>

<DT><KBD>C-x v l</KBD>
<DD>
Показывает состояние файла в системе управления версиями и историю
изменений.
</DL>

<P>
<A NAME="IDX604"></A>
<A NAME="IDX605"></A>
  Чтобы просмотреть подробную информацию о статусе версии и историю
файла, наберите <KBD>C-x v l</KBD> (<CODE>vc-print-log</CODE>).  Это покажет
историю изменений текущего файла, в том числе текст журнальных записей.
Вывод появляется в другом окне.




<H4><A NAME="SEC136" HREF="emacs_toc.html#TOC136">Отмена действий над версиями</A></H4>

<DL COMPACT>

<DT><KBD>C-x v u</KBD>
<DD>
Возвращает буфер и его файл к последней зафиксированной версии.

<DT><KBD>C-x v c</KBD>
<DD>
Удаляет последнее внесенное изменение из мастер-файла для файла, к
которому вы обратились.  Это отменяет ваше последнее фиксирование.
</DL>

<P>
<A NAME="IDX606"></A>
<A NAME="IDX607"></A>
  Если вы хотите сбросить ваши текущие изменения и вернуть файл к его
последней версии, используйте <KBD>C-x v u</KBD> (<CODE>vc-revert-buffer</CODE>).
Файл остается неблокированным; если используется блокирование, до того,
как сможете изменять этот файл, вы должны сначала снова его
заблокировать.  <KBD>C-x v u</KBD> требует подтверждения, если только она не
видит, что вы не вносили изменения со времени последего фиксирования.


<P>
  <KBD>C-x v u</KBD> также нужна для разблокирования файла, когда вы
блокировали его, а потом решили не изменять.


<P>
<A NAME="IDX608"></A>
<A NAME="IDX609"></A>
  Чтобы отменить уже зафиксированное изменение, используйте <KBD>C-x v
c</KBD> (<CODE>vc-cancel-version</CODE>).  Эта команда сбрасывает все записи о
последней фиксированной версии.  <KBD>C-x v c</KBD> также предлагает вернуть
ваш рабочий файл и буфер к предыдущей версии (к той, что предшествовала
удаляемой).


<P>
  Если вы отвечаете <KBD>no</KBD>, VC сохраняет ваши изменения в буфере и
блокирует файл.  Такая возможность полезна, когда вы зафиксировали
изменение, а затем обнаружили в нем тривиальную ошибку; вы можете
отменить фиксирование, исправить ошибку и снова зафиксировать файл.


<P>
  Когда <KBD>C-x v c</KBD> не возвращает буфер, она вместо этого сворачивает
все заголовки версий (see section <A HREF="emacs_19.html#SEC150">Вставка заголовков версий</A>).  Это делается по той
причине, что буфер больше не соответствует никакой существующей версии.
Если вы снова зафиксируете его, заголовки будут раскрыты правильно
относительно нового номера версии.


<P>
  Однако, автоматически свернуть заголовок RCS <SAMP>`$Log: emacs_19.html,v $
  Однако, автоматически свернуть заголовок RCS <SAMP>`Revision 1.1  2004/08/29 08:02:27  ott
  Однако, автоматически свернуть заголовок RCS <SAMP>`syncing with new locations
  Однако, автоматически свернуть заголовок RCS <SAMP>`
  Однако, автоматически свернуть заголовок RCS <SAMP>`Revision 1.1  2002/10/29 20:16:13  ott
  Однако, автоматически свернуть заголовок RCS <SAMP>`Updates to GNU section
  Однако, автоматически свернуть заголовок RCS <SAMP>`'</SAMP>
невозможно.  Если вы пишете этот заголовок, вы должны свернуть его
вручную -- удалив вхождение для версии, которую вы отменили.


<P>
  Будьте осторожны при вызове <KBD>C-x v c</KBD>, так как при этом легко
потерять много работы.  Чтобы помочь вам не допустить ошибки, эта
команда всегда требует подтверждения с <KBD>yes</KBD>.  Обратите внимание
также на то, что эта команда выключена под CVS, поскольку там отмена
версий очень опасна и не рекомендуется.




<H4><A NAME="SEC137" HREF="emacs_toc.html#TOC137">Dired под VC</A></H4>

<P>
<A NAME="IDX610"></A>
<A NAME="IDX611"></A>
  Когда вы работаете над большой программой, часто бывает полезно
узнать, какие файлы были изменены в пределах целого дерева каталогов,
или просмотреть статус всех файлов с управлением версиями одновременно и
произвести какие-то операции над версиями для набора файлов.  Вы можете
использовать команду <KBD>C-x v d</KBD> (<CODE>vc-directory</CODE>), чтобы создать
распечатку каталога, который включает только файлы, имеющие отношение к
системе управления версиями.


<P>
<A NAME="IDX612"></A>
  <KBD>C-x v d</KBD> создает буфер, использующий режим VC Dired.  Он выглядит
как обычный буфер Dired (see section <A HREF="emacs_33.html#SEC371">Dired, редактор каталогов</A>); однако, как правило в нем
показаны только стоящие упоминания файлы (блокированные или
необновленные).  Это называется <EM>сжатым показом</EM>.  Если вы
установите переменную <CODE>vc-dired-terse-display</CODE> равной <CODE>nil</CODE>,
то VC Dired показывает все относящиеся к делу файлы -- те, что
находятся под контролем системы управления версиями, плюс все
подкаталоги (<EM>полный показ</EM>).  Команда <KBD>v t</KBD> в буфере VC Dired
переключает между сжатым и полным показом (see section <A HREF="emacs_19.html#SEC138">Команды VC Dired</A>).


<P>
<A NAME="IDX613"></A>
  По умолчанию VC Dired производит рекурсивую распечатку заслуживающих
упоминания или релевантных файлов в заданном каталоге и ниже.  Вы можете
изменить это, устанавливая переменную <CODE>vc-dired-recurse</CODE> равной
<CODE>nil</CODE>; тогда VC Dired показывает только файлы текущего каталога.


<P>
  Строка для отдельного файла показывает состояние версии на месте числа
жестких ссылок, владельца, группу и размер файла.  Если файл не изменен,
синхронизирован с мастер-файлом, статус версии пуст.  Иначе он состоит
из текста в круглых скобках.  Под RCS и SCCS показывается имя
пользователя, блокировавшего этот файл; под CVS используется сокращенная
версия вывода <SAMP>`cvs status'</SAMP>.  Вот пример с использованием RCS:



<PRE>
  /home/jim/project:

  -rw-r--r-- (jim)      Apr  2 23:39 file1
  -r--r--r--            Apr  5 20:21 file2
</PRE>

<P>
Файлы <SAMP>`file1'</SAMP> и <SAMP>`file2'</SAMP> находятся под управлеием RCS,
<SAMP>`file1'</SAMP> блокировал пользователь jim, а <SAMP>`file2'</SAMP> неблокирован.


<P>
  Вот пример с использованием CVS:



<PRE>
  /home/joe/develop:

  -rw-r--r-- (modified) Aug  2  1997 file1.c
  -rw-r--r--            Apr  4 20:09 file2.c
  -rw-r--r-- (merge)    Sep 13  1996 file3.c
</PRE>

<P>
  Здесь <SAMP>`file1.c'</SAMP> изменен по отношению к репозиторию, а
<SAMP>`file2.c'</SAMP> не изменен.  <SAMP>`file3.c'</SAMP> изменен, но в репозитории
были также зафиксированы другие изменения -- вам нужно объединить их в
рабочем файле перед фиксированием.


<P>
<A NAME="IDX614"></A>
  Когда VC Dired показывает подкаталоги (в режиме "полного" показа),
он опускает некоторые из них, которые никогда не могут содержать файлов
под контролем системы управления версиями.  По умолчанию это включает
каталоги, создаваемые этими системами, такие как <SAMP>`RCS'</SAMP> и
<SAMP>`CVS'</SAMP>; вы можете настраивать это, устанавливая переменную
<CODE>vc-directory-exclusion-list</CODE>.


<P>
  Вы можете подобрать подходящий формат VC Dired, набрав <KBD>C-u C-x v
d</KBD> -- как в обычном Dired, что позволяет вам указывать дополнительные
ключи для команды @command{ls}.




<H4><A NAME="SEC138" HREF="emacs_toc.html#TOC138">Команды VC Dired</A></H4>

<P>
  Все обычные команды Dired работают как всегда и в режиме VC Dired, за
исключением <KBD>v</KBD>, которая переопределена как префикс управления
версиями.  Вы можете вызывать команды VC, такие как <CODE>vc-diff</CODE> и
<CODE>vc-print-log</CODE>, набирая <KBD>v =</KBD> или <KBD>v l</KBD> и так далее.
Большинство этих команд применяются к имени файла на текущей строке.


<P>
  Команда <KBD>v v</KBD> (<CODE>vc-next-action</CODE>) обрабатывает все помеченные
файлы, так что вы можете заблокировать или зафиксировать несколько
файлов одновременно.  Если она работает более чем с одним файлом, то
обрабатывает каждый файл в соответствии с его статусом; таким образом,
она может блокировать один файл, но зафиксировать другой.  Возможно,
это смутит вас; но вы вольны избежать путаницы, помечая набор файлов с
одним и тем же статусом.


<P>
  Если какой-либо файл требует фиксирования, <KBD>v v</KBD> считывает
единственную журнальную запись и использует ее для всех фиксируемых
файлов.  Это удобно для одновременного регистрирования или фиксирования
нескольких файлов как частей одного изменения.


<P>
<A NAME="IDX615"></A>
<A NAME="IDX616"></A>
  Вы можете в любое время переключаться между сжатым показом (только
блокированные или необновленные файлы) и полным показом, набирая <KBD>v
t</KBD> <CODE>vc-dired-toggle-terse-mode</CODE>.  Есть также особая команда <KBD>*
l</KBD> (<CODE>vc-dired-mark-locked</CODE>), которая помечает все заблокированные в
данный момент файлы (или, для CVS, все необновленные).  Таким образом,
набор <KBD>* l t k</KBD> -- это другой способ удалить из буфера все файлы,
кроме тех, что сейчас заблокированы.




<H3><A NAME="SEC139" HREF="emacs_toc.html#TOC139">Множество ветвей файла</A></H3>
<P>
<A NAME="IDX617"></A>
<A NAME="IDX618"></A>


<P>
  Одно из применений управления версиями -- сопровождение нескольких
"текущих" версий файла.  Например, у вас могло бы быть несколько
разных версий программы, в которой вы постепенно добавляли различные
незавершенные новые возможности.  Каждая независимая линия разработки
называется <EM>ветвью</EM>.  VC позволяет вам создавать ветви,
переключаться между разными ветвями и вливать изменения из одной ветви в
другую.  Пожалуйста, заметьте однако, что такие ветви на данный момент
поддерживаются только для RCS.


<P>
  Главная линия развития файла обычно называется <EM>стволом</EM>.  Версии
ствола обычно нумеруются как 1.1, 1.2, 1.3, etc.  На любой из этих
версий вы можете начать независимую ветвь.  Ветвь, начинающаяся на
версии 1.2 имела бы номер 1.2.1.1, а последующие версии этой ветви имели
бы номера 1.2.1.2, 1.2.1.3, 1.2.1.4 и так далее.  Если есть вторая
ветвь, также начинающаяся на версии 1.2, она состояла бы из версий
1.2.2.1, 1.2.2.2, 1.2.2.3, etc.


<P>
<A NAME="IDX619"></A>
  Если вы опускаете последний компонент в номере версии, это называется
<EM>номером ветви</EM>.  Он ссылается на самую верхнюю существующую версию
этой ветви -- ее <EM>головную версию</EM>.  Ветви в примере выше имеют
номера 1.2.1 и 1.2.2.




<H4><A NAME="SEC140" HREF="emacs_toc.html#TOC140">Переключение между ветвями</A></H4>

<P>
  Чтобы переключиться между ветвями, введите <KBD>C-u C-x C-q</KBD> и укажите
номер версии, который вы хотите выбрать.  Тогда к этой версии делается
обращение в <EM>неблокированном</EM> (защищенном от записи) режиме, так
что вы можете просмотреть ее перед блокированием.  Переключение ветвей
таким способом допускается только тогда, когда файл блокирован.


<P>
  Вы можете опустить номер второстепенной версии, задавая таким образом
только номер ветви; это переносит вас к головной версии выбранной ветви.
Если вы наберете просто <KBD>RET</KBD>, Emacs переходит к самой верхней
версии ствола.


<P>
  После переключения на любую ветвь (включая главную), вы остаетесь в
ней с точки зрения всех последующих команд VC, пока явно не выберете
какую-то другую ветвь.




<H4><A NAME="SEC141" HREF="emacs_toc.html#TOC141">Создание новых ветвей</A></H4>

<P>
  Чтобы создать новую ветвь из головной версии (последней в своей
ветви), сначала выберите эту версию, если необходимо, заблокируйте ее
командой <KBD>C-x C-q</KBD> и делайте нужные вам изменения.  Затем, когда вы
фиксируете изменения, используйте <KBD>C-u C-x C-q</KBD>.  Это позволит вам
задать номер для новой версии.  Вы должны задать подходящий номер для
ветви, отходящей от текущей версии.  Например, если текущая версия ---
2.5, то номер ветви должен быть 2.5.1, 2.5.2 и так далее в зависимости
от номеров существующих ветвей в этой точке.


<P>
  Чтобы создать новую ветвь от более старой версии (той, что уже не
является головной в ветви), сначала выберите эту версию
(see section <A HREF="emacs_19.html#SEC140">Переключение между ветвями</A>), затем заблокируйте ее с помощью <KBD>C-x
C-q</KBD>.  Когда вы блокируете старую версию, вас попросят подтвердить, что
вы действительно имели в виду создание новой ветви, -- если вы ответите
нет, вам предоставят возможность блокировать вместо этого последнюю
версию.


<P>
  Потом вносите ваши изменения и снова наберите <KBD>C-x C-q</KBD>, чтобы
зафиксировать новую версию.  Это автоматически создаст новую ветвь от
выбранной версии.  Вам не нужно специально запрашивать создание новой
ветви, поскольку это единственный способ добавить новую версию в точке,
которая уже не находится в голове ветви.


<P>
  После того как ветвь создана, вы "остаетесь" в ней.
Это означает, что последующие фиксирования создают новые версии в этой
ветви.  Чтобы покинуть ветвь, вы должны явно выбрать другую версию с
помощью <KBD>C-u C-x C-q</KBD>.  Чтобы перенести изменения из одной ветви в
другую, используйте команду объединения, описанную в следующем разделе.




<H4><A NAME="SEC142" HREF="emacs_toc.html#TOC142">Объединение ветвей</A></H4>

<P>
<A NAME="IDX620"></A>
<A NAME="IDX621"></A>
  Когда вы закончили изменения в конкретной ветви, вам часто будет нужно
внести их в главную линию разработки файла (ствол).  Это нетривиальная
процедура, потому что в стволе тоже могло идти развитие, поэтому вы
должны <EM>объединить</EM> изменения с файлом, который уже был изменен
иначе.  VC позволяет вам сделать это (и другие вещи) при помощи команды
<CODE>vc-merge</CODE>.


<DL COMPACT>

<DT><KBD>C-x v m (vc-merge)</KBD>
<DD>
Вливает изменения в рабочий файл.
</DL>

<P>
<A NAME="IDX622"></A>
<A NAME="IDX623"></A>
  <KBD>C-x v m</KBD> (<CODE>vc-merge</CODE>) берет набор изменений и вливает их в
текущую версию рабочего файла.  Сначала она спрашивает у вас номер ветви
или пару номеров версий в минибуфере.  Затем она находит отличия от этой
ветви или между двумя заданными версиями и объединяет их в текущей
версии текущего файла.


<P>
  В качестве примера предположим, что вы завершили некоторое добавление
в ветви 1.3.1.  Тем временем разработка ствола продвинулась до версии
1.5.  Чтобы влить изменения в ствол, сначала перейдите в головную версию
ствола, набрав <KBD>C-u C-x C-q RET</KBD>.  Версия 1.5 теперь стала текущей.
Если для этого файла используется блокирование, наберите <KBD>C-x C-q</KBD>
для блокирования версии 1.5, чтобы вы могли ее изменять.  Затем наберите
<KBD>C-x v m 1.3.1 RET</KBD>.  Это возьмет весь набор изменений в ветви 1.3.1
(относительно версии 1.3, где ветвь была начата, и до самой последней
версии этой ветви) и вливает их в текущую версию рабочего файла.  Теперь
вы можете зафиксировать измененный файл, созадвая таким образом версию
1.6, содержащую изменения из ветви.


<P>
  После объединения можно делать дальнейшее редактирование до следующего
фиксирования.  Но обычно мудрее зафиксировать объединенную версию, затем
блокировать ее и только тогда продолжать редактирование.  Это сохранит
лучшую запись истории изменений.


<P>
<A NAME="IDX624"></A>
<A NAME="IDX625"></A>
  Когда вы вливаете изменения в файл, который сам был модифицирован,
различия могут перекрываться.  Мы называем такую ситуацию
<EM>конфликтом</EM>, а согласование различий называется <EM>разрешением
конфликта</EM>.


<P>
  Когда во время объединения возникают конфликты, VC замечает их,
говорит вам о них в эхо-области и спрашивает, хотите ли вы помочь в
объединении.  Если вы отвечаете да, VC запускает сеанс Ediff
(@pxref{Top, Ediff, Ediff, @external{ediff}, The Ediff Manual}).


<P>
  Если вы говорите нет, в файл вставляются оба конфликтующих изменения,
окруженные <EM>маркерами конфликта</EM>.  Пример ниже показывает, как
выглядят конфликтующие области; файл называется <SAMP>`имя-файла'</SAMP>, а
номер текущей версии в мастер-файле, где находятся с изменения
пользователя Б -- 1.11.



<PRE>
&#60;&#60;&#60;&#60;&#60;&#60;&#60; имя-файла
  <VAR>Версия пользователя А</VAR>
=======
  <VAR>Версия пользователя Б</VAR>
&#62;&#62;&#62;&#62;&#62;&#62;&#62; 1.11
</PRE>

<P>
<A NAME="IDX626"></A>
  Теперь вы можете разрешить конфликт, редактируя файл вручную.  Или вы
можете напечатать <CODE>M-x vc-resolve-conflicts</CODE> после обращения к
файлу.  Это запускает сеанс Ediff, как описано выше.




<H4><A NAME="SEC143" HREF="emacs_toc.html#TOC143">Многопользовательские разветвления</A></H4>

<P>
  Часто нескольким разработчикам бывает полезно работать одновременно
над различными ветвями файла.  CVS позволяет это по умолчанию; в RCS это
возможно, если вы создадите несколько исходных каталогов.  Каждый
исходный каталог должен иметь ссылку с именем <TT>`RCS'</TT>, которая
указывает на общий каталог с мастер-файлами RCS.  Тогда каждый исходный
каталог может хранить собственный набор выбранных версий, но все они
разделяют одни общие записи RCS.


<P>
  Этот метод работает надежно и автоматически, при условии, что исходные
файлы содержат заголовки RCS о версии (see section <A HREF="emacs_19.html#SEC150">Вставка заголовков версий</A>).  Эти
заголовки позволяют Emacs всегда точно знать номер версии, присутсвующей
в рабочем файле.


<P>
  Если в файлах нет заголовков версии, вы должны в каждом сеансе явно
говорить Emacs, над какой ветвью вы работаете.  Чтобы сделать так,
сначала обратитесь к файлу, затем наберите <KBD>C-u C-x C-q</KBD> и укажите
правильный номер версии.  Это должно гарантировать, что Emacs знает,
какая ветвь используется во время конкретного сеанса редактирования.




<H3><A NAME="SEC144" HREF="emacs_toc.html#TOC144">Снимки</A></H3>
<P>
<A NAME="IDX627"></A>


<P>
  <EM>Снимок</EM> -- это именованный набор версий файлов (одна для каждого
зарегистрированного файла), с которыми вы можете обращаться как с одним
целым.  Один важный вид снимка назвается <EM>выпуском</EM>, это
(теоретически) стабильная версия системы, готовая к распространению
среди пользователей.




<H4><A NAME="SEC145" HREF="emacs_toc.html#TOC145">Создание и использование снимков</A></H4>

<P>
  Есть две основные команды для работы со снимками; одна создает снимок
с заданным именем, а вторая извлекает именованный снимок.


<DL COMPACT>

<DT><CODE>C-x v s <VAR>имя</VAR> <KBD>RET</KBD></CODE>
<DD>
<A NAME="IDX628"></A>
 <A NAME="IDX629"></A>
 
Определяет последние сохраненные версии каждого зарегистрированного
файла в текущем каталоге или ниже него как снимок с заданным
<VAR>именем</VAR> (<CODE>vc-create-snapshot</CODE>).

<A NAME="IDX630"></A>
<A NAME="IDX631"></A>
<DT><CODE>C-x v r <VAR>имя</VAR> <KBD>RET</KBD></CODE>
<DD>
Для всех зарегистрированных файлов на уровне текущего каталога или ниже
выбирает версии, соответствующие снимку с заданным <VAR>именем</VAR>
(<CODE>vc-retrieve-snapshot</CODE>).

Эта команда сообщает об ошибке, если в текущем каталоге или ниже есть
заблокированные файлы, и ничего не изменяет; это делается для
предотвращения перезаписи редактируемых в данный момент файлов.
</DL>

<P>
  Снимок занимает очень небольшой объем ресурсов -- ровно столько,
сколько нужно для запоминания списка имен файлов и принадлежищих снимку
версий.  Поэтому нужно не колебаться и создавать снимки всегда, когда
они могут быть полезными.


<P>
  Вы можете предоставить в качестве аргумента для <KBD>C-x v =</KBD> или
<KBD>C-x v ~</KBD> имя снимка (see section <A HREF="emacs_19.html#SEC132">Просмотр и сравнение старых версий</A>).  Таким образом, вы
можете использовать это для сравнения снимка с текущими файлами, или
двух снимков друг с другом или снимка с заданной версией.




<H4><A NAME="SEC146" HREF="emacs_toc.html#TOC146">Опасные места при работе со снимками</A></H4>

<P>
<A NAME="IDX632"></A>
  Работа со снимками в VC смоделирована на основе поддежки именованных
конфигураций в RCS.  Для нее используются встроенные средства RCS,
поэтому снимки, сделанные под VC с использованием RCS, видны, даже когда
вы обходите VC.


<P>
  Для SCCS, VC реализует снимки сама.  Используемые ей файлы содержат
тройки имя/файл/номер-версии.  Такие снимки видны только через VC.


<P>
  Снимок -- это набор зафиксированных версий.  Поэтому при создании
снимка вы должны убедиться, что все файлы зафиксированы и неблокированы.


<P>
  Переименование и удаление файлов может создать некоторые трудности со
снимками.  Эта проблема не специфична для VC, но является общим вопросом
в реализации систем управления версиями, который никем еще не решен
хорошо.


<P>
  Если вы переименовываете зарегистрированный файл, вам нужно
переименовать и его мастер-файл (команда <CODE>vc-rename-file</CODE> делает
это автоматически).  Если вы пользуетесь SCCS, вы должны также обновить
записи о снимках, чтобы они ссылались на этот файл по новому имени
(<CODE>vc-rename-file</CODE> делает и это тоже).  Старый снимок, ссылающийся
на мастер-файл, который больше не существует под записанным именем, уже
не корректен; VC больше не может извлечь его.  Достаточное углубление в
подробности об RCS и SCCS для объяснения процесса ручного обновления
снимков вышло бы за рамки данного руководства.


<P>
  Использование <CODE>vc-rename-file</CODE> сохраняет корректность снимка для
извлечения, но не решает всех проблем.  Например, некоторые файлы в
программе вероятно ссылаются на другие файлы по именам.  По самой
меньшей мере, переименованный вами файл упомянут в Make-файле.  Если вы
извлекаете старый снимок, переименованный файл получает свое новое имя,
а не то, которое ожидает Make-файл.  Поэтому на самом деле программа не
заработает в том виде, в каком ее извлекли.




<H3><A NAME="SEC147" HREF="emacs_toc.html#TOC147">Различные команды и возможности VC</A></H3>

<P>
  Этот раздел рассказывает о других возможностях VC, применяемых не
столь часто.




<H4><A NAME="SEC148" HREF="emacs_toc.html#TOC148">Журналы изменений и VC</A></H4>

<P>
  Если вы используете для программы RCS или CVS и также сопровождаете
файл журнала ее изменений (see section <A HREF="emacs_27.html#SEC275">Журналы изменений</A>), вы можете автоматически
генерировать вхождения для него из журнальных записей системы управления
версиями:


<DL COMPACT>

<DT><KBD>C-x v a</KBD>
<DD>
<A NAME="IDX633"></A>
<A NAME="IDX634"></A>
Обращается к журнальному файлу текущего каталога и создает для
зарегистрированных файлов в этом каталоге новые вхождения для версий,
зафиксированных позже последнего вхождения в этом журнальном файле
(<CODE>vc-update-change-log</CODE>).

Эта команда работает только с RCS или CVS, но не с SCCS.

<DT><KBD>C-u C-x v a</KBD>
<DD>
Как выше, но находит вхождения только для файла текущего буфера.

<DT><KBD>M-1 C-x v a</KBD>
<DD>
Как выше, но находит вхождения для всех файлов, к которым вы
обращаетесь, и которые сопровождаются системой управления версиями.  Это
работает только с RCS и также помещает все вхождения в журнал для
каталога по умолчанию, что может не подходить.
</DL>

<P>
  Для примера предположим, что первая строка в <TT>`ChangeLog'</TT>
датирована 1999-04-10, и что с тех пор случилось только фиксирование,
сделанное Натениэлом Боудичем для <TT>`rcs2log'</TT> 1999-05-22 с журнальной
записью <SAMP>`Ignore log messages that start with `#'.'</SAMP>.  Тогда <KBD>C-x
v a</KBD> обращается к <TT>`ChangeLog'</TT> в вставляет подобный текст:


<P>
@medbreak

<PRE>
1999-05-22  Nathaniel Bowditch  &#60;nat@apn.org&#62;

        * rcs2log: Ignore log messages that start with `#'.
</PRE>

<P>
@medbreak


<P>
Теперь вы можете еще отредактировать новое вхождение в журнал по своему
желанию.


<P>
  К сожалению, метки в файлах ChangeLog сообщают только даты, поэтому
некоторые новые журнальные записи могут продублировать то, что уже есть
в ChangeLog.  Вам придется удалить дублирования вручную.


<P>
  Обычно вхождение в журнале для файла <TT>`foo'</TT> отображается как
<SAMP>`* foo: <VAR>текст вхождения</VAR>'</SAMP>.  Знак <SAMP>`:'</SAMP> после <TT>`foo'</TT>
опускается, если текст вхождения начинается со строки
<SAMP>`(<VAR>имя-функции</VAR>): '</SAMP>.  Например, если вхождение для
<TT>`vc.el'</TT> такое: <SAMP>`(vc-do-command): Check call-process status.'</SAMP>,
то текст в <TT>`ChangeLog'</TT> выглядит как:


<P>
@medbreak

<PRE>
1999-05-06  Nathaniel Bowditch  &#60;nat@apn.org&#62;

        * vc.el (vc-do-command): Check call-process status.
</PRE>

<P>
@medbreak


<P>
  Когда <KBD>C-x v a</KBD> добавляет несколько вхождений одновременно, она
группирует связанные между собой журнальные записи вместе, если все они
зафиксированы одним автором примерно в одно время.  Если вхождения для
нескольких таких файлов имеют одинаковый текст, она объединяет их в одно
вхождение.  Например, предположим, что последние фиксирования были с
такими журнальными записями:



<PRE>
* Для <TT>`vc.texinfo'</TT>: <SAMP>`Fix expansion typos.'</SAMP>
* Для <TT>`vc.el'</TT>: <SAMP>`Don't call expand-file-name.'</SAMP>
* Для <TT>`vc-hooks.el'</TT>: <SAMP>`Don't call expand-file-name.'</SAMP>
</PRE>

<P>
В <TT>`ChangeLog'</TT> они появятся так:


<P>
@medbreak

<PRE>
1999-04-01  Nathaniel Bowditch  &#60;nat@apn.org&#62;

        * vc.texinfo: Fix expansion typos.

        * vc.el, vc-hooks.el: Don't call expand-file-name.
</PRE>

<P>
@medbreak


<P>
  Обычно <KBD>C-x v a</KBD> разделяет журнальные записи пустой строкой, но вы
можете сделать так, чтобы несколько связанных записей сцеплялись вместе
(без промежуточной пустой строки), начиная текст каждой из связанных
журнальных записей с метки в форме <SAMP>`{<VAR>имя-сцепки</VAR>} '</SAMP>.
Сама метка не копируется в <TT>`ChangeLog'</TT>.  Например, предположим, что
есть такие журнальные записи:



<PRE>
* Для <TT>`vc.texinfo'</TT>: <SAMP>`{expand} Fix expansion typos.'</SAMP>
* Для <TT>`vc.el'</TT>: <SAMP>`{expand} Don't call expand-file-name.'</SAMP>
* Для <TT>`vc-hooks.el'</TT>: <SAMP>`{expand} Don't call expand-file-name.'</SAMP>
</PRE>

<P>
Тогда текст в <TT>`ChangeLog'</TT> выглядит так:


<P>
@medbreak

<PRE>
1999-04-01  Nathaniel Bowditch  &#60;nat@apn.org&#62;

        * vc.texinfo: Fix expansion typos.
        * vc.el, vc-hooks.el: Don't call expand-file-name.
</PRE>

<P>
@medbreak


<P>
  Журнальные записи, чей текст начинается с <SAMP>`#'</SAMP>, не копируются в
<TT>`ChangeLog'</TT>.  Например, если вы просто поправили грамматические
ошибки в комментариях, вы можете сделать в журнале запись, начинающуюся
с <SAMP>`#'</SAMP>, чтобы в <TT>`ChangeLog'</TT> не заносились столь тривиальные
вещи.




<H4><A NAME="SEC149" HREF="emacs_toc.html#TOC149">Переименование файлов под VC</A></H4>

<P>
<A NAME="IDX635"></A>
  Когда вы переименовываете зарегистрированный файл, вы должны
переименовать также соответствующий мастер-файл, чтобы получить
правильный результат.  Используйте <CODE>vc-rename-file</CODE>, чтобы
переименовать исходный файл, как вы укажете, и соответственно его
мастер-файл.  Это также обновит все снимки (see section <A HREF="emacs_19.html#SEC144">Снимки</A>), которые
упоминают данный файл, так что они будут использовать новое имя;
несмотря на это, измененный таким образом снимок может не работать
(see section <A HREF="emacs_19.html#SEC146">Опасные места при работе со снимками</A>).


<P>
  Вы не можете использовать <CODE>vc-rename-file</CODE> для файла, который
блокирован кем-то еще.




<H4><A NAME="SEC150" HREF="emacs_toc.html#TOC150">Вставка заголовков версий</A></H4>

<P>
   Иногда удобно помещать строки для идентификации версии прямо в
рабочие файлы.  Некоторые особые строки, называемые <EM>заголовками
версии</EM>, заменяются в каждой версии на ее номер.


<P>
  Если вы пользуетесь RCS, и в ваших рабочих файлах присутствуют
заголовки версий, Emacs может использовать их для определения текущей
версии и состояния блокировки этих файлов.  Это более надежно, чем
обращение к мастер-файлам, которое делается, если заголовков версий нет.
Заметьте, что в среде с несколькими ветвями заголовки версий необходимы
для корректной работы VC (see section <A HREF="emacs_19.html#SEC143">Многопользовательские разветвления</A>).


<P>
  Переменная <CODE>vc-consult-headers</CODE> управляет поиском заголовков
версий.  Если она отлична от <CODE>nil</CODE>, Emacs производит поиск
заголовков, чтобы узнать номер версии, которую вы редактируете.
Установка этой переменной в <CODE>nil</CODE> выключает это средство.


<P>
<A NAME="IDX636"></A>
<A NAME="IDX637"></A>
  Для вставки подходящей строки заголовка вы можете использовать команду
<KBD>C-x v h</KBD> (<CODE>vc-insert-headers</CODE>).


<DL COMPACT>

<DT><KBD>C-x v h</KBD>
<DD>
Вставляет в файл заголовки для использования с вашей системой управления
версиями.
</DL>

<P>
<A NAME="IDX638"></A>
  Стока заголовка по умолчанию -- это <SAMP>`$Id: emacs_19.html,v 1.1 2004/08/29 08:02:27 ott Exp $'</SAMP> для RCS и
<SAMP>`%W%'</SAMP> для SCCS.  Вы можете указать другие вставляемые
заголовки, устанавливая переменную <CODE>vc-header-alist</CODE>.  Ее значение
--- это список элементов в форме <CODE>(<VAR>программа</VAR> . <VAR>строка</VAR>)</CODE>,
где <VAR>программа</VAR> -- это <CODE>RCS</CODE> или <CODE>SCCS</CODE>, а <VAR>строка</VAR>
--- это используемая строка.


<P>
  Вместо одной строки вы можете задать список строк; тогда каждая строка
из списка вставится как отдельный заголовок на отдельной строке.


<P>
  Часто необходимо применять "излишние" обратные косые черты, когда вы
пишете строки для этой переменной.  Это нужно для того, чтобы такие
строки не интерпретировались в константах как заголовки версий, если сам
файл на Emacs Lisp находится под контролем системы управления версиями.


<P>
<A NAME="IDX639"></A>
  Каждый заголовок вставляется в точке на новой строке, в окружении
знаков табуляции внутри ограничителей комментария.  Как правило,
используются обычные для текущего режима строки для начала и завершения
комментария, но в некоторых режимах для этой цели есть особые
ограничители комметариев; их определяет переменная
<CODE>vc-comment-alist</CODE>.  Каждый элемент в этом списке имеет форму
<CODE>(<VAR>режим</VAR> <VAR>начало</VAR> <VAR>конец</VAR>)</CODE>.


<P>
<A NAME="IDX640"></A>
  Переменная <CODE>vc-static-header-alist</CODE> указывает, какие еще строки
должны добавляться в зависимости от имени буфера.  Ее значение должно
быть списком элементов в форме <CODE>(<VAR>regexp</VAR> . <VAR>формат</VAR>)</CODE>.
Когда <VAR>regexp</VAR> соответствует имени буфера, как часть загловка
вставляется <VAR>формат</VAR>.  Строка загловка вставляется для каждого
элемента, совпадающего с именем буфера, и для каждой строки, указанной в
<CODE>vc-header-alist</CODE>.  Строка загловка получается путем форматирования
строки из <CODE>vc-header-alist</CODE> с форматом, взятым из элемента
<CODE>vc-static-header-alist</CODE>.  По умолчанию
<CODE>vc-static-header-alist</CODE> имеет следующее значение:



<PRE>
(("\\.c$" .
  "\n#ifndef lint\nstatic char vcid[] = \"\%s\";\n\
#endif /* lint */\n"))
</PRE>

<P>
Это определяет вставку текста в такой форме:



<PRE>

#ifndef lint
static char vcid[] = "<VAR>строка</VAR>";
#endif /* lint */
</PRE>

<P>
Заметьте, что текст выше начинается с пустой строки.


<P>
  Если вы хотите использовать в файле более одного заголовка версии,
помещайте их рядом.  Механизм сохранения меток в <CODE>revert-buffer</CODE>
может не обработать метки, расположенные между двумя заголовками.




<H3><A NAME="SEC151" HREF="emacs_toc.html#TOC151">Настройка VC</A></H3>

<P>
  Есть много способов настройки VC.  Параметры, которые вы можете
установить, разделяются на четыре катагории, описанные в последующих
разделах.




<H4><A NAME="SEC152" HREF="emacs_toc.html#TOC152">Параметры для постпроцессора VC</A></H4>

<P>
<A NAME="IDX641"></A>
<A NAME="IDX642"></A>
  Вы можете сказать RCS и CVS, должны ли они использовать для файла
блокирование или не должны (see section <A HREF="emacs_19.html#SEC126">Концепции управления версиями</A>, для получения описания
блокирования).  VC автоматически распознает, что вы выбрали, и ведет
себя соответственно.


<P>
<A NAME="IDX643"></A>
<A NAME="IDX644"></A>
  В RCS по умолчанию применяется блокирование, но есть режим, называемый
<EM>нестрогим блокированием</EM>, в котором вы можете фиксировать изменения
без предварительного блокирования файла.  Используйте <SAMP>`rcs -U'</SAMP> для
переключения к нестрогому блокированию для некоторого файла, подробности
смотрите в документе Man <SAMP>`rcs'</SAMP>.


<P>
<A NAME="IDX645"></A>
  Под CVS блокирование по умолчанию не применяется; каждый может
изменять рабочий файл в любое время.  Однако, есть способы ограничить
это, дающие в результате поведение, похожее на блокирование.


<P>
<A NAME="IDX646"></A>
  С одной стороны, вы можете установить переменную среды @env{CVSREAD} в
произвольное значение.  Если эта переменная определена, CVS делает ваши
рабочие файлы доступными только для чтения по умолчанию.  В Emacs вы
должны набрать <KBD>C-x C-q</KBD>, чтобы сделать файл доступным для записи,
так что редактирование рабочих файлов фактически похоже на
редактирование с применением блокирования.  Заметьте однако, что
фактически блокировки не происходит, поэтому несколько пользователей
могут одновременно сделать свои рабочие файлы записываемыми.  Когда вы
устанавливаете @env{CVSREAD} первый раз, обязательно заново извлеките
все ваши модули, чтобы защита файлов была правильно выставлена.


<P>
<A NAME="IDX647"></A>
<A NAME="IDX648"></A>
  Другой способ достичь чего-то похожего на блокировку ---
воспользоваться средством <EM>наблюдения</EM> в CVS.  Если над файлом
установлено наблюдение, CVS по умолчанию делает его доступным только для
чтения, и вы также должны использовать в Emacs <KBD>C-x C-q</KBD>, чтобы
сделать его записываемым.  Чтобы сделать файл доступным для записи, VC
вызывает <CODE>cvs edit</CODE>, и CVS заботится о том, чтобы другие
разработчики были оповещены о вашем намерении изменить этот файл.
Подробности об использовании средства наблюдения смотрите в документации
по CVS.  


<P>
<A NAME="IDX649"></A>
  Вы можете подавить использование VC для файлов, управляемых CVS,
установив переменную <CODE>vc-handle-cvs</CODE> в <CODE>nil</CODE>.  Если вы
сделаете так, Emacs считает эти файлы незарегистритованными, и команды
VC становятся в них недоступными.  Тогда вы должны делать все операции
CVS вручную.




<H4><A NAME="SEC153" HREF="emacs_toc.html#TOC153">Управление рабочими файлам в VC</A></H4>

<P>
<A NAME="IDX650"></A>
  Обычно Emacs не сохраняет резервные копии для исходных файлов, которые
находятся под контролем системы управления версиями.  Если вы хотите
делать резервные копии даже для таких файлов, установите переменную
<CODE>vc-make-backup-files</CODE> в отличное от <CODE>nil</CODE> значение.


<P>
<A NAME="IDX651"></A>
  Как правило рабочие файлы существуют всегда, блокированы они или нет.
Если вы установите <CODE>vc-keep-workfiles</CODE> в <CODE>nil</CODE>, то при
фиксировании новой версии с помощью <KBD>C-x C-q</KBD> рабочий файл будет
удаляться; но любая попытка обратиться к этому файлу из Emacs создаст
его снова.  (Под CVS рабочие файлы остаются всегда.)


<P>
<A NAME="IDX652"></A>
  Редактирование файла в управлением версиями через символьную ссылку
может быть опасным.  Это обходит систему управления версиями -- вы
можете редактировать файлы, не блокируя их, и у вас может не получиться
зафиксировать свои изменения.  Также, ваши изменения могут перезаписать
версию другого пользователя.  Чтобы предоставить защиту от этого, VC
проверяет каждую символьную ссылку, к которой вы обращаетсь, чтобы
узнать, не указывает ли она на файл под контролем системы управления
версиями.


<P>
  Переменная <CODE>vc-follow-symlinks</CODE> говорит, что нужно делать, когда
символьная ссылка указывает на файл с управлением версиями.  Если она
равна <CODE>nil</CODE>, VC лишь показывает предупреждающее сообщение.  Если
это <CODE>t</CODE>, VC автоматически следует по ссылке и обращается к
настоящему файлу, сообщая вам об этом в эхо-области.  Если это значение
равно <CODE>ask</CODE> (по умолчанию), VC всякий раз спрашивает вас, нужно ли
проследовать по ссылке.




<H4><A NAME="SEC154" HREF="emacs_toc.html#TOC154">Как VC узнает статус файла</A></H4>

<P>
  При вычислении статуса блокировки файла, VC сначала ищет в нем строку
заголовка версии RCS (see section <A HREF="emacs_19.html#SEC150">Вставка заголовков версий</A>).  Если строки заголовка
нет, или если вы пользуетесь SCCS, VC обычно смотрит на разрешения,
установленные для рабочего файла; это быстро.  Но могут быть ситуации,
когда разрешениям нельзя доверять.  В таком случае делается обращение к
мастер-файлу, что довольно дорого.  Кроме того, мастер-файл может
<EM>только</EM> сказать, заблокирован ли файл кем-то, но не то, что ваш
рабочий файл содержит именно эту блокированную версию.


<P>
<A NAME="IDX653"></A>
  Вы можете указать VC не использовать заголовки версии для определения
статуса блокировки, установив <CODE>vc-consult-headers</CODE> в <CODE>nil</CODE>.
Тогда VC всегда использует для этого биты разрешений для файла (если она
может им доверять) или проверяет мастер-файл.


<P>
<A NAME="IDX654"></A>
  Вы можете задать критерий, по которому следует доверять разрешениям
для файла, с помощью переменной <CODE>vc-mistrust-permissions</CODE>.  Ее
значением может быть <CODE>t</CODE> (никогда не доверять битам разрешений и
всегда проверять мастер-файл), <CODE>nil</CODE> (всегда доверять разрешениям)
или функция с одним аргументом, которая принимает решение.  Аргумент ---
это имя подкаталога <TT>`RCS'</TT>, <TT>`CVS'</TT> или <TT>`SCCS'</TT>.  Отличное от
<CODE>nil</CODE> значение из этой функции говорит, что битам разрешений
доверять нельзя.  Если вы обнаружили, что разрешения для рабочего файла
выстановлены ошибочно, установите <CODE>vc-mistrust-permissions</CODE> в
<CODE>t</CODE>.  Тогда VC всегда будет проверять мастер-файл для определения
статуса файла.




<H4><A NAME="SEC155" HREF="emacs_toc.html#TOC155">Выполнение команд в VC</A></H4>

<P>
<A NAME="IDX655"></A>
  Если <CODE>vc-suppress-confirm</CODE> отлична от <CODE>nil</CODE>, то <KBD>C-x
C-q</KBD> и <KBD>C-x v i</KBD> могут сохранять текущий буфер без запроса, и
<KBD>C-x v u</KBD> также работает без подтверждения.  (Эта переменная не
влияет на <KBD>C-x v c</KBD>; данная операция насколько значительна, что для
нее всегда нужно спрашивать подтверждение.)


<P>
<A NAME="IDX656"></A>
  Режим VC делает большую часть работы, запуская команды оболочки для
RCS, CVS и SCCS.  Если <CODE>vc-command-messages</CODE> отлична от <CODE>nil</CODE>,
VC выводит сообщения, показывающие, какие команды оболочки запускаются,
и дополнительные сообщения, когда команда завершается.


<P>
<A NAME="IDX657"></A>
  Вы можете задать дополнительные каталоги для поиска программ
управления версиями, устанавливая переменную <CODE>vc-path</CODE>.  Эти
каталоги просматриваются перед обычным путем поиска.  Но обычно
правильные файлы находятся автоматически.




<H2><A NAME="SEC156" HREF="emacs_toc.html#TOC156">Каталоги файлов</A></H2>

<P>
<A NAME="IDX658"></A>
<A NAME="IDX659"></A>
  Файловая система группирует файлы по <EM>каталогам</EM>.  <EM>Распечатка
каталога</EM> -- это список всех файлов в каталоге.  Emacs предоставляет
команды для создания и удаления каталогов и для выдачи распечатки
каталогов в кратком формате (только имена файлов) и в подробном формате
(включающем размеры, даты и авторов).  Есть также броузер каталогов,
называемый Dired; смотрите section <A HREF="emacs_33.html#SEC371">Dired, редактор каталогов</A>.


<DL COMPACT>

<DT><KBD>C-x C-d <VAR>кат-или-образец</VAR> <KBD>RET</KBD></KBD>
<DD>
Выводит краткую распечатку каталога (<CODE>list-directory</CODE>).
<DT><KBD>C-u C-x C-d <VAR>кат-или-образец</VAR> <KBD>RET</KBD></KBD>
<DD>
Выводит подробную распечатку каталога.
<DT><KBD>M-x make-directory <KBD>RET</KBD> <VAR>имя-кат</VAR> <KBD>RET</KBD></KBD>
<DD>
Создает новый каталог с именем <VAR>имя-кат</VAR>.
<DT><KBD>M-x delete-directory <KBD>RET</KBD> <VAR>имя-кат</VAR> <KBD>RET</KBD></KBD>
<DD>
Удаляет каталог с именем <VAR>имя-кат</VAR>.  Он должен быть пуст, иначе вы
получите ошибку.
</DL>

<P>
<A NAME="IDX660"></A>
<A NAME="IDX661"></A>
  Команда для вывода распечатки каталога -- это <KBD>C-x C-d</KBD>
(<CODE>list-directory</CODE>).  Она считывает, используя минибуфер, имя файла,
который является либо каталогом, который нужно распечатать, либо
шаблоном имен файлов, которые нужно перечислить.  Например,



<PRE>
C-x C-d /u2/emacs/etc <KBD>RET</KBD>
</PRE>

<P>
перечисляет все файлы в каталоге <TT>`/u2/emacs/etc'</TT>.  Вот пример
описания образца имен файлов:



<PRE>
C-x C-d /u2/emacs/src/*.c <KBD>RET</KBD>
</PRE>

<P>
  Обычно <KBD>C-x C-d</KBD> печатает краткий перечень каталога, содержащий
только имена файлов.  Числовой аргумент (независимо от значения) велит
показывать подробную распечатку (как <SAMP>`ls -l'</SAMP>).


<P>
<A NAME="IDX662"></A>
<A NAME="IDX663"></A>
  Текст распечатки каталога получается от @command{ls}, запущенной в
подчиненном процессе.  Две переменные Emacs управляют ключами,
передаваемыми @command{ls}: <CODE>list-directory-brief-switches</CODE> -- это
строка, дающая ключи для использования в кратких распечатках
(<CODE>"-CF"</CODE> по умолчанию), и <CODE>list-directory-verbose-switches</CODE>
--- ключи для подробной распечатки (<CODE>"-l"</CODE> по умолчанию).




<H2><A NAME="SEC157" HREF="emacs_toc.html#TOC157">Сравнение файлов</A></H2>
<P>
<A NAME="IDX664"></A>


<P>
<A NAME="IDX665"></A>
<A NAME="IDX666"></A>
  Команда <KBD>M-x diff</KBD> сравнивает два файла, показывая различия в
буфере Emacs с именем <TT>`*Diff*'</TT>.  Она запускает программу
@command{diff}, используя ключи, получаемые из переменной
<CODE>diff-switches</CODE>, чье значение должно быть строкой.


<P>
  Буфер <TT>`*Diff*'</TT> имеет в качестве основного режим Compilation,
поэтому вы можете использовать <KBD>C-x `</KBD>, чтобы последовательно
обратиться к изменившимся местам в двух исходных файлах.  Вы также
можете перейти к конкретному ломтю изменений и нажать <KBD>RET</KBD> или
<KBD>C-c C-c</KBD>, или щелкнуть на нем <KBD>Mouse-2</KBD>, чтобы перейти к
соответствующей позиции в исходном тексте.  Вы также можете использовать
другие особые команды режима Compilation: <KBD>SPC</KBD> и <KBD>DEL</KBD> для
прокрутки и <KBD>M-p</KBD> и <KBD>M-n</KBD> для передвижения курсора.
See section <A HREF="emacs_28.html#SEC312">Запуск компиляторов в Emacs</A>.


<P>
<A NAME="IDX667"></A>
  Команда <KBD>M-x diff-backup</KBD> сравнивает заданный файл с его самой
последней резервной копией.  Если вы задали имя резервного файла,
<CODE>diff-backup</CODE> сравнивает его с исходным файлом.


<P>
<A NAME="IDX668"></A>
  Команда <KBD>M-x compare-windows</KBD> сравнивает текст в текущем окне с
текстом следующего окна.  Сравнение начинается от точки в каждом окне, и
обе начальные позиции вталкиваются в список пометок соответствующего
буфера.  Затем точка перемещается в каждом окне вперед по одному знаку,
пока не будет найдено несовпадение.  Тогда эта команда останавливается.
Для получения большей информации об окнах в Emacs смотрите section <A HREF="emacs_21.html#SEC169">Множество окон</A>.


<P>
<A NAME="IDX669"></A>
  С числовым аргументом, <CODE>compare-windows</CODE> игнорирует изменения в
пропусках.  Если переменная <CODE>compare-ignore-case</CODE> не <CODE>nil</CODE>,
она игнорирует также и различия в регистре букв.


<P>
  Смотрите также section <A HREF="emacs_27.html#SEC283">Объединение файлов с помощью Emerge</A>, описание удобных средств для слияния двух
похожих файлов.




<H2><A NAME="SEC158" HREF="emacs_toc.html#TOC158">Разнообразные действия над файлами</A></H2>

<P>
  В Emacs есть команды для произведения многих других операций над
файлами.  Все они действуют на один файл; они не воспринимают имена
файлов с шаблонами.


<P>
<A NAME="IDX670"></A>
<A NAME="IDX671"></A>
<A NAME="IDX672"></A>
<A NAME="IDX673"></A>
  <KBD>M-x view-file</KBD> позволяет вам просмотреть или прочитать файл по
целым экранам.  Она считывает имя файла, используя минибуфер.  После
загрузки файла в буфер Emacs, <CODE>view-file</CODE> показывает его начало.
Теперь вы можете нажать <KBD>SPC</KBD>, чтобы прокрутить вперед на целое
окно, или <KBD>DEL</KBD> для прокрутки назад.  Предоставляются и другие
различные команды для перемещения по файлу, но не для его изменения;
наберите во время просмотра <KBD>?</KBD>, чтобы получить их перечень.  Это
практически те же обычные команды Emacs для передвижения курсора.  Чтобы
выйти из просмотра, наберите <KBD>q</KBD>.  Команды просмотра определяются
особым основным режимом, называемом режимом View.


<P>
  Есть родственная команда, <KBD>M-x view-buffer</KBD>, для просмотра буфера,
уже существующего в Emacs.  See section <A HREF="emacs_20.html#SEC165">Разнообразные операции над буфером</A>.


<P>
<A NAME="IDX674"></A>
  <KBD>M-x insert-file</KBD> вставляет копию содержимого заданного файла в
текущий буфер в позиции точки, оставляя точку неизменной перед
вставленным и метку после него.


<P>
<A NAME="IDX675"></A>
  <KBD>M-x write-region</KBD> -- это обращение <KBD>M-x insert-file</KBD>; она
копирует содержимое области в указанный файл.  <KBD>M-x append-to-file</KBD>
добавляет текст области в конец заданного файла.  See section <A HREF="emacs_14.html#SEC71">Накопление текста</A>.


<P>
<A NAME="IDX676"></A>
<A NAME="IDX677"></A>
  <KBD>M-x delete-file</KBD> удаляет указанный файл, как команда оболочки
@command{rm}.  Если вы хотите удалить много файлов в одном каталоге,
может оказаться удобнее воспользоваться Dired (see section <A HREF="emacs_33.html#SEC371">Dired, редактор каталогов</A>).


<P>
<A NAME="IDX678"></A>
  <KBD>M-x rename-file</KBD> считывает, используя минибуфер, два имени файла,
<VAR>старый</VAR> и <VAR>новый</VAR>, а затем переименоывает файл <VAR>старый</VAR> в
<VAR>новый</VAR>.  Если файл с именем <VAR>новый</VAR> уже существует, вы должны
подтвердить переименование вводом <KBD>yes</KBD>, или переименование не
производится; это сделано, потому что такое переименование приведет к
потере старого значения имени <VAR>новый</VAR>.  Если <VAR>старый</VAR> и
<VAR>новый</VAR> находятся на разных файловых системах, файл <VAR>старый</VAR>
копируется и удаляется.


<P>
<A NAME="IDX679"></A>
  Похожая команда <KBD>M-x add-name-to-file</KBD> используется для добавления
еще одного имени существующему файлу без удаления старого имени.  Новое
имя обязано принадлежять той же файловой системе, где находится сам
файл.


<P>
<A NAME="IDX680"></A>
<A NAME="IDX681"></A>
  <KBD>M-x copy-file</KBD> считывает файл <VAR>старый</VAR> и записывает новый
файл с именем <VAR>новый</VAR> с тем же содержимым.  Если файл с именем
<VAR>новый</VAR> уже существует, требуется подтверждение, потому что
копирование затирает старое содержимое файла <VAR>новый</VAR>.


<P>
<A NAME="IDX682"></A>
  <KBD>M-x make-symbolic-link</KBD> считывает два имени файла, <VAR>цель</VAR> и
<VAR>имя-ссылки</VAR>, а затем создает символьную ссылку с именем
<VAR>имя-ссылки</VAR>, указывающую на <VAR>цель</VAR>.  Это проявится в том, что
будущие попытки открыть файл <VAR>имя-ссылки</VAR> получат тот файл, который
называется <VAR>цель</VAR> во время открытия, или получат ошибку, если имя
<VAR>цель</VAR> в это время не используется.  Эта команда не раскрывает
аргумент <VAR>цель</VAR>, поэтому она позволяет вам указать относительное имя
в качестве файла назначения ссылки.


<P>
  Если <VAR>имя-ссылки</VAR> занято, требуется подтверждение.  Обратите
внимание, не все системы поддерживают символьные ссылки.




<H2><A NAME="SEC159" HREF="emacs_toc.html#TOC159">Доступ к сжатым файлам</A></H2>
<P>
<A NAME="IDX683"></A>
<A NAME="IDX684"></A>
<A NAME="IDX685"></A>
<A NAME="IDX686"></A>


<P>
<A NAME="IDX687"></A>
  Emacs поставляется с библиотекой, которая автоматически распаковывает
сжатые файлы, когда вы к ним обращаетесь, и автоматически сжимает их
снова, если вы их изменили и сохраняете.  Чтобы задействовать эту
возможность, наберите команду <KBD>M-x auto-compression-mode</KBD>.


<P>
  Когда включено автоматическое сжатие (что подразумевает и
автоматическую распаковку), Emacs распознает сжатые файлы по именам.
Имена файлов, завершающиеся на <SAMP>`.gz'</SAMP>, указывают, что этот файл сжат
программой @command{gzip}.  Другие окончания обозначают другие методы
сжатия.


<P>
  Автоматическая распаковка и сжатие применяются ко всем операциям, в
которых Emacs использует содержимое файлов.  Это включает обращение,
сохранение, вставку содержимого в буфер, загрузку и байт-компиляцию.




<H2><A NAME="SEC160" HREF="emacs_toc.html#TOC160">Удаленные файлы</A></H2>

<P>
<A NAME="IDX688"></A>
<A NAME="IDX689"></A>
  Вы можете сослаться на файлы на других машинах, используя особый
синтаксис имен:



<PRE>
/<VAR>машина</VAR>:<VAR>имя-файла</VAR>
/<VAR>пользователь</VAR>@<VAR>машина</VAR>:<VAR>имя-файла</VAR>
</PRE>

<P>
Когда вы делаете так, Emacs использует для чтения и записи файлов на
указанной машине программу FTP.  Он заходит через FTP, используя ваше
пользовательское имя или имя <VAR>пользователь</VAR>.  Он может спрашивать у
вас пароль время от времени; это используется для захода на
<VAR>машину</VAR>.


<P>
<A NAME="IDX690"></A>
<A NAME="IDX691"></A>
  Обычно, если вы не задали имя пользователя в имени удаленного файла,
это означает, что нужно использовать ваше собственное пользовательское
имя.  Но если вы установите переменную <CODE>ange-ftp-default-user</CODE>
равной какой-то строке, то будет использоваться эта строка.  (Пакет
Emacs, который реализует доступ к файлам по FTP, называется
<CODE>ange-ftp</CODE>.)


<P>
<A NAME="IDX692"></A>
  Вы можете полностью выключить обработку имен FTP-файлов, установив
переменную <CODE>file-name-handler-alist</CODE> в значение <CODE>nil</CODE>.




<H2><A NAME="SEC161" HREF="emacs_toc.html#TOC161">Буквальные имена файлов</A></H2>

<P>
<A NAME="IDX693"></A>
  Вы можете <EM>отменить особый смысл</EM> абсолютного имени файла, чтобы
блокировать действие специальных символов и синтаксиса.  Это можно
сделать, добавив <SAMP>`/:'</SAMP> в начале.


<P>
  Например, вы можете отменить особый смысл имени локального файла,
который выглядит как удаленный, чтобы предотвратить его трактовку как
имени удаленного файла.  Таким образом, если у вас есть каталог с именем
<TT>`/foo:'</TT> и в нем файл с именем <TT>`bar'</TT>, вы можете сослаться в
Emacs на этот файл как на <SAMP>`/:/foo:/bar'</SAMP>.


<P>
  <SAMP>`/:'</SAMP> также может предотвратить понимание <SAMP>`~'</SAMP> как
специального символа, обозначающего начальный каталог этого
пользователя.  Например, <TT>`/:/tmp/~hack'</TT> ссылается на файл с именем
<TT>`~hack'</TT> в каталоге <TT>`/tmp'</TT>.


<P>
  Аналогично, использование <SAMP>`/:'</SAMP> -- это один из способов ввести в
минибуфере имя файла, содержащее <SAMP>`$'</SAMP>.  Однако, <SAMP>`/:'</SAMP> обязана
быть в начале этого буфера, чтобы блокировать эффект <SAMP>`$'</SAMP>.


<P>
  С помощью <SAMP>`/:'</SAMP> вы также можете подавить эффект символов
подстановки при обращении к файлам.  Например, <TT>`/:/tmp/foo*bar'</TT>
обращается к файлу <TT>`/tmp/foo*bar'</TT>.  Однако, чаще всего вы просто
можете ввести символы подстановки как есть.  Например, если единственное
имя файла в <TT>`/tmp'</TT>, которое начинается на <SAMP>`foo'</SAMP> и завершается
на <SAMP>`bar'</SAMP> -- это <TT>`foo*bar'</TT>, то указав <TT>`/tmp/foo*bar'</TT> вы
обратитесь только к <TT>`/tmp/foo*bar'</TT>.
<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_18.html">previous</A>, <A HREF="emacs_20.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">_uacct = "UA-78697-3"; urchinTracker(); </script></body>
</HTML>
