<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Настройка</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_35.html">previous</A>, <A HREF="emacs_37.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC440" HREF="emacs_toc.html#TOC440">Настройка</A></H1>
<P>
<A NAME="IDX2565"></A>


<P>
В этой главе обсуждаются различные вопросы, относящиеся к простой
адаптации поведения Emacs.  Чтобы узнать, как сделать большие изменения,
смотрите книгу <CITE>The Emacs Lisp Reference Manual</CITE>.


<P>
Все виды настройки воздействуют только на тот сеанс Emacs, в котором вы
их делаете.  Они полностью исчезают при завершении работы с Emacs и не
действуют на другие сеансы Emacs, которые могут быть запущены в то же
самое время или позже.  Только в одном случае сеанс работы с Emacs может
повлиять на что-либо вне его самого -- при записи файла.  В частности,
чтобы сделать настройку "постоянной", существует единственный путь ---
поместить нечто в ваш файл <TT>`.emacs'</TT> или другой подходящий файл, что
будет выполнять настройку в каждом сеансе.  See section <A HREF="emacs_36.html#SEC470">Файл инициализации, <TT>`~/.emacs'</TT></A>.




<H2><A NAME="SEC441" HREF="emacs_toc.html#TOC441">Второстепенные режимы</A></H2>
<P>
<A NAME="IDX2566"></A>
<A NAME="IDX2567"></A>


<P>
Второстепенные режимы -- это необязательные возможности, которые вы
можете включать и выключать.  Например, режим Auto Fill -- это
второстепенный режим, в котором <KBD>SPC</KBD> разрывает строки на границе
слов по мере того, как вы набираете.  Все второстепенные режимы
независимы друг от друга и от выбранного основного режима.  Большинство
второстепенных режимов сообщают, что они включены, в строке режима;
например, надпись <SAMP>`Fill'</SAMP> в строке режима означает, что включен
режим Auto Fill.


<P>
Для получения имени командной функции, включающей или выключающей
второстепенный режим, добавьте к имени второстепенного режима слово
<CODE>-mode</CODE>.  Таким образом, команда запуска или выключения режима Auto
Fill называется <KBD>M-x auto-fill-mode</KBD>.  Подобные команды обычно
запускаются через <KBD>M-x</KBD>, но при желании к ним можно привязать ключи.
Без аргумента эти команды включают режим, если он был выключен, и
выключают, когда он был включен.  Эта техника известна как
<EM>переключение</EM>.  Положительный аргумент всегда включает режим, а
явный нулевой или отрицательный аргумент всегда выключает его.


<P>
Включение или выключение некоторых второстепенных режимов применяется
только к текущему буферу; каждый буфер независим от других.
Следовательно, вы можете включить режим в одних буферах и выключить в
других.  К второстепенным режимам, которые могут так работать, относятся
режим Abbrev, режим Auto Fill, режим Auto Save, режим Font-Lock, режим
Hscroll, режим ISO Accents, второстепенный режим Outline, режим
Overwrite и режим Binary Overwrite.


<P>
Режим Abbrev позволяет вам определить сокращения, которые автоматически
расшифровываются при наборе.  Например, <SAMP>`amd'</SAMP> может раскрываться в
<SAMP>`abbrev mode'</SAMP>.  See section <A HREF="emacs_29.html#SEC326">Сокращения</A>, для получения полной информации.


<P>
Режим Auto Fill позволяет вводить заполненный текст без явного
прерывания строк.  Emacs вставляет перевод строки, когда это нужно,
чтобы строка не стала слишком длинной.  See section <A HREF="emacs_26.html#SEC222">Заполнение текста</A>.


<P>
Режим Auto Save заставляет Emacs периодически сохранять содержимое
буфера, чтобы уменьшить возможный объем потерянной работы в случае краха
системы.  See section <A HREF="emacs_19.html#SEC118">Самосохранение: защита от гибели</A>.


<P>
Режим Enriched позволяет редактировать и сохранять форматированный
текст.  See section <A HREF="emacs_26.html#SEC239">Редактирование форматированного текста</A>.


<P>
Режим Flyspell автоматически подсвечивает неправильно набранные слова.
See section <A HREF="emacs_18.html#SEC107">Поиск и исправление орфографических ошибок</A>.


<P>
Режим Font-Lock автоматически подсвечивает определенные текстовые
единицы, используемые в программах, такие как комментарии, строки и
имена определенных функций.  Для этого требуется оконная система,
которая может отображать разные шрифты.  See section <A HREF="emacs_22.html#SEC189">Использование разных начертаний</A>.


<P>
Режим Hscroll выполняет автоматическую горизонтальную прокрутку экрана,
чтобы точка всегда была видна.  See section <A HREF="emacs_16.html#SEC83">Горизонтальная прокрутка</A>.


<P>
Режим ISO Accents компонует знаки <SAMP>``'</SAMP>, <SAMP>`''</SAMP>, <SAMP>`"'</SAMP>,
<SAMP>`^'</SAMP>, <SAMP>`/'</SAMP> и <SAMP>`~'</SAMP> со следующий буквой в букву с акцентом из
набора знаков ISO Latin-1.  See section <A HREF="emacs_23.html#SEC210">Поддержка однобайтных европейских знаков</A>.


<P>
Второстепенный режим Outline обеспечивает те же возможности, что и
основной режим, называемый Outline; но поскольку он является
второстепенным режимом, то вы можете использовать его вместе с любым
основным.  See section <A HREF="emacs_26.html#SEC229">Режим Outline</A>.


<P>
<A NAME="IDX2568"></A>
<A NAME="IDX2569"></A>
<A NAME="IDX2570"></A>
<A NAME="IDX2571"></A>
Режим Overwrite заменяет существующие знаки при вводе новых вместо
обычной вставки со сдвигом вправо.  Например, если точка находится перед
<SAMP>`B'</SAMP> в слове <SAMP>`FOOBAR'</SAMP>, то в режиме Overwrite ввод <KBD>G</KBD>
изменяет это слово на <SAMP>`FOOGAR'</SAMP>, вместо <SAMP>`FOOGBAR'</SAMP>, как это
делается обычно.  В режиме Overwrite, команда <KBD>C-q</KBD> вставляет знак,
каким бы он не был, даже если это цифра, -- это дает вам способ вставки
знака вместо замены существующего.


<P>
Режим Binary Overwrite -- это вариант режима Overwrite для
редактирования двоичных файлов; он обрабатывает знаки новой строки и
табуляции точно также, как и другие знаки, так что они могут заменять
другие знаки и сами могут быть заменены другими знаками.


<P>
Следующие второстепенные режимы обычно применяются ко всем буферам
сразу.  Поскольку каждый из них включается или выключается с помощью
установки значения переменной, вы <EM>можете</EM> установить их по-разному
для отдельных буферов, явно делая эти переменные локальными для этих
буферов.  See section <A HREF="emacs_36.html#SEC450">Локальные переменные</A>.


<P>
Режим Icomplete показывает возможность завершения, когда вы находитесь в
минибуфере и завершение активно.  See section <A HREF="emacs_10.html#SEC43">Параметры завершения</A>.


<P>
Режим Line Number постоянно отображает номер текущей строки в строке
режима.  See section <A HREF="emacs_6.html#SEC15">Строка режима</A>.


<P>
Режим Resize-Minibuffer заставляет минибуфер расширяться так, чтобы он
мог вместить весь текст, который вы в него помещаете.
See section <A HREF="emacs_10.html#SEC38">Редактирование в минибуфере</A>.


<P>
Режим Scroll Bar прикрепляет к каждому окну полоску прокрутки
(see section <A HREF="emacs_22.html#SEC187">Полоски прокрутки</A>).  Режим Menu Bar прикрепляет к каждому
фрейму полоску меню (see section <A HREF="emacs_22.html#SEC188">Полоски меню</A>).  Оба этих режима по
умолчанию включены при использовании X Window System.


<P>
В режиме Transient Mark, каждое изменение содержимого буфера
"деактивирует" метку, так что команды, которые оперируют с областью,
буду выдавать ошибку.  Это означает, что вы должны либо установить
пометку, либо явно "активировать" ее перед каждой командой, которая
работает с областью.  Преимущество режима Transient Mark в том, что
Emacs может отрисовывать область подсвеченной (в настоящее время только
при работе в X).  See section <A HREF="emacs_13.html#SEC56">Установка метки</A>.


<P>
Для большинства второстепенных режимов, имя команды также совпадает с
именем переменной, которая контролирует данный режим.  Режим включается,
когда значение переменной устанавливается в не-<CODE>nil</CODE>, и команда
установки второстепенного режима работает путем установки этой
переменной.  Например, команда <CODE>outline-minor-mode</CODE> работает,
устанавливая значение <CODE>outline-minor-mode</CODE> как переменной; именно
эта переменная непосредственно включает и выключает второстепенный режим
Outline.  Чтобы проверить, работает ли некий второстепенный режим таким
способом, используйте <KBD>C-h v</KBD>, чтобы запросить документацию на имя
переменной.


<P>
Переменные второстепенных режимов обеспечивают хороший способ включения
и выключения второстепенных режимов для программ на Лиспе; они также
полезны в списках локальных переменных файлов.  Но пожалуйста, дважды
подумайте, прежде чем устанавливать второстепенные режимы через список
локальных переменных, потому что большинство второстепенных режимов
являются предметом предпочтений пользователя -- другие пользователи,
которые будут редактировать этот же файл, могут не захотеть использовать
те же режимы, что предпочитаете вы.




<H2><A NAME="SEC442" HREF="emacs_toc.html#TOC442">Переменные</A></H2>
<P>
<A NAME="IDX2572"></A>
<A NAME="IDX2573"></A>
<A NAME="IDX2574"></A>


<P>
<EM>Переменная</EM> -- это лисповский символ, который имеет значение.  Имя
символа также называется именем соответствующей переменной.  Имена
переменных могут содержать любые знаки, которые могут появиться в файле,
но принято составлять их из слов, разделенных дефисами.  Переменная
может иметь строку документации, которая описывает, значение какого вида
она должна иметь, и как это значение будет использоваться.


<P>
Лисп позволяет хранить в любой переменной любой вид значения, но
большинство используемых в Emacs переменных требуют значение
определенного типа.  Зачастую значение должно всегда быть строкой или
всегда числом.  Иногда мы говорим, что некоторое свойство включено, если
некая переменная "отлична от <CODE>nil</CODE>", подразумевая, что если
значение переменной равно <CODE>nil</CODE>, то это свойство выключено, но оно
включено для <EM>любого</EM> другого значения.  Поскольку при установке
переменной вам нужно выбрать одно определенное значение, для включения
свойства принято использовать значение <CODE>t</CODE>.


<P>
Как и всякая программа на Лиспе, Emacs использует много лисповских
переменных для хранения внутренних записей.  Но большинство переменных,
которые представляют для вас интерес, -- это те, что существуют ради
настройки.  Emacs (обычно) не меняет значения этих переменных, вместо
этого вы сами устанавливаете значения, тем самым изменяя и управляя
поведением некоторых команд Emacs.  Эти переменные называются
<EM>пользовательскими параметрами</EM>.  Большинство параметров описаны в
этом руководстве и приведены в указателе переменных (see section <A HREF="emacs_45.html#SEC535">Указатель переменных</A>).


<P>
Примером переменной, являющейся пользовательским параметром, служит
<CODE>fill-column</CODE>; она определяет позицию правого края (как число
знаков от левого края), которая используется командами заполнения
(see section <A HREF="emacs_26.html#SEC222">Заполнение текста</A>).




<H3><A NAME="SEC443" HREF="emacs_toc.html#TOC443">Просмотр и установка переменных</A></H3>
<P>
<A NAME="IDX2575"></A>


<DL COMPACT>

<DT><KBD>C-h v <VAR>пер</VAR> <KBD>RET</KBD></KBD>
<DD>
Показывает значение переменной <VAR>пер</VAR> и документацию по ней
(<CODE>describe-variable</CODE>).
<DT><KBD>M-x set-variable <KBD>RET</KBD> <VAR>пер</VAR> <KBD>RET</KBD> <VAR>значение</VAR> <KBD>RET</KBD></KBD>
<DD>
Изменяет значение переменной <VAR>пер</VAR> на <VAR>значение</VAR>.
</DL>

<P>
Чтобы посмотреть значение отдельной переменной, используется команда
<KBD>C-h v</KBD> (<CODE>describe-variable</CODE>), которая считывает в минибуфере
имя переменной с возможностью завершения.  Эта команда печатает и
значение переменной, и документацию по ней.  Например,



<PRE>
C-h v fill-column <KBD>RET</KBD>
</PRE>

<P>
выведет примерно следующее:



<PRE>
fill-column's value is 75

Documentation:
*Column beyond which automatic line-wrapping should happen.
Automatically becomes buffer-local when set in any fashion.
</PRE>

<P>
Звездочка в начале описания показывает, что эта переменная является
пользовательским параметром.  <KBD>C-h v</KBD> не ограничивается только
пользовательскими параметрами, она принимает имя любой переменной.


<P>
<A NAME="IDX2576"></A>
Наиболее удобный способ установить конкретный параметр -- выполнить
<KBD>M-x set-variable</KBD>.  Эта команда считывает имя переменной с помощью
минибуфера (с завершением), а затем считывает лисповское выражение для
нового значения, снова используя минибуфер.  Например,



<PRE>
M-x set-variable <KBD>RET</KBD> fill-column <KBD>RET</KBD> 75 <KBD>RET</KBD>
</PRE>

<P>
устанавливает <CODE>fill-column</CODE> равной 75.


<P>
Действие <KBD>M-x set-variable</KBD> ограничено пользовательскими
параметрами, но вы можете установить значение любой переменной с помощью
выражения на языке Лисп, используя функцию <CODE>setq</CODE>.  Вот
выражение для установки значения переменной <CODE>fill-column</CODE> через
<CODE>setq</CODE>:



<PRE>
(setq fill-column 75)
</PRE>

<P>
Чтобы выполнить выражение, подобное этому, переключитесь в буфер
<TT>`*scratch*'</TT>, наберите выражение и затем нажмите <KBD>C-j</KBD>.
See section <A HREF="emacs_28.html#SEC324">Буферы диалога с Лиспом</A>.


<P>
Установка переменных влияет только на текущий сеанс Emacs, так же, как и
все остальные способы настройки Emacs, за исключением случаев, когда
явно сказано иное.




<H3><A NAME="SEC444" HREF="emacs_toc.html#TOC444">Интерфейс для простой настройки</A></H3>

<P>
<A NAME="IDX2577"></A>
<A NAME="IDX2578"></A>
Удобный способ найти желаемые параметры и изменить их предоставляет
команда <KBD>M-x customize</KBD>.  Она создает <EM>буфер настройки</EM>, где вы
можете просмотривать пользовательские параметры Emacs, представленные
логически организованной структурой, редактировать их и устанавливать их
значения.  Вы также можете использовать буфер настройки для постоянного
сохранения этих установок.  (Пока в эту структуру включены не все
пользовательские параметры Emacs, но мы добавляем оставшиеся.)




<H4><A NAME="SEC445" HREF="emacs_toc.html#TOC445">Группы настройки</A></H4>
<P>
<A NAME="IDX2579"></A>
<A NAME="IDX2580"></A>


<P>
В целях настройки пользовательские параметры собраны в <EM>группы</EM>,
чтобы их было проще найти.  Группы собраны в еще большие группы, и так
до самой верхней группы, названной <CODE>Emacs</CODE>.


<P>
Команда <KBD>M-x customize</KBD> создает буфер настройки, который показывает
группу верхнего уровня <CODE>Emacs</CODE> и группы, которые лежат на уровень
ниже.  Это выглядит примерно так, показана часть:



<PRE>
/- Emacs group: ---------------------------------------------------\
      [State]: visible group members are all at standard settings.
   Customization of the One True Editor.
   See also [Manual].

Editing group: [Go to Group] 
Basic text editing facilities.

External group: [Go to Group] 
Interfacing to external utilities.

<VAR>еще группы второго уровня</VAR>

\- Emacs group end ------------------------------------------------/

</PRE>

<P>
Это означает, что буфер показывает содержимое группы <CODE>Emacs</CODE>.
Другие группы перечислены здесь, поскольку они являются ее содержимым.
Но они перечислены иначе, без отступов и тире, потому что <EM>их</EM>
содержимое сюда не включено.  Каждая группа имеет однострочное описание;
у группы <CODE>Emacs</CODE> также есть строка <SAMP>`[State]'</SAMP>.


<P>
<A NAME="IDX2581"></A>
<A NAME="IDX2582"></A>
Большинство текста в буфере настройки находится в режиме только для
чтения, но обычно в него включено несколько <EM>редактируемых полей</EM>,
которые вы можете изменять.  Существуют также <EM>активные поля</EM>; это
означает, что они делают что-то, когда вы <EM>активизируете</EM> их.  Для
активизации активного поля либо щелкните на нем кнопкой <KBD>Mouse-1</KBD>,
или установите на нем точку и нажмите <KBD>RET</KBD>.


<P>
Например, фраза <SAMP>`[Go to Group]'</SAMP>, появляющая в группе второго
уровня, -- активное поле.  Активизация поля <SAMP>`[Go to Group]'</SAMP> для
группы создает новый буфер настройки, который показывает эту группу и ее
содержимое.  Это поле является чем-то вроде гиперссылки на другую
группу.


<P>
Сама группа <CODE>Emacs</CODE> не включает ни одного пользовательского
параметра, но они есть в других группах.  Исследуя разные группы, вы в
конце концов найдете нужные вам параметры и начертания.  Затем вы можете
использовать буфер настройки, чтобы установить их.


<P>
<A NAME="IDX2583"></A>
Вы можете просмотреть структуру групп настройки в укрупненном виде,
используя команду <KBD>M-x customize-browse</KBD>.  Эта команда создает
особый вид буфера настройки, который показывает только имена групп (а
также параметры и начертания) и их структуру.


<P>
В этом буфере вы можете просматривать содержимое группы, активизируя
кнопку <SAMP>`[+]'</SAMP>.  Когда показывается содержимое группы, эта кнопка
меняется на <SAMP>`[-]'</SAMP>; активизация этой кнопки прячет содержимое
группы.


<P>
Имя каждой группы, параметра или начертания в этом буфере имеет активное
поле, в котором написано <SAMP>`[Group]'</SAMP>, <SAMP>`[Option]'</SAMP> или
<SAMP>`[Face]'</SAMP>.  При активизации этого активного поля создается обычный
буфер настройки, показывающий только эту группу с ее содержимым, или
только этот параметр или только это начертание.  Таким способом
устанавливают значения.




<H4><A NAME="SEC446" HREF="emacs_toc.html#TOC446">Изменение параметра</A></H4>

<P>
Здесь приведен пример того, как выглядят в буфере настройки
пользовательский параметр:



<PRE>
Kill Ring Max: [Hide] 30
   [State]: this option is unchanged from its standard setting.
Maximum length of kill ring before oldest elements are thrown away.
</PRE>

<P>
Текст, следующий за <SAMP>`[Hide]'</SAMP>, -- в нашем случае это <SAMP>`30'</SAMP> ---
показывает текущее значение параметра.  Если вместо <SAMP>`[Hide]'</SAMP> вы
видите <SAMP>`[Show]'</SAMP>, то это означает, что значение скрыто; буфер
настройки сначала скрывает значения, которые занимают несколько строк.
Нажмите на <SAMP>`[Show]'</SAMP>, чтобы открыть значение.


<P>
Строка, следующая за именем параметра, показывает <EM>состояние
настройки</EM> для данного параметра: в вышеприведенном примере, она
сообщает, что вы еще не изменили этот параметр.  Слово <SAMP>`[State]'</SAMP> в
начале строки является активным; вы можете получить меню разных
операций, нажав на ней <KBD>Mouse-1</KBD> или <KBD>RET</KBD>.  Эти операции
являются существенными для настройки переменной.


<P>
Строка после строки <SAMP>`[State]'</SAMP> показывает начало описания данного
параметра.  Если документация занимает несколько строк, то эта строка
оканчивается кнопкой <SAMP>`[More]'</SAMP>; вы можете выбрать ее для того, чтобы
посмотреть более полное описание.


<P>
Для того чтобы ввести новое значение для <SAMP>`Kill Ring Max'</SAMP>,
переместите точку к значению и отредактируйте его как обычный текст.
Например, вы можете набрать <KBD>M-d</KBD> и ввести затем другое число.


<P>
Когда вы начинаете редактировать текст, вы увидите, что строка
<SAMP>`[State]'</SAMP> изменилась, сообщая, что вы поменяли значение:



<PRE>
[State]: you have edited the value as text, but not set the option.
</PRE>

<P>
<A NAME="IDX2584"></A>
Изменение значения в действительности не устанавливает значение
переменной.  Для этого вы должны <EM>установить</EM> данный параметр.
Чтобы сделать это, активизируйте кнопку <SAMP>`[State]'</SAMP> и выберите
<SAMP>`Set for Current Session'</SAMP>.


<P>
Когда вы установите параметр, его состояние визуально изменится:



<PRE>
[State]: you have set this option, but not saved it for future sessions.
</PRE>

<P>
Не нужно беспокоиться о том, что вы указали недопустимое значение; при
установке параметра значение проверяется, и недопустимое значение
никогда не будет установлено.


<P>
<A NAME="IDX2585"></A>
<A NAME="IDX2586"></A>
При редактировании значения поля, которое является именем файла,
каталога, команды или чем-нибудь еще, для чего определено завершение, вы
можете нажимать <KBD>M-<KBD>TAB</KBD></KBD> (<CODE>widget-complete</CODE>), чтобы
произвести завершение.


<P>
Некоторые параметры имеют небольшой фиксированный набор возможных
значений.  Эти параметры не позволяют вам редактировать значения как
текст.  Вместо этого перед значением появляется активное поле
<SAMP>`[Value Menu]'</SAMP>; активизируйте это поле для изменения значения.  Для
логического значения "вкл/выкл" активное поле показывает надпись
<SAMP>`[Toggle]'</SAMP>, и оно переключает это значение.  <SAMP>`[Value Menu]'</SAMP> и
<SAMP>`[Toggle]'</SAMP> изменяют буфер; изменения вступают в силу, когда вы
используете операцию <SAMP>`Set for Current Session'</SAMP>.


<P>
Некоторые параметры имеют значения со сложной структурой.  Например,
значение переменной <CODE>load-path</CODE> является списком каталогов.  Здесь
показано, как оно изображается в буфере настройки:



<PRE>
Load Path:
[INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/site-lisp
[INS] [DEL] [Current dir?]: /usr/local/share/emacs/site-lisp
[INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/leim
[INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/lisp
[INS] [DEL] [Current dir?]: /build/emacs/e20/lisp
[INS] [DEL] [Current dir?]: /build/emacs/e20/lisp/gnus
[INS]
   [State]: this item has been changed outside the customization buffer.
List of directories to search for files to load....
</PRE>

<P>
Каждый каталог в этом списке изображается на отдельной строке, а каждая
строка имеет несколько редактируемых или активных полей.


<P>
Вы можете изменять любое из имен каталогов.  Для того чтобы удалить
каталог из списка, выберите кнопку <SAMP>`[DEL]'</SAMP> в его строке.  Для того
чтобы вставить в список новый каталог, выберите кнопку <SAMP>`[INS]'</SAMP> в
той точке, куда вы хотите вставить имя.


<P>
Вы также можете выбрать поле <SAMP>`[Current dir?]'</SAMP>, чтобы переключиться
между включением в путь конкретного указанного каталога или значения
<CODE>nil</CODE>.  (<CODE>nil</CODE> в пути поиска означает "попробовать текущий
каталог").


<P>
<A NAME="IDX2587"></A>
<A NAME="IDX2588"></A>
<A NAME="IDX2589"></A>
<A NAME="IDX2590"></A>
Две специальные команды, <KBD>TAB</KBD> и <KBD>S-<KBD>TAB</KBD></KBD>, полезны для
перемещения по буферу настройки.  <KBD>TAB</KBD> (<CODE>widget-forward</CODE>)
перемещает вперед на следующее активное или редактируемое поле;
<KBD>S-<KBD>TAB</KBD></KBD> (<CODE>widget-backward</CODE>) перемещает в обратном
направлении на предыдущее активное или редактируемое поле.


<P>
Нажимая <KBD>RET</KBD> на редактируемом поле, вы также перемещаетесь на
следующее поле, аналогично действию <KBD>TAB</KBD>.  Причина этого
заключается в том, что люди часто нажимают <KBD>RET</KBD> по завершении
редактирования поля.  Если вам понадобится вставить в редактируемое поле
перевод строки, используйте <KBD>C-o</KBD> или <KBD>C-q C-j</KBD>.


<P>
<A NAME="IDX2591"></A>
Установка параметра изменяет его значение в текущем сеансе Emacs;
<EM>сохранение</EM> значения изменяет его и для будущих сеансов.  Это
работает путем записи кода в ваш файл <TT>`~/.emacs'</TT>, так что значения
параметров будут устанавливаться каждый раз, когда вы запускаете Emacs.
Для того чтобы сохранить параметр, активизируйте кнопку <SAMP>`[State]'</SAMP> и
выберите операцию <SAMP>`Save for Future Sessions'</SAMP>.


<P>
Вы также можете восстановить стандартные значения параметров,
активизируя кнопку <SAMP>`[State]'</SAMP> и выбирая операцию <SAMP>`Reset to
Standard Settings'</SAMP>.  В действительности существует три стандартных
операции восстановления:


<DL COMPACT>

<DT><SAMP>`Reset'</SAMP>
<DD>
Если вы внесли некоторые изменения и не установили параметр, то эта
операция восстанавливает текст буфера настройки, чтобы он соответствал
текущему значению.

<DT><SAMP>`Reset to Saved'</SAMP>
<DD>
Эта операция восстанавливает значение параметра в последнее сохраненное
значение и соответственно обновляет текст.

<DT><SAMP>`Reset to Standard Settings'</SAMP>
<DD>
Эта операция устанавливает параметр в его стандартное значение и
соответственно обновляет текст.  Эта операция также уничтожает любое
сохраненное значение для данного параметра, так что в будущих сеансах
работы с Emacs вы будете получать стандартное значение.
</DL>

<P>
Состояние группы показывает, было ли что-нибудь в этой группе изменено,
установлено или сохранено.  Вы можете выбрать операции <SAMP>`Set for
Current Session'</SAMP>, <SAMP>`Save for Future Sessions'</SAMP> и различные виды
операции <SAMP>`Reset'</SAMP> для данной группы; эти операции над группой
применяются сразу ко всем настройкам в группе и ее подгруппах.


<P>
В начале буфера настройки находятся две строки, содержащие несколько
активных полей:



<PRE>
 [Set for Current Session] [Save for Future Sessions]
 [Reset] [Reset to Saved] [Reset to Standard]   [Bury Buffer]
</PRE>

<P>
Активизация кнопки <SAMP>`[Bury Buffer]'</SAMP> скрывает буфер настройки.
Каждое из остальных полей выполняет операции -- установку, сохранение
или восстановление -- над каждым из пунктов в буфере, которые могут
быть установлены, сохранены или восстановлены.




<H4><A NAME="SEC447" HREF="emacs_toc.html#TOC447">Настройка начертаний</A></H4>
<P>
<A NAME="IDX2592"></A>
<A NAME="IDX2593"></A>
<A NAME="IDX2594"></A>
<A NAME="IDX2595"></A>


<P>
Помимо пользовательских параметров, некоторые группы настройки также
включают в себя начертания.  Когда вы просматриваете содержимое группы,
в буфере настройки показываются и пользовательские параметры, и
начертания из этой группы.  Начертание может выглядеть так:



<PRE>
Custom Changed Face: (sample)
   [State]: this face is unchanged from its standard setting.
Face used when the customize item has been changed.
Attributes: [ ] Bold: [toggle] off
            [X] Italic: [toggle] on
            [ ] Underline: [toggle] off
            [ ] Inverse-Video: [toggle] on
            [ ] Foreground: black (sample)
            [ ] Background: white (sample)
            [ ] Stipple:  
</PRE>

<P>
Каждый атрибут начертания располагается на отдельной строке.  Поле
<SAMP>`[<VAR>x</VAR>]'</SAMP> перед именем атрибута показывает, <EM>включен</EM> ли этот
атрибут; знак <SAMP>`X'</SAMP> обозначает, что включен.  Вы можете включать или
выключать атрибут, выбирая данное поле.  Когда атрибут включен, вы
можете изменить его значение обычными способами.


<P>
На черно-белом дисплее вам доступны для использования в качестве фона
следующие цвета: <SAMP>`black'</SAMP>, <SAMP>`white'</SAMP>, <SAMP>`gray'</SAMP>, <SAMP>`gray1'</SAMP> и
<SAMP>`gray3'</SAMP>.  Emacs поддерживает эти оттенки серого, используя вместо
цвета штрихование фона с помощью масок.


<P>
Установка, сохранение и сброс начертания работает точно также, как и с
пользовательскими параметрами (see section <A HREF="emacs_36.html#SEC446">Изменение параметра</A>).


<P>
Начертание может задавать разный вид для разных типов дисплеев.
Например, начертание может сделать текст красным на цветном дисплее, а
на монохромном отображать этот текст жирным шрифтом.  Для того чтобы
указать разный вид для данного начертания, выберите пункт <SAMP>`Show
Display Types'</SAMP> из меню, которое появляется при выборе кнопки
<SAMP>`[State]'</SAMP>.


<P>
<A NAME="IDX2596"></A>
Другой, более общий способ установить атрибуты заданного начертания ---
использовать команду <KBD>M-x modify-face</KBD>.  Эта команда считывает имя
начертания и атрибуты, один за другим.  Для атрибутов, задающих цвета и
маски, текущим значением атрибута будет значение по умолчанию -- просто
нажмите <KBD>RET</KBD>, если вы не хотите изменять этот атрибут.  Наберите
<SAMP>`none'</SAMP> в том случае, когда вы хотите очистить данный атрибут.




<H4><A NAME="SEC448" HREF="emacs_toc.html#TOC448">Настройка отдельных пунктов</A></H4>

<P>
Вместо того чтобы находить параметр, который вы хотите изменить,
перемещаясь сквозь дерево групп, вы можете указать, какой конкретно
параметр, начертание или группу вы хотите настроить.


<DL COMPACT>

<DT><KBD>M-x customize-option <KBD>RET</KBD> <VAR>параметр</VAR> <KBD>RET</KBD></KBD>
<DD>
Создать буфер настройки только для одного <VAR>параметра</VAR>.
<DT><KBD>M-x customize-face <KBD>RET</KBD> <VAR>начертание</VAR> <KBD>RET</KBD></KBD>
<DD>
Создать буфер настройки только для одного <VAR>начертания</VAR>.
<DT><KBD>M-x customize-group <KBD>RET</KBD> <VAR>группа</VAR> <KBD>RET</KBD></KBD>
<DD>
Создать буфер настройки только для одной <VAR>группы</VAR>.
<DT><KBD>M-x customize-apropos <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>
Создать буфер настройки для всех параметров, начертаний и групп, которые
соответствуют <VAR>regexp</VAR>.
<DT><KBD>M-x customize-changed-options <KBD>RET</KBD> <VAR>версия</VAR> <KBD>RET</KBD></KBD>
<DD>
Создать буфер настройки для всех параметров, начертаний и групп, чей
смысл изменился начиная с указанной <VAR>версии</VAR> Emacs.
<DT><KBD>M-x customize-saved</KBD>
<DD>
Создать буфер настройки, содержащий все параметры и начертания, которые
вы сохранили с помощью буферов настройки.
<DT><KBD>M-x customize-customized</KBD>
<DD>
Создать буфер настройки, содержащий все параметры и начертания, которые
вы изменили, но не сохранили.
</DL>

<P>
<A NAME="IDX2597"></A>
Если вы хотите изменить конкретный пользовательский параметр с помощью
буфера настройки, и вы знаете его имя, то вы можете использовать команду
<KBD>M-x customize-option</KBD> и указать имя этого параметра.  Это создает
буфер настройки только для одного параметра -- для того, который вы
запросили.  Изменение, установка и сохранение значения работает точно
так же, как описано выше, но только для указанного параметра.


<P>
<A NAME="IDX2598"></A>
Таким же образом вы можете изменить параметры конкретного начертания,
выбранного по имени.  Для этого используйте команду <KBD>M-x
customize-face</KBD>.


<P>
<A NAME="IDX2599"></A>
Вы также можете создать буфер настройки для отдельной группы, используя
команду <KBD>M-x customize-group</KBD>.  В этом буфере появится
непосредственное содержимое выбранной группы, в том числе
переменные-параметры, начертания и другие группы.  Однако содержимое
подгрупп изначально будет скрыто.  Вы можете просмотреть их содержимое
обычным способом, выбрав кнопку <SAMP>`[Show]'</SAMP>.


<P>
<A NAME="IDX2600"></A>
Для более точного указания того, что вы хотите настроить, вы можете
использовать команду <KBD>M-x customize-apropos</KBD>.  В качестве аргумента
вы указываете регулярное выражение; затем в созданном буфере настройки
отображаются все параметры, начертания и группы, чьи имена удовлетворяют
этому регулярного выражению.  Если вы укажете пустое регулярное
выражение, то буфер настройки будет включать <EM>все</EM> группы,
параметры и начертания (но это займет длительное время).


<P>
<A NAME="IDX2601"></A>
Когда вы устанавливаете новую версию Emacs, вы можете захотеть настроить
новые параметры, а также те параметры, чей смысл или значения по
умолчанию были изменены.  Чтобы сделать это, воспользуйтесь командой
<KBD>M-x customize-changed-options</KBD> и укажите в минибуфере номер
предыдущей версии Emacs.  Эта команда создаст буфер настройки, который
покажет вам все параметры (и группы), чье определение изменилось по
сравнению с указанной версией.


<P>
<A NAME="IDX2602"></A>
<A NAME="IDX2603"></A>
Если вы изменили значения параметров и затем решили, что сделали это по
ошибке, то у вас есть две специальные команды для того, чтобы
пересмотреть предыдущие изменения.  Используйте команду
<KBD>customize-saved</KBD>, чтобы посмотреть на параметры и начертания,
которые вы уже сохранили.  А команду <KBD>M-x customize-customized</KBD>
используйте для того, чтобы посмотреть на параметры и начертания,
которые вы установили, но еще не сохранили.




<H3><A NAME="SEC449" HREF="emacs_toc.html#TOC449">Ловушки</A></H3>
<P>
<A NAME="IDX2604"></A>
<A NAME="IDX2605"></A>
<A NAME="IDX2606"></A>


<P>
<EM>Ловушки</EM> -- это важный механизм настройки Emacs.  Ловушкой
называют лисповскую переменную, содержащую список функций, которые
вызываются в некоторой определенной ситуации.  (Это называется
<EM>запуском ловушки</EM>.)  Отдельные функции в этом списке называются
<EM>функциями этой ловушки</EM>.  За редкими исключениями, сразу после
запуска ловушки в Emacs пустые, так что все функции в любой ловушке ---
это явно помещенные туда вами для настройки.


<P>
Большинство основных режимов запускают на последнем этапе инициализации
одну или более <EM>ловушек режима</EM>.  Это облегчает настройку поведения
режима путем перекрытия локальных переменных, значения которых уже были
присвоены данным режимом.  Но ловушки также используются в других
контекстах.  Например, ловушка <CODE>suspend-hook</CODE> запускается
непосредственно перед тем, как Emacs приостанавливает свою работу
see section <A HREF="emacs_8.html#SEC23">Выход из Emacs</A>).


<P>
<A NAME="IDX2607"></A>
Большинство ловушек в Emacs являются <EM>нормальными ловушками</EM>.  Это
означает, что запуск такой ловушки действует путем безусловного вызова
всех ее функций без аргументов.  Мы старались сохранить большую часть
ловушек нормальными, чтобы вы могли использовать их одним и тем же
способом.  Каждая переменная в Emacs, чье имя оканчивается на
<SAMP>`-hook'</SAMP>, является нормальной ловушкой.


<P>
<A NAME="IDX2608"></A>
Также есть несколько <EM>аномальных ловушек</EM>.  Имена этих переменных
оканчиваются на <SAMP>`-hooks'</SAMP> или <SAMP>`-functions'</SAMP>, а не на
<SAMP>`-hook'</SAMP>.  Аномальность этих ловушек заключается в том, что их
функции вызываются с какой-то особенностью -- возможно, им передаются
аргументы, а может возвращаемое ими значение как-то используется.
Например, <CODE>find-file-not-found-hooks</CODE> (see section <A HREF="emacs_19.html#SEC110">Обращение к файлам</A>) ---
аномальная ловушка, потому что как только одна из ее функций возвращает
отличное от <CODE>nil</CODE> значение, остальные функции не вызываются совсем.
В документации на каждую аномальную ловушку подробно описано, в чем
состоит ее особенность.


<P>
Для добавления функции к ловушке (как нормальной, так и аномальной)
рекомендуется вызывать функцию <CODE>add-hook</CODE>.  Вы можете использовать
любую правильную функцию языка Лисп как функцию ловушки, при условии,
что она может обработать правильное число аргументов (нуль в случае
нормальной ловушки).  Конечно, не всякая лисповская функция
<EM>полезна</EM> в каждой конкретной ловушке.


<P>
Например, вот как установить ловушку для включения режима Auto Fill при
входе в режим Text и в другие режимы, основанные на режиме Text:



<PRE>
(add-hook 'text-mode-hook 'turn-on-auto-fill)
</PRE>

<P>
Следующий пример показывает, как использовать ловушки для настройки
отступов в программах на Си.  (Люди часто отдают строгое предпочтение
одному формату по сравнению с другим).  Приводимая здесь функция ловушки
является анонимным лямбда-выражением.



<PRE>
(setq my-c-style
  '((c-comment-only-line-offset . 4)
    (c-cleanup-list . (scope-operator
		       empty-defun-braces
		       defun-close-semi))
    (c-offsets-alist . ((arglist-close . c-lineup-arglist)
			(substatement-open . 0)))))

(add-hook 'c-mode-common-hook
  (function (lambda ()
    (c-add-style "my-style" my-c-style t))))
</PRE>

<P>
Лучше всего проектировать функции ловушек таким образом, чтобы порядок
выполнения не играл роли.  Создавать любую зависимость от порядка вызова
--- "напрашиваться на проблемы".  Однако, порядок предсказуем:
функции, добавленные последними, выполняются первыми.




<H3><A NAME="SEC450" HREF="emacs_toc.html#TOC450">Локальные переменные</A></H3>

<DL COMPACT>

<DT><KBD>M-x make-local-variable <KBD>RET</KBD> <VAR>пер</VAR> <KBD>RET</KBD></KBD>
<DD>
Сделать переменную <VAR>пер</VAR> локальной в текущем буфере.
<DT><KBD>M-x kill-local-variable <KBD>RET</KBD> <VAR>пер</VAR> <KBD>RET</KBD></KBD>
<DD>
Сделать так, что переменная <VAR>пер</VAR> использовала в текущем буфере свое
глобальное значение.
<DT><KBD>M-x make-variable-buffer-local <KBD>RET</KBD> <VAR>пер</VAR> <KBD>RET</KBD></KBD>
<DD>
Пометить переменную <VAR>пер</VAR> так, чтобы ее установка делала ее
локальной для текущего в тот момент буфера.
</DL>

<P>
<A NAME="IDX2609"></A>
Почти любая переменная может быть сдалана в <EM>локальной</EM> для
определенного буфера Emacs.  Это означает, что ее значение в этом буфере
не зависит от ее значения в других буферах.  Несколько переменных всегда
являются локальными в каждом буфере.  Любая другая переменная Emacs
имеет <EM>глобальное</EM> значение, которое действует во всех буферах, в
которых эта переменная не сделана локальной.


<P>
<A NAME="IDX2610"></A>
Команда <KBD>M-x make-local-variable</KBD> считывает имя переменной и делает
ее локальной для данного буфера.  Будущие изменения в данном буфере не
затронут другие буферы, а будущие изменения глобального значения не
затронут значения для данного буфера.


<P>
<A NAME="IDX2611"></A>
<A NAME="IDX2612"></A>
<KBD>M-x make-variable-buffer-local</KBD> считывает имя переменной и изменяет
будущее ее поведение таким образом, что при установке она автоматически
становится локальной.  Точнее, если переменная помечается таким
способом, то обычные способы установки переменной сначала будут
автоматически выполнять <CODE>make-local-variable</CODE>.  Такие переменные мы
называем <EM>переменными буфера</EM>.


<P>
Основные режимы (see section <A HREF="emacs_24.html#SEC211">Основные режимы</A>) всегда делают переменные
локальными для буфера до их установки.  Поэтому изменение основного
режима в одном буфере не влияет на другие буферы.  Второстепенные режимы
также работают путем установки переменных -- обычно каждый
второстепенный режим имеет одну управляющую переменную, которая отлична
от <CODE>nil</CODE>, когда данный режим включен (see section <A HREF="emacs_36.html#SEC441">Второстепенные режимы</A>).  Для большинства второстепенных режимов управляющая переменная
является переменной буфера.


<P>
Emacs содержит некоторое количество переменных, которые всегда являются
переменными буфера.  Сюда включаются <CODE>abbrev-mode</CODE>,
<CODE>auto-fill-function</CODE>, <CODE>case-fold-search</CODE>,
<CODE>comment-column</CODE>, <CODE>ctl-arrow</CODE>, <CODE>fill-column</CODE>,
<CODE>fill-prefix</CODE>, <CODE>indent-tabs-mode</CODE>, <CODE>left-margin</CODE>,
<CODE>mode-line-format</CODE>, <CODE>overwrite-mode</CODE>,
<CODE>selective-display-ellipses</CODE>, <CODE>selective-display</CODE>,
<CODE>tab-width</CODE> и <CODE>truncate-lines</CODE>.  Некоторые другие переменные
также всегда являются локальными для текущего буфера, но они
используются для внутренних целей.


<P>
Некоторые переменные не могут быть локальными для буфера, потому что они
вместо этого всегда локальны для каждого дисплея (see section <A HREF="emacs_22.html#SEC184">Множество дисплеев</A>).  Если вы попытаетесь сделать какую-либо из этих переменных
локальной для буфера, то вы получите сообщение об ошибке.


<P>
<A NAME="IDX2613"></A>
Команда <KBD>M-x kill-local-variable</KBD> считывает из минибуфера имя
переменной и прекращает ее существование как локальной для текущего
буфера.  С этого момента в этом буфере начинает действовать глобальное
значение переменной.  Установка основного режима уничтожает все
локальные переменные буфера за исключением нескольких, специально
отмеченных как <EM>постоянно локальные</EM>.


<P>
<A NAME="IDX2614"></A>
Для установки глобального значения переменной, независимо от того, имеет
ли она локальное значение в текущем буфере, можно использовать функцию
Лиспа <CODE>setq-default</CODE>.  Она работает аналогично <CODE>setq</CODE>, но
устанавливает глобальные значения переменных, а не локальные (если они
есть).  Если в текущем буфере действительно существует локальное
значение, то новое глобальное значение может быть невидимо до тех пор,
пока вы не переключитесь в другой буфер.  Вот пример:



<PRE>
(setq-default fill-column 75)
</PRE>

<P>
<CODE>setq-default</CODE> -- это единственный способ установки глобального
значения переменной, которая была помечена функцией
<CODE>make-variable-buffer-local</CODE>.


<P>
<A NAME="IDX2615"></A>
Программы на Лиспе могут посмотреть на значение некоторой переменной по
умолчанию с помощью функции <CODE>default-value</CODE>.  Эта функция принимает
в качестве аргумента символ и возвращает его значение по умолчанию.
Аргумент вычисляется; обычно вы должны явно поставить перед ним кавычку.
Например, вот как можно получить значение по умолчанию для переменной
<CODE>fill-column</CODE>:



<PRE>
(default-value 'fill-column)
</PRE>



<H3><A NAME="SEC451" HREF="emacs_toc.html#TOC451">Локальные переменные в файлах</A></H3>
<P>
<A NAME="IDX2616"></A>


<P>
Файл может указывать список значений локальных переменных, которые
должны использоваться при редактировании этого файла в Emacs.  Обращение
к файлу проверяет список локальных переменных, при этом каждая из этих
переменных делается локальной для буфера, и для нее устанавливается
значение, указанное в файле.


<P>
Есть два способа указания локальных переменных: в первой строке или с
помощью списка локальных переменных.  Здесь мы покажем, как задать
переменные в первой строке:



<PRE>
-*- mode: <VAR>имя-режима</VAR>; <VAR>пер</VAR>: <VAR>значение</VAR>; ... -*-
</PRE>

<P>
Таким способом вы можете написать любое количество пар
переменная/значение, каждая пара разделяется двоеточием и точкой с
запятой, как показано выше.  <CODE>mode: <VAR>имя-режима</VAR>;</CODE> задает
основной режим; эта пара должна быть первой в строке.  <VAR>Значения</VAR> не
вычисляются, а используются буквально.  Вот пример, который задает режим
Lisp и устанавливает две переменные с числовыми значениями:



<PRE>
;; -*-mode: Lisp; fill-column: 75; comment-column: 50; -*-
</PRE>

<P>
Этим способом вы можете также указать систему кодирования для данного
файла: просто задайте значение для "переменной" с именем
<CODE>coding</CODE>.  Значением должно быть имя системы кодирования, которое
Emacs может распознать.  See section <A HREF="emacs_23.html#SEC205">Системы кодирования</A>.


<P>
<EM>Список локальных переменных</EM> находится в конце файла, на последней
странице.  (Часто бывает лучше всего поместить его на отдельную
страницу.)  Список локальных переменных начинается со строки, содержащей
<SAMP>`Local Variables:'</SAMP>, и оканчивается строкой, содержащей <SAMP>`End:'</SAMP>.
Между ними идут имена переменных и их значения, по одному на строке, в
виде <SAMP>`<VAR>переменная</VAR>: <VAR>значение</VAR>'</SAMP>.  <VAR>Значения</VAR> не
вычисляются, они используются буквально.  Если в файле используются
и список локальных переменных, и строка <SAMP>`-*-'</SAMP>, то Emacs обрабатывает
сначала <EM>все</EM> в строке <SAMP>`-*-'</SAMP>, а затем <EM>все</EM> в списке
локальных переменных.


<P>
Вот пример списка локальных переменных:



<PRE>
;;; Local Variables: ***
;;; mode:lisp ***
;;; comment-column:0 ***
;;; comment-start: ";;; "  ***
;;; comment-end:"***" ***
;;; End: ***
</PRE>

<P>
Как вы видите, каждая строка начинается с префикса <SAMP>`;;; '</SAMP> и
заканчивается суффиксом <SAMP>` ***'</SAMP>.  Emacs распознает их как префикс и
суффикс, основываясь на первой строке списка, так как они окружают
магическую строку <SAMP>`Local Variables:'</SAMP>; затем они автоматически
исключаются из остальных строк списка.


<P>
Обычно префиксы и/или суффиксы используются для встраивания списка
локальных переменных в комментарии, чтобы он не смущал другие программы,
на вход которым подается этот файл.  Пример выше написан для языка, где
комментарий начинается с <SAMP>`;;; '</SAMP> и заканчивается на <SAMP>`***'</SAMP>;
значения локальных переменных <CODE>comment-start</CODE> и <CODE>comment-end</CODE>
настраивают Emacs на понимание этого необычного синтаксиса.  Не
используйте префикс или суффикс, если они вам не нужны.


<P>
Два "имени переменных" имеют особый смысл в списке локальных
переменных: значение для переменной <CODE>mode</CODE> в действительности
устанавливает основной режим, а значение для переменной <CODE>eval</CODE>
просто вычисляется как выражение, а его значение игнорируется.
<CODE>mode</CODE> и <CODE>eval</CODE> не являются настоящими переменными; установка
переменных с именами <CODE>mode</CODE> и <CODE>eval</CODE> в любом другом контексте
не имеет особого смысла.  Если <CODE>mode</CODE> используется для установки
основного режима, то она должна быть первой "переменной" в списке.


<P>
Вы можете использовать "переменную" <CODE>mode</CODE> для установки
второстепенных режимов точно так же, как и основных режимов; в
действительности, вы можете использовать ее несколько раз, сначала для
установки основного режима, а затем для установки второстепенных
режимов, которые будет действовать для выбранного буфера.  Но
большинство второстепенных режимов не стоит никак указывать в файле,
поскольку они представляют предпочтения пользователя.


<P>
Например, у вас можете появиться искушение включить режим Auto Fill с
помощью списка локальных переменных.  Это будет ошибкой.  Использовать
режим Auto Fill или нет -- это дело личного вкуса, а не свойство
содержимого файла.  Если вы хотите использовать режим Auto Fill, то
установите ловушки основных режимов в вашем файле <TT>`.emacs'</TT>, чтобы
он включался (когда нужно) только для вас (see section <A HREF="emacs_36.html#SEC470">Файл инициализации, <TT>`~/.emacs'</TT></A>).
Не используйте список локальных переменных для навязывания вашего вкуса
всем остальным.


<P>
Список локальных переменных должен начинаться не далее, чем за 3000
знаков от конца файла, и он должно находиться на последней странице,
если файл поделен на страницы.  Иначе Emacs не заметит его там.  Цель
этого в том, чтобы случайная <SAMP>`Local Variable:'</SAMP>, появившаяся не на
последней странице, не путала Emacs, и чтобы при обращении к длинному
файлу, который полностью является одной страницей и не имеет списка
локальных переменных, не тратилось время на просмотр всего файла.


<P>
Используйте команду <CODE>normal-mode</CODE> для переустановки локальных
переменных и основного режима данного буфера соответственно имени файла
и его содержимого, включая списки локальных переменных, если они есть.
See section <A HREF="emacs_24.html#SEC212">Как выбираются основные режимы</A>.


<P>
<A NAME="IDX2617"></A>
Переменная <CODE>enable-local-variables</CODE> говорит, нужно ли обрабатывать
локальные переменные в файлах, и таким образом дает вам шанс перекрыть
их.  По умолчанию ее значение равно <CODE>t</CODE>, что означает обработку
локальных переменных в файлах.  Если вы установите значение переменной
равным <CODE>nil</CODE>, то Emacs просто будет игнорировать локальные
переменные в файлах.  Любое другое значение велит делать запрос у
пользователя о каждом файле, в котором имеются локальные переменные,
показывая определения локальных переменных, чтобы вы могли принять
решение.


<P>
<A NAME="IDX2618"></A>
"Переменная" <CODE>eval</CODE> и некоторые настоящие переменные создают
некий риск; когда вы обращаетесь к чужим файлам, определения локальных
переменных для них могут произвольно воздействовать на ваш Emacs.
Поэтому параметр <CODE>enable-local-eval</CODE> контролирует, будет ли Emacs
обрабатывать переменные <CODE>eval</CODE>, а так же переменные, чьи имена
оканчиваются на <SAMP>`-hook'</SAMP>, <SAMP>`-hooks'</SAMP>, <SAMP>`-function'</SAMP> или
<SAMP>`-functions'</SAMP>, а также некоторые другие переменные.  Существует три
возможных значения для данного параметра: <CODE>t</CODE>, <CODE>nil</CODE> и
что-нибудь другое, точно так же, как и для
<CODE>enable-local-variables</CODE>.  Значением по умолчанию является
<CODE>maybe</CODE>, это не <CODE>t</CODE> и не <CODE>nil</CODE>, так что обычно Emacs
спросит подтверждение об установке этих переменных.




<H2><A NAME="SEC452" HREF="emacs_toc.html#TOC452">Клавиатурные макросы</A></H2>

<P>
<A NAME="IDX2619"></A>
<A NAME="IDX2620"></A>
<EM>Клавиатурный макрос</EM> -- это определенная пользователем команда,
обозначающая другую последовательность ключей.  Например, если вы
обнаружили, что вам нужно набрать <KBD>C-n C-d</KBD> сорок раз, то вы можете
ускорить работу, определив клавиатурный макрос для <KBD>C-n C-d</KBD> и
вызвав его со счетчиком повторений 40.


<DL COMPACT>

<DT><KBD>C-x (</KBD>
<DD>
Начать определение клавиатурного макроса (<CODE>start-kbd-macro</CODE>).
<DT><KBD>C-x )</KBD>
<DD>
Закончить определение клавиатурного макроса (<CODE>end-kbd-macro</CODE>).
<DT><KBD>C-x e</KBD>
<DD>
Выполнить самый последний клавиатурный макрос (<CODE>call-last-kbd-macro</CODE>).
<DT><KBD>C-u C-x (</KBD>
<DD>
Заново выполнить последний клавиатурный макрос и затем добавить
дополнительные ключи к его определению.
<DT><KBD>C-x q</KBD>
<DD>
Когда достигается эта точка при выполнении макроса, сделать запрос о
подтверждении (<CODE>kbd-macro-query</CODE>).
<DT><KBD>M-x name-last-kbd-macro</KBD>
<DD>
Задать имя команды (на время текущего сеанса) для последнего
определенного клавиатурного макроса.
<DT><KBD>M-x insert-kbd-macro</KBD>
<DD>
Вставить в буфер определение клавиатурного макроса как код на Лиспе.
<DT><KBD>C-x C-k</KBD>
<DD>
Отредактировать ранее определенный клавиатурный макрос
(<CODE>edit-kbd-macro</CODE>).
<DT><KBD>M-x apply-macro-to-region-lines</KBD>
<DD>
Запустить последний клавиатурный макрос на каждой полной строке в
области.
</DL>

<P>
Клавиатурные макросы отличаются от обычных команд Emacs тем, что они
написаны на командном языке Emacs, а не на Лиспе.  Это облегчает их
написание для новичков и делает их более удобными в качестве временных
хаков.  Однако, мощности командного языка Emacs как языка
программирования недостаточно, чтобы он был удобным для написания
чего-либо умного или универсального.  Для таких вещей надо использовать
Лисп.


<P>
Вы определяете клавиатурные макросы во время выполнения команд,
являющихся определением.  Говоря другими словами, во время определения
клавиатурного макроса его определение выполняется в первый раз.  Таким
образом, вы можете видеть, каково действие ваших команд, так что вы не
должны просчитывать его в уме.  Когда вы кончили, макрос клавиатуры
определен, а также один раз фактически выполнен.  После этого вы можете
снова и снова выполнять все целиком, вызывая макрос.




<H3><A NAME="SEC453" HREF="emacs_toc.html#TOC453">Основы использования</A></H3>

<P>
<A NAME="IDX2621"></A>
<A NAME="IDX2622"></A>
<A NAME="IDX2623"></A>
<A NAME="IDX2624"></A>
<A NAME="IDX2625"></A>
<A NAME="IDX2626"></A>
Для начала определения клавиатурного макроса наберите команду <KBD>C-x
(</KBD> (<CODE>start-kbd-macro</CODE>).  Начиная с этого момента ваши нажатия на
клавиши по-прежнему выполняются, но также становятся частью определения
макроса.  В строке режима появляется слово <SAMP>`Def'</SAMP>, чтобы напомнить
вам о том, что происходит.  Когда вы закончите, команда <KBD>C-x )</KBD>
(<CODE>end-kbd-macro</CODE>) закончит определение макроса (но не станет его
частью!).  Например,



<PRE>
C-x ( M-f foo C-x )
</PRE>

<P>
определяет макрос для перемещения вперед на слово и вставки <SAMP>`foo'</SAMP>.


<P>
Определенный таким образом макрос может запускаться снова с помощью
команды <KBD>C-x e</KBD> (<CODE>call-last-kbd-macro</CODE>), в качестве числового
аргумента которой можно задать счетчик повторов для многократного
выполнения макроса.  Команде <KBD>C-x )</KBD> также можно задать счетчик
повторов в качестве аргумента, в этом случае именно столько раз она
повторяет макрос сразу после его определения, но само определение
макроса засчитывается как первое повторение (так как оно выполняется в
то время, как вы его определяете).  Таким образом, <KBD>C-x )</KBD> с
аргументом 4 приводит к непосредственному выполнению макроса еще 3 раза.
Аргумент 0 для <KBD>C-x e</KBD> или <KBD>C-x )</KBD> означает повторение макроса
бесконечное число раз (пока он не получит ошибку, или вы не наберете
<KBD>C-g</KBD> или, в MS-DOS, <KBD>C-<KBD>BREAK</KBD></KBD>).


<P>
Если вы хотите повторять операцию в регулярно расположенных местах в
тексте, то определите макрос и включите в него команды для передвижения
к следующему месту, в котором вы хотите его использовать.  Например,
если вы хотите изменить каждую строку, вам нужно поставить точку в
начало строки и определить макрос, изменяющий эту строку и перемещающий
точку в начало следующей строки.  После этого повторение макроса будет
обрабатывать строки одну за другой.


<P>
После того как вы завершили определение макроса, вы можете добавить
что-либо в его конец, набрав <KBD>C-u C-x )</KBD>.  Это эквивалентно обычной
<KBD>C-x (</KBD>, за которой следует повторный набор всего имевшегося до сих
пор определения.  Как следствие этого, она повторно выполнит макрос, как
было определено ранее.


<P>
Вы можете использовать в клавиатурных макросах функциональные клавиши,
точно так же, как клавиши клавиатуры.  Вы даже можете использовать
события от мыши, но будьте внимательны с ними: когда макрос проигрывает
событие мыши, он использует оригинальную позицию мыши для этого события,
ту, которую мышь имела во время определения макроса.  Что может при этом
произойти, трудно предсказать.  (Эффект от использования текущей позиции
мыши был бы еще менее предсказуем.)


<P>
Одна из вещей, которая не всегда правильно работает в клавиатурных
макросах, -- это команда <KBD>C-M-c</KBD> (<CODE>exit-recursive-edit</CODE>).
Когда эта команда выводит из рекурсивного редактирования, которое было
начато внутри макроса, то она работает так, как вы ожидали.  Но если вы
выходите из рекурсивного редактирования, которое было начато до того,
как вы запустили клавиатурный макрос, то также происходит выход из
клавиатурного макроса как из части этого процесса.


<P>
<A NAME="IDX2627"></A>
<A NAME="IDX2628"></A>
Вы можете отредактировать уже существующий клавиатурный макрос,
используя <KBD>C-x C-k</KBD> (<CODE>edit-kbd-macro</CODE>).  Затем вы должны ввести
то, что вы будете использовать для вызова макроса -- <KBD>C-x e</KBD> или
<KBD>M-x <VAR>имя</VAR></KBD> или какую-то другую последовательность ключей.  Это
форматирует определение макроса в буфере и входит в специальный основной
режим для его редактирования.  Наберите в этом буфере <KBD>C-h m</KBD>, чтобы
получить подробности о редактировании макроса.  Когда вы закончите
редактирование, нажмите <KBD>C-c C-c</KBD>.


<P>
<A NAME="IDX2629"></A>
Команда <KBD>M-x apply-macro-to-region-lines</KBD> повторяет последний
определенный клавиатурный макрос для каждой полной строки внутри текущей
области.  Она делает это строка за строкой, перемещая точку в начало
строки и выполняя затем макрос.




<H3><A NAME="SEC454" HREF="emacs_toc.html#TOC454">Именование и сохранение клавиатурных макросов</A></H3>

<P>
<A NAME="IDX2630"></A>
<A NAME="IDX2631"></A>
Если вы хотите сохранить макрос клавиатуры дольше, чем до следующего
определения, то вы должны дать ему имя, используя <KBD>M-x
name-last-kbd-macro</KBD>.  Эта команда считывает имя как аргумент, используя
минибуфер, и определяет это имя для выполнения макроса.  Имя макроса ---
это лисповский символ, а определение его таким способом делает его
допустимым именем команды для вызова при помощи <KBD>M-x</KBD> или для
привязывания ключа с помощью <CODE>global-set-key</CODE> (see section <A HREF="emacs_36.html#SEC457">Таблицы ключей</A>).  Если вы укажете имя, уже имеющее определение, отличное от
макроса клавиатуры, то печатается сообщение об ошибке, и ничего не
изменяется.


<P>
<A NAME="IDX2632"></A>
Когда макрос получает имя команды, вы можете записать его определение в
файл.  Потом его можно будет использовать в другом сеансе
редактирования.  Сначала обратитесь к файлу, в котором хотите записать
определение.  Затем используйте эту команду:



<PRE>
M-x insert-kbd-macro <KBD>RET</KBD> <VAR>имя-макро</VAR> <KBD>RET</KBD>
</PRE>

<P>
Это вставляет Лисп-код, который, будучи выполнен позднее, определит тот
же самый макрос с тем же самым определением, которое он имеет сейчас.
(Чтобы сделать это, вам не нужно разбираться в Лисп-коде, так как
<CODE>insert-kbd-macro</CODE> напишет его за вас.)  Затем сохраните файл.
Позже вы можете загрузить этот файл с помощью <CODE>load-file</CODE>
(see section <A HREF="emacs_28.html#SEC322">Библиотеки Лисп-программ для Emacs</A>).  Если файл, в который вы записываете,
является вашим файлом инициализации <TT>`~/.emacs'</TT> (see section <A HREF="emacs_36.html#SEC470">Файл инициализации, <TT>`~/.emacs'</TT></A>), то макрос будет определяться каждый раз, когда вы
запускаете Emacs.


<P>
Если вы зададите команде <CODE>insert-kbd-macro</CODE> числовой аргумент, то
она создаст дополнительный Лисп-код для записи ключей (если они есть),
которые вы привязали к макросу клавиатуры; таким образом, когда вы
загрузите файл, макрос будут вновь привязан к тем же самым ключам.




<H3><A NAME="SEC455" HREF="emacs_toc.html#TOC455">Выполнение макроса с вариациями</A></H3>

<P>
<A NAME="IDX2633"></A>
<A NAME="IDX2634"></A>
Используя <KBD>C-x q</KBD> (<CODE>kbd-macro-query</CODE>), вы можете достигнуть
эффекта, сходного с действием <CODE>query-replace</CODE>, когда макрос каждый
раз запрашивает у вас, должен ли он производить изменения.  Во время
определения макроса наберите <KBD>C-x q</KBD> в той точке, где вы хотите
получать запрос.  При определении макроса эта команда ничего не делает,
но когда вы запускаете макрос, то <KBD>C-x q</KBD> произведет интерактивный
запрос о продолжении действий.


<P>
Правильными ответами на запрос от <KBD>C-x q</KBD> являются <KBD>SPC</KBD> (или
<KBD>y</KBD>), <KBD>DEL</KBD> (или <KBD>n</KBD>), <KBD>RET</KBD> (или <KBD>q</KBD>), <KBD>C-l</KBD> и
<KBD>C-r</KBD>.  Ответы те же самые, что и для <CODE>query-replace</CODE>, хотя не
все варианты ответа для <CODE>query-replace</CODE> имеют смысл.


<P>
Эти ответы включают <KBD>SPC</KBD> для продолжения, а <KBD>DEL</KBD> для пропуска
остатка этого повторения макроса и начала нового повторения макроса.
<KBD>RET</KBD> означает пропуск остатка данного повторения и отмены остальных
повторений.  <KBD>C-l</KBD> перерисовывает экран и снова делает запрос.


<P>
<KBD>C-r</KBD> входит на уровень рекурсивного редактирования, где вы можете
выполнить редактирование, которое не является частью макроса.  Когда вы
выйдете из рекурсивного редактирования с помощью <KBD>C-M-c</KBD>, у вас
снова спросят о том, как продолжать выполнение клавиатурного макроса.
Если тогда вы нажмете <KBD>SPC</KBD>, то будет выполнен остаток макроса.


<P>
<KBD>C-u C-x q</KBD>, то есть <KBD>C-x q</KBD> с числовым аргументом, осуществляет
совершенно другую функцию.  Она входит в рекурсивное редактирование,
считывая ввод с клавиатуры, и когда вы набираете его во время
определения макроса, и когда он выполняется из макроса.  Во время
определения, редактирование, которое вы делаете внутри рекурсивного
редактирования, не становится частью макроса.  Во время выполнения
макроса рекурсивное редактирование дает вам возможность выполнить
какое-либо особенное редактирование в каждом повторении.
See section <A HREF="emacs_35.html#SEC436">Уровни рекурсивного редактирования</A>.


<P>
Другой способ изменить поведение клавиатурного макроса -- использовать
в качестве счетчика регистр, увеличивая его при каждом повторе макроса.
See section <A HREF="emacs_15.html#SEC78">Хранение чисел в регистрах</A>.




<H2><A NAME="SEC456" HREF="emacs_toc.html#TOC456">Настройка привязок ключей</A></H2>
<P>
<A NAME="IDX2635"></A>


<P>
Этот раздел описывает <EM>привязки ключей</EM>, которые отображают ключи в
команды, и <EM>таблицы ключей</EM>, которые сохраняют привязки.  Здесь
также объясняется, как изменять привязки ключей для своих нужд.


<P>
Напомним, что команда -- это функция Лиспа, чье определение
обеспечивает интерактивное использование.  Подобно любой лисповской
функции, каждая команда имеет имя, которое обычно состоит из букв
нижнего регистра и дефисов.




<H3><A NAME="SEC457" HREF="emacs_toc.html#TOC457">Таблицы ключей</A></H3>
<P>
<A NAME="IDX2636"></A>


<P>
Привязки между последовательностями ключей и функциями-командами
сохраняются в структурах данных, называемых <EM>таблицами ключей</EM>.  В
Emacs много таких таблиц, каждая из которых используется в особых
случаях.


<P>
Напомним, что <EM>последовательность ключей</EM> (или коротко, <EM>ключ</EM>)
--- это последовательность <EM>событий ввода</EM>, которая имеет смысл как
одно целое.  События ввода включают в себя знаки, функциональные клавиши
и кнопки мыши -- все виды ввода, какие вы можете послать компьютеру с
вашего терминала.  Последовательность ключей получает свой смысл из
<EM>привязки</EM>, которая говорит, какую команду данный ключ запускает.
Назначение таблиц ключей состоит в сохранении этих привязок.


<P>
<A NAME="IDX2637"></A>
<EM>Глобальная</EM> таблица ключей является наиболее важной, потому что она
действует всегда.  Глобальная таблица определяет ключи для режима
Fundamental; большинство из этих определений являются общими для всех
основных режимов.  Каждый основной или второстепенный режим может иметь
свою собственную таблицу ключей, которая перекрывает глобальные
определения некоторых ключей.


<P>
Например, самовставляющийся знак, такой как <KBD>g</KBD>, является
самовставляющимся, потому что глобальная таблица ключей привязывает его
к команде <CODE>self-insert-command</CODE>.  Стандартные знаки редактирования
в Emacs, такие как <KBD>C-a</KBD>, также получают свой стандартный смысл из
глобальной таблицы ключей.  Команды для перепривязки ключей, такие как
<KBD>M-x global-set-key</KBD>, на самом деле работают путем сохранения новой
привязки в соответствующем месте глобальной таблицы ключей.
See section <A HREF="emacs_36.html#SEC461">Интерактивное изменение привязок ключей</A>.


<P>
Meta-знаки работают по другому; Emacs транслирует каждый Meta-знак в
пары знаков, начинающиеся с <KBD>ESC</KBD>.  Когда вы набираете знак
<KBD>M-a</KBD>, Emacs заменяет ее на <KBD><KBD>ESC</KBD> a</KBD>.  Meta-клавиша
приходит как одиночное событие ввода, но для целей привязки ключей
становится двумя событиями.  Это происходит по историческим причинам, и
мы можем когда-нибудь это изменить.


<P>
<A NAME="IDX2638"></A>
На большинстве современных клавиатур помимо знаковых клавиш есть
функциональные клавиши.  Функциональные клавиши посылают события ввода,
точно так же, как и знаковые клавиши, и таблицы ключей могут содержать
привязки для них.


<P>
На многих терминалах нажатие на функциональную клавишу в
действительности посылает компьютеру последовательность знаков; точная
информация о том, что это за последовательность, зависит от самой
функциональной клавиши и от того, какую модель терминала вы используете.
(Часто такая последовательность начинается с <KBD><KBD>ESC</KBD> [</KBD>.)  Если
Emacs понимает ваш тип терминала правильно, то он распознает
последовательности знаков, формирующие функциональные клавиши, в каком
бы месте последовательности ключей они не встречались (не только в
начале).  Таким образом, для большинства целей вы можете считать, что
функциональные клавиши достигают Emacs непосредственно, и игнорировать
их кодирование как последовательность знаков.


<P>
<A NAME="IDX2639"></A>
Кнопки мыши также производят события ввода.  Эти события приносят другую
информацию -- окно и позицию, где была нажата или отпущена кнопка мыши,
и временную метку.  Но для привязок ключей важно лишь знать кнопку;
другие данные играют роль, только если это нужно команде.  (Команды,
разработанные для вызова с помощью мыши, на самом деле обычно обращают
внимание на эти данные).


<P>
Таблица ключей записывает определения для одиночных событий.  Для
интерпретации последовательности ключей, состоящей из нескольких
событий, нужна цепочка таблиц ключей.  Первая таблица дает определение
первого события; это определение является другой таблицей ключей,
которая используется для поиска второго события в последовательности, и
так далее.


<P>
Последовательность ключей может содержать нажатия на функциональные и
знаковые клавиши.  Например, <KBD>C-x <KBD>SELECT</KBD></KBD> имеет смысл.  Если
вы сделаете клавишу <KBD>SELECT</KBD> префиксным ключом, то <KBD><KBD>SELECT</KBD>
C-n</KBD> тоже будет иметь смысл.  Вы даже можете смешивать события от мыши с
событиями от клавиатуры, но мы не рекомендуем делать так, потому что
такие последовательности неудобно набирать.


<P>
Как пользователь вы можете перепривязать любой ключ; но будет лучше,
если вы всегда будете использовать последовательности ключей, состоящие
из <KBD>C-c</KBD>, за которым следует буква.  Эти клавиши "зарезервированы
для пользователей", так что они не будут конфликтовать ни с одним
правильно спроектированным расширением Emacs.  Функциональные клавиши от
<KBD>F5</KBD> до <KBD>F9</KBD> также зарезервированы для пользователей.  Если вы
перепривязываете какой-то другой ключ, ваше определение может быть
перекрыто некоторыми расширениями или основными режимами, которые
переопределяют тот же самый ключ.




<H3><A NAME="SEC458" HREF="emacs_toc.html#TOC458">Таблицы префиксных ключей</A></H3>

<P>
Префиксный ключ, такой как <KBD>C-x</KBD> или <KBD>ESC</KBD>, имеют собственную
таблицу ключей, которая хранит определения для событий, непосредственно
следующих за этим префиксом.


<P>
Определение префиксного ключа -- это обычно таблица ключей, в которой
ищется следующее событие.  Это определение также может быть лисповским
символом, чье определение функции является следующей таблицей ключей;
результат этого тот же самый, но он предоставляет для префиксного ключа
командное имя, которое может быть использовано как описание того, для
чего предназначен этот префиксный ключ.  Таким образом, привязка
<KBD>C-x</KBD> -- это символ <CODE>Ctl-X-Prefix</CODE>, чье определение функции
является таблицей ключей для команд на <KBD>C-x</KBD>.  Определения
<KBD>C-c</KBD>, <KBD>C-x</KBD>, <KBD>C-h</KBD> и <KBD>ESC</KBD> как префиксных ключей
появляются в глобальной таблице, так что эти префиксные ключи доступны
всегда.


<P>
Помимо обычных префиксных ключей существуют фиктивные "префиксные
ключи", которые представляют полоску меню; смотрите @xref{Menu Bar,,,@external{elisp}, The Emacs Lisp Reference Manual}, для
дополнительной информации о привязках ключей полоски меню.  События от
кнопок мыши, которые запускают всплывающие меню, также являются
префиксными ключами; смотрите @ref{Menu Keymaps,,,@external{elisp}, The
Emacs Lisp Reference Manual}, для дополнительной информации.


<P>
Некоторые таблицы префиксных ключей хранятся в именованных переменных:



<UL>
<LI>

<A NAME="IDX2640"></A>
<CODE>ctl-x-map</CODE> -- это имя переменной для таблицы, используемой для
знаков, следующих за <KBD>C-x</KBD>.
<LI>

<A NAME="IDX2641"></A>
<CODE>help-map</CODE> для знаков, следующих за <KBD>C-h</KBD>.
<LI>

<A NAME="IDX2642"></A>
<CODE>esc-map</CODE> для знаков, следующих за <KBD>ESC</KBD>.  Таким образом, все
Meta-знаки в действительности определяются этой таблицей.
<LI>

<A NAME="IDX2643"></A>
<CODE>ctl-x-4-map</CODE> для знаков, следующих за <KBD>C-x 4</KBD>.
<LI>

<A NAME="IDX2644"></A>
<CODE>mode-specific-map</CODE> для знаков, следующих за <KBD>C-c</KBD>.
</UL>



<H3><A NAME="SEC459" HREF="emacs_toc.html#TOC459">Локальные таблицы ключей</A></H3>

<P>
<A NAME="IDX2645"></A>
До сих пор мы объясняли принципы работы глобальной таблицы.  Основные
режимы настраивают Emacs, предоставляя собственные привязки ключей в
<EM>локальных таблицах ключей</EM>.  Например, режим C переопределяет
<KBD>TAB</KBD> для создания отступа текущей строки кода на Си.  Куски текста
в буфере могут указывать свои собственные таблицы ключей взамен таблицы
основного режима этого буфера.


<P>
<A NAME="IDX2646"></A>
Второстепенные режимы также могут иметь локальные таблицы ключей.  Когда
действует второстепенный режим, определения из его таблицы ключей
перекрывают и локальную таблицу основного режима, и глобальную таблицу.


<P>
<A NAME="IDX2647"></A>
<A NAME="IDX2648"></A>
Локальные таблицы ключей для режима Lisp и некоторых других основных
режимов всегда существуют, даже когда не используются.  Они хранятся в
переменных с именами <CODE>lisp-mode-map</CODE> и так далее.  Для менее часто
используемых основных режимов локальная таблица ключей обычно создается
при первом использовании в сеансе.  Это сберегает ресурсы.  Если вы
хотите изменить одну из этих таблиц ключей, то вы должны использовать
<EM>ловушку режима</EM> -- смотрите ниже.


<P>
Все таблицы ключей второстепенных режимов создаются заранее.  Не
существует способа задержать их создание до тех пор, пока этот
второстепенный режим не будет включен первый раз.


<P>
Локальная таблица ключей может локально переопределять ключ как
префиксный, определяя его как префиксную таблицу ключей.  Если этот ключ
определен как префикс и в глобальной таблице, то его локальное и
глобальное определения (из обоих таблиц ключей) эффективно
комбинируется: обе они используются для поиска события, которое следует
за префиксным ключом.  Таким образом, если локальная таблица ключей
определяет <KBD>C-c</KBD> как еще одну таблицу ключей, а эта таблица
определяет <KBD>C-z</KBD> как команду, то это придает локальный смысл для
<KBD>C-c C-z</KBD>.  Это не затрагивает другие последовательности, которые
начинаются с <KBD>C-c</KBD>; если у этих последовательностей нет собственной
локальной привязки, то продолжают действовать глобальные привязки.


<P>
Другой способ понять это -- считать, что Emacs обрабатывает
последовательности ключей, состоящие из нескольких событий, просматривая
несколько таблиц ключей одну за одной в поисках этой последовательности
целиком.  Сначала он проверяет таблицы ключей текущих второстепенных
режимов, затем таблицу ключей основного режима и затем он ищет в
глобальной таблице.  Это не совсем точно описывает то, как работает
поиск, но достаточно хорошо для понимания обычного положения дел.


<P>
<A NAME="IDX2649"></A>
Для изменения локальных привязок основного режима вы должны изменить
локальную таблицу ключей этого режима.  Обычно вы должны дождаться
первого использования режима, поскольку до того момента большинство
режимов не создают свои таблицы ключей.  Если вы хотите указать
что-нибудь в вашем файле <TT>`~/.emacs'</TT> для изменения привязок
основного режима, то вы должны использовать ловушку этого режима, чтобы
задержать изменения до его первого использования.


<P>
Например, команда <CODE>texinfo-mode</CODE> для выбора режима Texinfo
запускает ловушку <CODE>texinfo-mode-hook</CODE>.  Продемонстрируем, как можно
использовать эту ловушку для добавления локальных привязок (мы признаем,
не слишком полезной) для клавиш <KBD>C-c n</KBD> и <KBD>C-c p</KBD> в режиме
Texinfo:



<PRE>
(add-hook 'texinfo-mode-hook
          '(lambda ()
             (define-key texinfo-mode-map
                         "\C-cp"
                         'backward-paragraph)
             (define-key texinfo-mode-map
                         "\C-cn"
                         'forward-paragraph)
             ))
</PRE>

<P>
See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.




<H3><A NAME="SEC460" HREF="emacs_toc.html#TOC460">Таблицы ключей минибуфера</A></H3>

<P>
<A NAME="IDX2650"></A>
<A NAME="IDX2651"></A>
<A NAME="IDX2652"></A>
<A NAME="IDX2653"></A>
<A NAME="IDX2654"></A>
Минибуфер имеет свой собственный набор локальных таблиц ключей; они
содержат разные команды завершения и выхода.



<UL>
<LI>

<CODE>minibuffer-local-map</CODE> используется для обыкновенного ввода (без
завершения).
<LI>

<CODE>minibuffer-local-ns-map</CODE> похожа, но <KBD>SPC</KBD> выходит, точно так
же, как <KBD>RET</KBD>.  Это используется главным образом для совместимости с
Mocklisp.
<LI>

<CODE>minibuffer-local-completion-map</CODE> для свободного завершения.
<LI>

<CODE>minibuffer-local-must-match-map</CODE> для строгого и осторожного
завершения.
</UL>



<H3><A NAME="SEC461" HREF="emacs_toc.html#TOC461">Интерактивное изменение привязок ключей</A></H3>
<P>
<A NAME="IDX2655"></A>
<A NAME="IDX2656"></A>


<P>
Чтобы переопределить ключ в Emacs, надо изменить ее запись в таблице
ключей.  Вы можете изменить глобальную таблицу ключей, тогда изменение
подействует на все основные режимы (за исключением тех, в которых есть
свои локальные, перекрывающие определения для того же самого ключа).  Или
вы можете изменить локальную таблицу ключей текущего буфера, что
затронет все буферы, использующие тот же самый основной режим.


<P>
<A NAME="IDX2657"></A>
<A NAME="IDX2658"></A>
<A NAME="IDX2659"></A>
<A NAME="IDX2660"></A>
<DL COMPACT>

<DT><KBD>M-x global-set-key <KBD>RET</KBD> <VAR>ключ</VAR> <VAR>кмд</VAR> <KBD>RET</KBD></KBD>
<DD>
Глобально определяет <VAR>ключ</VAR> для запуска команды <VAR>кмд</VAR>.
<DT><KBD>M-x local-set-key <KBD>RET</KBD> <VAR>ключ</VAR> <VAR>кмд</VAR> <KBD>RET</KBD></KBD>
<DD>
Локально определяет <VAR>ключ</VAR> (в текущем основном режиме) для запуска
команды <VAR>кмд</VAR>.
<DT><KBD>M-x global-unset-key <KBD>RET</KBD> <VAR>ключ</VAR></KBD>
<DD>
Делает <VAR>ключ</VAR> неопределенным в глобальной таблице ключей.
<DT><KBD>M-x local-unset-key <KBD>RET</KBD> <VAR>ключ</VAR></KBD>
<DD>
Делает <VAR>ключ</VAR> неопределенным в локальной таблице ключей (в текущем
основном режиме).
</DL>

<P>
Допустим например, что вы хотите выполнять команды в подоболочке внутри
буфера Emacs, а не приостанавливать Emacs и выполнять команды в вашей
входной оболочке.  Обычно <KBD>C-z</KBD> привязан к функции
<CODE>suspend-emacs</CODE> (когда не используется система X Windows), но вы
можете изменить <KBD>C-z</KBD> на запуск интерактивной подоболочки внутри
Emacs, привязав ее к команде <CODE>shell</CODE>, как показано:



<PRE>
M-x global-set-key <KBD>RET</KBD> C-z shell <KBD>RET</KBD>
</PRE>

<P>
<CODE>global-set-key</CODE> считывает имя команды после клавиши.  После того
как вы нажмете клавишу, появится примерно такое сообщение, так что вы
сможете убедиться, что назначаете ту клавишу, которую хотите:



<PRE>
Set key C-z to command: 
</PRE>

<P>
Вы можете переопределить функциональные клавиши и события от мыши тем же
самым способом; просто нажмите на функциональную клавишу или щелкните
кнопкой мыши, когда у вас спрашивают, какой ключ нужно перепривязать.


<P>
Вы можете перепривязать ключ, который содержит больше одного события,
тем же самым способом.  Emacs продолжает считывать ключ для перепривязки
до тех пор, пока он не станет полным ключом (то есть непрефиксным).
Таким образом, если вы нажмете <KBD>C-f</KBD> как <VAR>ключ</VAR>, то на этом все
закончится; вы сразу попадете в минибуфер для считывания команды
<VAR>кмд</VAR>.  Но если вы нажмете <KBD>C-x</KBD>, считывается еще один знак;
если это <KBD>4</KBD>, считывается еще один, и так далее.  Например,



<PRE>
M-x global-set-key <KBD>RET</KBD> C-x 4 $ spell-other-window <KBD>RET</KBD>
</PRE>

<P>
переопределяет <KBD>C-x 4 $</KBD> для запуска команды (фиктивной)
<CODE>spell-other-window</CODE>.


<P>
Двухзнаковые ключи, состоящие из <KBD>C-c</KBD> и буквы, зарезервированы для
пользовательской настройки.  Предполагается, что программы на Лиспе не
определяют эти ключи, так что ваши привязки для них будут доступны во
всех основных режимах и не будут ничему мешать.


<P>
Вы можете убрать глобальное определение ключа с помощью команды
<CODE>global-unset-key</CODE>.  Это делает ключ <EM>неопределенным</EM>; если вы
наберете его, Emacs просто подаст звуковой сигнал.  Сходным образом
<CODE>local-unset-key</CODE> делает ключ неопределенным в таблице ключей
текущего основного режима, и в этом основном режиме вступает в действие
определение (или отсутствия определения) из глобальной таблицы ключей.


<P>
Если вы переопределили (или сделали неопределенным) какой-то ключ и
затем хотите отказаться от изменения, то отмена определения не будет
работать -- вам необходимо переопределить ключ, используя стандартное
определение.  Чтобы найти имя стандартного определения ключа, перейдите
в буфер с режимом Fundamental и примените <KBD>C-h c</KBD>.  Описания ключей
в данном руководстве также сообщают имена соответсвующих команд.


<P>
Если вы хотите обезопасить себя от ошибочного вызова команды, то лучше
блокировать команду, а не отменять определение ключа.  Блокированную
команду проще вызвать, когда вы на самом деле захотите этого.
See section <A HREF="emacs_36.html#SEC467">Блокирование команд</A>.




<H3><A NAME="SEC462" HREF="emacs_toc.html#TOC462">Перепривязка ключей в файле инициализации</A></H3>

<P>
<A NAME="IDX2661"></A>
<A NAME="IDX2662"></A>
Если у вас есть набор привязок ключей, которые вы хотите использовать
всегда, вы можете указать их в вашем файле <TT>`.emacs'</TT>, используя
синтаксис Лиспа.


<P>
Простейший способ работает только со знаками ASCII и их Meta-вариантами.
Этот метод использует для представления перепривязываемой
последовательности ключей строку.  Например, как привязать <KBD>C-z</KBD> к
команде <CODE>shell</CODE>:



<PRE>
(global-set-key "\C-z" 'shell)
</PRE>

<P>
Этот пример использует строковую константу, содержащую один знак,
<KBD>C-z</KBD>.  Одинарная кавычка перед именем команды, <CODE>shell</CODE>,
отмечает ее как константный символ, а не как переменную.  Если вы
опустите кавычку, Emacs попытается сразу вычислить <CODE>shell</CODE> как
переменную.  Это вероятно вызовет ошибку; это явно не то, что вы хотите.


<P>
Вот другой пример, который привязывает последовательность ключей из двух
знаков:



<PRE>
(global-set-key "\C-xl" 'make-symbolic-link)
</PRE>

<P>
Когда последовательность ключей включает в себя функциональные клавиши,
или события от кнопок мыши или не входящие в ASCII знаки, такие как
<CODE>C-=</CODE> или <CODE>H-a</CODE>, вы должны использовать более общий метод
перепривязки, в котором для указания последовательности ключей
используется вектор.


<P>
Для того чтобы записать вектор в Emacs Lisp, необходимо заключить
элементы вектора в квадратные скобки.  Для разделения элементов
используйте пробелы.  Если элемент является символом, то просто напишите
имя символа -- никаких других разделителей или пунктуации не нужно.
Если элемент вектора является знаком, то пишите его как знаковую
константу Лиспа: <SAMP>`?'</SAMP>, за которым следует сам знак в том виде, как
он появился бы в строке.


<P>
Вот примеры использования векторов для перепривязки <KBD>C-=</KBD>
(управляющий знак, не входящий в ASCII), <KBD>H-a</KBD> (Hyper-знак; в ASCII
вообще нет Hyper); <KBD>F7</KBD> (функциональная клавиша) и <KBD>C-Mouse-1</KBD>
(модифицированная с клавиатуры кнопка мыши):



<PRE>
(global-set-key [?\C-=] 'make-symbolic-link)
(global-set-key [?\H-a] 'make-symbolic-link)
(global-set-key [f7] 'make-symbolic-link)
(global-set-key [C-mouse-1] 'make-symbolic-link)
</PRE>

<P>
Вы также можете использовать вектор и для простых случаев.  Вот как
можно переписать первые два примера, приведенные выше, с использованием
векторов:



<PRE>
(global-set-key [?\C-z] 'shell)

(global-set-key [?\C-x ?l] 'make-symbolic-link)
</PRE>



<H3><A NAME="SEC463" HREF="emacs_toc.html#TOC463">Перепривязка функциональных клавиш</A></H3>

<P>
Последовательности ключей могут содержать функциональные клавиши, как и
обычные знаки.  Так же, как лисповские знаки (на самом деле целые числа)
представляют знаки клавиатуры, лисповские символы представляют
функциональные клавиши.  Если на функциональной клавиша надписано слово,
то это слово также будет именем соответствующего лисповского символа.
Здесь приводятся лисповские имена для часто встречающихся функциональных
клавиш:


<DL COMPACT>

<DT><CODE>left</CODE>, <CODE>up</CODE>, <CODE>right</CODE>, <CODE>down</CODE>
<DD>
Курсорные стрелки.

<DT><CODE>begin</CODE>, <CODE>end</CODE>, <CODE>home</CODE>, <CODE>next</CODE>, <CODE>prior</CODE>
<DD>
Другие клавиши перемещения курсора.

<DT><CODE>select</CODE>, <CODE>print</CODE>, <CODE>execute</CODE>, <CODE>backtab</CODE>
<DD>
<DT><CODE>insert</CODE>, <CODE>undo</CODE>, <CODE>redo</CODE>, <CODE>clearline</CODE>
<DD>
<DT><CODE>insertline</CODE>, <CODE>deleteline</CODE>, <CODE>insertchar</CODE>, <CODE>deletechar</CODE>,
<DD>
Различные функциональные клавиши.

<DT><CODE>f1</CODE>, <CODE>f2</CODE>, ... <CODE>f35</CODE>
<DD>
Нумерованные функциональные клавиши (расположенные сверху клавиатуры).

<DT><CODE>kp-add</CODE>, <CODE>kp-subtract</CODE>, <CODE>kp-multiply</CODE>, <CODE>kp-divide</CODE>
<DD>
<DT><CODE>kp-backtab</CODE>, <CODE>kp-space</CODE>, <CODE>kp-tab</CODE>, <CODE>kp-enter</CODE>
<DD>
<DT><CODE>kp-separator</CODE>, <CODE>kp-decimal</CODE>, <CODE>kp-equal</CODE>
<DD>
Клавиши дополнительной клавиатуры (справа от основной клавиатуры), с
именами или знаками пунктуации.

<DT><CODE>kp-0</CODE>, <CODE>kp-1</CODE>, ... <CODE>kp-9</CODE>
<DD>
Клавиши дополнительной клавиатуры с цифрами.

<DT><CODE>kp-f1</CODE>, <CODE>kp-f2</CODE>, <CODE>kp-f3</CODE>, <CODE>kp-f4</CODE>
<DD>
Функциональные клавиши дополнительной клавиатуры.
</DL>

<P>
Эти имена являются общепринятыми, но некоторые системы (особенно при
использовании X Windows) могут использовать другие имена.  Чтобы
убедиться, какой символ используется для определенной функциональной
клавиши на вашем терминале, наберите <KBD>C-h c</KBD> и затем нужную клавишу.


<P>
Последовательность ключей, которая содержит символы функциональных
клавиш (или что-то другое кроме ASCII-знаков), должны быть вектором, а
не строкой.  Синтаксис векторов использует пробел между элементами и
квадратные скобки вокруг всего вектора.  Таким образом, для привязки
функциональной клавиши <SAMP>`f1'</SAMP> к команде <CODE>rmail</CODE>, напишите
следующее:



<PRE>
(global-set-key [f1] 'rmail)
</PRE>

<P>
Для привязки клавиши с правой стрелкой к команде <CODE>forward-char</CODE>, вы
можете использовать такое выражение:



<PRE>
(global-set-key [right] 'forward-char)
</PRE>

<P>
Здесь используется лисповский синтаксис для вектора, содержащего символ
<CODE>right</CODE>.  (Эта привязка существует по умолчанию в Emacs).


<P>
See section <A HREF="emacs_36.html#SEC462">Перепривязка ключей в файле инициализации</A>, для дополнительной информации об
использовании векторов для перепривязки.


<P>
В последовательности ключей вы можете смешивать функциональные клавиши и
знаки.  Этот пример привязывает <KBD>C-x <KBD>NEXT</KBD></KBD> к команде
<CODE>forward-page</CODE>.



<PRE>
(global-set-key [?\C-x next] 'forward-page)
</PRE>

<P>
где <CODE>?\C-x</CODE> -- это знаковая константа Лиспа для знака <KBD>C-x</KBD>.
Элемент вектора <CODE>next</CODE> является лисповским символом, и поэтому к
нему не приписан вопросительный знак.


<P>
Вы можете использовать клавиши-модификаторы <KBD>CTRL</KBD>, <KBD>META</KBD>,
<KBD>HYPER</KBD>, <KBD>SUPER</KBD>, <KBD>ALT</KBD> и <KBD>SHIFT</KBD> вместе с
функциональными клавишами.  Для представления этих модификаторов
добавьте строки <SAMP>`C-'</SAMP>, <SAMP>`M-'</SAMP>, <SAMP>`H-'</SAMP>, <SAMP>`s-'</SAMP>, <SAMP>`A-'</SAMP> и
<SAMP>`S-'</SAMP> в начало имени символа.  Таким образом, чтобы
<KBD>Hyper-Meta-<KBD>RIGHT</KBD></KBD> перемещал вперед на слово, нужно сделать
так:



<PRE>
(global-set-key [H-M-right] 'forward-word)
</PRE>



<H3><A NAME="SEC464" HREF="emacs_toc.html#TOC464">Именованные управляющие ASCII-знаки</A></H3>

<P>
<KBD>TAB</KBD>, <KBD>RET</KBD>, <KBD>BS</KBD>, <KBD>LFD</KBD>, <KBD>ESC</KBD> и <KBD>DEL</KBD> начали
свою жизнь как имена определенных управляющих знаков ASCII,
использовавшихся так часто, что для них были сделаны специальные
клавиши.  Позднее, пользователи сочли удобным различать в Emacs эти
клавиши и "те же самые" управляющие знаки, набранными с помощью
клавиши <KBD>CTRL</KBD>.


<P>
Emacs различает эти два типа ввода, когда используется с X Window
System.  Он обрабатывает эти "особые" клавиши как функциональные с
именами <CODE>tab</CODE>, <CODE>return</CODE>, <CODE>backspace</CODE>, <CODE>linefeed</CODE>,
<CODE>escape</CODE> и <CODE>delete</CODE>.  Эти функциональные клавиши автоматически
транслируются в соответствующие ASCII-знаки, <EM>если</EM> у них нет
собственных привязок.  В результате ни пользователи, ни программы на
Лиспе не обязаны помнить об этом различии, если только им это не нужно.


<P>
Если вы не хотите различать (например) <KBD>TAB</KBD> и <KBD>C-i</KBD>, просто
сделайте одну привязку для ASCII-знака <KBD>TAB</KBD> (восьмиричный код 011).
Если вы действительно хотите различать их, то сделайте одну привязку для
этого ASCII-знака, а вторую для "функциональной клавиши" <CODE>tab</CODE>.


<P>
На обычных ASCII-терминалах нет способа различать <KBD>TAB</KBD> и <KBD>C-i</KBD>
(и аналогично для других таких пар), потому что терминал посылает один и
тот же знак в обоих случаях.




<H3><A NAME="SEC465" HREF="emacs_toc.html#TOC465">Не-ASCII-знаки на клавиатуре</A></H3>

<P>
Если на вашей клавиатуре есть клавиши, которые посылают знаки, не
входящие в ASCII, например акцентированные буквы, перепривязка их
делается несколько хитро.  Есть два решения.  Одно -- указать систему
кодирования для клавиатуры, используя <CODE>set-keyboard-coding-system</CODE>
(see section <A HREF="emacs_23.html#SEC207">Задание системы кодирования</A>).  Затем вы можете привязывать эти клавиши
обычным способом, но записывая



<PRE>
(global-set-key [?<VAR>знак</VAR>] 'какая-то-функция)
</PRE>

<P>
и подставляя <VAR>знак</VAR>, который вы хотите привязать


<P>
Если вы не указываете систему кодирования для клавиатуры, этот способ не
сработает.  Вместо этого вам нужно выяснить код, который в
действительности посылает терминал.  Простейший способ сделать это в
Emacs -- создать пустой буфер с помощью <KBD>C-x b temp <KBD>RET</KBD></KBD>,
сделать его однобайтным, набрав <KBD>M-x
toggle-enable-multibyte-characters <KBD>RET</KBD></KBD>, а затем нажать клавишу,
которая вставит в этот буфер нужный знак.


<P>
Расположите точку сразу перед этим знаком, затем наберите <KBD>C-x =</KBD>.
Это отобразит в минибуфере сообщение, показывающее восьмиричный,
шестнадцатиричный и десятичный код знака, все в круглых скобках.
Используйте второе из этих трех чисел, десятичное, внутри вектора для
привязки:



<PRE>
(global-set-key [<VAR>десятичный-код</VAR>] 'какая-то-функция)
</PRE>



<H3><A NAME="SEC466" HREF="emacs_toc.html#TOC466">Перепривязка кнопок мыши</A></H3>
<P>
<A NAME="IDX2663"></A>
<A NAME="IDX2664"></A>
<A NAME="IDX2665"></A>
<A NAME="IDX2666"></A>
<A NAME="IDX2667"></A>
<A NAME="IDX2668"></A>


<P>
Emacs использует лисповские символы и для обозначения кнопок мыши.
Обычными событиями от мыши в Emacs являются события-<EM>щелчки</EM>; это
случается, когда вы нажимаете и отпускаете кнопку без перемещения мыши.
Вы можете также получить событие-<EM>проведение</EM>, когда вы перемещаете
мышь, держа нажатой кнопку.  События-проведения в действительности
происходят, когда вы отпускаете кнопку мыши.


<P>
Символами для основных событий-щелчков являются <CODE>mouse-1</CODE> для левой
кнопки мыши, <CODE>mouse-2</CODE> для следующей кнопки и так далее.  Вот как
можно переопределить вторую кнопку мыши для разделения текущего окна:



<PRE>
(global-set-key [mouse-2] 'split-window-vertically)
</PRE>

<P>
Символы для события-проведения похожи на предыдущие, но имеют префикс
<SAMP>`drag-'</SAMP> перед словом <SAMP>`mouse'</SAMP>.  Например, проведение с помощью
первой кнопки генерирует событие <CODE>drag-mouse-1</CODE>.


<P>
Вы также можете определить привязки для событий, которые возникают в
момент нажатия на кнопку мыши.  Имена этих событий начинаются со слова
<SAMP>`down-'</SAMP> вместо <SAMP>`drag-'</SAMP>.  Такие события генерируются, только
если они имеют привязку.  Когда вы получите событие-нажатие, то за ним
всегда будут следовать соответствующее событие-щелчок или проведение.


<P>
<A NAME="IDX2669"></A>
<A NAME="IDX2670"></A>
Если хотите, вы можете различать одиночные, двойные и тройные щелчки.
Двойной щелчок означает щелканье кнопкой мыши дважды почти в одном и том
же месте.  Первый щелчок генерирует обычное событие-щелчок.  Второй
щелчок, если он приходит достаточно быстро, генерирует событие-двойной
щелчок.  Тип события для двойного щелчка начинается с <SAMP>`double-'</SAMP>:
например, <CODE>double-mouse-3</CODE>.


<P>
Это означает, что вы можете придать особый смысл второму щелчку в том же
самом месте, но он должен действовать в предположении, что обычное
определение одинарного щелчка уже обработалось, когда был получен первый
щелчок.


<P>
Это ограничивает ваши возможности по использованию двойных щелчков, но
дизайнеры пользовательских интерфейсов говорят, что этому ограничению
нужно следовать в любом случае.  Двойной щелчок должен делать что-то
подобное одиночному щелчку, только "чуть больше".  Команда для
события-двойного щелчка должна выполнять больше работы для двойного
щелчка.


<P>
Если для события двойного щелчка нет привязки, оно изменяется на
соответствующее событие одиночного щелчка.  Таким образом, если вы не
определите специально двойной щелчок, то будет дважды выполняться
команда для одиночного щелчка.


<P>
Emacs также поддерживает события-тройные щелчки, чьи имена начинаются с
<SAMP>`triple-'</SAMP>.  Emacs не различает четвертное нажатие как тип события;
щелчки свыше третьего генерируют дополнительные события-тройные щелчки.
Однако полное количество щелчков сохраняется в списке событий, так что
вы можете различать такие случаи, если вам это действительно нужно.  Мы
не рекомендуем особых значений для более чем трех щелчков, но иногда
полезно, чтобы последующие щелчки проходили по циклу того же набора трех
значений, так что четыре щелчка эквивалентны одному, пять эквивалентны
двум, а шесть -- трем.


<P>
Emacs также записывает множественные нажатия в событиях проведения и
нажатия.  Например, когда вы дважды нажмете кнопку, а затем переместите
мышь, держа кнопку нажатой, Emacs получит событие <SAMP>`double-drag-'</SAMP>.
А когда вы нажимаете на кнопку второй раз, Emacs получит событие
<SAMP>`double-down-'</SAMP> (которое игнорируется, подобно всем событиям
нажатия, если у них нет привязки).


<P>
<A NAME="IDX2671"></A>
Переменная <CODE>double-click-time</CODE> задает промежуток времени, который
может пройти между двумя щелчками, чтобы они считались парой.  Ее
значение измеряется в миллисекундах.  Если значение равно <CODE>nil</CODE>, то
двойной щелчок не распознается совсем.  Если значение равно <CODE>t</CODE>, то
нет никакого временного ограничения.


<P>
Символы для событий мыши также показывают статус клавиш-модификаторов, с
обычными префиксами <SAMP>`C-'</SAMP>, <SAMP>`M-'</SAMP>, <SAMP>`H-'</SAMP>, <SAMP>`s-'</SAMP>,
<SAMP>`A-'</SAMP> и <SAMP>`S-'</SAMP>.  Они всегда стоят перед <SAMP>`double-'</SAMP> или
<SAMP>`triple-'</SAMP>, которые всегда предшествуют <SAMP>`drag-'</SAMP> или
<SAMP>`down-'</SAMP>.


<P>
Фрейм включает области, которые не отображают текст буфера, такие как
строка режима и линейка прокрутки.  Вы можете судить о том, что кнопка
мыши нажата на специальной области экрана, посредством префиксных
псевдо-ключей.  Например, если вы щелкнете мышью в строке режима, то вы
получите префиксный ключ <CODE>mode-line</CODE> перед обычным символом,
обозначающем кнопку мыши.  Вот как определить щелчок первой кнопкой на
строке режима для запуска <CODE>scroll-up</CODE>:



<PRE>
(global-set-key [mode-line mouse-1] 'scroll-up)
</PRE>

<P>
Вот полный список таких префиксных псевдо-ключей и их значений:


<DL COMPACT>

<DT><CODE>mode-line</CODE>
<DD>
Мышь находилась на строке режима окна.
<DT><CODE>vertical-line</CODE>
<DD>
Мышь находилась на вертикальной линии, разделяющей окна.  (Если вы
используете полоски прокрутки, они появляются вместо этих вертикальных
линий).
<DT><CODE>vertical-scroll-bar</CODE>
<DD>
Мышь находилась на вертикальной полоске прокрутки.  (Пока это
единственная разновидность полосок прокрутки, которые поддерживает
Emacs).
</DL>

<P>
Вы можете поместить в последовательность ключей больше одного события от
кнопок мыши, но обычно так не далают.




<H3><A NAME="SEC467" HREF="emacs_toc.html#TOC467">Блокирование команд</A></H3>
<P>
<A NAME="IDX2672"></A>


<P>
Блокирование помечает команду как требующую подтверждения до того, как
она будет выполнена.  Цель блокирования состоит в том, чтобы зщитить
начинающих пользователей от случайного выполнения команд, которые могли
бы их запутать.


<P>
Попытка интерактивного вызова блокированной команды в Emacs отображает
окно, содержащее имя команды, ее описание и некоторые рекомендации о
том, что надо сделать немедленно; затем Emacs спросит у вас ввод,
указывающий, нужно ли выполнять эту команду, как запрошено,
разблокировать ее или отменить запрос.  Если вы решите разблокировать
команду, то вас спросят, выполнить ли это постоянно или только для
текущего сеанса.  Постоянное разблокирование производится путем
автоматического редактирования вашего файла <TT>`.emacs'</TT>.


<P>
Прямой механизм блокирования команды -- помещение отличного от
<CODE>nil</CODE> свойства <CODE>disabled</CODE> в лисповский символ для данной
команды.  Вот программа на Лиспе, которая делает это:



<PRE>
(put 'delete-region 'disabled t)
</PRE>

<P>
Если значение свойства <CODE>disabled</CODE> является строкой, то эта строка
включается в сообщение, выводимое при использовании этой команды:



<PRE>
(put 'delete-region 'disabled
     "It's better to use `kill-region' instead.\n")
</PRE>

<P>
<A NAME="IDX2673"></A>
<A NAME="IDX2674"></A>
Вы можете блокировать команду либо непосредстенным редактированием файла
<TT>`.emacs'</TT>, либо с помощью команды <KBD>M-x disable-command</KBD>, которая
радактирует файл <TT>`.emacs'</TT> за вас.  Подобным образом команда
<KBD>M-x enable-command</KBD> изменяет <TT>`.emacs'</TT> для постоянного
разрешения команды.  See section <A HREF="emacs_36.html#SEC470">Файл инициализации, <TT>`~/.emacs'</TT></A>.


<P>
Блокирование команды не зависит от того, какой ключ используется для ее
запуска; блокирование также действует, если команда вызывается через
<KBD>M-x</KBD>.  Блокирование не имеет эффекта при вызове команды как функции
из программ на Лиспе.




<H2><A NAME="SEC468" HREF="emacs_toc.html#TOC468">Перевод клавиатуры</A></H2>

<P>
Некоторые клавиатуры не позволяют удобно посылать все специальные знаки,
которые использует Emacs.  Наиболее общим случаем этой проблемы является
знак <KBD>DEL</KBD>.  Некоторые клавиатуры не обеспечивают удобного способа
для набора этого очень важного знака -- обычно потому что они
спроектированы в предположении, что для удаления будет использоваться
знак <KBD>C-h</KBD>.  На таких клавиатурах, если вы нажмете клавишу, обычно
используемую для удаления, то Emacs обработает <KBD>C-h</KBD> как префиксный
ключ и предложит вам список параметров, а это не то, что вам нужно.


<P>
<A NAME="IDX2675"></A>
<A NAME="IDX2676"></A>
<A NAME="IDX2677"></A>
Вы можете обойти эту проблему внутри Emacs, подготовив перевод
клавиатуры для превращения <KBD>C-h</KBD> в <KBD>DEL</KBD> и <KBD>DEL</KBD> в
<KBD>C-h</KBD>, как показано:



<PRE>
;; Переводит <KBD>C-h</KBD> в <KBD>DEL</KBD>.
(keyboard-translate ?\C-h ?\C-?)

;; Переводит <KBD>DEL</KBD> в <KBD>C-h</KBD>.
(keyboard-translate ?\C-? ?\C-h)
</PRE>

<P>
Перевод клавиатуры -- это не то же самое, что и привязка ключей в
таблицах ключей (see section <A HREF="emacs_36.html#SEC457">Таблицы ключей</A>).  Emacs содержит многочисленные
таблицы ключей, которые применяются в разных ситуациях, но только один
набор переводов клавиш, и он применяется к каждому знаку, который Emacs
считывает с терминала.  Перевод клавиатуры происходят на низшем уровне
обработки ввода; ключи, поиск которых происходит в таблицах ключей,
содержат знаки, появляющиеся после перевода клавиатуры.


<P>
При работе в X, клавиша с именем <KBD>DELETE</KBD> является функциональной
клавишей, и она отличается от ASCII-знака с именем <KBD>DEL</KBD>.
See section <A HREF="emacs_36.html#SEC464">Именованные управляющие ASCII-знаки</A>.  Перевод клавиатуры затрагивает только
ввод ASCII-знаков, но не функциональных клавиш; таким образом, пример
выше, примененный под X, не влияет на клавишу <KBD>DELETE</KBD>.  Однако
такой перевод не является необходимым под X, потому что Emacs может
также различать клавишу <KBD>BACKSPACE</KBD> и <KBD>C-h</KBD>; и обычно он
рассматривает <KBD>BACKSPACE</KBD> как <KBD>DEL</KBD>.


<P>
Для более полной информации об использовании перевода клавиатуры
смотрите @ref{Translating Input,,,@external{elisp}, The Emacs Lisp
Reference Manual}.




<H2><A NAME="SEC469" HREF="emacs_toc.html#TOC469">Синтаксическая таблица</A></H2>
<P>
<A NAME="IDX2678"></A>


<P>
  Все команды Emacs, которые разбирают слова или балансируют скобки,
управляются <EM>синтаксической таблицей</EM>.  Синтаксическая таблица
говорит, какие знаки являются открывающими ограничителями, частями слов,
кавычками строковых констант и так далее.  У каждого основного режима
есть своя синтаксическая таблица (хотя родственные основные режимы часто
разделяют одну), которая устанавливается в любом буфере, использующем
этот режим.  Все команды применяют синтаксическую таблицу, установленную
в текущем буфере; именно ее мы имеем в виду, когда мы говорим просто
"синтаксическая таблица".  Синтаксическая таблица -- это лисповский
объект, таблица знаков, чьими элементами являются числа.


<P>
<A NAME="IDX2679"></A>
<A NAME="IDX2680"></A>
  Чтобы вывести на экран описание содержимого текущей синтаксической
таблицы, наберите <KBD>C-h s</KBD> (<CODE>describe-syntax</CODE>).  Описание
каждого знака включает строку, которую вы передали бы
<CODE>modify-syntax-entry</CODE> для установки текущего синтаксиса, и
небольшое объяснение этой строки на английском, если необходимо.


<P>
  Для получения полной информации о синтаксических таблицах смотрите
@ref{Syntax Tables,, Syntax Tables, @external{elisp}, The Emacs Lisp
Reference Manual}.




<H2><A NAME="SEC470" HREF="emacs_toc.html#TOC470">Файл инициализации, <TT>`~/.emacs'</TT></A></H2>
<P>
<A NAME="IDX2681"></A>
<A NAME="IDX2682"></A>
<A NAME="IDX2683"></A>
<A NAME="IDX2684"></A>


<P>
  Когда Emacs запускается, он обычно загружет Лисп-программу из файла
<TT>`.emacs'</TT> в вашем начальном каталоге.  Мы называем этот файл вашим
<EM>файлом инициализации</EM>, поскольку он указывает, как инициализировать
Emacs для вас.  Вы можете использовать ключи командной строки
@option{-q}, чтобы предотвратить загрузку файла инициализации, и
@option{-u} (или @option{--user}), чтобы указать файл инициализации
другого пользователя (see section <A HREF="emacs_8.html#SEC22">Вход и выход из Emacs</A>).


<P>
  Также может быть <EM>файл инициализации по умолчанию</EM>, это библиотека
с именем <TT>`default.el'</TT>, находимая по стандартному пути поиска для
библиотек.  В дистрибутиве Emacs нет такой библиотеки; она может быть
создана на вашей системе для локальных настроек.  Если эта библиотека
существует, она загружается при запуске Emacs (только если вы не задали
@option{-q}).  Но ваш файл инициализации, если он существует,
загружается первым; если он устанавливает <CODE>inhibit-default-init</CODE> в
отличное от <CODE>nil</CODE> значение, то <TT>`default'</TT> не загружается.


<P>
  На вашей системе также может быть <EM>системный файл запуска</EM>; он
называется <TT>`site-start.el'</TT>, если существует.  Emacs загружает эту
библиотеку до вашего файла инициализации.  Чтобы подавить загрузку этой
библиотеки, используйте ключ @option{-no-site-file}.


<P>
  Если ваш файл <TT>`.emacs'</TT> содержит большой объем кода, вам стоит
переместить его в другой файл, как <TT>`~/<VAR>что-нибудь</VAR>.el'</TT>,
скомпилировать его и сделать так, чтобы ваш файл <TT>`.emacs'</TT> загружал
его через <CODE>(load "~/<VAR>что-нибудь</VAR>")</CODE>.  @xref{Byte Compilation,, Byte Compilation, @external{elisp}, the Emacs Lisp Reference Manual},
для получения большей информации о компилировании программ на Emacs
Lisp.


<P>
  Если вы собираетесь писать настоящие программы на Emacs Lisp, которые
идут дальше простой настройки, вам нужно прочитать книгу <CITE>Emacs
Lisp Reference Manual</CITE>.




<H3><A NAME="SEC471" HREF="emacs_toc.html#TOC471">Синтаксис файла инициализации</A></H3>

<P>
  Файл <TT>`.emacs'</TT> содержит одно или несколько лисповских выражений
вызовов функций. Каждое из них состоит из имени функции, за которым
следуют аргументы, вс╠ в окружении круглых скобок.  Например,
<CODE>(setq fill-column 60)</CODE> вызывает функцию <CODE>setq</CODE> для установки
переменной <CODE>fill-column</CODE> (see section <A HREF="emacs_26.html#SEC222">Заполнение текста</A>) в значение 60.


<P>
  Второй аргумент <CODE>setq</CODE> -- это выражение для нового значения
переменной.  Это может быть константа, переменная или вызов функции.  В
файле <TT>`.emacs'</TT> чаще всего используются константы.  Это могут быть:


<DL COMPACT>

<DT>Числа:
<DD>
Числа записываются в десятичной форме, с необязательным знаком минус в
начале.

<DT>Строки:
<DD>
<A NAME="IDX2685"></A>
<A NAME="IDX2686"></A>
Синтаксис лисповских строк такой же, как в Си, но с некоторыми
дополнительными чертами.  Для начала и завершения строковой константы
используйте знак двойных кавычек.

В строковых константах вы можете писать переводы строк и специальные
знаки буквально.  Но часто для ясности лучше использовать для них
последовательности с обратной косой чертой: <SAMP>`\n'</SAMP> для перевода
строки, <SAMP>`\b'</SAMP> для возврата на одну позицию, <SAMP>`\r'</SAMP> для возврата
каретки, <SAMP>`\t'</SAMP> для табуляции, <SAMP>`\f'</SAMP> для прогона страницы
(control-L), <SAMP>`\e'</SAMP> для escape, <SAMP>`\\'</SAMP> для обратной косой черты,
<SAMP>`\"'</SAMP> для двойных кавычек или <SAMP>`\<VAR>ooo</VAR>'</SAMP> для знака с
восьмиричным кодом <VAR>ooo</VAR>.  Обратная косая черта и двойные кавычки
--- это единственные знаки, для которых такие последовательности
обязательны.

<SAMP>`\C-'</SAMP> можно использовать как префикс для управляющего знака, как
<SAMP>`\C-s'</SAMP> для ASCII control-S, а <SAMP>`\M-'</SAMP> можно применять в качестве
префикса для Meta-знака, как <SAMP>`\M-a'</SAMP> для <KBD>Meta-A</KBD> или
<SAMP>`\M-\C-a'</SAMP> для <KBD>Control-Meta-A</KBD>.

<DT>Знаки:
<DD>
Синтаксис лисповских знаковых констант состоит из <SAMP>`?'</SAMP>, за которым
идет либо знак, либо последовательность, начинающаяся с <SAMP>`\'</SAMP>.
Примеры: <CODE>?x</CODE>, <CODE>?\n</CODE>, <CODE>?\"</CODE>, <CODE>?\)</CODE>.  Заметьте, что
строки и знаки не взаимозаменимы в Лиспе; в некоторых контекстах
требуется одно, в некоторых другое.

<DT>Истина:
<DD>
<CODE>t</CODE> обозначает `истину'.

<DT>Ложь:
<DD>
<CODE>nil</CODE> обозначает `ложь'.

<DT>Другие лисповские объекты:
<DD>
Пишите одиночную кавычку (') и за ней желаемый лисповский объект.
</DL>



<H3><A NAME="SEC472" HREF="emacs_toc.html#TOC472">Примеры файла инициализации</A></H3>

<P>
  Вот несколько примеров выполнения часто нужных вещей с помощью
лисповских выражений:



<UL>
<LI>

Сделать так, чтобы <KBD>TAB</KBD> в режиме C просто вставлял табуляцию, если
точка находится в середине строки.


<PRE>
(setq c-tab-always-indent nil)
</PRE>

Здесь мы имеем переменную, чье значение обычно равно <CODE>t</CODE>, то есть
`истина', а альтернатива ему -- <CODE>nil</CODE>, `ложь'.

<LI>

Сделать так, чтобы поиск производился с учетом регистра (во всех
буферах, которые не перекрывают это).


<PRE>
(setq-default case-fold-search nil)
</PRE>

Это устанавливает значение по умолчанию, оно распространяется на все
буферы, в которых нет локальных значений для этой переменной.  Установка
<CODE>case-fold-search</CODE> с помощью <CODE>setq</CODE> затрагивает только
локальное значение текущего буфера, а это не то, что вы, скорее всего,
хотите сделать в файле инициализации.

<LI>

<A NAME="IDX2687"></A>
Указать ваш адрес электронной почты, если Emacs не может правильно
выяснить его сам.


<PRE>
(setq user-mail-address "coon@yoyodyne.com")
</PRE>

Различные пакеты Emacs, которым нужно знать ваш адрес, используют
значение <CODE>user-mail-address</CODE>.

<LI>

Сделать режим Text режимом для новых буферов по умолчанию.


<PRE>
(setq default-major-mode 'text-mode)
</PRE>

Заметьте, что используется <CODE>text-mode</CODE>, поскольку это команда для
входа в режим Text.  Одиночная кавычка перед ним делает этот символ
константой; иначе <CODE>text-mode</CODE> рассматривался бы как имя переменной.

<LI>

Подготовить установки по умолчанию для набора знаков Latin-1, который
поддерживает большинство западноевропейских языков.


<PRE>
(set-language-environment "Latin-1")
</PRE>

<LI>

Включать режим Auto Fill автоматически в режиме Text и родственных с
ним.


<PRE>
(add-hook 'text-mode-hook
  '(lambda () (auto-fill-mode 1)))
</PRE>

Это показывает, как добавить функцию-ловушку к переменной-ловушке
(see section <A HREF="emacs_36.html#SEC449">Ловушки</A>).  Функция, которую мы предоставляем -- это список,
начинающийся с <CODE>lambda</CODE>, с одиночной кавычкой в начале, чтобы
сделать этот список константой, а не выражением.

Объяснение функций Лиспа выходит за рамки данного руководства, но для
этого примера достаточно знать, что действием будет вычисление
<CODE>(auto-fill-mode 1)</CODE>, когда вы входите в режим Text.  При желании
вы можете заменить это на другое выражение или на несколько выражений
подряд.

Emacs поставляется с функцией с именем <CODE>turn-on-auto-fill</CODE>, чье
определение -- это <CODE>(lambda () (auto-fill-mode 1))</CODE>.  Таким
образом, более простой способ написать приведенное выше выражение
выглядит так:


<PRE>
(add-hook 'text-mode-hook 'turn-on-auto-fill)
</PRE>

<LI>

Загрузить установленную лисповскую библиотеку с именем <TT>`foo'</TT> (на
самом деле файл <TT>`foo.elc'</TT> или <TT>`foo.el'</TT> из стандартного
каталога Emacs).


<PRE>
(load "foo")
</PRE>

Когда аргументом <CODE>load</CODE> является относительное имя файла, не
начинающееся с <SAMP>`/'</SAMP> или <SAMP>`~'</SAMP>, <CODE>load</CODE> просматривает каталоги
из <CODE>load-path</CODE> (see section <A HREF="emacs_28.html#SEC322">Библиотеки Лисп-программ для Emacs</A>).

<LI>

Загрузить скомпилированный Лисп-файл <TT>`foo.elc'</TT> из вашего начального
каталога.


<PRE>
(load "~/foo.elc")
</PRE>

Здесь использовано абсолютное имя файла, поэтому поиск не производится.

<LI>

Перепривязать ключ <KBD>C-x l</KBD> на запуск функции
<CODE>make-symbolic-link</CODE>.


<PRE>
(global-set-key "\C-xl" 'make-symbolic-link)
</PRE>

или


<PRE>
(define-key global-map "\C-xl" 'make-symbolic-link)
</PRE>

Еще раз обратите внимание, одиночная кавычка используется для ссылки на
символ <CODE>make-symbolic-link</CODE>, а не на его значение как переменной.

<LI>

Сделать то же самое, только для режима Lisp.


<PRE>
(define-key lisp-mode-map "\C-xl" 'make-symbolic-link)
</PRE>

<LI>

Переопределить все ключи, которые сейчас запускают <CODE>next-line</CODE> в
режиме Fundamental, чтобы они вместо этого запускали
<CODE>forward-line</CODE>.


<PRE>
(substitute-key-definition 'next-line 'forward-line
                           global-map)
</PRE>

<LI>

Сделать <KBD>C-x C-v</KBD> неопределенным.


<PRE>
(global-unset-key "\C-x\C-v")
</PRE>

Одна из причин для удаления определения ключа состоит в том, чтобы вы
могли сделать его префиксом.  Просто определение <KBD>C-x C-v
<VAR>что-угодно</VAR></KBD> сделает <KBD>C-x C-v</KBD> префиксом, но сначала нужно
лишить <KBD>C-x C-v</KBD> его обычного непрефиксного определения.

<LI>

Присвоить <SAMP>`$'</SAMP> синтаксическую категорию пунктуации в режиме Text.
Обратите внимание на использование знаковой константы для <SAMP>`$'</SAMP>.


<PRE>
(modify-syntax-entry ?\$ "." text-mode-syntax-table)
</PRE>

<LI>

Разрешить использование команды <CODE>narrow-to-region</CODE> без
подтверждения.


<PRE>
(put 'narrow-to-region 'disabled nil)
</PRE>

</UL>



<H3><A NAME="SEC473" HREF="emacs_toc.html#TOC473">Инициализация терминала</A></H3>

<P>
  Для каждого типа терминала может быть библиотека, загружаемая в Emacs,
когда он запускается на этом типе терминала.  Для типа терминала с
именем <VAR>тип-терм</VAR> эта библиотека называется
<TT>`term/<VAR>тип-терм</VAR>'</TT>, и она находится, как обычно, путем поиска в
каталогах <CODE>load-path</CODE>, при этом пробуются окончания <SAMP>`.elc'</SAMP> и
<SAMP>`.el'</SAMP>.  Обычно она появляется в подкаталоге <TT>`term'</TT> из
каталога, где хранится большинство библиотек Emacs.


<P>
  Обычное назначение специфичной для терминала библиотеки ---
отображение escape-последовательностей, используемых функциональными
клавишами терминала, в более осмысленные имена с помощью функции
<CODE>function-key-map</CODE>.  Пример того, как это делается, смотрите в
файле <TT>`term/lk201.el'</TT>.  Многие функциональные клавиши отображаются
автоматически в соответсвтии с базой данных Termcap; в специфичной для
терминала библиотеке нужно описать только те функциональные клавиши,
которые на указаны в Termcap.


<P>
  Когда тип терминала содержит дефис, при выборе имени библиотеки имеет
значение только часть перед первым дефисом.  Таким образом, типы
терминалов <SAMP>`aaa-48'</SAMP> и <SAMP>`aaa-30-rv'</SAMP> оба используют библиотеку
<TT>`term/aaa'</TT>.  Код библиотеки может применять <CODE>(getenv "TERM")</CODE>
для выяснения полного имени типа терминала.


<P>
<A NAME="IDX2688"></A>
  Имя библиотеки конструируется конкатенацией значения переменной
<CODE>term-file-prefix</CODE> и типа терминала.  Ваш файл <TT>`.emacs'</TT> может
предотвратить загрузку специфичной для терминала библиотеки,
устанавливая <CODE>term-file-prefix</CODE> равной <CODE>nil</CODE>.


<P>
<A NAME="IDX2689"></A>
  В конце инициализации, когда считаны и ваш файл <TT>`.emacs'</TT>, и любая
специфичная для терминала библиотека, Emacs запускает ловушку
<CODE>term-setup-hook</CODE>.  Добавьте к этой ловушке функции, если вы хотите
перекрыть часть специфичной для терминала библиотеки или определить
инициализацию для терминалов, к которым нет библиотеки.  See section <A HREF="emacs_36.html#SEC449">Ловушки</A>.




<H3><A NAME="SEC474" HREF="emacs_toc.html#TOC474">Как Emacs находит файл инициализации</A></H3>

<P>
  Обычно для поиска файла <TT>`.emacs'</TT> Emacs использует переменную
среды @env{HOME}; знак <SAMP>`~'</SAMP> в имени файла обозначает именно это.  Но
если вы сделали @command{su}, Emacs пытается найти ваш собственный
<TT>`.emacs'</TT>, а не того пользователя, за кого вы себя сейчас выдаете.
Идея в том, чтобы вы получали свои собственные настройки редактора, даже
если работаете как привелигированный пользователь.


<P>
  Более точно, Emacs сначала определяет, файл инициализации какого
пользователя нужно использовать.  Он получает имя пользователя из
переменных среды @env{LOGNAME} и @env{USER}; если ни одна из них не
существует, берется эффективный ID пользователя.  Если имя пользователя
соответствует реальному пользовательскому ID, то Emacs использует
@env{HOME}; иначе, он находит начальный каталог в системной базе данных
о пользователях.


<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_35.html">previous</A>, <A HREF="emacs_37.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
</BODY>
</HTML>
