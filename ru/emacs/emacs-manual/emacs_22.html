<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from emacs.texi on 29 October 2002 -->

<TITLE>Руководство по GNU Emacs - Фреймы и X Windows</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_21.html">previous</A>, <A HREF="emacs_23.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC176" HREF="emacs_toc.html#TOC176">Фреймы и X Windows</A></H1>
<P>
<A NAME="IDX763"></A>


<P>
@hyphenation{фрей-ме фрей-мы фрей-ма фрей-му фрей-мом}
  При использовании X Window System вы можете создавать в одном сеансе
Emacs несколько окон уровня оконной системы.  Каждое принадлежащее Emacs
X-окно показывает один <EM>фрейм</EM>, который может содержать одно или
несколько окон Emacs.  Изначально фрейм содержит одно окно Emacs общего
назначения, которое вы можете поделить вертикально или горизонтально на
меньшие.  Обычно фрейм имеет собственную эхо-область и минибуфер, но вы
можете сделать фреймы без них -- они будут использовать эхо-область и
минибуфер другого фрейма.


<P>
  Редактирование в одном фрейме затрагивает и другие фреймы.  К примеру,
если вы поместите текст в список уничтожений в одном фрейме, вы можете
восстановить его в другом.  Если вы выходите из Emacs через <KBD>C-x
C-c</KBD> в одном фрейме, это удалит все фреймы.  Чтобы удалить только один
фрейм, используйте <KBD>C-x 5 0</KBD>.


<P>
  Чтобы избежать путаницы, мы резервируем слово "окно" для тех окон,
которые реализует сам Emacs, и никогда не используем его для обозначения
фрейма.


<P>
  Emacs, скомпилированный для MS-DOS, эмулирует некоторые аспекты
оконной системы, так что вы сможете использовать многие возможности из
описанных в этой главе.  See section <A HREF="emacs_40.html#SEC514">Клавиатура и мышь в MS-DOS</A>, для дальнейшей информации.




<H2><A NAME="SEC177" HREF="emacs_toc.html#TOC177">Команды мыши для редактирования</A></H2>
<P>
<A NAME="IDX764"></A>


<P>
  Команды мыши для выделения и копирования области в основном совместимы
с командами программы @command{xterm}.  Вы можете пользоваться одними и
теми же командами мыши для обмена текстом между Emacs другими
X-клиентами.


<P>
<A NAME="IDX765"></A>
  Если вы выделите область с помощью любой из этих команд и сразу же
после этого нажмете функциональную клавишу <KBD>DELETE</KBD>, она удалит
выделенную область.  Функциональная клавиша <KBD>BACKSPACE</KBD> или
ASCII-знак <KBD>DEL</KBD> не делают этого; и если вы нажмете между командой
мыши и <KBD>DELETE</KBD> какую-то другую клавишу, <KBD>DELETE</KBD> не подействует
таким образом.


<P>
<A NAME="IDX766"></A>
<A NAME="IDX767"></A>
<A NAME="IDX768"></A>
<A NAME="IDX769"></A>
<A NAME="IDX770"></A>
<A NAME="IDX771"></A>
<A NAME="IDX772"></A>
<DL COMPACT>

<DT><KBD>Mouse-1</KBD>
<DD>
Перемещает точку туда, где вы щелкнули (<CODE>mouse-set-point</CODE>).  Обычно
это левая кнопка.

<DT><KBD>Drag-Mouse-1</KBD>
<DD>
Устанавливает область вокруг текста, по которому вы провели, и копирует
этот текст в список уничтожений (<CODE>mouse-set-region</CODE>).  С помощью
этой команды вы можете указать оба конца области.

<A NAME="IDX773"></A>
Если при проведении мышью вы переместите ее за верхний или нижний предел
окна, это окно непрерывно прокручивается, пока вы не вернете в него
мышь.  Таким способом вы можете выделять области, не умещающиеся на
экране.  Число прокручиваемых за один шаг строк зависит от того,
насколько далеко за край окна ушла мышь; минимальный размер шага
определяет переменная <CODE>mouse-scroll-min-lines</CODE>.

<DT><KBD>Mouse-2</KBD>
<DD>
Восстанавливает последний уничтоженный текст в том месте, где вы
щелкнули (<CODE>mouse-yank-at-click</CODE>).  Обычно это средняя кнопка.

<DT><KBD>Mouse-3</KBD>
<DD>
Эта команда, <CODE>mouse-save-then-kill</CODE>, имеет несколько назначений в
зависимости от того, где вы щелкнули, и от состояния области.

Самый основной случай -- это когда вы щелкаете <KBD>Mouse-1</KBD> в одном
месте, а затем <KBD>Mouse-3</KBD> в другом.  Это выделяет текст между двумя
этими позициями в качестве области.  Это также копирует новую область в
список уничтожений, чтобы вы могли скопировать его в другое место.

Если вы щелкните в тексте <KBD>Mouse-1</KBD>, прокрутите окно с помощью
полоски прокрутки и затем щелкните <KBD>Mouse-3</KBD>, Emacs запомнит, где
была точка перед прокруткой (где вы поместили ее с помощью
<KBD>Mouse-1</KBD>), и использует эту позицию как другой конец области.  Это
сделано, чтобы вы могли выделять области, которые не умещаются полностью
на экране.

В более общем виде, если у вас нет подсвеченной области, <KBD>Mouse-3</KBD>
выделяет в качестве области текст между точкой и местом щелчка.  Она
делает это, устанавливая метку там, где была точка, и перемещая точку к
той позиции, где вы щелкнули.

Если у вас есть подсвеченная область, или если область была установлена
непосредственно перед этим с помощью проведения кнопкой 1, <KBD>Mouse-3</KBD>
подстраивает ближайший конец области, перемещая его к месту щелчка.
Также, текст подстроенной области замещает в списке уничтожений текст
старой области.

Если вы изначально задали область, используя двойной или тройной щелчок
<KBD>Mouse-1</KBD>, чтобы определить область как состоящую из целых слов или
строк, то подстройка области с помощью <KBD>Mouse-3</KBD> также проходит по
целым словам или строкам.

Если вы примените <KBD>Mouse-3</KBD> два раз подряд на одном месте, вы
уничтожите уже выделенную область.

<DT><KBD>Double-Mouse-1</KBD>
<DD>
Этот ключ устанавливает область вокруг слова, на котором вы щелкнули.
Если вы щелкнули на знаке с синтаксической категорией "symbol"
(например, на подчерке в режиме C), он устанавливает область вокруг
символа, которому принадлежит этот знак.

Если вы щелкнули на знаке с синтаксической категорией открывающей или
закрывающей круглой скобки, область устанавливается вокруг группы
(s-выражения), которая завершается или начинается на этом знаке.  Если
вы щелкнули на знаке с синтаксической категорией разделителя строк
(таком как кавычка или двойные кавычки в Си), область будет установлена
вокруг этой строковой константы (с использованием эвристики, чтобы
выяснить, является ли этот знак начинающим или завершающим).

<DT><KBD>Double-Drag-Mouse-1</KBD>
<DD>
Этот ключ выделяет область, состоящую из слов, по которым вы провели.

<DT><KBD>Triple-Mouse-1</KBD>
<DD>
Этот ключ устанавливает область вокруг строки, на которой вы щелкнули.

<DT><KBD>Triple-Drag-Mouse-1</KBD>
<DD>
Этот ключ выделяет область, состоящую из строк, по которым вы провели.
</DL>

<P>
  Простейший способ уничтожить текст с помощью мыши -- нажать
<KBD>Mouse-1</KBD> в одном конце, а затем дважды нажать <KBD>Mouse-3</KBD> на
другом.  See section <A HREF="emacs_14.html#SEC63">Удаление и уничтожение</A>.  Чтобы скопировать текст в список
уничтожений, не удаляя его из буфера, нажмите <KBD>Mouse-3</KBD> только один
раз или просто проведите по этому тексту с прижатой <KBD>Mouse-1</KBD>.
Потом вы можете скопировать этот текст в другое место восстановлением.


<P>
<A NAME="IDX774"></A>
  Чтобы восстановить уничтоженный или скопированный текст в другое
место, переведите туда мышь и нажмите <KBD>Mouse-2</KBD>.
See section <A HREF="emacs_14.html#SEC67">Восстановление</A>.  Однако, если <CODE>mouse-yank-at-point</CODE> не равна
<CODE>nil</CODE>, <KBD>Mouse-2</KBD> восстанавливает в точке.  Тогда не имеет
значения, где вы щелкаете, или даже в каком из окон фрейма вы щелкаете.
Значение по умолчанию равно <CODE>nil</CODE>.  Эта переменная влияет также на
восстановление вторичного выделения.


<P>
<A NAME="IDX775"></A>
<A NAME="IDX776"></A>
<A NAME="IDX777"></A>
  Чтобы скопировать текст в другое X-окно, уничтожьте его или сохраните в
списке уничтожений.  Под X это кроме того установит <EM>первичное
выделение</EM>.  Затем используйте в программе, работающей в другом окне,
команду "вставить", чтобы вставить текст выделения.


<P>
  Чтобы скопировать текст из другого X-окна, используйте в программе,
работающей в другом окне, команды "вырезать" или "копировать", чтобы
выделить нужный вам текст.  Затем восстановите его в Emacs с помощью
<KBD>C-y</KBD> или <KBD>Mouse-2</KBD>.


<P>
  Эти команды вырезания и вставки работают также и в MS-Windows.


<P>
<A NAME="IDX778"></A>
<A NAME="IDX779"></A>
<A NAME="IDX780"></A>
<A NAME="IDX781"></A>
  Когда Emacs помещает текст в список уничтожений или перекладывает
текст на вершину списка уничтожений, он устанавливает <EM>первичное
выделение</EM> X-сервера.  Именно таким образом другие X-клиенты могут
получить доступ к этому тексту.  Emacs также сохраняет текст в буфере
вырезок, но только если этот текст достаточно короткий
(<CODE>x-cut-buffer-max</CODE> задает максимальное число знаков); помещение в
буфер вырезок длинных строк может быть медленным.


<P>
  Команды восстановления первого вхождения списка уничтожений на самом
деле сначала проверяют, нет ли первичного выделения из других программ;
после этого они проверяют, нет ли текста в буфере вырезок.  Если ни тот,
ни другой источник не предоставляют текста для восстановления,
используется содержимое списка уничтожений.




<H2><A NAME="SEC178" HREF="emacs_toc.html#TOC178">Вторичное выделение</A></H2>
<P>
<A NAME="IDX782"></A>


<P>
  <EM>Вторичное выделение</EM> -- это другой способ выделения текста с
использованием X Windows.  Оно не использует точку или метку, поэтому вы
можете использовать его для уничтожения текста без установки точки или
метки.


<DL COMPACT>

<DT><KBD>M-Drag-Mouse-1</KBD>
<DD>
<A NAME="IDX783"></A>
 <A NAME="IDX784"></A>
 
Устанавливает вторичное выделение с одним концом в том месте, где вы
нажали кнопку, и другим -- в том, где вы ее отпустили
(<CODE>mouse-set-secondary</CODE>).  Когда вы проводите мышью, появляется и
изменяется подсветка.

Если при проведении мышью вы сдвинете ее за верхний или нижний предел
окна, это окно непрерывно прокручивается, пока вы не вернете в него
мышь.  Таким способом вы можете выделять области, не умещающиеся на
экране.

<A NAME="IDX785"></A>
<A NAME="IDX786"></A>
<DT><KBD>M-Mouse-1</KBD>
<DD>
Устанавливает одну из граничных точек <EM>вторичного выделения</EM>
(<CODE>mouse-start-secondary</CODE>).

<A NAME="IDX787"></A>
<A NAME="IDX788"></A>
<DT><KBD>M-Mouse-3</KBD>
<DD>
Создает вторичное выделение, используя место, указанное с помощью
<KBD>M-Mouse-1</KBD> как его второй конец
(<CODE>mouse-secondary-save-then-kill</CODE>).  Второй щелчок на этом же месте
уничтожает только что сделанное вторичное выделение.

<A NAME="IDX789"></A>
<A NAME="IDX790"></A>
<DT><KBD>M-Mouse-2</KBD>
<DD>
Вставляет в месте щелчка вторичное выделение
(<CODE>mouse-yank-secondary</CODE>).  Это помещает точку в конец
восстановленного текста.
</DL>

<P>
Двойные и тройные щелчки <KBD>M-Mouse-1</KBD> действуют на слова и строки, во
многом как для <KBD>Mouse-1</KBD>.


<P>
Если <CODE>mouse-yank-at-point</CODE> не равна <CODE>nil</CODE>, <KBD>M-Mouse-2</KBD>
восстанавливает в точке.  Тогда не имеет значения, где вы щелкнули;
главное, в каком окне.  See section <A HREF="emacs_22.html#SEC177">Команды мыши для редактирования</A>.




<H2><A NAME="SEC179" HREF="emacs_toc.html#TOC179">Следование по ссылкам с помощью мыши</A></H2>
<P>
<A NAME="IDX791"></A>


<P>
  Некоторые буферы Emacs показывают различного рода перечни.  Это
перечни файлов, буферов, возможных завершений, совпадений с образцом и
так далее.


<P>
  Поскольку восстановление в этих буферах бессмысленно, в большинстве из
них <KBD>Mouse-2</KBD> определена особо, как команда для использования или
просмотра пункта, на котором вы щелкнули.


<P>
  Например, если вы щелкните <KBD>Mouse-2</KBD> на имени файла в буфере
Dired, вы обратитесь к этому файлу.  Если вы щелкните <KBD>Mouse-2</KBD> на
сообщении об ошибке в буфере <TT>`*Compilation*'</TT>, вы перейдете к
исходному коду для этого сообщения.  Если вы щелкните <KBD>Mouse-2</KBD> на
завершении в буфере <TT>`*Completions*'</TT>, вы выберете это завершение.


<P>
  Обычно вы можете судить о том, имеет ли <KBD>Mouse-2</KBD> особое значение,
по тому, что чувствительный текст подсвечивается, когда вы проводите над
ним мышь.




<H2><A NAME="SEC180" HREF="emacs_toc.html#TOC180">Щелчки мыши для меню</A></H2>

<P>
  Щелчки мыши, модифицированные с помощью клавиш <KBD>CTRL</KBD> и
<KBD>SHIFT</KBD>, выводят меню.


<P>
<A NAME="IDX792"></A>
<DL COMPACT>

<DT><KBD>C-Mouse-1</KBD>
<DD>
Это меню для выбора буфера.

<DT><KBD>C-Mouse-2</KBD>
<DD>
Это меню для задания начертаний и других свойств текста для
редактирования форматированного текста.  See section <A HREF="emacs_26.html#SEC239">Редактирование форматированного текста</A>.

<DT><KBD>C-Mouse-3</KBD>
<DD>
Это меню определяется режимом.  Для большинства режимов данное меню
имеет те же пункты, что содержатся во всех определяемых режимом меню из
полоски меню.  Некоторые режимы могут определять для этой кнопки другое
меню.<A NAME="DOCF4" HREF="emacs_foot.html#FOOT4">(4)</A>

<DT><KBD>S-mouse-1</KBD>
<DD>
Это меню для задания основного шрифта фрейма.
</DL>



<H2><A NAME="SEC181" HREF="emacs_toc.html#TOC181">Команды мыши для строки режима</A></H2>

<P>
  Вы можете использовать мышь на строке режима для выбора окон и
манипуляций с ними.


<DL COMPACT>

<DT><KBD>Mouse-1</KBD>
<DD>
<KBD>Mouse-1</KBD> на строке режима выбирает окно сверху.  Проводя мышью с
нажатой на строке режима <KBD>Mouse-1</KBD>, вы можете перемещать эту строку
режима, изменяя таким образом высоту окон сверху и снизу.

<DT><KBD>Mouse-2</KBD>
<DD>
<KBD>Mouse-2</KBD> на строке режима раскрывает окно на весь фрейм.

<DT><KBD>Mouse-3</KBD>
<DD>
<KBD>Mouse-3</KBD> на строке режима удаляет окно сверху.

<DT><KBD>C-Mouse-2</KBD>
<DD>
<KBD>C-Mouse-2</KBD> на строке режима разбивает окно сверху по вертикали в
том месте, где вы щелкнули.
</DL>

<P>
  <KBD>C-Mouse-2</KBD> на полоске прокрутки разбивает соответствующее окно по
горизонтали.  See section <A HREF="emacs_21.html#SEC171">Разделение окон</A>.




<H2><A NAME="SEC182" HREF="emacs_toc.html#TOC182">Создание фреймов</A></H2>
<P>
<A NAME="IDX793"></A>


<P>
<A NAME="IDX794"></A>
  Префиксный ключ <KBD>C-x 5</KBD> аналогичен <KBD>C-x 4</KBD>, и на них
определены параллельные подкоманды.  Разница между ними в том, что
команды с <KBD>C-x 5</KBD> создают новый фрейм, а не просто новое окно в
выбранном фрейме (see section <A HREF="emacs_21.html#SEC173">Изображение в другом окне</A>).  Если запрошенный материал
уже показывается в существующем видимом или минимизированном фрейме, эти
команды используют существующий фрейм после его поднимания или
деминимизации по необходимости.


<P>
  Команды на <KBD>C-x 5</KBD> различаются по тому, как они находят или
создают буфер для выбора:


<DL COMPACT>

<DT><KBD>C-x 5 2</KBD>
<DD>
<A NAME="IDX795"></A>
<A NAME="IDX796"></A>
Создает новый фрейм (<CODE>make-frame-command</CODE>).
<DT><KBD>C-x 5 b <VAR>имя-буфера</VAR> <KBD>RET</KBD></KBD>
<DD>
Выбирает буфер <VAR>имя-буфера</VAR> в другом фрейме.  Это запускает
<CODE>switch-to-buffer-other-frame</CODE>.
<DT><KBD>C-x 5 f <VAR>имя-файла</VAR> <KBD>RET</KBD></KBD>
<DD>
Обращается к файлу <VAR>имя-файла</VAR> и выбирает его буфер в другом фрейме.
Это запускает <CODE>find-file-other-frame</CODE>.  See section <A HREF="emacs_19.html#SEC110">Обращение к файлам</A>.
<DT><KBD>C-x 5 d <VAR>каталог</VAR> <KBD>RET</KBD></KBD>
<DD>
Выбирает буфер Dired для каталога <VAR>каталог</VAR> в другом фрейме.  Это
запускает <CODE>dired-other-frame</CODE>.  See section <A HREF="emacs_33.html#SEC371">Dired, редактор каталогов</A>.
<DT><KBD>C-x 5 m</KBD>
<DD>
Позволяет начать составление почтового сообщения в другом фрейме
(<CODE>mail-other-frame</CODE>).  Это вариант <KBD>C-x m</KBD>, работающий в другом
фрейме.  See section <A HREF="emacs_31.html#SEC339">Посылка почты</A>.
<DT><KBD>C-x 5 .</KBD>
<DD>
Обращается к тегу из текущей таблицы тегов в другом фрейме.  Это
запускает <CODE>find-tag-other-frame</CODE>, вариант <KBD>M-.</KBD>, работающий с
несколькими фреймами.  See section <A HREF="emacs_27.html#SEC276">Таблицы тегов</A>.
<DT><KBD>C-x 5 r <VAR>имя-файла</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX797"></A>
<A NAME="IDX798"></A>
Обращается к файлу <VAR>имя-файла</VAR> в режиме только для чтения и выбирает
его буфер в другом фрейме.  Это запускает
<CODE>find-file-read-only-other-frame</CODE>.  See section <A HREF="emacs_19.html#SEC110">Обращение к файлам</A>.
</DL>

<P>
<A NAME="IDX799"></A>
<A NAME="IDX800"></A>
  Вы можете управлять видом вновь создаваемых фреймов, устанавливая
параметры фрейма в <CODE>default-frame-alist</CODE>.  Для задания параметров,
относящихся только к начальному фрейму, вы можете использовать
переменную <CODE>initial-frame-alist</CODE>.  @xref{Initial Parameters,,, @external{elisp}, The Emacs Lisp Reference Manual}, для дальнейшей
информации.


<P>
<A NAME="IDX801"></A>
  Простейший способ указать основной шрифт для всех фреймов Emacs ---
через X-ресурс (see section <A HREF="emacs_38.html#SEC503">Ключи для задания шрифта</A>), но вы также можете сделать это,
изменив <CODE>default-frame-alist</CODE> так, чтобы в нем задавался параметр
<CODE>font</CODE>, как показано здесь:



<PRE>
(add-to-list 'default-frame-alist '(font . "10x20"))
</PRE>



<H2><A NAME="SEC183" HREF="emacs_toc.html#TOC183">Создание и использование фрейма Speedbar</A></H2>
<P>
<A NAME="IDX802"></A>


<P>
  Фрейм Emacs может иметь <EM>speedbar</EM>, то есть вертикальное окно,
служащее как меню с возможностью прокрутки для файлов, к которым вы
можете обратиться, и тегов внутри этих файлов.  Чтобы создать speedbar,
введите <KBD>M-x speedbar</KBD>; это создает окно speedbar для выбранного
фрейма.  После этого вы можете щелкнуть в speedbar на имени файла, чтобы
обратиться к нему в соответствующем фрейме Emacs, или щелкнуть на имени
тега, чтобы перескочить к нему соответствующем фрейме.


<P>
  Изначально speedbar перечисляет непосредственное содержание текущего
каталога по одному файлу на строке.  В каждой строке также есть кнопка,
<SAMP>`[+]'</SAMP> или <SAMP>`&#60;+&#62;'</SAMP>, на которой вы можете щелкнуть <KBD>Mouse-2</KBD>,
чтобы "открыть" содержимое данного элемента.  Если на этой строке
перечислен каталог, то при открытии к показанному в speedbar добавляется
содержание этого каталога под его собственной строкой.  Если на строке
перечислен обычный файл, при его открытии к содержимому speedbar
добавляется список тегов из этого файла.  Когда файл открывается,
<SAMP>`[+]'</SAMP> заменяется на <SAMP>`[-]'</SAMP>; вы можете щелкнуть на этой кнопке,
чтобы "закрыть" этот файл (скрыть его содержание).


<P>
  Некоторые основные режимы, включая режим Rmail, Info и GUD, имеют
специализированные способы поместить в speedbar другие полезные вещи.
Например, в режиме Rmail speedbar показывает перечень Rmail-файлов и
позволяет вам перенести текущее сообщение в другой Rmail-файл, щелкнув
на кнопке <SAMP>`&#60;M&#62;'</SAMP>.


<P>
  Speedbar принадлежит одному фрейму Emacs и всегда работает с этим
фреймом.  Если вы используете несколько фреймов, вы можете сделать
speedbar для некоторых или для всех из них; чтобы сделать speedbar для
любого данного фрейма, наберите в нем <KBD>M-x speedbar</KBD>.




<H2><A NAME="SEC184" HREF="emacs_toc.html#TOC184">Множество дисплеев</A></H2>
<P>
<A NAME="IDX803"></A>
<A NAME="IDX804"></A>


<P>
  Один Emacs может общаться более чем с одним дисплеем X Windows.
Изначально Emacs использует только один дисплей -- тот, что указан в
переменной среды @env{DISPLAY} или с помощью ключа @option{--display}
(see section <A HREF="emacs_38.html#SEC496">Ключи запуска</A>).  Чтобы подсоединиться к другому дисплею,
воспользуйтесь командой <CODE>make-frame-on-display</CODE>:


<P>
<A NAME="IDX805"></A>
<DL COMPACT>

<DT><KBD>M-x make-frame-on-display <KBD>RET</KBD> <VAR>дисплей</VAR> <KBD>RET</KBD></KBD>
<DD>
Создает новый фрейм на дисплее <VAR>дисплей</VAR>.
</DL>

<P>
  Один X-сервер может обрабатывать более одного экрана.  Когда вы
открываете фреймы на экранах, принадлежащих одному серверу, Emacs знает,
что они разделяют одну клавиатуру и воспринимает все команды, приходящие
с этих экранов, как один поток ввода.


<P>
  Когда вы открываете фреймы на разных X-серверах, Emacs создает для
каждого сервера отдельный поток ввода.  Поэтому два пользователя могут
одновременно печатать на двух дисплеях, и Emacs не смешивает их ввод.
Каждый сервер имеет также собственный выбранный фрейм.  Команды, которые
вы вводите на конкретном X-сервере, относятся к выбранному фрейму этого
сервера.


<P>
  Несмотря на это, люди, использующие одно и то же задание Emacs с
разных дисплеев, все же могут вмешиваться в дела друг друга, если будут
неосторожны.  Например, если любой их них напечатает <KBD>C-x C-c</KBD>, это
прекратит задание Emacs для всех!




<H2><A NAME="SEC185" HREF="emacs_toc.html#TOC185">Фреймы специальных буферов</A></H2>

<P>
<A NAME="IDX806"></A>
  Вы можете сделать так, чтобы определенные буферы, для которых Emacs
обычно создает второе окно, если у вас есть только одно, появлялись в
особых собственных фреймах.  Чтобы сделать это, установите переменную
<CODE>special-display-buffer-names</CODE> равной списку имен буферов; любой
буфер, чье имя содержится в этом списке, автоматически получает
специальный фрейм, когда какая-нибудь команда Emacs хочет показать его
"в другом окне".


<P>
  Например, если вы установите эту переменную таким образом:



<PRE>
(setq special-display-buffer-names
      '("*Completions*" "*grep*" "*tex-shell*"))
</PRE>

<P>
то списки завершений, вывод @command{grep} и буфер оболочки режима
TeX получат свои собственные фреймы.  Эти фреймы и окна в них никогда
не разбиваются автоматически и не используются для других буферов.  Они
продолжают показывать буферы, для которых были созданы, пока вы не
измените их вручную.  Уничтожение специального буфера автоматически
удаляет его фрейм.


<P>
<A NAME="IDX807"></A>
  В более общем случае вы можете установить
<CODE>special-display-regexps</CODE> равной списку регулярных выражений; тогда
буфер получает собственный фрейм, если его имя совпадает в любым из них.
(Еще раз, это относится только к буферам, которые обычно отображаются в
отдельном окне.)


<P>
<A NAME="IDX808"></A>
  Переменная <CODE>special-display-frame-alist</CODE> задает параметры для
этих фреймов.  У нее есть значение по умолчанию, поэтому вам
необязательно устанавливать ее.


<P>
  Те, кто знает Лисп, могут также сделать элемент
<CODE>special-display-buffer-names</CODE> или <CODE>special-display-regexps</CODE>
списком.  Тогда первый элемент -- это имя буфера или регулярное
выражение, а остальные указывают, как создавать фрейм.  Это может быть
ассоциативный список, задающий значения параметров фрейма; эти значения
имеют приоритет перед значениями параметров, указанных в
<CODE>special-display-frame-alist</CODE>.  Или же остальные элементы могут
иметь такую форму:



<PRE>
(<VAR>функция</VAR> <VAR>аргументы</VAR>...)
</PRE>

<P>
где <VAR>функция</VAR> -- это символ.  Тогда фрейм конструируется путем
вызова <VAR>функции</VAR>; ее первым аргументом является буфер, а остальными
аргументами -- <VAR>аргументы</VAR>.


<P>
   Аналогичными средствами вы можете указать буферы, которые должны
отображаться в выбранном окне.  See section <A HREF="emacs_21.html#SEC174">Принудительное изображение в том же окне</A>.
Показ в том же окне обладает приоритетом перед показом в специальном
фрейме; следовательно, если вы добавили имя буфера к
<CODE>special-display-buffer-names</CODE>, но это не возымело никакого
эффекта, проверьте, не используется ли для этого же имени буфера
средство показа в том же окне.




<H2><A NAME="SEC186" HREF="emacs_toc.html#TOC186">Установка параметров фрейма</A></H2>
<P>
<A NAME="IDX809"></A>
<A NAME="IDX810"></A>
<A NAME="IDX811"></A>


<P>
  Этот раздел описывает команды для изменения стиля отображения
выбранного фрейма и его поведения в оконной среде.


<P>
<A NAME="IDX812"></A>
<A NAME="IDX813"></A>
<A NAME="IDX814"></A>
<A NAME="IDX815"></A>
<A NAME="IDX816"></A>
<A NAME="IDX817"></A>
<A NAME="IDX818"></A>
<DL COMPACT>

<DT><KBD>M-x set-foreground-color <KBD>RET</KBD> <VAR>цвет</VAR> <KBD>RET</KBD></KBD>
<DD>
Задает <VAR>цвет</VAR> для текста в выбранном фрейме.

<DT><KBD>M-x set-background-color <KBD>RET</KBD> <VAR>цвет</VAR> <KBD>RET</KBD></KBD>
<DD>
Задает <VAR>цвет</VAR> для фона в выбранном фрейме.  Также изменяет цвет
текста в начертании <CODE>modeline</CODE>, чтобы оно оставалось инверсией
начертания по умолчанию.

<DT><KBD>M-x set-cursor-color <KBD>RET</KBD> <VAR>цвет</VAR> <KBD>RET</KBD></KBD>
<DD>
Задает <VAR>цвет</VAR> курсора в выбранном фрейме.

<DT><KBD>M-x set-mouse-color <KBD>RET</KBD> <VAR>цвет</VAR> <KBD>RET</KBD></KBD>
<DD>
Задает <VAR>цвет</VAR> указателя мыши, когда он находится над выбранным
фреймом.

<DT><KBD>M-x set-border-color <KBD>RET</KBD> <VAR>цвет</VAR> <KBD>RET</KBD></KBD>
<DD>
Задает <VAR>цвет</VAR> рамки выбранного фрейма.

<DT><KBD>M-x list-colors-display</KBD>
<DD>
Выводит определенные имена цветов и показывает, как эти цвета выглядят.
Это несколько медленная команда.

<DT><KBD>M-x auto-raise-mode</KBD>
<DD>
Переключает автоматическое поднятие выбранного фрейма.  Автоматическое
поднятие означает, что всякий раз, когда вы передвигаете мышь в этот
фрейм, он поднимается.

Обратите внимание, это средство автоматического поднятия реализовано
самим Emacs.  Некоторые программы управления окнами также реализуют
автоподнятие.  Если вы включите автоподнятие для фреймов Emacs в вашей
программе управления X-окнами, это будет работать, но не под контролем
Emacs, и следовательно, <CODE>auto-raise-mode</CODE> не будет играть роли.

<DT><KBD>M-x auto-lower-mode</KBD>
<DD>
Переключает автоматическое опускание выбранного фрейма.  Автоматическое
опускание означает, что всякий раз, когда вы передвигаете мышь за
пределы этого фрейма, он переносится вниз стека X-окон.

Команда <CODE>auto-lower-mode</CODE> не влияет на автоопускание, реализованное
программой управления X-окнами.  Чтобы контролировать это, вы должны
использовать соответствующие средства своей программы управления окнами.

<A NAME="IDX819"></A>
<DT><KBD>M-x set-frame-font <KBD>RET</KBD> <VAR>шрифт</VAR> <KBD>RET</KBD></KBD>
<DD>
<A NAME="IDX820"></A>
Определяет <VAR>шрифт</VAR> как основной шрифт в выбранном фрейме.  Основной
шрифт используется для всего отображаемого в этом фрейме текста, кроме
случаев, когда для какого-то текста с помощью начертания
(see section <A HREF="emacs_22.html#SEC189">Использование разных начертаний</A>) определен другой шрифт.  See section <A HREF="emacs_38.html#SEC503">Ключи для задания шрифта</A>, чтобы
узнать о способах перечисления доступных в вашей системе шрифтов.

<A NAME="IDX821"></A>
Вы также можете установить основной шрифт фрейма через всплывающее меню.
Чтобы вызвать это меню, нажмите <KBD>S-Mouse-1</KBD>.
</DL>

<P>
  В версиях Emacs, которые используют X toolkit, функции для установки
цвета и шрифтов не влияют на меню, так как меню отображаются со своими
собственными классами виджетов.  Чтобы сменить вид меню, вы должны
использовать X-ресурсы (see section <A HREF="emacs_38.html#SEC509">X-ресурсы</A>).  See section <A HREF="emacs_38.html#SEC504">Параметры для задания цветов</A>, сведения о
цветах, а также section <A HREF="emacs_38.html#SEC503">Ключи для задания шрифта</A>, касающийся вопросов о выборе шрифта.


<P>
  Для получения информации о параметрах и настройках фреймов смотрите
@ref{Frame Parameters,,, @external{elisp}, The Emacs Lisp Reference
Manual}.




<H2><A NAME="SEC187" HREF="emacs_toc.html#TOC187">Полоски прокрутки</A></H2>
<P>
<A NAME="IDX822"></A>
<A NAME="IDX823"></A>


<P>
  При использовании X, Emacs обычно создает <EM>полоски прокрутки</EM>
слева от каждого окна.  Полоска прокрутки проходит по всей высоте окна,
а внутри ее есть прямоугольник, представляющий показанную в данный
момент часть буфера.  Полная высота полоски прокрутки представляет всю
длину буфера.


<P>
  Вы можете использовать на полоске прокрутки <KBD>Mouse-2</KBD> (обычно это
средняя кнопка), чтобы передвинуть или перетащить внутренний
прямоугольник вверх или вниз.  Если вы переместите его к верху полоски
прокрутки, вы увидите начало буфера.  Если вы переместите его к низу
полоски прокрутки, то увидите конец буфера.


<P>
  Правая и левая кнопки мыши прокручивают на контролируемое число строк.
<KBD>Mouse-1</KBD> (обычно левая кнопка) перемещает строку, на уровне которой
вы щелкнули, к верхнему краю окна.  <KBD>Mouse-3</KBD> (обычно правая кнопка)
перемещает верхнюю строку окна вниз к тому уровню, где вы щелкнули.
Щелкая последовательно на одном месте, вы можете прокручивать на одно и
то же расстояние еще и еще.


<P>
  Помимо прокрутки, вы также можете щелкнуть на полоске прокрутки с
помощью <KBD>C-Mouse-2</KBD>, чтобы разбить окно по горизонтали.  Разбиение
делается в той строке, где вы щелкнули.


<P>
<A NAME="IDX824"></A>
  Вы можете включить или выключить режим Scroll Bar командой <KBD>M-x
scroll-bar-mode</KBD>.  Без аргумента, она переключает использование полосок
прокрутки.  С аргументом, она включает использование полосок прокрутки
тогда и только тогда, когда аргумент положителен.  Эта команда
применяется ко всем фреймам, включая те, что еще будут созданы.  Для
управления начальной установкой режима Scroll Bar вы можете использовать
X-ресурс <SAMP>`verticalScrollBars'</SAMP>.  See section <A HREF="emacs_38.html#SEC509">X-ресурсы</A>.


<P>
<A NAME="IDX825"></A>
  Чтобы включить или выключить полоски прокрутки только для выбранного
фрейма, воспользуйтесь командой <KBD>M-x toggle-scroll-bar</KBD>.




<H2><A NAME="SEC188" HREF="emacs_toc.html#TOC188">Полоски меню</A></H2>
<P>
<A NAME="IDX826"></A>
<A NAME="IDX827"></A>


<P>
  Вы можете включить или выключить показ полосок меню с помощью команды
<KBD>M-x menu-bar-mode</KBD>.  Без аргументов, эта команда переключает режим
Menu Bar; это второстепенный режим.  С аргументом, эта команда включает
режим Menu Bar, если аргумент положителен, и выключает, если аргумент
неположителен.  Для управления начальной установкой режима Menu Bar вы
можете использовать X-ресурс <SAMP>`menuBarLines'</SAMP>.  See section <A HREF="emacs_38.html#SEC509">X-ресурсы</A>.
Профессиональные пользователи часто выключают полоску меню, особенно на
текстовых терминалах, где это освобождает одну дополнительную строку для
текста.


<P>
  See section <A HREF="emacs_6.html#SEC16">Полоска меню</A>, для получения информации о том, как вызывать
команды с помощью полоски меню.




<H2><A NAME="SEC189" HREF="emacs_toc.html#TOC189">Использование разных начертаний</A></H2>
<P>
<A NAME="IDX828"></A>


<P>
  Когда вы используете Emacs с системой X, вы можете настроить несколько
стилей отображения знаков.  Вы можете контролировать такие аспекты
стиля: шрифт, цвет текста, цвет фона и подчеркивание.  Emacs частично
поддерживает начертания в MS-DOS, позволяя вам контролировать для
каждого начертания цвета текста и фона (see section <A HREF="emacs_40.html#SEC513">Emacs и MS-DOS</A>).


<P>
  Вы управляете стилем отображения путем определения именованных
<EM>начертаний</EM>.  Каждое начертание может задавать шрифт, цвет текста,
цвет фона и флаг подчеркивания; но оно не обязано задавать их все.
Затем, указывая начертание или начертания для заданной части текста в
буфере, вы управляете внешним видом этого текста.  


<P>
  Используемый для каждого данного знака стиль отображения определяется
комбинацией нескольких начертаний.  Любой аспект стиля, не заданный
перекрытиями или свойствами текста, предоставляется самим фреймом.


<P>
  Режим Enriched, предназначенный для редактирования форматированного
текста, включает несколько команд и меню для задания начертаний.
See section <A HREF="emacs_26.html#SEC243">Начертания в форматированном тексте</A>, чтобы
узнать, как указать шрифт для текста в буфере.  See section <A HREF="emacs_26.html#SEC244">Цвета в форматированном тексте</A>, о задании цветов текста и фона.


<P>
  Для изменения внешнего вида начернания используйте буфер настройки.
See section <A HREF="emacs_36.html#SEC447">Настройка начертаний</A>.  Для определения атрибутов конкретных
начертаний вы также можете использовать X-ресурсы (see section <A HREF="emacs_38.html#SEC509">X-ресурсы</A>).


<P>
<A NAME="IDX829"></A>
  Чтобы узнать, какие начертания определены в данный момент, и как они
выглядят, наберите <KBD>M-x list-faces-display</KBD>.  Одно начертание может
выглядеть по-разному в разных фреймах; данная команда показывает его вид
в том фрейме, где вы ее набрали.  Вот перечень стандартных определенных
начертаний:


<P>
@hyphenation{шриф-та}
<DL COMPACT>

<DT><CODE>default</CODE>
<DD>
Это начертание используется для обычного текста, для которого не
определено другое начертание.
<DT><CODE>modeline</CODE>
<DD>
Это начертание используется для строк режима.  По умолчанию оно
устанавливается как инверсия начертания <CODE>default</CODE>.
See section <A HREF="emacs_16.html#SEC88">Переменные управления изображением</A>.
<DT><CODE>highlight</CODE>
<DD>
Это начертание используется в различных режимах для подсветки частей
текста.
<DT><CODE>region</CODE>
<DD>
Это начертание применяется для отображения выделенной области (когда
включен режим Transient Mark -- смотрите ниже).
<DT><CODE>secondary-selection</CODE>
<DD>
Это начертание используется для отображения вторичного выделения
(see section <A HREF="emacs_22.html#SEC178">Вторичное выделение</A>).
<DT><CODE>bold</CODE>
<DD>
Это начертание использует жирный вариант шрифта по умолчанию, если он
есть.
<DT><CODE>italic</CODE>
<DD>
Это начертание использует курсивный вариант шрифта по умолчанию, если он
есть.
<DT><CODE>bold-italic</CODE>
<DD>
Это начертание использует жирный курсивный вариант шрифта по умолчанию,
если он есть.
<DT><CODE>underline</CODE>
<DD>
Это начертание подчеркивает текст.
</DL>

<P>
<A NAME="IDX830"></A>
  Если включен режим Transient Mark, текст области подсвечивается, когда
метка активна.  Для этого используется начертание с именем
<CODE>region</CODE>; вы можете управлять стилем подсветки, меняя стиль этого
начертания (see section <A HREF="emacs_36.html#SEC447">Настройка начертаний</A>).  See section <A HREF="emacs_13.html#SEC57">Режим Transient Mark</A>, для
получения большей информации о режиме Transient Mark и активизации и
деактивизации метки.


<P>
  Один простой способ использовать разные начертания -- включить режим
Font Lock.  Этот второстепенный режим, всегда локальный для конкретного
буфера, подбирает начертания в соответствии с синтаксисом редактируемого
текста.  Он может распознавать комментарии и строки в большинстве
языков; в некоторых языках он умеет даже распознавать и правильно
подсвечивать различные другие важные конструкции.  See section <A HREF="emacs_22.html#SEC190">Режим Font Lock</A>, для
получения большей информации о режиме Font Lock и синтаксической
подсветке.


<P>
  Вы можете распечатать буфер с подсветкой, какую вы видите на экране, с
помощью команды <CODE>ps-print-buffer-with-faces</CODE>.  See section <A HREF="emacs_35.html#SEC429">Печать через Postscript</A>.




<H2><A NAME="SEC190" HREF="emacs_toc.html#TOC190">Режим Font Lock</A></H2>
<P>
<A NAME="IDX831"></A>
<A NAME="IDX832"></A>
<A NAME="IDX833"></A>
<A NAME="IDX834"></A>


<P>
  Режим Font Lock -- это второстепенный режим, всегда локальный для
каждого буфера, который подсвечивает редактируемый вами текст, используя
различные начертания в соответствии с синтаксисом текста.  Он может
распознавать комментарии и строки в большинстве языков; в некоторых
языках он может также распознавать и правильно подсвечивать различные
другие важные конструкции -- например, имена определяемых функций и
зарезервированные ключевые слова.


<P>
<A NAME="IDX835"></A>
<A NAME="IDX836"></A>
  Команда <KBD>M-x font-lock-mode</KBD> включает и выключает режим Font Lock
в соответствии с аргументом и переключает, если аргумент не задан.
Функция <CODE>turn-on-font-lock</CODE> безусловно включает режим Font Lock.
Это полезно в функциях-ловушках режима.  Например, чтобы задействовать
режим Font Lock всякий раз, когда вы редактируете файл на Си, вы можете
сделать так:



<PRE>
(add-hook 'c-mode-hook 'turn-on-font-lock)
</PRE>

<P>
<A NAME="IDX837"></A>
  Чтобы включить режим Font Lock автоматически во всех режимах, которые
его поддерживают, используйте функцию <CODE>global-font-lock-mode</CODE>, как
показано здесь:



<PRE>
(global-font-lock-mode 1)
</PRE>

<P>
<A NAME="IDX838"></A>
<A NAME="IDX839"></A>
  Когда вы редактируете текст в режиме Font Lock, подсветка в измененной
строке обновляется автоматически.  Чаще всего изменения не оказывают
влияния на подсветку последующих строк, но иногда все же влияют.  Чтобы
обновить подсветку нескольких строк, используйте команду <KBD>M-g M-g</KBD>
(<CODE>font-lock-fontify-block</CODE>).


<P>
<A NAME="IDX840"></A>
  В некоторых основных режимах <KBD>M-g M-g</KBD> обновляет подсветку всей
текущей функции.  (Как именно можно найти текущую функцию, указывает
переменная <CODE>font-lock-mark-block-function</CODE>.)  В других основных
режимах <KBD>M-g M-g</KBD> обновляет подсветку 16-ти строк над и под точкой.


<P>
  С числовым аргументом <VAR>n</VAR>, <KBD>M-g M-g</KBD> обновляет подсветку
<VAR>n</VAR> строк над и под точкой, независимо от режима.


<P>
  Чтобы получить все преимущества режима Font Lock, вам придется выбрать
такой шрифт по умолчанию, у которого есть жирный, курсивный и жирный
курсивный варианты; или вам понадобится цветной монитор или монитор,
отображающий много градаций серого.


<P>
<A NAME="IDX841"></A>
  Переменная <CODE>font-lock-maximum-decoration</CODE> задает предпочтительный
уровень оформления для режимов, которые предоставляют несколько уровней.
Уровень 1 -- это минимальное оформление; некоторые режимы поддерживают
до трех уровней.  Обычное значение по умолчанию обозначает "как можно
больше".  Вы можете указать целое число, которое применяется ко всем
режимам, или задать разные числа для конкретных режимов; например, чтобы
использовать уровень 1 для режимов C/C++ и уровень по умолчанию в
остальных случаях, напишите так:



<PRE>
(setq font-lock-maximum-decoration
      '((c-mode . 1) (c++-mode . 1)))
</PRE>

<P>
<A NAME="IDX842"></A>
  В больших буферах подсветка может быть слишком медленной, поэтому вы
можете подавить ее.  Переменная <CODE>font-lock-maximum-size</CODE> задает
размер буфера, сверх которого подсветка не делается.


<P>
<A NAME="IDX843"></A>
  Подсветка комментариев и строк (или "синтаксическая" подсветка)
основывается на анализе синтаксической структуры текста буфера.  В целях
увеличения скорости некоторые режимы, включая режим C и режим Lisp
полагаются на особое соглашение: открывающая скобка в самом левом
столбце всегда обозначает начало определения функции и, таким образом,
всегда находится вне любой строки или комментария.  (See section <A HREF="emacs_27.html#SEC253">Определения функций</A>.)  Если вы не следуете этому соглашению, режим Font Lock может
сделать неправильную подсветку текста после открывающей скобки в левом
столбце, которая попадает в строку или комментарий.


<P>
  Переменная <CODE>font-lock-beginning-of-syntax-function</CODE> (всегда
локальная для буфера) указывает, каким образом режим Font Lock может
найти позицию, которая гарантированно находится вне любого комментария
или строки.  В режимах, использующих соглашение об открывающей скобке в
левом столбце, значение этой переменной по умолчанию -- это
<CODE>beginning-of-defun</CODE>, что велит режиму Font Lock применять это
соглашение.  Если вы установите эту переменную в <CODE>nil</CODE>, Font Lock
больше не станет полагаться на это соглашение.  Это позволяет избежать
неверных результатов, но ценой этого будет то, что в некоторых случаях
для подсветки придется проходить текст буфера с самого начала.


<P>
<A NAME="IDX844"></A>
  Образцы подсветки Font Lock уже существуют для многих режимов, но вы
можете захотеть раскрасить что-то дополнительно.  Чтобы добавить свои
собственные образцы подсветки для определенного режима, вы можете
использовать функцию <CODE>font-lock-add-keywords</CODE>.  К примеру, чтобы
выделить в комментариях Си слова <SAMP>`FIXME:'</SAMP>, используйте это:



<PRE>
(font-lock-add-keywords
 'c-mode
 '(("\\&#60;\\(FIXME\\):" 1 font-lock-warning-face t)))
</PRE>



<H2><A NAME="SEC191" HREF="emacs_toc.html#TOC191">Режимы поддержки Font Lock</A></H2>

<P>
  Режимы поддержки убыстряют режим Font Lock в больших буферах.  Есть
два режима поддержки: режим Fast Lock и режим Lazy Lock.  Они используют
два разных метода ускорения режима Font Lock.




<H3><A NAME="SEC192" HREF="emacs_toc.html#TOC192">Режим Fast Lock</A></H3>

<P>
<A NAME="IDX845"></A>
<A NAME="IDX846"></A>
  Чтобы сделать режим Font Lock более быстрым для буферов, обращающихся
к большим файлам, вы можете использовать режим Fast Lock.  Режим Fast
Lock сохраняет информацию о шрифтах для каждого файла в отдельном файле
кеша; всякий раз, когда вы обращаетесь к файлу, он заново считывает
информацию о шрифтах из файла кеша вместо того, чтобы вычислять шрифты
для текста с нуля.


<P>
<A NAME="IDX847"></A>
  Команда <KBD>M-x fast-lock-mode</KBD> включает и выключает режим Fast Lock
в соответствии с аргументом (без аргумента, режим переключается).  Вы
также можете сделать так, чтобы режим Fast Lock включался всякий раз,
когда вы используете режим Font Lock, следующим образом:



<PRE>
(setq font-lock-support-mode 'fast-lock-mode)
</PRE>

<P>
<A NAME="IDX848"></A>
  Записывать файл кеша для маленьких буферов не имеет смысла.  Поэтому
есть переменная, <CODE>fast-lock-minimum-size</CODE>, задающая наименьший
размер файла, для которого информация о шрифтах кешируется.


<P>
<A NAME="IDX849"></A>
  Переменная <CODE>fast-lock-cache-directories</CODE> указывает, где нужно
размещать файлы кеша.  Ее значение -- это список каталогов, которые
будут испробованы; <CODE>"."</CODE>  означает тот же каталог, где файл
редактируется.  Значение по умолчанию равно <CODE>("."
"~/.emacs-flc")</CODE>, что велит использовать тот же каталог, если это
возможно, иначе использовать каталог <TT>`~/.emacs-flc'</TT>.


<P>
<A NAME="IDX850"></A>
  Переменная <CODE>fast-lock-save-others</CODE> указывает, должен ли режим
Fast Lock сохранять файлы кеша для файлов, чьим владельцем являетесь не
вы.  Отличное от <CODE>nil</CODE> значение говорит, что должен (и это
значение по умолчанию).




<H3><A NAME="SEC193" HREF="emacs_toc.html#TOC193">Режим Lazy Lock</A></H3>
<P>
<A NAME="IDX851"></A>
<A NAME="IDX852"></A>


<P>
  Чтобы ускорить режим Font Lock для больших буферов, вы можете
использовать режим Lazy Lock, который уменьшает количество текста,
подлежащего подсветке.  В режиме Lazy Lock подсветка буфера делается по
необходимости; она производится только для тех частей буфера, которые
должны появиться на экране.  И подсветка ваших изменений замедлена; она
производится, только когда Emacs бездействовал определенный небольшой
промежуток времени.


<P>
<A NAME="IDX853"></A>
  Команда <KBD>M-x lazy-lock-mode</KBD> включает и выключает режим Lazy Lock
в соответствии с аргументом (без аргумента, режим переключается).  Вы
также можете сделать так, чтобы режим Lazy Lock включался всякий раз,
когда вы используете режим Font Lock, следующим образом:



<PRE>
(setq font-lock-support-mode 'lazy-lock-mode)
</PRE>

<P>
<A NAME="IDX854"></A>
  Избегать подсветки маленьких буферов не имеет смысла.  Минимальный
размер буфера, для которого подсветка делается по необходимости,
определяется переменной <CODE>lazy-lock-minimum-size</CODE>.  Меньшие буферы
расцвечиваются сразу, как в простом режиме Font Lock.


<P>
<A NAME="IDX855"></A>
  Когда вы изменяете буфер, режим Lazy Lock откладывает подсветку
измененного текста.  Переменная <CODE>lazy-lock-defer-time</CODE> задает число
секунд, которое Emacs должен оставаться незанятым, прежде чем начать
подсветку ваших изменений.  Если ее значение равно 0, изменения
подсвечиваются незамедлительно, как в простом режиме Font Lock.


<P>
<A NAME="IDX856"></A>
  Обычно режим Lazy Lock подсвечивает ставшие видимыми фрагменты буфера
перед тем, как они впервые показываются на экране.  Однако, если
значение <CODE>lazy-lock-defer-on-scrolling</CODE> не равно <CODE>nil</CODE>, вновь
видимый текст подсвечивается только после того, как Emacs бездействовал
<CODE>lazy-lock-defer-time</CODE> секунд.


<P>
<A NAME="IDX857"></A>
  В некоторых режимах, включая режим C и режим Emacs Lisp, изменение
содержимого одной строки изменяет контекст последующих строк и,
следовательно, ту подсветку, которая должна для них использоваться.
Обычно вы должны набрать <KBD>M-g M-g</KBD>, чтобы обновить подсветку
последующих строк.  Однако, если вы установите переменную
<CODE>lazy-lock-defer-contextually</CODE> не равной <CODE>nil</CODE>, режим Lazy
Lock делает это автоматически по истечении <CODE>lazy-lock-defer-time</CODE>
секунд.


<P>
<A NAME="IDX858"></A>
  Когда Emacs бездействует продолжительное время, Lazy Lock подсвечивает
дополнительные фрагменты буфера, которые еще не показаны, на случай,
если вы вынесете их на экран позднее.  Это называется <EM>скрытой
подсветкой</EM>.


<P>
<A NAME="IDX859"></A>
<A NAME="IDX860"></A>
<A NAME="IDX861"></A>
  Переменная <CODE>lazy-lock-stealth-time</CODE> определяет, сколько минут
Emacs должен оставаться незанятым, прежде чем начать скрытую подсветку.
Значение <CODE>nil</CODE> означает отсутствие скрытой подсветки.  Переменные
<CODE>lazy-lock-stealth-lines</CODE> и <CODE>lazy-lock-stealth-verbose</CODE> задают
диапазон и подробность скрытой подсветки.




<H3><A NAME="SEC194" HREF="emacs_toc.html#TOC194">Fast Lock или Lazy Lock?</A></H3>

<P>
  Вот простые указания, которые помогут вам выбрать один из режимов
поддержки Font Lock.



<UL>
<LI>

Режим Fast Lock играет роль только при обращении к файлам и уничтожении
буферов (и связанных событий); следовательно, редактирование буфера и
прокрутка окна не быстрее и не медленнее, чем в простом режиме Font
Lock.

<LI>

Режим Fast Lock медленнее при считывании файлов кеша, чем режим Lazy
Lock при подсветке буфера; следовательно, режим Fast Lock медленнее при
обращении к файлам, чем режим Lazy Lock.

<LI>

Режим Lazy Lock работает во время прокрутки окна, чтобы раскрасить
текст, выносимый на экран; следовательно, прокрутка медленнее, чем в
простом режиме Font Lock.

<LI>

Режим Lazy Lock не подсвечивает буфер в процессе редактирования (он
откладывает подсветку изменений); следовательно, редактирование в нем
быстрее, чем в простом режиме Font Lock.

<LI>

Режим Fast Lock может быть сбит с толку файлом, находящимся под
контролем системы управления версиями; следовательно, подсветка буфера
может производиться, даже если для этого файла есть файл кеша.

<LI>

Режим Fast Lock работает только с буферами, обращающимися к файлам;
режим Lazy Lock работает с любыми буферами.

<LI>

Режим Fast Lock создает файлы кеша; режим Lazy Lock не создает.
</UL>

<P>
<A NAME="IDX862"></A>
  Переменная <CODE>font-lock-support-mode</CODE> указывает, какой из этих
режимов поддержки следует использовать; например, чтобы сказать, что в
режимах C/C++ используется режим Fast Lock, а в остальных случаях ---
режим Lazy Lock, установите эту переменную так:



<PRE>
(setq font-lock-support-mode
      '((c-mode . fast-lock-mode) (c++-mode . fast-lock-mode)
        (t . lazy-lock-mode)))
</PRE>



<H2><A NAME="SEC195" HREF="emacs_toc.html#TOC195">Режим Highlight Changes</A></H2>

<P>
<A NAME="IDX863"></A>
  Используйте <KBD>M-x highlight-changes-mode</KBD>, чтобы включить
второстепенный режим, который показывает с помощью разных начертаний (в
основном цветов), какие части текста буфера изменялись недавно.




<H2><A NAME="SEC196" HREF="emacs_toc.html#TOC196">Другие возможности X Windows</A></H2>

<P>
  Следующие команды позволяют вам создавать и удалять фреймы, а также
делать другие операции над ними:


<DL COMPACT>

<DT><KBD>C-z</KBD>
<DD>
<A NAME="IDX864"></A>
<A NAME="IDX865"></A>
Минимизирует выбранный фрейм (<CODE>iconify-or-deiconify-frame</CODE>).
Обычное значение <KBD>C-z</KBD>, приостановка Emacs, бесполезно под оконной
системой, поэтому в данном случае у этого ключа другая привязка.

Если вы введете эту команду в пиктограмме фрейма Emacs, она
деминимизирует этот фрейм.

<DT><KBD>C-x 5 0</KBD>
<DD>
<A NAME="IDX866"></A>
<A NAME="IDX867"></A>
Удаляет выбранный фрейм (<CODE>delete-frame</CODE>).  Это не допускается, если
есть только один фрейм.

<DT><KBD>C-x 5 o</KBD>
<DD>
<A NAME="IDX868"></A>
<A NAME="IDX869"></A>
Выбирает другой фрейм, поднимает его и переносит в него мышь, чтобы он
оставался выбранным.  Если вы повторяете эту команду, она циклически
проходит по всем фреймам на вашем терминале.
</DL>



<H2><A NAME="SEC197" HREF="emacs_toc.html#TOC197">Неоконные терминалы</A></H2>
<P>
<A NAME="IDX870"></A>
<A NAME="IDX871"></A>


<P>
  Если ваш терминал не обладает оконной системой, которую поддерживает
Emacs, то он может показывать только один фрейм Emacs в один момент
времени.  Однако, вы все же можете создавать несколько фреймов Emacs и
переключаться между ними.  На таких терминалах переключение фреймов во
многом похоже на переключение между различными конфигурациями окон.


<P>
  Чтобы создать новый фрейм и переключиться в него, используйте <KBD>C-x
5 2</KBD>; для кругового прохода по существующим фреймам используйте <KBD>C-x
5 o</KBD>; чтобы удалить текущий фрейм, используйте <KBD>C-x 5 0</KBD>.


<P>
  Каждый фрейм имеет отличительный номер.  Если ваш терминал может
показывать в одно время только один фрейм, то около начала строки режима
появляется номер <VAR>n</VAR> текущего фрейма в форме <SAMP>`F<VAR>n</VAR>'</SAMP>.


<P>
<A NAME="IDX872"></A>
<A NAME="IDX873"></A>
  <SAMP>`F<VAR>n</VAR>'</SAMP> на самом деле -- это имя фрейма.  Вы также можете
указать другое имя, если хотите, и вы можете выбирать фреймы по именам.
Чтобы задать новое имя для текущего фрейма, используйте команду <KBD>M-x
set-frame-name <KBD>RET</KBD> <VAR>имя</VAR> <KBD>RET</KBD></KBD>, а для выбора фрейма в
соответствии с его именем используйте <KBD>M-x select-frame-by-name
<KBD>RET</KBD> <VAR>имя</VAR> <KBD>RET</KBD></KBD>.  Указанное вами имя появляется в строке
режима, когда этот фрейм становится выбранным.
<P><HR><P>
Go to the <A HREF="emacs_1.html">first</A>, <A HREF="emacs_21.html">previous</A>, <A HREF="emacs_23.html">next</A>, <A HREF="emacs_46.html">last</A> section, <A HREF="emacs_toc.html">table of contents</A>.
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">_uacct = "UA-78697-3"; urchinTracker(); </script></body>
</HTML>
