#title Использование Emacs вместе с CEDET
#keywords c, c++, java, maven, emacs, cedet, programming, semantic, ede, программирование, ide, integrated development environment, ява, с++

Этот рассказ не претендует на звание полного описания настройки Emacs как среды разработки
на разных языках, а является попыткой написать краткий рассказ о настройке пакета [[http://cedet.sf.net][CEDET]]
для работы с языками программирования C, C++ & Java, хотя большая часть изложенного
подходит и к работе с другими языками, поддерживаемыми пакетом CEDET[1].

<contents>

* Что такое CEDET?

Пакет CEDET объединяет в своем составе несколько пакетов, реализующих различную
функциональность, но объединенных вокруг одной задачи: работе с исходным кодом на
различных языках программирования (*хочется отметить, что не все эти пакеты входят в состав
GNU Emacs*):
 - Semantic -- является основой для построения анализаторов для различных языков
   программирования, позволяя использовать общее представление извлеченной информации для
   разных языков, используя которую реализуется остальной функционал не только CEDET, но и
   других пакетов -- [[http://jdee.sourceforge.net/][JDEE]] и [[http://ecb.sf.net][ECB]], которые являются попыткой создать среды разработки,
   близкие по виду к имеющимся на рынке (Eclipse, NetBeans и т.п.);
 - SemanticDB -- входит в состав Semantic, и реализует интерфейсы к разным модулям
   хранения информации, используемой при дополнении имен, навигации по коду и т.п.
   Синтаксическая информация может сохраняться между сессиями работы в Emacs, что
   уменьшает потребность в регулярном разборе одного и того же кода;
 - Senator -- реализует функциональность для навигации по синтаксической информации,
   извлеченной Semantic;
 - Srecode -- библиотека для генерации кода основываясь на существующей синтаксической
   информации, в том числе и полученной в результате работы Semantic;
 - EDE -- реализует набор расширений, которые позволяют работать с проектами -- управлять
   списком целей для сборки, выполнять сборку проекта и т.п.  Кроме того, используя
   концепцию проекта, существует возможность более точного использования Semantic для
   дополнения имен и другой функциональности;
 - Speedbar -- используется для отображения информации о текущем буфере, основываясь на
   данных из различных источниках -- Semantic, специализированные провайдеры информации
   (например, для texinfo & HTML) и т.п.
 - Eieio -- реализация CLOS-like (Common Lisp Object System) инфраструктуры для Emacs
   Lisp;
 - Cogre -- библиотека для создания UML-подобных диаграмм в буфере Emacs с базовой
   интеграцией с Semantic.

* Версии CEDET

Стоит отметить, что имеется несколько версий CEDET, которые отличаются способом установки
и настройки:
 - автономные версии CEDET до версии 1.1 включительно -- это те версии, которые доступны
   для [[https://sourceforge.net/projects/cedet/files/][загрузки с сайта проекта]]. В этих версиях используется метод активации и "старая"
   структура каталогов с исходным кодом, не совместимые с версией входящей в GNU Emacs.  В
   этих версиях файлы с исходным кодом часто имели "длинные" имена, например,
   =semanticdb.el=, или =semantic-gcc.el=, что делало их несовместимыми с некоторыми ОС
   поддерживаемыми GNU Emacs;
 - автономные версии CEDET после версии 1.1 -- в них используется "новая" структура
   исходного кода и такой же метод активации, что и в версии для GNU Emacs, но обычно эти
   версии имеют лучшую функциональность и включают в себя дополнительные пакеты.  В этой
   версии используются имена файлов, соответствующие наименованию принятом в GNU Emacs, но
   при этом пришлось изменить структуру каталогов и переименовать некоторые файлы,
   например, =semanticdb.el= был переименован в =semantic/db.el=, а =semantic-gcc.el= стал
   =semantic/bovine/gcc.el=, и т.д.
 - Версия входящая в состав GNU Emacs (начиная с GNU Emacs 23.2) -- в этой версии
   отсутствуют некоторые пакеты, такие как Senator, и код может быть более "старым" по
   сравнению с текущей автономной версией CEDET.

Данная статья описывает текущую версию CEDET, в том числе входящую в состав GNU Emacs.  В
том случае, если вы хотите использовать автономную версию до версии 1.1 включительно, то
вам необходимо использовать [[./EmacsCedetOld][предыдущую версию данной статьи]].

* Установка автономной версии CEDET

В данный момент (октябрь 2012-го года) не имеется отдельных версий CEDET с "новым"
методом активации, поэтому вам необходимо взять [[http://www.randomsample.de/cedet-snapshots/][текущий снапшот]] или получить
[[http://cedet.sourceforge.net/bzr-repo.shtml][версию из репозитория]].  Распакуйте исходный код, если это необходимо, перейдите в каталог
и выполните команду:
<src lang="sh>
make clean-all && make
</src>

* Настройка пакета

Если вы используете автономную версию CEDET, то вам необходимо выполнить загрузку пакета с
помощью команды:
<src lang="emacs-lisp">
(load-file "~/emacs/cedet-bzr/cedet-devel-load.el")
</src>

А в том случае, если вы хотите использовать CEDET из поставки GNU Emacs, то все будет уже
загружено при старте.

** Включение Semantic

Автономные версии до версии 1.1 (включительно) имели метод активации, отличный от текущей
версии CEDET и версии, поставляемой с GNU Emacs.  В новых версиях, активация происходит
путем добавления нужных режимов в специальный список и включения =semantic-mode=.  В то
время как в старых версиях, использовались отдельные функции, которые подключали
конкретные наборы функциональности.  В отличии от "старых" версий, в новых версиях
включение Semantic происходит с помощью команды:

<src lang="emacs-lisp">
(semantic-mode 1)
</src>

То, какая дополнительная функциональность будет доступна для работы, зависит от
содержимого списка =semantic-default-submodes=, который может содержать следующие символы
(вы должны заполнить этот список до включения =semantic-mode=):
 =global-semanticdb-minor-mode= :: включает глобальную поддержку Semanticdb;
 =global-semantic-mru-bookmark-mode= :: включает режим автоматического запоминания
   информации о редактируемых тагах, так что вы можете перейти к ним позднее с помощью
   команды =semantic-mrub-switch-tags=;
 =global-cedet-m3-minor-mode= :: активирует контекстное меню привязанное к правой клавише мыши;
 =global-semantic-highlight-func-mode= :: активирует подстветку первой строки текущего тага (функции, класса и т.п.);
 =global-semantic-stickyfunc-mode= :: активирует показ названия текущего тага в верхней строке буфера;
 =global-semantic-decoration-mode= :: активирует использование стилей при показе тагов
   разных типов.  Набор стилей определяется списком =semantic-decoration-styles=;
 =global-semantic-idle-local-symbol-highlight-mode= :: включает подсветку вхождений
   локальных переменных чье имя совпадает с именем текущего тага;
 =global-semantic-idle-scheduler-mode= :: активирует автоматический анализ кода в буферах
   когда Emacs "свободен" и ожидает ввода данных от пользователя (idle time);
 =global-semantic-idle-completions-mode= :: активирует показ возможных дополнений имен во
   время ожидания ввода.  Требует чтобы был включен =global-semantic-idle-scheduler-mode=;
 =global-semantic-idle-summary-mode= :: активирует показ информации о текущем таге во время
   ожидания ввода. Требует чтобы был включен =global-semantic-idle-scheduler-mode=.

Следующие символы в основном полезны при разработке и/или отладке CEDET:
 =global-semantic-show-unmatched-syntax-mode= :: включает показ элементов, которые не
   обработались текущими правилами парсера;
 =global-semantic-show-parser-state-mode= :: включает показ в строке статуса состояния
   парсера;
 =global-semantic-highlight-edits-mode= :: включает показ изменений сделанных в буфере, но
   которые еще не были обработаны инкрементальным парсером.

Данный подход позволяет сделать настройку Semantic более гибкой, поскольку пользователь
может подключать только необходимую функциональность.  Вы также можете воспользоваться
одноименными функциями чтобы включать/выключать выбранные режимы в рамках текущей сессии.
Помимо этого, вы можете включать/выключать конкретные режимы для отдельных буферов (обычно
это делается в хуке) -- названия соответствующих переменных вы можете посмотреть в
описаниях функций =global-semantic-*=.

Чтобы использовать возможности по дополнению имен и показу информации о функциях и
классах, вам необходимо загрузить пакет =semantic/ia= с помощью следующей команды:
<src lang="emacs-lisp">
(require 'semantic/ia)
</src>

** Системные подключаемые файлы

Для полноценной работы с системными библиотеками, Semantic должен иметь информацию о
подключаемых файлах, которые содержат информацию о функциях и типах данных,
предоставляемых этими библиотеками.

Если вы используете GCC для программирования на C & C++, то пакет может автоматически
получить данные о нахождении системных подключаемых файлов.  Для этого вам необходимо
загрузить пакет =semantic/bovine/gcc=:
<src lang="emacs-lisp">
(require 'semantic/bovine/gcc)
</src>

Вы также можете явно задать дополнительные пути поиска подключаемых файлов, которые будут
использоваться при работе в определенном режиме.  Для этого используется команда
=semantic-add-system-include=, которой передается два параметра -- путь к заголовочным
файлам, и имя режима в котором этот путь будет использоваться.  Например:
<src lang="emacs-lisp">
(semantic-add-system-include "~/exp/include/boost_1_37" 'c++-mode)
</src>

*Хотя стоит отметить, что настройка Boost является более сложной, и требует указания
конфигурационных файлов с определениями констант.*

** Оптимизация работы Semantic

Для оптимизации поиска тагов вы можете использовать несколько приемов:
 - Ограничить область поиска путем настройки проекта EDE, как это описано ниже;
 - Явно указать список корневых каталогов для ваших проектов, так что Semantic будет
   использовать ограниченное количество баз тагов;
 - Заранее сгенерировать базы данных тагов для часто используемых каталогов (=/usr/include=,
   =/usr/local/include=, и т.п.) с помощью команд =semanticdb-create-ebrowse-database= или
   =semanticdb-create-cscope-database=;
 - Ограничить диапазон поиска с помощью настройки переменной
   =semanticdb-find-default-throttle= для конкретных режимов, например, не использовать
   информацию о системных подключаемых файлов, убрав директиву =system= из списка объектов
   поиска для режима =c-mode=:
<src lang="emacs-lisp">
(setq-mode-local c-mode semanticdb-find-default-throttle
	 '(project unloaded system recursive))
</src>

Кроме того, вы можете указать Semantic, что он должен извлекать синтаксическую информацию
из текущего буфера только тогда, когда Emacs ничего не делает.  Для этого вам необходимо
включить =semantic-idle-scheduler-mode=, а для настройки времени ожидания (в секундах)
используется переменная =semantic-idle-scheduler-idle-time=.

*** Интеграция с *imenu*

Пакет Semantic умеет интегрироваться с пакетом *imenu*, который позволяет отображать меню со
списком функций, переменных и т.п. информацией.  Для включения этой поддержки, вам
необходимо добавить следующий код в файл инициализации:

<src lang="emacs-lisp">
(defun my-semantic-hook ()
  (imenu-add-to-menubar "TAGS"))
(add-hook 'semantic-init-hooks 'my-semantic-hook)
</src>

** Настройка Semanticdb

Для включения Semanticdb, вам необходимо добавить символ =global-semanticdb-minor-mode= в
список =semantic-default-submodes=.  А для настройки поведения Semanticdb используется
некоторое количество переменных, которые позволяет указать вам куда сохранять данные, а
также другие параметры.  Эти переменные можно настроить через группу настройки =semanticdb=.

Кроме того, Semanticdb может использовать базы данных, сгенерированные внешними утилитами
-- =gtags= из состава [[http://www.gnu.org/software/global/][GNU Global]], [[http://ctags.sourceforge.net/][exubertant ctags]], =ebrowse= & =cscope=.  Для активации этой
поддержки, вы можете использовать следующий код:

<src lang="emacs-lisp">
;; если вы хотите включить поддержку gnu global
(when (cedet-gnu-global-version-check t)
  (semanticdb-enable-gnu-global-databases 'c-mode)
  (semanticdb-enable-gnu-global-databases 'c++-mode))

;; включить поддержку ctags для основных языков:
;;  Unix Shell, Perl, Pascal, Tcl, Fortran, Asm
(when (cedet-ectag-version-check t)
  (semantic-load-enable-primary-exuberent-ctags-support))
</src>

** Настройка EDE

Если вы планируете использовать проекты, то необходимо включить соответствующий режим,
реализуемый пакетом EDE:
<src lang="emacs-lisp">
(global-ede-mode t)
</src>

В состав EDE входит поддержка разных видов проектов, я хочу упомянуть тут самые часто
используемые.

*** Использование EDE для работы с проектами на C & C++

Для правильной работы Semantic с кодом на С & C++ рекомендуется воспользоваться пакетом
EDE (работа с проектами и т.п.) также из поставки CEDET.  Для этих языков, EDE определяет
специальный тип проекта -- =ede-cpp-root-project=, который предоставляет Semantic
дополнительную информацию, используемую для анализа исходных текстов вашего проекта, и
последующего использования информации только для вашего проекта.  Для этого, необходимо
включить соответствующий режим при загрузке пакета.

Для определения проекта используется следующий код:
<src lang="emacs-lisp">
(ede-cpp-root-project "Test"
		:name "Test Project"
		:file "~/work/project/CMakeLists.txt"
		:include-path '("/"
				"/Common"
				"/Interfaces"
				"/Libs"
			       )
		:system-include-path '("~/exp/include")
		:spp-table '(("isUnix" . "")
			     ("BOOST_TEST_DYN_LINK" . "")))
</src>

В качестве параметра =:file= вам надо указать любой из файлов, находящихся в корневом
каталоге проекта.  Этот файл никак не анализируется, а служит только отправной точкой для
поиска файлов.   

Для поиска подключаемых файлов используется каталоги из двух списков, которые могут быть
определены в проекте.  Параметр =:system-include-path= используется для задания списка
полных путей каталогов, в которых будет производиться поиск "системных" подключаемых
файлов.  А параметр =:include-path= задает список каталогов, относительно корневого каталога
проекта, в которых будет производиться поиск подключаемых файлов, специфичных для вашего
проекта (заметьте, что имена начинаются со знака =/=, что означает, что имена задаются
относительно корневого каталога проекта).  Вместо явного задания каталогов, вы также
можете задать функцию, которая будет заниматься поиском файлов вашего проекта.  Об этом вы
можете прочитать в руководстве EDE.

Еще один параметр, который может быть задан в проекте -- список определений, которые будут
использоваться при обработке кода препроцессором.  Параметр =:spp-table= позволяет
определить список пар, состоящих из имени символа и связанного с ним значения.  В нашем
примере мы определяем два символа =isUnix= и =BOOST_TEST_DYN_LINK=, которые будут переданы
препроцессору, что позволит произвести правильный разбор кода.  

В том случае, если это необходимо, пользователь может переопределить для проекта некоторые
переменные путем указания параметра =:local-variables=, указав набор пар вида имя
символа/значение, и эти значения будут установлены для файлов, входящих в проект.

**** Обработка кода на C/C++ препроцессором

Более подробно про определения символов препроцессора вы можете прочитать в документации
на переменную =semantic-lex-c-preprocessor-symbol-map=, а список символов препроцессора,
определенных для какого-то файла, можно получить с помощью команды
=semantic-lex-spp-describe=, и использовать нужные значения для настройки проекта.

Многие библиотеки перечисляют все используемые макросы в одном заголовочном файле, и
поэтому вы можете воспользоваться существующими определениями.  Для этого, вы должны
указать необходимые файлы в переменной =semantic-lex-c-preprocessor-symbol-file=, и при
проведении анализа, значения из этих файлов будут автоматически учтены.  По умолчанию, эта
переменная содержит только одно значение -- файл с определениями для стандартной
библиотеки C++.  В качестве примера я хочу привести настройку CEDET для работы с
библиотекой Qt4:

<src lang="emacs-lisp">
(setq qt4-base-dir "/usr/include/qt4")
(semantic-add-system-include qt4-base-dir 'c++-mode)
(add-to-list 'auto-mode-alist (cons qt4-base-dir 'c++-mode))
(add-to-list 'semantic-lex-c-preprocessor-symbol-file (concat qt4-base-dir "/Qt/qconfig.h"))
(add-to-list 'semantic-lex-c-preprocessor-symbol-file (concat qt4-base-dir "/Qt/qconfig-dist.h"))
(add-to-list 'semantic-lex-c-preprocessor-symbol-file (concat qt4-base-dir "/Qt/qglobal.h"))
</src>

После добавления этого кода в ваш файл инициализации, вы сможете использовать механизмы
дополнения для классов, определенных в Qt4.  Пример дополнения вы можете увидеть на
рисунке ниже.

<div id="screenshot">
[[../../../common/writings/emacs-devenv/cedet-qt-name-completion.png]]
</div>

*** Использование EDE для проектов на Java

Semantic имеет в своем составе парсер для исходного кода, написанного на Java, поэтому
дополнение имен классов работало всегда.  Раньше основной проблемой было получение
дополнений имен для базовых классов JDK, а также подключенных библиотек.  Для
скомпилированного кода, Semanticdb умеет получать информацию о именах используя =javap= и
список библиотек в =CLASSPATH=.  Чтобы это работало, вам нужно загрузить библиотеку
=semantic/db-javap=:

<src lang="emacs-lisp">
(require 'semantic/db-javap)
</src>

Путь к основной библиотеке Java (=rt.jar= на Linux & Windows, и =classes.jar= на Mac OS X)
обычно определяется автоматически с помощью функции =cedet-java-find-jdk-core-jar=, хотя вы
можете изменить ее поведение путем установки переменных среды =JAVA_HOME=, или других
параметров.

В том случае, если вы используете Maven для сборки ваших проектов, то =CLASSPATH= будет
получен автоматически, путем запуска Maven в корне вашего проекта (в том числе и при
использовании проектов, состоящих из нескольких модулей).  При этом, вам нет нужды вручную
указывать корень проекта -- EDE вычислит его автоматически, путем поиска файлов =pom.xml=.
*Стоит отметить, что первый вызов функции дополнения имен может быть достаточно медленным
-- EDE должен запустить Maven и собрать информацию об используемых библиотеках. Но затем
эта информация кешируется, и следующие вызовы будут происходить быстрее.*

Если же вы не используете Maven, то вы можете либо указать нужные библиотеки в переменной
=semanticdb-javap-classpath=, либо использовать проект =ede-java-root-project=, который
аналогичен по функционалу =ede-cpp-root-project=.  Чтобы воспользоваться этим типом проекта,
вам необходимо добавить что-то подобное следующему коду:

<src lang="emacs-list">
 (ede-java-root-project "TestProject" 
         :file "~/work/TestProject/build.xml"
	 :srcroot '("src" "test")
	 :localclasspath '("/relative/path.jar")
	 :classpath '("/absolute/path.jar"))
</src>

Так же как и для C/C++, то вам необходимо указать название проекта, указать существующий
файл в корне проекта, и опции, которые определяют поведение при дополнении имен:
 =:srcroot= :: список каталогов с исходным кодом, указанных относительно корня проекта (в
   данном примере это =src= и =test=);
 =:classpath= :: список абсолютных имен файлов с используемыми библиотеками;
 =:localclasspath= :: список имен файлов с библиотеками, указанных относительно корня
   проекта.

Найдя такое определение проекта, Semantic сможет использовать указанную информацию при
дополнении имен.


* Использование Semantic

С точки зрения пользователя Semantic реализует несколько основных функции -- дополнение
имен, получение информации о тагах (переменных, функциях и т.д.) и навигацию по исходному
коду.  Часть команд реализуется пакетом =semantic/ia=, часть пакетом Senator, и часть --
ядром самого Semantic.

Часть команд не имеет стандартных привязок клавиш, поэтому вам лучше самим выбрать удобные
для вас привязки и привязать к ним нужные команды, например вот так (только для автономной
версии CEDET):
<src lang="emacs-lisp">
(defun my-cedet-hook ()
  (local-set-key [(control return)] 'semantic-ia-complete-symbol)
  (local-set-key "\C-c?" 'semantic-ia-complete-symbol-menu)
  (local-set-key "\C-c>" 'semantic-complete-analyze-inline)
  (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle))
(add-hook 'c-mode-common-hook 'my-cedet-hook)
</src>

*Я хотел бы отметить, что работа над Semantic ведется достаточно активно, и в случае
неправильной работы каких-либо компонент, просьба отправлять примеры кода в
[[https://lists.sourceforge.net/lists/listinfo/cedet-devel][список рассылки cedet-devel]] -- автор реагирует на баг-репорты достаточно оперативно.*

** Дополнение имен

Дополнение имен функций и классов -- достаточно востребованная и часто используемая
функция[2].  В составе Semantic идет два пакета реализующих данную функциональность --
=semantic/ia= и Senator (он не включен в состав GNU Emacs).  *Стоит учитывать то, что в
новых версиях рекомендуется использовать Semantic только как источник информации, а
дополнение имен выполнять используя дополнительные пакеты, такие как =auto-complete=.
Пример настройки =auto-complete= вы можете увидеть ниже.*

Функции реализованные в составе =semantic/ia= используют для определения списка возможных
дополнений функцию =semantic-analyze-possible-completions=, которая учитывает достаточно
много параметров -- области видимости определений, и т.п., и кроме того, она может быть
переопределена пользователем для более точной генерации списка имен.  В то время как
функции Senator используют более простой механизм определения списка возможных дополнений
(в основном используя информацию об определениях в текущем файле), что иногда ведет к
неправильному его формированию, хотя и работает намного быстрее чем функции из
=semantic/ia=.

Использование функции =semantic-ia-complete-symbol= при наборе кода приведет к дополнению
соответствующего имени -- функции, переменной или переменной-члена класса, в зависимости
от контекста в котором она была вызвана.  Если существует несколько вариантов, то имя
будет дополнено до наибольшей общей части имени, а при повторном вызове команды, будет
показан буфер со списком всех возможных вариантов имени.  Пользователь может также
воспользоваться функцией =semantic-ia-complete-symbol-menu=, которая также анализирует
контекст в котором она вызвана, и отображает варианты дополнений в виде графического меню,
перемещаясь по которому пользователь может выбрать нужный вариант дополнения[3].  Кроме
того, существует функция =semantic-ia-complete-tip=, которая отображает список возможных
дополнений в виде всплывающей подсказки (tooltip).  

Как упоминалось выше, Senator также предоставляет функции для дополнения имен, которые
работают более быстро, но учитывают меньше параметров при генерации списка дополнений.
Функция =senator-complete-symbol= (=C-c , TAB=) дополняет имя для текущего тага, при этом она
сразу подставляет имя первого варианта из списка всех возможных вариантов.  Если вам это
не подходит, то вы можете продолжать вызывать эту функцию для перебора всех вариантов
дополнения имен (что не всегда удобно). В том случае, если вариантов имен много, или вы
хотите посмотреть полный список функций и переменных для какого-то класса, то лучше
воспользоваться функцией =senator-completion-menu-popup= (=C-c , SPC=), которая отображает
список возможных вариантов дополнений в виде графического меню.

Помимо этого, для отдельных языков пользователь может включить специальный режим --
=semantic-idle-completions-mode= (или включить его глобально путем добавления символа
=global-semantic-idle-completions-mode= в список =semantic-default-submodes=) при котором
дополнения имен начинают показываться спустя некоторое время бездействия.  При этом, в
качестве варианта предлагается первое значение из списка возможных дополнений, и
пользователь может использовать клавишу =TAB= для перебора вариантов.

Для языков с C-подобным синтаксисом, пользователь может воспользоваться командой
=semantic-complete-self-insert=, привязанной к клавишам =.= и =>=, как это показано ниже:
<src lang="emacs-lisp">
(defun my-c-mode-cedet-hook ()
 (local-set-key "." 'semantic-complete-self-insert)
 (local-set-key ">" 'semantic-complete-self-insert))
(add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
</src>

Использование этого кода приведет к тому, что при нажатии =.= или =>= после переменных,
экземпляров класса, будет показан список возможных дополнений для данного класса.

При программировании на C & C++, вы также можете получить список возможных дополнений имен
от Clang (версии 2.9 и выше).  Для этого, вам необходимо загрузить пакет
=semantic/bovine/clang=, и вызвать функцию =semantic-clang-activate=.  После этого, Semantic
начнет вызывать Clang, и использовать его анализатор кода для вывода списка возможных
дополнений имен.

*** Настройка дополнения имен используя пакет auto-complete

Пакет [[http://cx4a.org/software/auto-complete/][auto-complete]] разрабатывался для облегчения ввода текста.  Он позволяет вставлять
новый текст основываясь на самых различных источниках информации -- предварительно
подготовленных словарях, тексте в текущем буфере, внешних программах (GNU Global, etags,
...) и т.д.  Semantic также может являться одним из источников дополнений.

Этот пакет доступен в стандартном репозитории пакетов GNU Emacs (наберите =M-x
package-list-packages= чтобы получить список доступных пакетов), вы также можете установить
его через =el-get= или вручную.  Установка и настройка описаны в [[http://cx4a.org/software/auto-complete/manual.html][руководстве пользователя]],
поэтому я не буду их здесь описывать подробно.

Чтобы использовать информацию Semantic для дополнения имен, вам необходимо добавить
=ac-source-semantic= или =ac-source-semantic-raw= в список =ac-sources= (этот список позволяет
вам контролировать какие источники данных будут доступны в текущем файле, так что вы
можете изменять его как хотите для разных режимов). =ac-source-semantic-raw= отличается от
=ac-source-semantic= тем, что для него не производится фильтрации относительно текущего
пространства имен.  

Так что настройка может выглядеть следующим образом -- вместо явной привязки клавиш к
функциям =semantic-ia-complete-symbol-menu=, =semantic-ia-complete-symbol= и т.п., вы можете
просто добавить новые источники и затем пользоваться привязками пакета =auto-complete=.
Например:

<src lang="emacs-lisp">
(defun my-c-mode-cedet-hook ()
  (add-to-list 'ac-sources 'ac-source-gtags)
  (add-to-list 'ac-sources 'ac-source-semantic))
(add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
</src>

** Получение информации о тагах

Пакет =semantic/ia= реализует несколько команд, которые позволяют разработчику получать
информацию о классах, функциях и переменных.  В качестве документации используются
комментарии, извлеченные из исходного кода, в том числе и используемые для генерации
документации с помощью Doxygen.  В настоящее время реализованы следующие функции:

 =semantic-ia-show-doc= :: показывает документацию для функции или переменной чье имя
   находится под курсором.  Документация показывается в отдельном буфере.  Для переменных
   показывается их объявление, включающее тип, и строка документации, если она есть.  Для
   функций показывается их прототип, и документация по аргументам функции и возвращаемому
   значению;
 =semantic-ia-show-summary= :: показывает документацию для символа под курсором, но при
   информация отображается в мини-буфере, так что пользователь увидит только объявление
   переменной или функции;
 =semantic-ia-describe-class= :: запрашивает у пользователя имя класса и возвращает список
   функций и переменных определенных в данном классе и всех родительских классах.

** Навигация по коду

Одной из самых полезных функций для навигации является функция =semantic-ia-fast-jump=,
которая позволяет переходить к объявлению переменной или функции, чье имя находится под
курсором.  Вернуться назад вы сможете использовав функцию =semantic-mrub-switch-tag= (=C-x
B=), которая доступна при использовании =semantic-mru-bookmark-mode=.

Также в Semantic определено две функции для перехода к объявлению функции или переменной
находящемся в текущем файле -- =semantic-complete-jump-local= (=C-c , j=), или в области
видимости всего проекта -- =semantic-complete-jump= (=C-c , J=).  Обе эти функции позволяют
ввести имя функции или переменной (включая локальные для функций), используя механизмы
дополнения имен, и перейти к данному определению.

Функция =semantic-analyze-proto-impl-toggle= позволяет "прыгать" между объявлением функции и
ее реализацией для языков, поддерживающих раздельное объявление и реализацию.  Еще одной
полезной функцией является =semantic-decoration-include-visit=, которая позволяет
переключиться в заголовочный файл, чье имя находится под курсором.

Senator также реализует несколько функций для навигации в исходном коде.  Сюда относятся
функции =senator-next-tag= (=C-c , n=) и =senator-previous-tag= (=C-c , p=), которые перемещаются
к следующему или предыдущему тагу, а также функция =senator-go-to-up-reference= (=C-c , u=),
которая переходит к "родительскому" тагу  (например, для функции-члена класса,
"родительским" тагом будет объявление класса).

** Поиск использования функции

Недавно в Semantic была добавлена полезная команда -- =semantic-symref=, которая позволяет
найти где символ, чье имя находится под курсором, используется в проекте.  В том случае,
если вы хотите найти данные для символа с произвольным именем, то вам стоит
воспользоваться функцией =semantic-symref-symbol=, которая позволяет вам ввести имя символа
вручную.

При этом, если вхождения символа в соответствующей базе данных (GNU Global и т.п.) не
найдены, то команда попытается найти использование заданного символа с помощью команды
=find-grep=.  В итоге создается вот такой вот буфер с найденными результатами, используя
который пользователь может перемещаться к нужным частям кода:

<div id="screenshot">
[[../../../common/writings/emacs-devenv/cedet-symref.png]]
</div>

** Свертывание (folding) кода

Поскольку Semantic имеет практически полную синтаксическую информацию об исходных текстах,
то это позволяет реализовать практически такую же функциональность по свертыванию кусков
кода, которая реализуется пакетом *hideshow*.  Для получения этой функциональности вам
необходимо выполнить настройку переменной =global-semantic-tag-folding-mode=.  Это приведет
к появлению небольших треугольников в области значков (*fringle*), нажимая на которые можно
сворачивать или разворачивать соответствующий кусок текста (не только исходного текста, но
и комментариев и других объектов).

В Senator также имеется схожая функциональность, но она в основном предназначена для
работы с объектами верхнего уровня -- функциями, классами и т.п.  Сворачивание участка
кода производится с помощью функции =senator-fold-tag= (=C-c , -=), а разворачивание с помощью
функции =senator-unfold-tag= (=C-c , +=).

** Прочие команды Senator

Пакет Senator определяет некоторое количество команд для работы с тагами -- вырезать или
скопировать текущий таг, вставить его в другом месте, и т.д.  Для вырезания текущего тага
(обычно это определение функции) определена функция =senator-kill-tag= (=C-c , C-w=).
Вставить таг целиком в другом месте можно с помощью стандартной комбинации клавиш =C-y=, в
то время как функция =senator-yank-tag= (=C-c , C-y=) вставляет лишь определение данного тага,
без тела.  Еще одной полезной функцией является =senator-copy-tag= (=C-c , M-w=), которая
копирует текущий таг для последующей вставки (с помощью =C-c , C-y=), что очень удобно для
вставки объявлений функций в заголовочных файлах, а полный текст скопированного тага,
вставляется с помощью =C-y=.

Senator позволяет изменить поведение стандартных функций поиска (=re-search-forward=,
=isearch-forward= и др.) при работе с исходным кодом таким образом, что функции будут
производить поиск только в соответствующих тагах.  Чтобы включить этот режим вы можете
использовать функцию =senator-isearch-toggle-semantic-mode= (=C-c , i=), а с помощью функции
=senator-search-set-tag-class-filter= (=C-c , f=) вы можете ограничить пространство поиска
только указанными классами тагов -- =function= для функций, =variable= для переменных, и т.д.

Вы также можете воспользоваться поиском по тагам не переключаясь явно в режим ограничения
поиска.  Вам нужно лишь вызвать одну из функций: =senator-search-forward= или
=senator-search-backward=.
         
* Работа с Srecode

Пакет Srecode позволяет пользователю определять различные шаблоны, но в отличии от других
систем для работы с шаблонами, вставка новых кусков текста, может сильно зависеть от
текущего контекста, например, вставка пары =get/set= может производиться только внутри
объявления класса, или вставка объявления новой функции может производиться только вне
какой-либо другой функции.

Основной командой, используемой для вставки шаблонов, является функция =srecode-insert=,
которая привязана к сочетанию клавиш =C-c / /=.  Эта функция запросит у вас имя шаблона,
которое вы можете ввести, используя механизмы дополнения.  В зависимости от текущего
контекста, список доступных шаблонов может меняться.  Если вы хотите вставить тот же самый
шаблон еще раз, то в можете воспользоваться командой =srecode-insert-again= (=C-c / .=),
которая вставит последний использованный шаблон.

Шаблоны также могут определять собственные привязки клавиш -- для них зарегистрирован
диапазон сочетаний =C-c / [a..z]=, и пользователь может указать в шаблоне какая клавиша
будет к нему привязана -- например, для C++ использование сочетания =C-c / c= приведет к
вставке шаблона для класса.  

Сочетания клавиш, использующие заглавные буквы, зарезервированы для шаблонов и команд,
определенных в Srecode.  Например, =C-c / G= (=srecode-insert-getset=) вставляет пару функций
=get/set= для заданной переменной-члена класса, а =C-c / E= (=srecode-edit=) используется для
редактирования шаблонов.  Число этих команд регулярно меняется, поэтому для получения
полного их списка, лучше посмотреть в документацию.

Кроме шаблонов поставляемых вместе с CEDET, пользователь может определять собственные
шаблоны и сохранять их в каталоге =~/.srecode=, где CEDET найдет их автоматически.  Про
создание шаблонов вы можете прочитать в руководстве для данного пакета, которое входит в
состав документации, поставляемой вместе с CEDET.

* Дополнительные пакеты

Вместе с автономной версией CEDET поставляется некоторое количество дополнительных
пакетов, часто находящихся в каталоге =contrib= дистрибутива, который надо добавить в пути
поиска пакетов.

** Пакет eassist

Пакет *eassist* реализует несколько дополнительных команд, которые в своей работе используют
информацию, полученную от Semantic.  По умолчанию эти команды не имеют предопределенных
привязок клавиш, поэтому вам необходимо самим назначить нужные клавиши, если вы планируете
пользоваться этими командами.

Функция =eassist-list-methods=, запущенная в файле с исходным кодом, показывает список
функций в этом файле, позволяя выполнить быстрый переход к выбранной функции.

При разработке на языках C и C++ полезной может оказаться функция =eassist-switch-h-cpp=,
которая выполняет переключение между подключаемым файлом и файлом реализации (если они
имеют одинаковые имена, но разные расширения файлов).

<div id="rule">[[./index][На главную страницу]]</div>

Footnotes: 
[1] Вы можете использовать следующие конфигурационные файлы в качестве основы для вашей
    конфигурации: [[https://gist.github.com/3968635][автономные версии 1.1 и ранее]],
    [[https://gist.github.com/3930120][версии после 1.1 & входящие в состав GNU Emacs]].

[2] Существует также функция =semantic-complete-analyze-inline=, которая отображает список
    возможных дополнений в отдельном окне, часто более удобно чем использование
    графического меню.

[3] В том случае, если дополнение имен работает неправильно, то попробуйте
    проанализировать почему это происходит, и лишь затем отправлять сообщение об ошибке в
    список рассылки.  Описание процесса отладки вы можете найти в Semantic User Guide в
    разделе *Smart Completion Debugging*.

;  LocalWords: emacs ede cedet localwords lang autoloads Makefile xargs ECB src etags gcc
;  LocalWords:  Speedbar JDEE LocalWords CVS тагах Senator Semantic Srecode SPC Global GNU
;  LocalWords:  semantic-ia emacs-lisp my-cedet-hook senator-complete-symbol ac-sources
;  LocalWords:  semantic-analyze-proto-impl-toggle semantic-ia-complete-symbol el-get
;  LocalWords:  semantic-complete-analyze-inline senator-completion-menu-popup add-hook
;  LocalWords:  semantic-ia-complete-symbol-menu semantic-complete-self-insert clang
;  LocalWords:  semantic-analyze-possible-completions TAB tooltip fringle C-c репозитории
;  LocalWords:  semantic-ia-complete-tip semantic-idle-completions-mode auto-complete
;  LocalWords:  my-c-mode-cedet-hook semantic-ia-show-doc senator-fold-tag add-to-list
;  LocalWords:  global-semantic-tag-folding-mode global-semantic-folding-mode bovine
;  LocalWords:  hideshow senator-unfold-tag senator-copy-tag senator-pulse-tag semantic
;  LocalWords:  senator-search-set-tag-class-filter ac-source-semantic-raw semantic-gcc
;  LocalWords:  senator-isearch-toggle-semantic-mode ac-source-semantic c-mode-cedet-hook
;  LocalWords:  ac-source-gtags c-mode-common-hook semanticdb el programming
