#title Настройка Emacs & Cedet для программирования на C & C++
#keywords c, c++, emacs, cedet, programming, semantic, ede, программирование

Этот рассказ не претендует на звание полного описания настройки Emacs как среды разработки
на разных языках (это будет [[emacs-devenv/index][отдельная статья]]), а является попыткой написать краткий
рассказ о настройке пакета [[http://cedet.sf.net][Cedet]] для работы с языками программирования C & C++, хотя
большая часть изложенного подходит и к работе с другими языками, поддерживаемыми пакетом
Cedet.

<contents>

* Что такое Cedet?

Пакет Cedet объединяет в своем составе несколько пакетов, реализующих различную
функциональность, но объединенных вокруг одной задачи по работе с исходным кодом на
различных языках программирования.

 - Semantic -- является основой для построения анализаторов для различных языков
   программирования, позволяя использовать общее представление извлеченной информации для
   разных языков, используя которую реализуется остальной функционал не только Cedet, но и
   других пакетов -- [[http://jdee.sourceforge.net/][JDEE]] и [[http://ecb.sf.net][ECB]], которые являются попыткой создать среды разработки,
   близкие по виду к имеющимся на рынке (Eclipse, NetBeans и т.п.);
 - SemanticDB -- входит в состав Semantic, и реализует интерфейсы к разным модулям
   хранения информации, используемой при дополнении имен, навигации по коду и т.п.
   Синтаксическая информация может сохраняться между сессиями работы в Emacs, что
   уменьшает потребность в регулярном разборе одного и того же кода;
 - Senator -- реализует функциональность для навигации по синтаксической информации,
   извлеченной Semantic;
 - Srecode -- библиотека для генерации кода основываясь на существующей синтаксической
   информации, в том числе и полученной в результате работы Semantic;
 - EDE -- реализует набор расширений, которые позволяют работать с проектами -- управлять
   списком целей для сборки, выполнять сборку проекта и т.п.  Кроме того, используя
   концепцию проекта, существует возможность более точного использования Semantic для
   дополнения имен и другой функциональности;
 - Speedbar -- используется для отображения информации о текущем буфере, основываясь на
   данных из различных источниках -- Semantic, специализированные провайдеры информации
   (например, для texinfo & html) и т.п.
 - Eieio -- реализация CLOS-like (Common Lisp Object System) инфраструктуры для Emacs
   Lisp;
 - Cogre -- библиотека для отрисовки UML-подобных диаграм в буфере Emacs с базовой
   интеграцией с Semantic.

* Установка Cedet

Лучше всего в настоящее время пользоваться версией Cedet находящейся в репозитории на
[[http://sourceforge.net/cvs/?group_id=17886][Sourceforge.net]].  После загрузки данных из репозитория, необходимо скомпилировать пакет
воспользовавшись следующей последовательностью команд:

<src lang="sh">
find . -name Makefile|xargs touch
make clean && make autoloads && make -k all
</src>

Первая команда необходима, поскольку файлы Makefile, используемые для сборки, генерируются
из файлов Projects.ede, и при извлечении из репозитория имеют неправильную дату, что
приводит к ошибкам сборки.[1] 

* Базовая настройка пакета

<src lang="emacs-lisp">
(load-file "~/emacs/cedet/common/cedet.el")

;; если будете использовать проекты, то необходимо установить соответствующий режим
(global-ede-mode t)
</src>

** Настройка Semantic

В зависимости от того, какие возможности вы хотите получить от Semantic, вы можете
воспользоваться одной из команд для загрузки соответствующих наборов функциональности (они
перечислены в порядке возрастания реализованных функций, и каждый следующий включает в
себя предыдущие наборы функциональности):

 - =semantic-load-enable-minimum-features= -- включает только необходимый минимум
   возможностей -- поддержание актуальности синтаксической информации для текущего буфера,
   сохранение синтаксической информации для последующего использования (Semanticdb) и
   подгрузку существующей информации Semanticdb и Ebrowse;
 - =semantic-load-enable-code-helpers= -- включает =senator-minor-mode= для навигации по
   буферу, =semantic-mru-bookmark-mode= для запоминания и навигации между тагами, и
   =semantic-idle-summary-mode=, который показывает информацию для тага под курсором;
 - =semantic-load-enable-gaudy-code-helpers= -- включает =semantic-stickyfunc-name= для
   отображения имени текущей функции в самой верхней строке буфера,
   =semantic-decoration-mode= для декорирования тагов, используя различные аттрибуты, и
   =semantic-idle-completion-mode= для генерации списка возможных дополнений имен, если
   пользователь останавливает свою работу на некоторое время;
 - =semantic-load-enable-excessive-code-helpers= -- подключает =which-func-mode=, который
   отображает имя текущей функции в строке состояния;
 - =semantic-load-enable-semantic-debugging-helpers= -- включает несколько режимов, которые
   полезны при отладке Semantic -- показ ошибок разбора кода, состояния парсера и т.п.

Таким образом, вам необходимо поместить вызов одной из функций в файл инициализации после
загрузки Cedet.  Например, вот так

<src lang="emacs-lisp">
(semantic-load-enable-excessive-code-helpers)
</src>

Чтобы использовать возможности по дополнению имен и показу информации о функциях и
классах, вам необходимо загрузить пакет =semantic-ia= с помощью следующей команды:

<src lang="emacs-lisp">
(require 'semantic-ia)
</src>

После загрузки этого пакета, вы получите возможность использования соответствующего
функционала, описанного ниже.

*** Системные подключаемые файлы

Если вы используете GCC для программирования на C & C++, то пакет может автоматически
получить данные о нахождении системных подключаемых файлов.  Для этого вам нужно загрузить
пакет =semantic-gcc= с помощью следующей команды:

<src lang="emacs-lisp">
(require 'semantic-gcc)
</src>

Вы также можете явно задать дополнительные пути поиска подключаемых файлов, которые будут
использоваться при работе в определенном режиме.  Для этого используется команда
=semantic-add-system-include=, которой передается два параметра -- путь к заголовочным
файлам, и имя режима в котором этот путь будет использоваться.  Например:

<src lang="emacs-lisp">
(semantic-add-system-include "~/exp/include/boost_1_37" 'c++-mode)
</src>

*** Оптимизация работы Semantic

Для оптимизации поиска тагов вы можете использовать несколько приемов:
 - Ограничить область поиска путем настройки проекта EDE, как это описано ниже;
 - Явно указать список корневых каталогов для ваших проектов, так что Semantic будет
   использовать ограниченное количество баз тагов;
 - Заранее сгенерировать базы данных тагов для часто используемых каталогов (=/usr/include=,
   =/usr/local/include=, и т.п.) с помощью команд =semanticdb-create-ebrowse-database= или
   =semanticdb-create-cscope-database=;
 - Ограничить диапазон поиска с помощью настройки переменной
   =semanticdb-find-default-throttle= для конкретных режимов, например, не использовать
   информацию о системных подключаемых файлов, убрав директиву =system= из списка объектов
   поиска для режима =c-mode=:
<src lang="emacs-lisp">
(setq-mode-local c-mode semanticdb-find-default-throttle
								 '(project unloaded system recursive))
</src>

Кроме того, вы можете указать Semantic, что он должен извлекать синтаксическую информацию
из текущего буфера только тогда, когда Emacs ничего не делает.  Для этого вам необходимо
включить =semantic-idle-scheduler-mode=, а для настройки времени ожидания (в секундах)
используется переменная =semantic-idle-scheduler-idle-time=.

*** Интеграция с *imenu*

Пакет Semantic умеет интегрироваться с пакетом *imenu*, который позволяет отображать меню со
списком функций переменных и т.п. информацией.  Для включения этой поддержки, вам
необходимо добавить следующий код в файл инициализации:

<src lang="emacs-lisp">
(defun my-semantic-hook ()
  (imenu-add-to-menubar "TAGS"))
(add-hook 'semantic-init-hooks 'my-semantic-hook)
</src>

** Настройка Semanticdb

Если вы использовали стандартный механизм загрузки компонентов Cedet, то Semanticdb будет
загружен автоматически.  Иначе, вы можете загрузить и включить его с помощью следующих
команд:

<src lang="emacs-lisp">
(require 'semanticdb)
(global-semanticdb-minor-mode 1)
</src>

Для настройки поведения Semanticdb используется некоторое количество переменных, которые
позволяет указать вам куда сохранять данные, а также другие параметры.  Эти переменные
можно настроить через группу настройки =semanticdb=.

Кроме того, Semanticdb может использовать базы данных, сгенерированные внешними утилитами
-- =gtags= из состава [[http://www.gnu.org/software/global/][GNU Global]], =ctags=, =ebrowse= & =cscope=.  Для активации этой поддержки, вы
можете использовать следующий код:

<src lang="emacs-lisp">
;; если вы хотите включить поддержку gnu global
(require 'semanticdb-global)
(semanticdb-enable-gnu-global-databases 'c-mode)
(semanticdb-enable-gnu-global-databases 'c++-mode)

;; включить поддержку ctags 
(semantic-load-enable-all-exuberent-ctags-support)
</src>


** Настройка Semantic для работы с проектами на C & C++

Для правильной работы Semantic с кодом на С & C++ рекомендуется воспользоваться пакетом
EDE (работа с проектами и т.п.) также из поставки CEDET.  Для этих языков, EDE определяет
специальный тип проекта -- =ede-cpp-root-project=, который предоставляет Semantic
дополнительную информацию, используемую для анализа исходных текстов вашего проекта, и
последующего использования информации только для вашего проекта.  Для этого, необходимо
включить соответствующий режим при загрузке пакета.

Для определения проекта используется следующий код:

<src lang="emacs-lisp">
(ede-cpp-root-project "Test"
											:name "Test Project"
											:file "~/work/project/CMakeLists.txt"
											:include-path '("/"
																			"/Common"
																			"/Interfaces"
																			"/Libs"
																			 )
											:system-include-path '("~/exp/include")
											:spp-table '(("isUnix" . "")
																	 ("BOOST_TEST_DYN_LINK" . "")))
</src>

В качестве параметра =:file= вам надо указать любой из файлов, находящихся в корневом
каталоге проекта.  Этот файл никак не анализируется, а служит только отправной точкой для
поиска файлов.   

Для поиска подключаемых файлов используется каталоги из двух списков, которые могут быть
определены в проекте.  Параметр =:system-include-path= используется для задания списка
полных путей каталогов, в которых будет производиться поиск "системных" подключаемых
файлов.  А параметр =:include-path= задает список каталогов, относительно корневого каталога
проекта, в которых будет производиться поиск подключаемых файлов, специфичных для вашего
проекта (заметьте, что имена начинаются со знака =/=, что означает, что имена задаются
относительно корневого каталога проекта).  Вместо явного задания каталогов, вы также
можете задать функцию, которая будет заниматься поиском файлов вашего проекта.  Об этом вы
можете прочитать в руководстве EDE.

Еще один параметр, который может быть задан в проекте -- список определений, которые будут
использоваться при обработке кода препроцессором.  Параметр =:spp-table= позволяет
определить список пар, состоящих из имени символа и свзяанного с ним значения.  В нашем
примере мы определяем два символа =isUnix= и =BOOST_TEST_DYN_LINK=, которые будут переданы
препроцессору, что позволит произвести правильный разбор кода.  Более подробно про эти
определения вы можете прочитать в документации на переменную
=semantic-lex-c-preprocessor-symbol-map=.

* Использование Semantic

С точки зрения пользователя Semantic реализует несколько основных функции -- дополнение
имен, получение информации о тагах (переменных, функциях и т.д.) и навигацию по исходному
коду.  Часть команд реализуется пакетом =semantic-ia=, часть пакетом Senator, и часть --
ядром самого Semantic.

Часть команд не имеет стандартных привязок клавиш, поэтому вам лучше самим выбрать удобные
для вас привязки и привязать к ним нужные команды, например вот так:

<src lang="emacs-lisp">
(defun my-cedet-hook ()
  (local-set-key [(control return)] 'semantic-ia-complete-symbol)
  (local-set-key "\C-c?" 'semantic-ia-complete-symbol-menu)
  (local-set-key "\C-c>" 'semantic-complete-analyze-inline)
  (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle))
(add-hook 'c-mode-common-hook 'my-cedet-hook)
</src>

*Я хотел бы отметить, что работа над Semantic ведется достаточно активно, и в случае
неправильной работы каких-либо компонент, просьба отправлять примеры кода в список
рассылки cedet-devel -- автор реагирует на баг-репорты достаточно оперативно.*

** Дополнение имен

Дополнение имен функций и классов -- достаточно востребованная и часто используемая
функция[2].  В составе Semantic идет два пакета реализующих данную функциональность --
=semantic-ia= и Senator.  Функции реализованные в составе =semantic-ia= используют для
определения списка возможных дополнений функцию =semantic-analyze-possible-completions=,
которая учитывает достаточно много параметров -- области видимости определений, и т.п., и
кроме того, она может быть переопределена пользователем для более точной генерации списка
имен.  В то время как функции Senator используют более простой механизм определения списка
возможных дополнений (в основном используя информацию об определениях в текущем файле),
что иногда ведет к неправильному его формированию, хотя и работает намного быстрее чем
функции =semantic-ia=.

Использование функции =semantic-ia-complete-symbol= при наборе кода приведет к дополнению
соответствующего имени -- функции, переменной или переменной-члена класса, в зависимости
от контекста в котором она была вызвана.  Если существует несколько вариантов, то имя
будет дополнено до наибольшей общей части имени, а при повторном вызове команды, будет
показан буфер со списком всех возможных вариантов имени.  Пользователь может также
воспользоваться функцией =semantic-ia-complete-symbol-menu=, которая также анализирует
контекст в котором она вызвана, и отображает варианты дополнений в виде графического меню,
перемещаясь по которому пользователь может выбрать нужный вариант дополнения[3].  Кроме
того, существует функция =semantic-ia-complete-tip=, которая отображает список возможных
дополнений в виде всплывающей подсказки (tooltip).

Как упоминалось выше, Senator также предоставляет функции для дополнения имен, которые
работают более быстро, но учитывают меньше параметров при генерации списка дополнений.
Функция =senator-complete-symbol= (=C-c , TAB=) дополняет имя для текущего тага, при этом она
сразу подставляет имя первого варианта из списка всех возможных вариантов.  Если вам это
не подходит, то вы можете продолжать вызывать эту функцию для перебора всех вариантов
дополнения имен (что не всегда удобно). В том случае, если вариантов имен много, или вы
хотите посмотреть полный список функций и переменных для какого-то класса, то лучше
воспользоваться функцией =senator-completion-menu-popup= (=C-c , SPC=), которая отображает
список возможных вариантов дополнений в виде графического меню.

Помимо этого, для отдельных языков пользователь может включить специальный режим --
=semantic-idle-completions-mode= (или воспользоваться функцией
=global-semantic-idle-scheduler-mode= чтобы включить его для всех режимов) при котором
дополнения имен начинают показываться спустя некоторое время бездействия.  При этом, в
качестве варианта предлагается первое значение из списка возможных дополнений, и
пользователь может использовать клавишу =TAB= для перебора вариантов.

Для языков с C-подобным синтаксисом, пользователь может воспользоваться командой
=semantic-complete-self-insert=, привязанной к клавишам =.= и =>=, как это показано ниже.

<src lang="emacs-lisp">
(defun my-c-mode-cedet-hook ()
 (local-set-key "." 'semantic-complete-self-insert)
 (local-set-key ">" 'semantic-complete-self-insert))
(add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
</src>

Использование этого кода приведет к тому, что при нажатии =.= или =>= после переменных,
экземпляров класса, будет показан список возможных дополнений для данного класса.

** Получение информации о тагах

Пакет =semantic-ia= реализует несколько команд, которые позволяют разработчику получать
информацию о классах, функциях и переменных.  В качестве документации используются
комментарии, извлеченные из исходного кода, в том числе и используемые для генерации
документации с помощью Doxygen.  В настоящее время реализованы следующие функции:

 =semantic-ia-show-doc= :: показывает документацию для функции или переменной чье имя
   находится под курсором.  Документация показывается в отдельном буфере.  Для переменных
   показывается их объявление, включающее тип, и строка документации, если она есть.  Для
   функций показывается их прототип, и документация по аргументам функции и возвращаемому
   значению;
 =semantic-ia-show-summary= :: показывает документацию для символа под курсором, но при
   информация отображается в мини-буфере, так что пользователь увидит только объявление
   переменной или функции;
 =semantic-ia-describe-class= :: запрашивает у пользователя имя класса и возвращает список
   функций и переменных определенных в данном классе и всех родительских классах.

** Навигация по коду

Одной из самых полезных функций для навигации является функция =semantic-ia-fast-jump=,
которая позволяет переходить к объявлению переменной или функции, чье имя находится под
курсором.  Вернуться назад вы сможете использовав функцию =semantic-mrub-switch-tag= (=C-x
B=), которая доступна при использовании =semantic-mru-bookmark-mode=.

Также в Semantic определено две функции для перехода к объявлению функции или переменной
находящемся в текущем файле -- =semantic-complete-jump-local= (=C-c , j=), или в области
видимости всего проекта -- =semantic-complete-jump= (=C-c , J=).  Обе эти функции позволяют
ввести имя функции или переменной (включая локальные для функций), используя механизмы
дополнения имен, и перейти к данному определению.

Функция =semantic-analyze-proto-impl-toggle= позволяет "прыгать" между объявлением функции и
ее реализацией для языков, поддерживающих раздельное объявление и реализацию.  Еще одной
полезной функцией является =semantic-decoration-include-visit=, которая позволяет
переключиться в заголовочный файл, чье имя находится под курсором.

Senator также реализует несколько функций для навигации в исходном коде.  Сюда относятся
функции =senator-next-tag= (=C-c , n=) и =senator-previous-tag= (=C-c , p=), которые перемещаются
к следующему или предыдущему тагу, а также функция =senator-go-to-up-reference= (=C-c , u=),
которая переходит к "родительскому" тагу  (например, для функции-члена класса,
"родительским" тагом будет объявление класса).

** Поиск использования функции

Недавно в Semantic была добавлена полезная команда -- =semantic-symref=, которая позволяет
найти где символ, чье имя находится под курсором, используется в проекте.  В том случае,
если вы хотите найти данные для символа с произвольным именем, то вам стоит
воспользоваться функцией =semantic-symref-symbol=, которая позволяет вам ввести имя символа
вручную.

При этом, если вхождения символа в соответствующей базе данных (GNU Global и т.п.) не
найдены, то команда попытается найти использование заданного символа с помощью команды
=find-grep=.  В итоге создается вот такой вот буфер с найдеными результатами, используя
который пользователь может перемещаться к нужным частям кода:

<div id="screenshot">
[[../../../common/writings/emacs-devenv/cedet-symref.png]]
</div>

** Свертывание (folding) кода

Поскольку Semantic имеет практически полную синтаксическую информацию об исходных текстах,
то это позволяет реализовать практически такую же функциональность по свертыванию кусков
кода, которая реализуется пакетом *hideshow*.  Для получения этой функциональности вам
необходимо добавить следующий код в ваш файл инициализации:

<src lang="emacs-lisp">
(global-semantic-folding-mode 1)
</src>

и выполнить настройку переменной =global-semantic-tag-folding-mode=.  Это приведет к
появлению небольших треугольников в области значков (*fringle*), нажимая на которые можно
сворачивать или разворачивать соответствующий кусок текста (не только исходного текста, но
и комментариев и других объектов).

В Senator также имеется схожая функциональность, но она в основном предназначена для
работы с объектами верхнего уровня -- функциями, классами и т.п.  Сворачивание участка
кода производится с помощью функции =senator-fold-tag= (=C-c , -=), а разворачивание с помощью
функции =senator-unfold-tag= (=C-c , +=).

** Прочие команды Senator

Пакет Senator определяет некоторое количество команд для работы с тагами -- вырезать или
скопировать текущий таг, вставить его в другом месте, и т.д.  Для вырезания текущего тага
(обычно это определение функции) определена функция =senator-kill-tag= (=C-c , C-w=).
Вставить таг целиком в другом месте можно с помощью стандартной комбинации клавиш =C-y=, в
то время как функция =senator-yank-tag= (=C-c , C-y=) вставляет лишь определение данного тага,
без тела.  Еще одной полезной функцией является =senator-copy-tag= (=C-c , M-w=), которая
копирует текущий таг для последующей вставки, что очень удобно для вставки объявлений
функций в заголовочных файлах.

Senator позволяет изменить поведение стандартных функций поиска (=re-search-forward=,
=isearch-forward= и др.) при работе с исходным кодом таким образом, что функции будут
производить поиск только в соответствующих тага.  Чтобы включить этот режим вы можете
использовать функцию =senator-isearch-toggle-semantic-mode= (=C-c , i=), а с помощью функции
=senator-search-set-tag-class-filter= (=C-c , f=) вы можете ограничить пространство поиска
только указанными классами тагов -- =function= для функций, =variable= для переменных, и т.д.

Вы также можете воспользоваться поиском по тагам не переключаясь явно в режим ограничения
поиска.  Вам нужно лишь вызвать одну из функций: =senator-search-forward= или
=senator-search-backward=.
         
* Работа с Srecode

Пакет Srecode позволяет пользователю определять различные шаблоны, но в отличии от других
систем для работы с шаблонами, вставка новых кусков текста, может сильно зависеть от
текущего контекста, например, вставка пары =get/set= может производиться только внутри
объявления класса, или вставка объявления новой функции может производиться только вне
какой-либо другой функции.

Основной командой, используемой для вставки шаблонов, является функция =srecode-insert=,
которая привязана к сочетанию клавиш =C-c / /=.  Эта функция запросит у вас имя шаблона,
которое вы можете ввести, используя механизмы дополнения.  В зависимости от текущего
контекста, список доступных шаблонов может меняться.  Если вы хотите вставить тот же самый
шаблон еще раз, то в можете воспользоваться командой =srecode-insert-again= (=C-c / .=),
которая вставит последний использованный шаблон.

Шаблоны также могут определять собственные привязки клавиш -- для них зарегистрирован
диапазон сочетаний =C-c / [a..z]=, и пользователь может указать в шаблоне какая клавиша
будет к нему привязана -- например, для C++ использование сочетания =C-c / c= приведет к
вставке шаблона для класса.  

Сочетания клавиш, использующие заглавные буквы, зарезервированы для шаблонов и команд,
определенных в Srecode.  Например, =C-c / G= (=srecode-insert-getset=) вставляет пару функций
=get/set= для заданной переменной-члена класса, а =C-c / E= (=srecode-edit=) используется для
редактирования шаблонов.  Число этих команд регулярно меняется, поэтому для получения
полного их списка, лучше посмотреть в документацию.

Кроме шаблонов поставляемых вместе с Cedet, пользователь может определять собственные
шаблоны и сохранять их в каталоге =~/.srecode=, где Cedet найдет их автоматически.  Про
создание шаблонов вы можете прочитать в руководстве для данного пакета, которое входит в
состав документации, поставляемой вместе с Cedet.

<div id="rule">[[./index][На главную страницу]]</div>

Footnotes: 

[1] Это относится только к сборке пакета из CVS

[3] Существует также функция =semantic-complete-analyze-inline=, которая отображает список
    возможных дополнений в отдельном окне, часто более удобно чем использование
    графического меню.

[2] В том случае, если дополнение имен работает неправильно, то попробуйте
    проанализировать почему это происходит, и лишь затем отправлять сообщение об ошибке в
    список рассылки.  Описание процесса отладки вы можете найти в Semantic User Guide в
    разделе *Smart Completion Debugging*.

;  LocalWords: emacs ede cedet localwords lang autoloads Makefile xargs ECB src
;  LocalWords:  Speedbar JDEE LocalWords CVS тагах Senator Semantic Srecode SPC

;  LocalWords:  semantic-ia emacs-lisp my-cedet-hook senator-complete-symbol
;  LocalWords:  semantic-analyze-proto-impl-toggle semantic-ia-complete-symbol
;  LocalWords:  semantic-complete-analyze-inline senator-completion-menu-popup
;  LocalWords:  semantic-ia-complete-symbol-menu semantic-complete-self-insert
;  LocalWords:  semantic-analyze-possible-completions TAB tooltip fringle C-c
;  LocalWords:  semantic-ia-complete-tip semantic-idle-completions-mode
;  LocalWords:  my-c-mode-cedet-hook semantic-ia-show-doc senator-fold-tag
;  LocalWords:  global-semantic-tag-folding-mode global-semantic-folding-mode
;  LocalWords:  hideshow senator-unfold-tag senator-copy-tag senator-pulse-tag
;  LocalWords:  senator-search-set-tag-class-filter
;  LocalWords:  senator-isearch-toggle-semantic-mode
