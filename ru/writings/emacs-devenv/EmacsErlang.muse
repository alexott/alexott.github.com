#title Работа с Erlang
#keywords emacs, erlang, distel

<contents>

Базовая поддержка Erlang в Emacs осуществляется пакетом erlang-mode, который поставляется
вместе с дистрибутивом Erlang.  Этот пакет обеспечивает реализует основные операции по
работе с исходным кодом на Erlang -- подсветку синтаксиса, расстановку отступов и т.п.  

Кроме того, существуют и другие пакеты, обеспечивающие выполнение операций, не
реализованных в *erlang-mode* -- отладку, профилирование и т.д.  Сюда относятся пакеты
*Distel*[1] и *erlware-mode*.  В то время, как первый пакет является дополнением для
*erlang-mode*, то второй, является прямой модификацией *erlang-mode* добавляющей
дополнительные команды.

* erlang-mode

*erlang-mode* входит в состав дистрибутива Erlang и поэтому доступен для работы сразу после
установки Erlang.  Документация для данного пакета доступна либо с [[http://www.erlang.org/doc/man/erlang_mode.html][сайта Erlang]], либо как
часть справочной документации Erlang, доступной с помощью команды =erl -man erlang_mode=.
Документация достаточно подробная и содержит описания всех основных команд.

Практически все команды реализуемые пакетом доступны для пользователя через меню =Erlang=, а
наиболее часто используемые могут быть выполнены используя сочетания клавиш, описанные ниже.

#erlang-customize
** Установка и настройка пакета

Установка пакета очень проста -- вам необходимо указать путь где находится *erlang-mode*
(обычно это подкаталог в дистрибутиве Erlang), и загрузить пакет =erlang-start=, например,
вот так:

<src lang="emacs-lisp">
(add-to-list 'load-path ".....")
(require 'erlang-start)

(add-to-list 'auto-mode-alist '("\\.erl?$" . erlang-mode))
(add-to-list 'auto-mode-alist '("\\.hrl?$" . erlang-mode))

(setq erlang-root-dir "/opt/local/lib/erlang")
(add-to-list 'exec-path "/opt/local/lib/erlang/bin")
(setq erlang-man-root-dir "/opt/local/lib/erlang/man")
</src>

в этом примере мы дополнительно устанавливаем список расширений, для которых *erlang-mode*
будет включаться автоматически.  А также были изменены пути поиска исполняемых программ,
так что все утилиты Erlang будут запускаться безо всяких проблем.  Две переменных --
=erlang-root-dir= и =erlang-man-root-dir= задают корневого каталога, содержащего дистрибутив
Erlang, а также каталога, содержащего документацию по Erlang.

Кроме того, пользователь может использовать =erlang-mode-hook= для установки различных
параметров, например, вот так:

<src lang="emacs-lisp">
(defun my-erlang-mode-hook ()
	;; when starting an Erlang shell in Emacs, default in the node name
	(setq inferior-erlang-machine-options '("-sname" "emacs"))
	;; add Erlang functions to an imenu menu
	(imenu-add-to-menubar "imenu")
	;; customize keys
	(local-set-key [return] 'newline-and-indent)
	)
;; Some Erlang customizations
(add-hook 'erlang-mode-hook 'my-erlang-mode-hook)
</src>

Данный код устанавливает опции с которыми будет запускаться процесс Erlang, а также
изменяет привязки некоторых клавиш и добавляет список функций Erlang в меню, реализуемое
пакетом *Imenu*.

** Редактирование исходного кода

*erlang-mode* предоставляет пользователю набор команд для работы с кодом.  Сюда можно
отнести команды навигации по коду, его редактирования и правильно расстановки отступов.

Когда вы работаете с кодом функций, состоящих из нескольких отдельных выражений (clause),
то вы можете воспользоваться командой =erlang-generate-new-clause= (она привязана к =C-c C-j=)
для вставки нового выражения в текущей точке -- эта команда берет название функции из
предыдущего выражения, и генерирует новое выражение, оставляя курсор в точке вставки
параметров функции.  В том случае, если параметры нового выражения почти совпадают с
параметрами предыдущего, то вы можете воспользоваться командой =erlang-clone-arguments= (=C-c
C-y=) для копирования параметров из предыдущего выражения и вставки их в текущее выражение.

В зависимости от текущего контекста, клавиши '<code>,</code>', '<code>;</code>',
'<code><</code>' и '<code>></code>' могут вести себя по разному.  Так, если вы находитесь
в конце выражения и нажимаете =;=, то автоматически будет вставлен шаблон для нового
выражения, так как будто вы воспользовались командой =erlang-generate-new-clause=.
Аналогичным образом, ввод =,= в конце подвыражения, приведет к переходу на новую строку и
выставлению правильного отступа.

Для более удобного оформления кода Erlang пользователь может также воспользоваться
командой =erlang-align-arrows= (=C-c C-a=), которая выполняет выравнивание в выделенном
регионе текста стрелок (=->=) после выражений, что улучшает восприятие исходного кода за
счет явного выделения границ выражений.

Достаточно регулярно возникает необходимость в выделении текущего выражения или всей
функции.  В этом случае пользователь может воспользоваться командами =erlang-mark-clause=
(=M-h= или =C-c M-h=) для выделения выражения, или =erlang-mark-function= (=M-C-h=) для выделения
функции целиком.

Для работы с комментариями определено несколько команд.  Для конвертации выбранного
региона в комментарий, пользователь может воспользоваться командой =comment-region= (=C-c
C-c=), которая вставит по одному знаку комментария (=%=) в начало каждой строки региона.  В
том случае, если вы хотите удалить комментарий с региона, то вы можете воспользоваться
командой =erlang-uncomment-region= (=C-c C-u=).  Вы также можете воспользоваться командой
=comment-dwim= (=M-;=) для того, чтобы закомментировать выделенный регион, или вставить
однострочный комментарий в конце существующей строки.

Кроме того, *erlang-mode* реализует команду =erlang-fill-paragraph= (=M-q=) которая пытается
правильно отформатировать текущий параграф комментария, что также позволяет улучшить
читаемость исходного кода.

*erlang-mode* реализует набор команд предназначенных для правильной расстановки отступов в
исходном тексте.  Нажав на клавишу =TAB= вы вызовите команду =erlang-indent-command= которая
сделает правильный отступ для текущей строки.  А для выделенного региона вы можете
использовать стандартную команду =indent-region= (=M-C-\=).  Существуют также отдельные
команды для расстановки отступов в текущем выражении -- =erlang-indent-clause=, функции --
=erlang-indent-function= (=C-c C-q=) и всем буфере -- =erlang-indent-current-buffer=.

** Навигация по коду

В дополнение к стандартным командам перемещения по коду -- следующая/предыдущая скобка, и
т.п., *erlang-mode* предоставляет набор дополнительных команд, которые позволяют выполнять
перемещение среди объектов Erlang -- выражений и функций.  Так, команды
=erlang-beginning-of-function= (=C-a M-a=) и =erlang-end-of-function= (=C-a M-e=) перемещают
курсор в начало и конец текущей функции Erlang[1], а команды =erlang-beginning-of-clause=
(=M-C-a=) и =erlang-end-of-clause= (=M-C-e=) выполняют перемещение курсора в начало или конец
текущего выражения.

Аналогичным образом *erlang-mode* расширяет набор стандартных команд для работы с тегами.
Для использования этих команд вам необходимо создать файл =TAGS=, который может быть
сгенерирован либо с помощью  утилиты =etags= из поставки Emacs, либо с помощью модуля =tags=
из поставки Erlang.  

Используя имеющийся файл =TAGS= вы можете использовать стандартные команды работы с тегами
-- =find-tag= (=M-.=), =tags-apropos=, =tags-search= (=C-x t s=) и другие.  *erlang-mode* добавляет
следующие команды -- =erlang-find-tag=, которая является аналогом =find-tag=, но позволяет
указывать модуль, в котором необходимо производить поиск (если тег задан в форме =module:=
или =module:tag=), =erlang-find-next-tag= (=M-+=), которая ищет следующий тег, и две команды
=erlang-find-tag-other-frame= (=C-x 5 .=) и =erlang-find-tag-other-window= (=C-x 4 .=), которые
открывают определение тега в новом фрейме или окне, соответственно.

Пользователь также может использовать команду =erlang-complete-tag= (=M-TAB=) для дополнения
имен известных функций, используя данные из файла =TAGS=.

** Использование шаблонов кода

Для облегчения работы пользователя, *erlang-mode* имеет в своем составе набор шаблонов кода,
которые могут вставляться пользователем используя пункт =Skeletons= меню =Erlang= или
используя команду  =tempo-template-erlang-XXX=, где =XXX= -- название шаблона.  Для вставки
шаблонов используется пакет *tempo* входящий в состав Emacs.  В настоящее время пакет
предоставляет следующие классы шаблонов:
 - заготовки для простых конструкций типа =if=, =case=, =receive= и т.д.;
 - заготовки для "стандартных" стилей оформления заголовков файлов -- название модуля,
   автор модуля и т.д.;
 - заготовки для различных стандартных серверов (*behaviour* в терминологии Erlang) --
   =gen_server=, =application=, =gen_fsm= и т.д.

** Компиляция и работа с =erl=

Пользователь может интерактивно выполнять команды Erlang используя процесс =erl= запущенный
в буфере Emacs (процесс запускается через =comint=, так что пользователь может использовать
стандартные возможности этого пакета, например перемещения по истории команд с помощью
клавиш =M-p= и =M-n=).  Этот же процесс используется *erlang-mode* для выполнения компиляции
исходного кода.

Для запуска нового процесса =erl= пользователь может воспользоваться командой =erlang-shell=,
но он также может быть запущен неявно при выполнении команды компиляции или переключения в
буфер =*erlang*= с помощью команды =erlang-shell-display= (=C-c C-z=).

Компиляция и загрузка кода из текущего модуля осуществляется с помощью команды
=erlang-compile= (=C-c C-k=).  В том случае если пользователь передаст этой команде префиксный
аргумент, то компиляция будет осуществлена с использованием отладочных опций =debug_info= и
=export_all=.  Для просмотра результатов компиляции пользователь может воспользоваться
командой =erlang-compile-display= (=C-c C-l=).  Для перемещения между найденными ошибками
используется команда =erlang-next-error= (=C-x `=).  В том случае, если вы хотите заново
переместиться на первую найденную ошибку, то вам необходимо передать префиксный аргумент
этой команде, например, вот так -- =C-u C-x `=.

* Настройка  flymake для работы с Erlang

Пакет *flymake*, входящий в поставку Emacs, позволяет выполнять проверку корректности кода
на лету.  Erlang пока не входит в список языков, поддерживаемых "из коробки", но мы можем
достаточно легко исправить это упущение[3].

Если вы еще не использовали *flymake*, то во первых вам необходимо загрузить его с помощью
следующей команды:

<src lang="emacs-lisp">
(require 'flymake)
</src>

Затем нам необходимо написать процедуру, которая будет правильно инициализировать *flymake*,
так чтобы он мог работать с кодом на Erlang.  Эта процедура будет захватывать код по мере
набора и будет передавать его скрипту на Erlang, который и будет проверять код на наличие
ошибок.  Процедура выглядит следующим образом:

<src lang="emacs-lisp">
(defun flymake-erlang-init ()
  (let* ((temp-file (flymake-init-create-temp-buffer-copy
										 'flymake-create-temp-inplace))
				 (local-file (file-relative-name
											temp-file
											(file-name-directory buffer-file-name))))
    (list "~/emacs/bin/eflymake" (list local-file))))
</src>

Путь к скрипту указывается в теле процедуры, так что вам необходимо изменить путь в том
случае, если он находится в другом месте.  Сам скрипт достаточно прост -- он получает имя
файла и пытается выполнить компиляцию кода, возвращая список ошибок и предупреждений: 

<src lang="erlang">
#!/usr/bin/env escript
-export([main/1]).

main([File_Name]) ->
    compile:file(File_Name, [warn_obsolete_guard, warn_unused_import,
    			    		   warn_shadow_vars, warn_export_vars,
					   strong_validation, report]).
</src>

После написания процедуры и скрипта, нам необходимо указать *flymake*, что он должен
использовать указанную процедуру для проверки файлов с расширением =.erl=, что делается с
помощью следующего кода.

<src lang="emacs-lisp">
(add-to-list 'flymake-allowed-file-name-masks
						 '("\\.erl\\'" flymake-erlang-init))
</src>

На этом подготовительные действия заканчиваются и вы можете либо разрешить использовать
*flymake* глобально, с помощью добавления хука открытия файла:

<src lang="emacs-lisp">
(add-hook 'find-file-hook 'flymake-find-file-hook)
</src>

либо явно включать режим *flymake* для нужных режимов, например, вот так:

<src lang="emacs-lisp">
(defun my-erlang-mode-hook ()
	(flymake-mode 1))
(add-hook 'erlang-mode-hook 'my-erlang-mode-hook)
</src>

После этого, при открытии файла с расширением =.erl= режим *flymake* будет включаться
автоматически, и вы будете видеть результаты проверки по мере набора вашего кода.  По
умолчанию, строки содержащие ошибки выделяются светло-розовым цветом, а строки, вызывающие
появление предупреждений -- светло-голубым[4].  Пример вы можете увидеть на скриншоте:

[[erlang-flymake.png]]

В данном примере, функции =some_wrong_function= не существует, и поэтому Erlang не может ее
найти и рапортует об ошибке.  А объявление функции подсвечено из-за того, что параметр =Fun=
не используется в теле функции, что приводит к получению предупреждения.

; ======================================================================

<div id="rule">[[./index][На главную страницу]]</div>

Footnotes: 
[1] На самом деле, этот пакет является реализацией Erlang-подобного стиля программирования
    для Emacs Lisp.  *erlang-extended-mode*, реализуемый этим пакетом, построен на основе
    библиотеки, обеспечивающей взаимодействие с процессами Erlang.

[2] Вы также можете задать числовой префикс для этих команд, что обеспечит пропуск
    соответствующего количества функций Erlang.

[3] Данный раздел основан на информации, полученной из [[http://weblog.hypotheticalabs.com/?p=265][блога Hypothetical Labs]].

[4] Вы можете сами указать нужные цвета, отредактировав параметры начертаний
    =flymake-errline= & =flymake-warnline=.

;  LocalWords:  flymake Erlang erl init src erlang lang
