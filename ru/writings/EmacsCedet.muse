#title Настройка Emacs & Cedet для программирования на C & C++
#keywords c, c++, emacs, cedet, programming, semantic, ede, программирование

Этот рассказ не претендует на звание полного описания настройки Emacs как среды разработки
на разных языках (это будет [[emacs-devenv/index][отдельная статья]]), а является попыткой написать краткий
рассказ о настройке пакета [[http://cedet.sf.net][Cedet]] для работы с языками программирования C & C++, хотя
большая часть изложенного подходит и к работе с другими языками, поддерживаемыми пакетом
Cedet.

* Что такое Cedet?

Пакет Cedet объединяет в своем составе несколько пакетов, реализующих различную
функциональность, но объединенных вокруг одной задачи по работе с исходным кодом на
различных языках программирования.

 - Semantic -- является основой для построения анализаторов для различных языков
   программирования, позволяя использовать общее представление извлеченной информации для
   разных языков, используя которую реализуется остальной функционал не только Cedet, но и
   других пакетов -- JDEE, ECB;
 - SemanticDB -- входит в состав Semantic, и реализует интерфейсы к разным модулям
   хранения информации, используемой при дополнении имен, навигации по коду и т.п.
   Синтаксическая информация может сохраняться между сессиями работы в Emacs, что
   уменьшает потребность в регулярном разборе одного и того же кода;
 - Senator -- реализует функциональность для навигации по синтаксической информации,
   извлеченной Semantic;
 - Srecode -- библиотека для генерации кода основываясь на существующей синтаксической
   информации, в том числе и полученной в результате работы Semantic;
 - EDE -- реализует набор расширений, которые позволяют работать с проектами -- управлять
   списком целей для сборки, выполнять сборку проекта и т.п.  Кроме того, используя
   концепцию проекта, существует возможность более точного использования Semantic для
   дополнения имен и другой функциональности;
 - Speedbar -- используется для отображения информации о текущем буфере, основываясь на
   данных из различных источниках -- Semantic, специализированные провайдеры информации
   (например, для texinfo & html) и т.п.
 - Quickpeek --
 - Eieio -- реализация CLOS-like (Common Lisp Object System) инфраструктуры для Emacs
   Lisp;
 - Cogre -- библиотека 

* Установка Cedet

Лучше всего в настоящее время пользоваться версией Cedet находящейся в репозитории на
[[http://sourceforge.net/cvs/?group_id=17886][Sourceforge.net]].  После загрузки данных из репозитория, необходимо скомпилировать пакет
воспользовавшись следующей последовательностью команд:

<src lang="sh">
find . -name Makefile|xargs touch
make clean && make autoloads && make -k all
</src>

Первая команда необходима, поскольку файлы Makefile, используемые для сборки, генерируются
из файлов Projects.ede, и при извлечении из репозитория имеют неправильную дату, что
приводит к ошибкам сборки.[1] 

* Базовая настройка пакета

<src lang="emacs-lisp">
(load-file "~/emacs/cedet/common/cedet.el")

;; если будете использовать проекты, то необходимо установить соответствующий режим
(global-ede-mode t)
</src>

** Настройка Semantic

В зависимости от того, какие возможности вы хотите получить от Semantic, вы можете
воспользоваться одной из команд для загрузки соответствующих наборов функциональности (они
перечислены в порядке возрастания реализованных функций, и каждый следующий включает в
себя предыдущие наборы функциональности):

 - =semantic-load-enable-minimum-features= -- включает только необходимый минимум
   возможностей -- поддержание актуальности синтаксической информации для текущего буфера,
   сохранение синтаксической информации для последующего использования (Semanticdb) и
   подгрузку существующей информации Semanticdb и Ebrowse;
 - =semantic-load-enable-code-helpers= -- включает =senator-minor-mode= для навигации по
   буферу, =semantic-mru-bookmark-mode= для запоминания и навигации между тагами, и
   =semantic-idle-summary-mode=, который показывает информацию для тага под курсором;
 - =semantic-load-enable-gaudy-code-helpers= -- включает =semantic-stickyfunc-name= для
   отображения имени текущей функции в самой верхней строке буфера,
   =semantic-decoration-mode= для декорирования тагов, используя различные аттрибуты, и
   =semantic-idle-completion-mode= для генерации списка возможных дополнений имен, если
   пользователь останавливает свою работу на некоторое время;
 - =semantic-load-enable-excessive-code-helpers= -- подключает =which-func-mode=, который
   отображает имя текущей функции в строке состояния;
 - =semantic-load-enable-semantic-debugging-helpers= -- включает несколько режимов, которые
   полезны при отладке Semantic -- показ ошибок разбора кода, состояния парсера и т.п.

Таким образом, вам необходимо поместить вызов одной из функций в файл инициализации после
загрузки Cedet.  Например, вот так

<src lang="emacs-lisp">
(semantic-load-enable-excessive-code-helpers)
</src>

*** Системные подключаемые файлы

Если вы используете GCC для программирования на C & C++, то пакет может автоматически
получить данные о нахождении системных подключаемых файлов.  Для этого вам нужно загрузить
пакет =semantic-gcc= с помощью следующей команды:

<src lang="emacs-lisp">
(require 'semantic-gcc)
</src>

Вы также можете явно задать дополнительные пути поиска подключаемых файлов, которые будут
использоваться при работе в определенном режиме.  Для этого используется команда
=semantic-add-system-include=, которой передается два параметра -- путь к заголовочным
файлам, и имя режима в котором этот путь будет использоваться.  Например:

<src lang="emacs-lisp">
(semantic-add-system-include "~/exp/include/boost_1_37" 'c++-mode)
</src>

*** Оптимизация работы Semantic

Для оптимизации поиска тагов вы можете использовать несколько приемов:
 - Ограничить область поиска путем настройки проекта EDE, как это описано ниже;
 - Явно указать список корневых каталогов для ваших проектов, так что Semantic будет
   использовать ограниченное количество баз тагов;
 - Заранее сгенерировать базы данных тагов для часто используемых каталогов (=/usr/include=,
   =/usr/local/include=, и т.п.) с помощью команд =semanticdb-create-ebrowse-database= или
   =semanticdb-create-cscope-database=;
 - Ограничить диапазон поиска с помощью настройки переменной
   =semanticdb-find-default-throttle= для конкретных режимов, например, не использовать
   информацию о системных подключаемых файлов, убрав директиву =system= из списка объектов
   поиска для режима =c-mode=:
<src lang="emacs-lisp">
(setq-mode-local c-mode semanticdb-find-default-throttle
								 '(project unloaded system recursive))
</src>

Кроме того, вы можете указать Semantic, что он должен извлекать синтаксическую информацию
из текущего буфера только тогда, когда Emacs ничего не делает.  Для этого вам необходимо
включить =semantic-idle-scheduler-mode=, а для настройки времени ожидания (в секундах)
используется переменная =semantic-idle-scheduler-idle-time=.

*** Интеграция с *imenu*

Пакет Semantic умеет интегрироваться с пакетом *imenu*, который позволяет отображать меню со
списком функций переменных и т.п. информацией.  Для включения этой поддержки, вам
необходимо добавить следующий код в файл инициализации:

<src lang="emacs-lisp">
(defun my-semantic-hook ()
  (imenu-add-to-menubar "TAGS"))
(add-hook 'semantic-init-hooks 'my-semantic-hook)
</src>


** Настройка Semanticdb

Если вы использовали стандартный механизм загрузки компонентов Cedet, то Semanticdb будет
загружен автоматически.  Иначе, вы можете загрузить и включить его с помощью следующих
команд:

<src lang="emacs-lisp">
(require 'semanticdb)
(global-semanticdb-minor-mode 1)
</src>

Для настройки поведения Semanticdb используется некоторое количество переменных, которые
позволяет указать вам куда сохранять данные, а также другие параметры.  Эти переменные
можно настроить через группу настройки =semanticdb=.


Кроме того, Semanticdb может использовать базы данных, сгенерированные внешними утилитами
-- =gtags= из состава [[http://www.gnu.org/software/global/][GNU Global]], =ctags=, =ebrowse= & =cscope=.  Для активации этой поддержки, вы
можете использовать следующий код:

<src lang="emacs-lisp">
;; если вы хотите включить поддержку gnu global
(require 'semanticdb-global)
(semanticdb-enable-gnu-global-databases 'c-mode)
(semanticdb-enable-gnu-global-databases 'c++-mode)

;; включить поддержку ctags 
(semantic-load-enable-all-exuberent-ctags-support)
</src>


** Настройка Semantic для работы с проектами на C & C++

Для правильной работы Semantic с кодом на С & C++ рекомендуется воспользоваться пакетом
EDE (работа с проектами и т.п.) также из поставки CEDET.  Для этих языков, EDE определяет
специальный тип проекта -- =ede-cpp-root-project=, который предоставляет Semantic
дополнительную информацию, используемую для анализа исходных текстов вашего проекта, и
последующего использования информации только для вашего проекта.  Для этого, необходимо
включить соответствующий режим при загрузке пакета.

Для определения проекта используется следующий код:

<src lang="emacs-lisp">
(ede-cpp-root-project "Test"
											:name "Test Project"
											:file "~/work/project/CMakeLists.txt"
											:include-path '("/"
																			"/Common"
																			"/Interfaces"
																			"/Libs"
																			 )
											:system-include-path '("~/exp/include")
											:spp-table '(("isUnix" . "")
																	 ("BOOST_TEST_DYN_LINK" . "")))
</src>

В качестве параметра =:file= вам надо указать любой из файлов, находящихся в корневом
каталоге проекта.  Этот файл никак не анализируется, а служит только отправной точкой для
поиска файлов.   

Для поиска подключаемых файлов используется каталоги из двух списков, которые могут быть
определены в проекте.  Параметр =:system-include-path= используется для задания списка
полных путей каталогов, в которых будет производиться поиск "системных" подключаемых
файлов.  А параметр =:include-path= задает список каталогов, относительно корневого каталога
проекта, в которых будет производиться поиск подключаемых файлов, специфичных для вашего
проекта (заметьте, что имена начинаются со знака =/=, что означает, что имена задаются
относительно корневого каталога проекта).  Вместо явного задания каталогов, вы также
можете задать функцию, которая будет заниматься поиском файлов вашего проекта.  Об этом вы
можете прочитать в руководстве EDE.

Еще один параметр, который может быть задан в проекте -- список определений, которые будут
использоваться при обработке кода препроцессором.  Параметр =:spp-table= позволяет
определить список пар, состоящих из имени символа и свзяанного с ним значения.  В нашем
примере мы определяем два символа =isUnix= и =BOOST_TEST_DYN_LINK=, которые будут переданы
препроцессору, что позволит произвести правильный разбор кода.  Более подробно про эти
определения вы можете прочитать в документации на переменную
=semantic-lex-c-preprocessor-symbol-map=.

* Использование Semantic

<src lang="emacs-lisp">
(require 'semantic-ia)
</src>



** Дополнение имен



semantic-ia-complete-symbol
semantic-ia-complete-symbol-menu
senator-complete-symbol (=C-c , TAB=)

semantic-complete-analyze-inline
semantic-decoration-include-visit

** Навигация по коду

semantic-ia-fast-jump
semantic-analyze-proto-impl-toggle

*** Использование Senator


C-c , TAB       senator-complete-symbol
C-c , C-w       senator-kill-tag
C-c , C-y       senator-yank-tag
C-c , SPC       senator-completion-menu-popup
C-c , +         senator-unfold-tag
C-c , -         senator-fold-tag
C-c , ?         senator-pulse-tag
C-c , J         semantic-complete-jump
C-c , f         senator-search-set-tag-class-filter
C-c , i         senator-isearch-toggle-semantic-mode
C-c , j         semantic-complete-jump-local
C-c , n         senator-next-tag
C-c , p         senator-previous-tag
C-c , u         senator-go-to-up-reference
C-c , M-w       senator-copy-tag


* Прочие утилиты и т.п.

 - semantic-symref
 - поддержка gtags
 - srecode?
 - http://www.dr-qubit.org/predictive/completion-ui.el
 - http://www.emacswiki.org/cgi-bin/wiki/CompletionUI#toc4

** eassist

(require 'eassist)
(local-set-key "\C-ct" 'eassist-switch-h-cpp)
(local-set-key "\C-xt" 'eassist-switch-h-cpp)



* Интеграция с другими пакетами

упомянуть про ECB, Speedbar & JDEE


Footnotes: 
[1] Это относится только к сборке пакета из CVS


;  LocalWords: emacs ede cedet localwords lang autoloads Makefile xargs ECB src
;  LocalWords:  Speedbar JDEE LocalWords CVS

