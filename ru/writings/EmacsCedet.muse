#title Настройка Emacs & Cedet для программирования на C & C++
#keywords c, c++, emacs, cedet, programming, semantic, ede, программирование

Этот рассказ не претендует на звание полного описания настройки Emacs как среды разработки
на разных языках (это будет [[emacs-devenv/index][отдельная статья]]), а является попыткой написать краткий
рассказ о настройке пакета [[http://cedet.sf.net][Cedet]] для работы с языками программирования C & C++, хотя
большая часть изложенного подходит и к работе с другими языками, поддерживаемыми пакетом
Cedet.

* Установка Cedet

Лучше всего в настоящее время пользоваться версией Cedet находящейся в репозитории на
[[http://sourceforge.net/cvs/?group_id=17886][Sourceforge.net]].  После загрузки данных из репозитория, необходимо скомпилировать пакет
воспользовавшись следующей последовательностью команд:

<src lang="sh">
find . -name Makefile|xargs touch
make clean && make autoloads && make -k all
</src>

Первая команда необходима, поскольку файлы Makefile, используемые для сборки, генерируются
из файлов Projects.ede, и при извлечении из репозитория имеют неправильную дату, что
приводит к ошибкам сборки.[1] 

* Базовая настройка пакета

<src lang="emacs-lisp">
(load-file "~/emacs/cedet/common/cedet.el")

;; если будете использовать проекты, то необходимо установить соответствующий режим
(global-ede-mode t)
</src>

** Настройка Semantic

В зависимости от того, какие возможности вы хотите получить от Semantic, вы можете
воспользоваться одной из команд для загрузки соответствующих наборов функциональности (они
перечислены в порядке возрастания реализованных функций):

 - =semantic-load-enable-code-helpers= -- 
 - =semantic-load-enable-gaudy-code-helpers= -- 
 - =semantic-load-enable-excessive-code-helpers= -- 
 - =semantic-load-enable-semantic-debugging-helpers= -- 

Если вы используете GCC в качестве компилятора, то пакет может автоматически получить
данные о нахождении системных подключаемых файлов.  Для этого вам нужно загрузить пакет
=semantic-gcc= с помощью следующей команды:

<src lang="emacs-lisp">
(require 'semantic-gcc)
</src>

Вы также можете явно задать дополнительные пути поиска подключаемых файлов, которые будут
использоваться при работе в определенном режиме.  Для этого используется команда
=semantic-add-system-include=, которой передается два параметра -- путь к заголовочным
файлам, и имя режима в котором этот путь будет использоваться.  Например:

<src lang="emacs-lisp">
(semantic-add-system-include "~/exp/include/boost_1_37" 'c++-mode)
</src>

** Настройка Semanticdb

<src lang="emacs-lisp">
;; если вы хотите включить поддержку gnu global
(require 'semanticdb-global)
(semanticdb-enable-gnu-global-databases 'c-mode)
(semanticdb-enable-gnu-global-databases 'c++-mode)

;; включить поддержку ctags 
(semantic-load-enable-all-exuberent-ctags-support)
</src>


** Настройка Semantic для работы с проектами на C & C++

Для правильной работы Semantic с кодом на С & C++ рекомендуется воспользоваться пакетом
EDE (работа с проектами и т.п.) также из поставки CEDET.  Для этих языков, EDE определяет
специальный тип проекта -- =ede-cpp-root-project=, который предоставляет Semantic
дополнительную информацию, используемую для анализа исходных текстов вашего проекта, и
последующего использования информации только для вашего проекта.  Для этого, необходимо
включить соответствующий режим при загрузке пакета.

Для определения проекта используется следующий код:

<src lang="emacs-lisp">
(ede-cpp-root-project "Test"
											:name "Test Project"
											:file "~/work/project/CMakeLists.txt"
											:include-path '("/"
																			"/Common"
																			"/Interfaces"
																			"/Libs"
																			 )
											:system-include-path '("~/exp/include")
											:spp-table '(("isUnix" . "")
																	 ("BOOST_TEST_DYN_LINK" . "")))
</src>

В качестве параметра =:file= вам надо указать любой из файлов, находящихся в корневом
каталоге проекта.  Этот файл никак не анализируется, а служит только отправной точкой для
поиска файлов.   

Для поиска подключаемых файлов используется каталоги из двух списков, которые могут быть
определены в проекте.  Параметр =:system-include-path= используется для задания списка
полных путей каталогов, в которых будет производиться поиск "системных" подключаемых
файлов.  А параметр =:include-path= задает список каталогов, относительно корневого каталога
проекта, в которых будет производиться поиск подключаемых файлов, специфичных для вашего
проекта (заметьте, что имена начинаются со знака =/=, что означает, что имена задаются
относительно корневого каталога проекта).  Вместо явного задания каталогов, вы также
можете задать функцию, которая будет заниматься поиском файлов вашего проекта.  Об этом вы
можете прочитать в руководстве EDE.

Еще один параметр, который может быть задан в проекте -- список определений, которые будут
использоваться при обработке кода препроцессором.  Параметр =:spp-table= позволяет
определить список пар, состоящих из имени символа и свзяанного с ним значения.  В нашем
примере мы определяем два символа =isUnix= и =BOOST_TEST_DYN_LINK=, которые будут переданы
препроцессору, что позволит произвести правильный разбор кода.  Более подробно про эти
определения вы можете прочитать в документации на переменную
=semantic-lex-c-preprocessor-symbol-map=.

* Использование Semantic

** Дополнение имен

<src lang="emacs-lisp">
;; smart completions
(require 'semantic-ia)
(setq-mode-local c-mode semanticdb-find-default-throttle
								 '(project unloaded system recursive))
(setq-mode-local c++-mode semanticdb-find-default-throttle
								 '(project unloaded system recursive))
</src>



semantic-ia-complete-symbol
semantic-ia-complete-symbol-menu
senator-complete-symbol

semantic-complete-analyze-inline
semantic-decoration-include-visit

semantic-ia-fast-jump
semantic-analyze-proto-impl-toggle



* Прочие утилиты и т.п.

 - semantic-symref
 - поддержка gtags
 - srecode?
 - http://www.dr-qubit.org/predictive/completion-ui.el
 - http://www.emacswiki.org/cgi-bin/wiki/CompletionUI#toc4

** eassist

(require 'eassist)
(local-set-key "\C-ct" 'eassist-switch-h-cpp)
(local-set-key "\C-xt" 'eassist-switch-h-cpp)



* Интеграция с другими пакетами

упомянуть про ECB, Speedbar & JDEE


Footnotes: 
[1] Это относится только к сборке пакета из CVS


;  LocalWords: emacs ede cedet localwords lang autoloads Makefile xargs ECB src
;  LocalWords:  Speedbar JDEE LocalWords CVS

