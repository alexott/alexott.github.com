#title Работа с Git
#keywords emacs, git, magit, git.el, gitsum, git-emacs, egg, git-blame, egit, гит, емакс

<contents>

Появление и популярность системы контроля версий *Git* связана с разработкой операционной
системы *Linux*.  Первоначально данная система разрабатывалась для обеспечения работы над
ядром операционной системы, но затем она стала применяться и в других проектах с открытым
исходным кодом. Поскольку над такими проектами работают люди из разных точек земного шара,
то и сама система контроля версий имеет идеологию, позволяющую работу в децентрализованной
среде[1].

Поддержка *Git* может осуществляться несколькими способами -- используя модули поддержки Git
для пакетов *VC* и *DVC*, а также используя пакеты *git.el*, *emacs-git*, *magit* & *egg*.  В первом
случае работа производится через стандартные интерфейсы пакетов *VC* и *DVC*, в то время как
остальные перечисленные пакеты реализуют интерфейсы, позволяющие использовать все
возможности *Git*.  Далее в статье речь пойдет именно об этих пакетах.

* Пакет git.el

** Установка пакета

Установка *git.el* очень проста -- он идет в составе дистрибутива *Git* и находится в
подкаталоге =contrib/emacs/=.  Для компиляции пакета достаточно выполнить команду =make=,
которая также может использоваться для установки пакета (по умолчанию, пакет ставится в
каталог =$HOME/share/emacs/site-lisp=, но вы можете изменить это значение передав параметр
=emacslispdir= команде =make= или просто скопировать нужные файлы в каталог, где Emacs сможет
найти их).

Для использования пакета *git.el*, вам нужно поместить в ваш файл инициализации следующую
команду:

<src lang="emacs-lisp">
(require 'git)
</src>

после выполнения которой вам станут доступны все команды пакета.

** Работа с пакетом git.el

Использование пакета всегда начинается с выполнения команды =git-status=, которая запросит у
вас имя каталога в котором необходимо искать дерево *Git*, и выполнит анализ состояния этого
дерева.  После анализа, будет открыт буфер с именем =*git-status*=, в котором можно будет
выполнять действия с файлами проекта.  Пример вывода в буфера вы можете видеть на рисунке
ниже (в нижней части рисунка вы можете видеть вывод команды =diff=).  Для данного буфера
определен специальный режим -- =git-status-mode=, для которого определенно некоторое
количество команд (и соответствующих им комбинаций клавиш, многие из которых совпадают с
аналогичными клавишами режима *PCL-CVS*, что облегчает переход на использование *Git*).  Все
команды работают только в данном буфере и не могут использоваться вне его.
    
<div id="screenshot">
[[../../../common/writings/emacs-vcs/git-status.png]]
</div>
     
Навигация по списку файлов, отображаемому после выполнения команды =git-status= может
осуществляться как с помощью клавиш курсора, так и с помощью команд =git-next-file= (клавиши
=n= и =SPC=) и =git-prev-file= (клавиша =p=).  Для большинства команд можно задать числовой
аргумент, который позволит изменить поведение команды.  Числовой аргумент вводится путем
набора цифр, а затем вызова нужной команды.  Вы также можете использовать отрицательные
аргументы, добавив знак минус перед набираемыми цифрами.

По умолчанию, все команды выполняются над файлом, на котором стоит курсор, но также
существуют команды для отметки нескольких файлов, над которыми могут выполняться операции.
Сюда можно отнести следующие команды и комбинации клавиш: клавиша =m= (команда
=git-mark-file=) отмечает один файл и перемещает курсор вниз, а с помощью клавиши =M= (команда
=git-mark-all=) вы можете отметить все файлы.  Для снятия пометки с одного файла вы можете
использовать клавиши =u= (=git-unmark-file=) или =DEL= (=git-unmark-file-up=), только стоит
отметить, что первая команда перемещает курсор вниз, а вторая -- вверх.  Для снятия
пометок со всех файлов вы можете использовать команду =git-unmark-all= (сочетание клавиш
=M-DEL=).  Для инверсии пометок можно использовать команду =git-toggle-all-marks= (клавиша =T=).

Практически также как и в *PCL-CVS*, открыть текущий файл можно с помощью команды
=git-find-file= (клавиша =RET= или =f=).  Открыть файл для просмотра можно с помощью клавиши =v=
(команда =git-view-file=).  В том случае, если при слиянии версий в файле возникли
конфликты, то вы можете вызвать команду разрешения конфликтов -- =git-resolve-file= (клавиша
=R=).

Добавление новых файлов в проект осуществляется с помощью команды =git-add-file= (клавиша
=a=), а удаление -- командой =git-remove-file= (клавиша =r=).  Для того, чтобы избавиться от
ненужных файлов, вы можете поместить их в список игнорируемых файлов с помощью команды
=git-ignore-file= (=i=).  Подтверждение изменений осуществляется с помощью команды
=git-commit-file= (клавиша =c=), а отмена изменений в отмеченных файлах -- с помощью команды
=git-revert-file= (=U=).  Сообщения, которые вводятся при подтверждении изменений, можно
просмотреть с помощью команды =git-log-file= (клавиша =l=).
    
Клавиша =d= является префиксом для команд, связанных с отображением изменений.  Самой важной
командой является команда =git-diff-file=, которую можно вызвать нажав <code>=</code> или
<code>d =</code>.  Команда =git-diff-file-base= (=d b=) позволяет выполнить поиск изменений
относительно базового файла.  Команда =git-diff-file-idiff= (=d e=) позволяет выполнить
интерактивный просмотр изменений в текущем файле. А команда =git-find-file-imerge= (=d E=),
позволяет открыть текущий файл в режиме интерактивного применения изменений.  Остальные
команды позволяют выполнить просмотр изменений относительно основной ветки --
=git-diff-file-merge-head= (=d h=), относительно версий файлов пользователя до слияния веток
-- =git-diff-file-mine= (=d m=), и т.п.  Полный список команд вы можете получить из справки.
    
К прочим командам можно отнести команды обновления статуса буфера =git-refresh-status=
(клавиша =g=), выхода из данного буфера используется команда =git-status-quit= (клавиша =q=),
удаления из списка обработанных файлов =git-remove-handled= (клавиша =x=) и получения справки
о работе в данном буфере -- =git-help= (клавиши =h= или =?=).

** Настройка пакета

Настройка пакета осуществляется с помощью стандартных средств настройки Emacs.  Группа
настройки называется =git= и позволяет задать и параметры *Git* и настройки начертаний,
используемых при отображении данных.

#git-emacs
* Пакет git-emacs

Пакет *git-emacs* во реализует примерно те же функции, что и пакет *git.el*, но имеет
некоторые улучшения, в основном в области пользовательского интерфейса.[2]
[[http://tsgates.cafe24.com/git/git-emacs.html][Домашняя страница]] проекта содержит достаточно подробный иллюстрированный мануал, так что
пользователь может быстро научиться пользоваться данным пакетом.

** Установка и настройка

Скачать пакет, и сопутствующие пакеты можно из [[http://github.com/tsgates/git-emacs/tree/master][репозитория разработчика]], и скачав,
поместите их в нужный каталог, и добавьте следующую команду в файл инициализации:

<src lang="emacs-lisp">
(require 'git-emacs)
</src>

Первоначальную настройку пакета можно выполнить с помощью команды =git-config-init=, которая
установит несколько переменных, необходимых для работы Git.  Значение остальных
переменных, можно установить используя группу настройки с именем =git=.

** Работа с существующим репозиторием

Работа с существующим репозиторием начинается с выполнения команды =git-status=,
выполнение которой создаст буфер, в котором будут отображена информация о состоянии
репозитория.  В данном буфере действует специальный режим =git-status-mode= и определены
команды для выполнения операций над файлами и репозиторием в целом.  Команды можно
выполнять с помощью соответствующих привязок клавиш или используя соответствующие пункты
меню =Emacs-Git=, которое появляется при включении данного режима.

Перемещение по буферу производится помощью нескольких команд -- к традиционным =n=
(=git---status-view-next-line=) и =p= (=git--status-view-prev-line=), которые осуществляют
переход к следующему или предыдущему файлу, были добавлены команды =N=
(=git--status-view-next-meaningfull-line=) и =P= (=git--status-view-prev-meaningfull-line=),
которые выполняют переход между измененными файлами.  Кроме того, определены команды для
перехода на первую -- клавиша =<= (=git--status-view-first-line=) и последнюю -- клавиша =>=
(=git--status-view-last-line=) строки списка файлов.

Также как и в других пакетах, пользователь может открыть нужный файл путем перемещения к
нему и нажатия =o= или =RET= (команда =git--status-view-open-file=).  Кроме того, пользователь
может открыть файл только для просмотра с помощью клавиши =v= (=git--status-view-view-file=).

Операции могут выполняться как с отдельными файлами, так и с группами отмеченных файлов.
Установка пометки на конкретный файл может выполняться клавишей =m=
(=git--status-view-mark-and-next=).  Для снятия пометки можно воспользоваться клавишей =u=
(=git--status-view-unmark-and-next=), которая снимает пометку с текущего файла и
перемещается к следующему.  Клавиша =SPC= (=git--status-view-toggle-and-next=) используется в
качестве переключателя отметки файла, изменяя его статус на противоположный.  Кроме того,
можно использовать клавишу =*= (=git--status-view-mark-reg=), которая позволяет отмечать
файлы, чьи имена подпадают под регулярное выражение, введенное пользователем.

Операции с файлами производятся с помощью нескольких команд.  Добавление и удаление файлов
производится командами =git--status-view-add= (клавиша =a=) и =git--status-view-rm= (клавиша =d=).
Если необходимо переименовать файл, то для этого определена команда
=git--status-view-rename=, привязанная к клавише =r=.  Но иногда в каталоге, содержащем
репозиторий, образуются файлы, нужные для работы, но которые нет необходимости помещать в
репозиторий.  В этом случае, пользователь может поместить их в список игнорирования, нажав
на клавишу =i= (=git--status-view-add-ignore=), что приведет к созданию соответствующей записи
в файле =.gitignore=.

** Создание новых репозиториев

Пакет *git-emacs* позволяет создавать новые репозитории двумя способами: клонированием
существующего репозитория, или путем импорта файлов из указанного архива.

Для клонирования существующих репозиториев имеется команда =git-clone=, которая запрашивает
у пользователя имя каталога где будет создан новый репозиторий, адрес репозитория, и если
необходимо, то имя и e-mail пользователя, и запустит асинхронный процесс клонирования, о
завершении которого пользователь будет оповещен сообщением в мини-буфере.

Для импорта файлов из архива, пользователь может воспользоваться командой
=git-init-from-archive=, которая запросит имя архива, имя каталога где будет создан
репозиторий, и прочие данные, и затем запустит процесс импорта данных, в конце которого
пользователь должен ввести описание данного изменения, и подтвердить его путем нажатия =C-c
C-c= как при обычном подтверждении измененных данных.

** Работа с изменениями

Увидеть сделанные изменения пользователь может воспользовавшись командой
=git--status-view-diff-file= (клавиша <code>=</code>), которая отобразит буфер, содержащий
изменения сделанные в выбранном файле.  Эту же операцию можно выполнить и с помощью
глобальной команды =git-diff=.  Обе команды запрашивают у пользователя имя версии с которой
будет производиться сравнение, и затем используют *ediff* для работы со сделанными
изменениями.

Подтверждение сделанных изменений в репозиторий производится с помощью команды
=git-commit-all= (клавиша =c=)[3], выполнение которой открывает новый буфер, в котором
пользователь может ввести описание изменения, и завершить подтверждение путем нажатия
сочетания клавиш =C-c C-c=.

Достаточно часто возникает задача слияния изменений из других веток.  Эта задача может
быть выполнена с помощью команды =git-merge=, запустив которую вы можете выбрать имя ветки
или тага, из которого будете выполнять слияние, и затем, после подтверждения своего
выбора, слияние будет произведено путем выполнения соответствующей команды *git*.  А если в
процессе слияния разных веток, репозиторий оказался в состоянии конфликта, то пользователь
может использовать клавишу =!= (=git--status-view-resolve-merge=) для того, чтобы начать
процесс разрешения конфликтов с помощью =ediff-merge=.

** История изменений

Для получения информации об истории изменений, пакет *git-emacs* определяет несколько
команд: команда =git-history= используется для получения информации об истории изменений
всего проекта.  А для получения информации об изменениях в конкретных файлах, пользователь
может использовать команду =git-log=.  Обе этих команды создают отдельный буфер, содержащих
подробную информацию о сделанных изменениях.

Пользователи привыкшие к использованию утилиты =gitk= могут использовать ее не покидая
Emacs.  Эту утилиту можно запустить как напрямую, из буфера статуса, используя клавишу =k=
(=git--status-view-gitk=), так и явно выполнив команду =gitk=.

Пользователь также может получать информацию о том, какая часть файла была изменена в
конкретных версиях.  В *Git* это реализуется командой =git blame=, а для ее интеграции с Emacs
был создан пакет *git-blame*, описанный [[#git-blame][ниже]].  Пользователь может получить эту информацию,
переместившись к нужному файлу в буфере статуса, и нажав клавишу =?=
(=git--status-view-blame=) -- это приведет к открытию нужного файла и включению в нем
вспомогательного режима =git-blame-mode=.

** Работка с ветками и тагами

Пакет *git-emacs* поддерживает работу с несколькими ветками разработки, существующих в одном
репозитории.  Для этого определена команда =git-branch= при выполнении которой будет создан
отдельный буфер со списком веток, существующих в текущем репозитории.  В данном буфере
пользователь может выполнять команды либо с помощью клавиш, либо используя меню
=Git-Branch=, которое появляется при создании этого буфера.  Текущая ветка всегда отмечена с
помощью знака =*=.

Нажатие клавиши =c= приведет к запросу имени новой ветки, имени базовой ветки и после этого,
к созданию новой ветки разработки.  Выбор другой ветки разработки может быть осуществлен
путем перехода к нужной ветке и нажатия клавиш =s= или =RET=.  Также из этого буфера можно
удалить ненужные ветки.  Это делается с помощью клавиши =d=.

В том случае, если вы не выполняли команду =git-branch= вы все равно можете создавать новые
ветки.  Это может быть выполнено с помощью команд =git-create-branch= или
=git-checkout-to-new-branch=.

Команды работы с ветками можно выполнить и из буфера статуса.  Нажатие на клавишу =z=
(=git-branch=) приведет к созданию буфера, как при выполнении команды =git-branch=.  А
переключиться на другую ветку разработки можно с помощью клавиши =b=
(=git--status-view-switch-branch=).
 
Работа с тагами также достаточно проста.  Вам необходимо выполнить команду =git-tag= или
=git-snapshot=, которые запросят у вас имя тага, и создадут его.  После этого, вы можете
вернуться к нужной версии, выполнив команду =git-checkout= и указав имя нужного тага.  Кроме
этого, вы можете использовать в качестве стартовой точки для новых веток.  Для этого,
нужно при выполнении команды =git-checkout-to-new-branch= указать нужный таг в качестве
основы для новой ветки.

#magit
* Пакет magit

Пакет [[http://zagadka.vm.bytemark.co.uk/magit/][magit]] является еще одной реализацией интерфейса для работы с *Git* из Emacs.  По
сравнению с другими пакетами, он предоставляет более точное отображение идеологии *Git*, но
имеет немного отличающийся, по сравнению с другими пакетами, набор управляющих клавиш, так
что сначала рекомендуется прочитать руководство пользователя, которое поставляется вместе
с пакетом.

** Установка и настройка

Установка пакета проста -- вам необходимо скачать исходные тексты из репозитория, адрес
которого указан на [[http://zagadka.vm.bytemark.co.uk/magit/][домашней странице]] проекта, и установить его, используя следующую
последовательность команд:

<src lang="sh">
sh ./autogen.sh
./configure [опции]
make && make install
</src>

После установки, добавьте в файл инициализации следующую строку:

<src lang="emacs-lisp">
(autoload 'magit-status "magit" nil t)
</src>

которая выполнит загрузку пакета при первом вызове команды =magit-status=.

** Основы работы

Аналогично многим другим режимам, работа с репозиторием начинается с выполнения отдельной
команды.  Для данного пакета это команда =magit-status=, выполнение которой приводит к
запросу имени каталога с репозиторием, и созданию буфера =*magit: имя_каталога*=, который
содержит текущее состояние репозитория, и из которого выполняются все операции используя
специальные клавиши или меню =Magit=.  Примерный вид буфера =*magit: имя_каталога*= вы можете
увидеть на рисунке ниже.

<div id="screenshot">
[[../../../common/writings/emacs-vcs/magit-status.png]]
</div>

Данный буфер содержит несколько списков объектов, соответствующих разным состояниям объектов
в репозитории *Git*: 
 - неизвестные объекты (*untracked*)
 - сохраненные (*stashed*) объекты
 - измененные объекты, но не добавленные в список для следующего подтверждения изменений
   (*unstaged*)
 - объекты, добавленные в список следующего подтверждения изменений (*staged*)
 - подтвержденные изменения, но не синхронизированные с исходным репозиторием (*unpushed*).

Кроме того, если списков *staged* и *unstaged* не существует, то измененные файлы показываются
в списке *changed*.

Между объектами можно перемещаться с помощью клавиш курсора или клавиш =n= & =p=.  Кроме того,
пользователь может быстро перемещаться между списками объектов с разными состояниями с
помощью клавиш =1= (=magit-jump-to-untracked=), =2= (=magit-jump-to-unstaged=), =3=
(=magit-jump-to-staged=) и =4= (=magit-jump-to-unpushed=).

Некоторые операции, которые можно выполнять над объектами, напрямую зависят от того, в
каком состоянии этот объект находится.  Так, например, клавиша =k= (=magit-discard-item=)
приведет к удалению неизвестного объекта, а при применении к измененному объекту, лишь
приведет к откату сделанных изменений.  Она также может использоваться для удаления
сохраненных (*stashed*) изменений.

Кроме удаления неизвестных файлов, можно также поместить их в список игнорирования.  Для
этого определены две команды: =i= (=magit-ignore-item=) помещает текущий объект в файл
=.gitignore=, а =I= (=magit-ignore-item-locally=) вносит его в файл =.git/info/exclude=, который
используется для игнорирования файлов только для текущего репозитория.  Кроме того, если
перед нужно клавишей задать префиксный аргумент, то у пользователя будет запрошено имя
игнорируемого файла, что удобно для ввода масок игнорируемых файлов.

И как обычно, открыть нужный объект в новом буфере можно с помощью клавиши =RET=
(=magit-visit-item=).  

** Работа с изменениями

Подтверждение изменений производится одной из двух команд -- =c= (=magit-log-edit=) или =C=
(=magit-add-log=).  Они обе открывают новый буфер в котором пользователь может ввести
описание изменения, но при этом они немного отличаются оформлением описания.  Для первой
команды пользователь может ввести текст в произвольной форме, тогда как во втором случае,
в буфер вставляется имя файла, что позволяет оформлять описания в виде принятом для файлов
=ChangeLog=.

Но стоит отметить, что изменения подтверждаются немного по разному в зависимости от
состояния репозитория.  Если существует только список измененных файлов (*changed*), то
подтверждаются все изменения из данного списка.  Если пользователь хочет подтвердить
только некоторые изменения, то ему стоит перенести их в список объектов для подтверждения
(*staged*), и уже затем выполнять операцию подтверждения изменений.  Для внесения объекта в
список подтверждения, пользователь может воспользоваться клавишей =s= (=magit-stage-item=),
которая помещает измененный объект в нужный список (для неизвестных файлов это
эквивалентно добавлению файла в репозиторий), удалить из которого можно с помощью клавиши
=u= (=magit-unstage-item=).  Для добавления всех объектов в список подтверждения, определена
клавиша =S= (=magit-stage-all=), и противоположная ей по действию клавиша =U=
(=magit-unstage-all=).

Кроме того, пакет может сохранять сделанные изменения, чтобы их можно было применить
позднее.  Это удобно в тех случаях, если вы не хотите подтверждать изменения в
репозиторий, но вам требуется выполнить какую-нибудь операцию требующую наличие "чистого"
репозитория.  Для этого определена команда =magit-stash=, привязанная к клавише =z=, которая
помещает изменения в список сохраненных (*stashed*) изменений.  После этого, можно выполнить
нужные операции, и после их выполнения, заново применить изменения к рабочим файлам (это
делается с помощью клавиши =a=).  И как упоминалось выше, удалить сохраненные изменения
можно с помощью клавиши =k=.

Пакет *magit* умеет показывать сделанные изменения несколькими способами.  Для просмотра
изменений в конкретном объекте можно воспользоваться клавишей =TAB= (=magit-toggle-section=),
которая показывает изменения сделанные в объекте, на котором находится курсор.  Эта же
клавиша используется и для скрытия показанных изменений.

Для просмотра изменений, внесенных в текущую ветку разработки определена команда =d=
(=magit-diff-working-tree=), которая запросит у пользователя имя ветки с которой надо
провести сравнение, и создаст новый буфер, содержащий изменения.  Для сравнения между
двумя произвольными ветками имеется команда =D= (=magit-diff=), которая запрашивает у
пользователя имена двух веток.  Листать содержимое буфера, создаваемого обоими командами
можно с помощью клавиш =SPC= (вперед) и =DEL= (назад).

И наконец, пользователь может вернуться к определенному подтвержденному состоянию
репозитория с помощью команды =x= (=magit-reset-head=), которая вернет репозиторий к
указанному состоянию (по умолчанию это предыдущее подтвержденное состояние).  Для большего
удобства определена команда =X= (=magit-reset-working-tree=), которая откатывает все сделанные
изменения и восстанавливает состояние на время последнего подтвержденного изменения.

** Работа с историей изменений

Просмотр истории изменений производится командами =l= (=magit-log-head=) и =L= (=magit-log=).
Первая команда отображает историю изменений для текущей ветки разработки, а вторая команда
-- для заданного отрезка истории, данные о котором запрашиваются у пользователя.  Пример
вывода истории изменений вы можете увидеть на рисунке ниже.  При этом стоит отметить, что
*magit* старается отображать изменения в разных ветках, примерно так, как это делает =gitk=.

<div id="screenshot">
[[../../../common/writings/emacs-vcs/magit-history.png]]
</div>

Перемещаясь по истории изменений пользователь может получать подробную информацию о
конкретном изменении нажав на клавишу =RET=.  Кроме этого, можно посмотреть сделанные
изменения между двумя произвольными подтвержденными изменениями.  Для этого, необходимо
отметить одно из нужных изменений с помощью клавиши =.= (=magit-mark-item=), и перейдя ко
второму изменению, нажать на клавишу <code>=</code> (=magit-diff-with-mark=).  Это приведет
к созданию нового буфера, в котором будут отображены соответствующие данные.

Пользователь может выполнять различные операции над конкретными изменениями.  С помощью
команды =a= (=magit-apply-item=) можно применить выбранное изменение к текущей ветке
разработки.  Только стоит отметить, что при выполнении этой команды, пользователю
необходимо будет явно подтвердить изменения, или воспользоваться командой =A=
(=magit-cherry-pick-item=), которая также применит выбранные изменения, но при этом еще и
выполнит подтверждение в репозиторий.  А для отмены изменений сделанных каким-то
конкретным подтверждением изменений можно воспользоваться командой =v= (=magit-revert-item=),
которая аккуратно применит патч в обратном порядке.

Кроме истории изменений репозитория, пользователь может просматривать записи в локальной
истории (*reflog*).  Для этого можно воспользоваться командой =h= (=magit-reflog-head=), которая
отображает *reflog* для текущей ветки разработки, или =H= (=magit-reflog=), которая может
показать данные для двух произвольных точек в истории.  Обе команды создают буфер с
историей изменений, в котором также могут выполняться команды для работы с изменениями,
описанные выше.

Также пакет *magit* реализует набор команд, предназначенных для переписывания истории
изменений, которые позволяют более удобно работать с историей, чем при использовании
сочетания команд =x= (reset head) и =a= (cherry pick).  Данный набор команд имеет общий
префикс =r=.  Для начала работы необходимо нажать =r s=, и у вас будет запрошено имя ревизии,
с которой вы хотите начать работу.  При этом все последующие изменения будут помещены в
специальный список *ожидающих* (*pending*) изменений.  Затем можно использовать команды =a=, =A= &
=v= для применения изменений в нужном вам порядке.  При этом, примененные изменения меняют
свой статус с знака =*= на знак =.= (точка).  Вы также можете явно изменить статус изменения
на нужный, используя команды =r .= и =r *=.

Если у вас что-то пошло не так, то вы можете вернуться к началу работы по переписыванию
истории нажав =r a=.  И завершить работу по переписыванию истории изменений можно с помощью
сочетания =r f=, которое применит все оставшиеся изменения в их обычном порядке, и закончит
работу по переписыванию истории изменений.

** Таги, ветки и сторонние репозитории

Пакет *magit* предоставляет достаточный набор средств для работы с ветками, тагами и
сторонними репозиториями, так что практически все операции можно выполнять не покидая
Emacs.  

Для создания тагов используются команды =t= (=magit-tag=) и =T= (=magit-annotated-tag=).  Они обе
запрашивают у пользователя имя тага, который нужно создать, но вторая команда позволяет
пользователю ввести описание тага, что иногда очень удобно.  После ввода всей необходимой
информации, пакет создает нужный таг, основываясь на текущем состоянии репозитория.

Работа с ветками также достаточно проста.  Для создания новой ветки и переключения в нее
может использоваться команда =B= (=magit-create-branch=) -- она запрашивает у пользователя
лишь имя нужной ветки.  А для переключения между существующими ветками можно
воспользоваться командой =b= (=magit-checkout=), которая запрашивает имя существующей ветки
(можно воспользоваться дополнением имен веток) и переключается в нее.  И для выполнения
=git rebase= пользователь должен использоваться командой =R= (=magit-rebase-step=).

Между ветками можно проводить слияние изменений.  Для автоматического слияния изменений из
указанной ветки можно использовать команду =M= (=magit-automatic-merge=), которая применит все
изменения и подтвердит их в репозиторий.  А если вы хотите просматривать изменения перед
их слиянием, то вам стоит воспользоваться командой =m= (=magit-manual-merge=).  Обе эти
команды получают в качестве аргумента имя ветки из которой будет производиться слияние. 

Пакет предоставляет несколько базовых команд для работы со сторонними репозиториями.
Команда =f= (=magit-remote-update=) получает из стороннего репозитория (*origin*) список
изменений, отсутствующих в текущем репозитории.  Эти изменения можно получить и применить
к текущему репозиторию с помощью команды =F= (=magit-pull=).  Кроме того, если у пользователя
правильно проведена настройка репозитория, то можно воспользоваться командой =P=
(=magit-push=), которая выполнит загрузку изменений в удаленный репозиторий (в данный момент
это только оригинальный репозиторий (*origin*)).

Также недавно в пакет была добавлена базовая поддержка =git svn=.  Если существующий
репозиторий был создан на основе проекта из Subversion, то пользователю становятся
доступными две команды: =N r= (=magit-svn-rebase=) приводит к выполнению команды =git svn
rebase=, которая производит синхронизацию с Subversion, и =N c= (=magit-svn-dcommit=), которая
помещает подтвержденные изменения из репозитория *Git* в репозиторий Subversion.

* Пакет egg

Пакет *egg* является форком пакета [[#magit][magit]], описанного выше.  Основным отличием от *magit*
является улучшение пользовательского интерфейса (пример интерфейса для работы с историей
изменений вы можете видеть на рисунке ниже) и корректная работа на MS Windows, остальной
функционал примерно соответствует пакету *magit*.  Пакет доступен для загрузки с
[[http://github.com/bogolisk/egg/tree/master][сайта разработчика]].

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egg-history.png]]
</div>


* Вспомогательные пакеты

В данном разделе приводятся краткие описания вспомогательных пакетов, которые реализуют
функционал, отсутствующий в многих из пакетов для работы с *Git*.

#git-blame
** git-blame

Данный пакет написан David Kågedal и его можно скачать вместе с пакетом *git-emacs*,
описанного [[#git-emacs][выше]].  Для загрузки пакета поместите в файл инициализации следующую команду:

<src lang="emacs-lisp">
(require 'git-blame)
</src>

или вот эту, если вы хотите, чтобы пакет загрузился только при первом обращении к нему:

<src lang="emacs-lisp">
(autoload 'git-blame-mode "git-blame" "Minor mode for incremental blame for Git." t)
</src>

Для того, чтобы воспользоваться пакетом, пользователь должен включить в нужном буфере
вспомогательный режим =git-blame-mode=.  Это приведет к изменению оформления буфера --
каждая строка будет иметь свое собственное оформление, в зависимости от того, в какой
версии происходило ее изменение.  При этом, при перемещении по буферу, в мини-буфере будет
отображаться информация о версии, в которой изменялась данная строка.

** gitsum

Пакет *gitsum* предназначен для выполнения частичных коммитов в репозиторий *Git*, так, как
это делается при работе с *darcs* через пакет [[./EmacsDarcs][darcsum]].  Для установки пакет, его нужно
скачать из [[http://github.com/chneukirchen/gitsum/tree/master][репозитория]], поместить в каталог, где его найдет Emacs, и добавить следующую
команду в файл инициализации:

<src lang="emacs-lisp">
(require 'gitsum)
</src>

Пакет *gitsum* предоставляет пользователю одну команду -- =gitsum=, которая позволяет
выполнять частичные коммиты используя Emacs.  Для проведения этой операции, пользователю
необходимо выполнить данную команду, находясь в каком-то из файлов, репозитория *Git*.
После ее выполнения, появится буфер, в котором будут отображены изменения, сделанные в
данном репозитории.  

В данном буфере пользователь может перемещаться как между отдельными изменениями (с
помощью клавиш =n= и =p=), так и между измененными файлами (с помощью клавиш =N= и =P=).  Те
изменения, которые вы не хотите включать в данный коммит, могут быть удалены используя
клавишу =k=.  В том случае, если вы не хотите включать все изменения из конкретного файла,
то вы можете воспользоваться клавишей =K= для их исключения из коммита.  После завершения
выбора, достаточно нажать =c= или =C-c C-c= для того, чтобы подтвердить изменения в
репозиторий (после ввода сообщения).  Кроме этого, есть еще одно сочетание клавиш, которое
может быть полезным -- =C-c C-s=, которое позволяет разделить конкретное изменение на два, и
использовать их по отдельности.

Хотелось бы также отметить, что пакет *gitsum* умеет интегрироваться с пакетом *git.el* и его
можно использовать из буфера статуса, запуская с помощью клавиши =s=.

** egit

Данный пакет реализует функциональность, пока отсутствующую в пакете *git.el*.  В основном
это расширения для работы с историей изменений и конкретными изменениями.  Для установки
пакета, его нужно скачать из [[http://github.com/jimhourihan/egit/tree/master][репозитория]], поместить в пути поиска, и добавить следующие
команды в файл инициализации:

<src lang="emacs-lisp">
(autoload 'egit "egit" "Emacs git history" t)
(autoload 'egit-file "egit" "Emacs git history file" t)
(autoload 'egit-dir "egit" "Emacs git history directory" t)
</src>

В пакете определены три команды, которые имеют сходную функциональность, но отличаются
объектом применения.  Команда =egit= работает с репозиторием, =egit-dir= -- с каталогом в
репозитории, а =egit-file= с конкретным файлом в репозитории.  Единственным отличием
является то, что =egit= запрашивает у пользователя информацию о имени ветке или таге, а
также количество записей в истории, которое нужно отобразить.

Все три команды создают отдельный буфер, в котором показывается история изменений, и в
котором определен специальный режим =egit-mode=, позволяющий пользователю выполнять команды
над отдельными изменениями.  Команды могут выполняться как с помощью сочетаний клавиш, так
и через меню =EGit=, которое появляется при создании буфера.  Пример работы в данном буфере
вы можете увидеть на рисунке ниже.

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egit.png]]
</div>

Для перемещения в буфере можно использовать клавиши =n= (=C-n=) и =p= (=C-p=) или клавиши
управления курсором.  По умолчанию, при перемещении между записями, пакет показывает
базовую информацию о текущем изменении -- имя автора, дату изменения, краткое описание
изменения и т.п.  Кроме этого, пользователь может увидеть полный текст описания изменения
(клавиша =RET= или стрелка вправо), список измененных файлов (клавиша =f=) и сами изменения
(клавиша =d=) внесенные в файлы (пример можно увидеть на рисунке ниже).

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egit-diff.png]]
</div>

Помимо просмотра истории, пользователь может заново применить выбранные изменения с
помощью команды =egit-cherry-pick= (клавиша =c=), что приведет к выполнению команды =git
cherry-pick= с нужными флагами.  Также можно откатить изменения сделанные в конкретном
патче -- это выполняется с помощью команды =egit-revert=, для которой нет привязки клавиш
(все-таки она слишком разрушительна), но которую можно вызвать через меню.

<div id="rule">[[./index][На главную страницу]]</div>

Footnotes: 
[1] Хотя существует возможность использования данной системы и в централизованной среде

[2] Стоит отметить некоторые неудобства возникающие при использовании данного пакета --
    некоторые команды пересекаются с командами пакета *git.el*, так что использовать их
    одновременно не получится.  И во вторых, пакет принудительно включает глобальный режим
    ido-mode, что не всегда удобно для пользователей, использующих другие пакеты.

[3] Эту команду можно выполнять не только из буфера статуса, но и воспользовавшись
    глобальной привязкой клавиш =C-x v v=.

;  LocalWords:  magit TODO unstaged untracked unpushed magit-jump-to-unpushed
;  LocalWords:  stashed magit-unstage-all
