#title Типы и протоколы в Clojure
#keywords clojure, кложура, datatype, protocol, defprotocol, reify

Одно из самых больших изменений в Clojure версии 1.2 -- введение в язык новых артифактов:
протоколов (protocols) и типов данных (datatypes).  Данные изменения позволяют улучшить
производительность программ по сравнению с мультиметодами, что в будущем даст возможность
написать Clojure на Clojure.

<contents>

* Что это такое и зачем нужно?

Протоколы и типы данных -- два связанных друг с другом понятия.  Протоколы используются
для определения полиморфных функций, которые затем могут быть реализованы для конкретных
типов данных (в том числе и из других библиотек).

Существует несколько причин введения протоколов и типов данных в новую версию языка:
 - Увеличить скорость работы полиморфных функций, при этом поддерживая большую часть
   функциональности мультиметодов, поскольку для протоколов диспатчеризация выполняется
   только по типу данных.
 - Использовать лучшие стороны интерфейсов (только спецификация функций, без реализации,
   реализация нескольких интерфейсов одним типом), в тоже время избегая недостатков
   (список реализуемых интерфейсов задан во время реализации типа данных, создание
   иерархии типов вида =isa/instanceof=);
 - Избежать [[http://en.wikipedia.org/wiki/Expression_Problem][Expression problem]] и дать возможность расширять набор операций над типами
   данных без изменениях определения типов данных (в том числе и чужих) и перекомпиляции
   исходного кода[1];
 - Использовать высокоуровневые абстракции для типов данных и операций над ними[2], что
   упрощает проектирование программ.

Также как и интерфейсы, протоколы позволяют объединить объявление нескольких полиморфных
функций (или одной функции) в один объект[3].  Отличием от интерфейсов является
то, что вы не можете унаследовать новый протокол от существующего протокола.

В отличии от имеющегося в Clojure =gen-interface= (и соответствующих =proxy/gen-class=)
определение протоколов и типов не требует AOT (ahead-of-time) компиляции исходного кода,
что упрощает распространение программ на Clojure.  Однако при определении протокола,
Clojure автоматически создает соответствующий интерфейс, который будет доступен для кода,
написанного на Java.

Типы данных, определенные с помощью =deftype= или =defrecord= позволяют программисту на
Clojure определять свои структуры данных, вместо использования обычных отображений (на
самом деле =defrecord= реализует тот же интерфейс, что и стандартные отображения, но при
этом он "имеет" тип, для которого можно сделать специализацию протокола).

* Определение протоколов




*Протоколы с одним и тем же именем могут быть определены в разных пространствах имен, так
что стоит быть осторожным и не наделать ошибок при импорте определений и последующей
реализации протоколов!*


* Определение типов данных

 deftype/defrecord/reify



; TODO: написать, что не обязательно реализовывать все функции объявленные в протоколе



* Дополнительные функции

написать про =extend-protocol= & =extend-type=, что первый раскрывается во второй, и может
применяться для нескольких типов.... Также написать про =extend=....

 - в extend-protocol вместо типа может быть указан =nil=, что является специальным случаем -

также про =extends?=, =satisfies?=, =extenders= 


про "наследование" реализаций -
http://fulldisclojure.blogspot.com/2010/08/thoughts-on-protocols.html ?


* Пример использования протоколов и типов данных



* Дополнительная информация

Как всегда, основной источник информации -- сайт языка: ознакомьтесь с разделами [[http://clojure.org/protocols][protocols]]
и [[http://clojure.org/datatypes][datatypes]].  Хорошее описание протоколов и типов данных можно найти в 13-й главе недавно
вышедшей книги [[http://www.amazon.com/gp/product/1430272317?ie=UTF8&tag=aleottshompag-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1430272317][Practical Clojure. The Definitive Guide]].

Stuart Halloway создал очень [[http://vimeo.com/11236603][интересный скринкаст]] в котором он рассказывает о том, зачем
были созданы протоколы и data types, и демонстрирует их применение на небольших примерах.

Введение новых возможностей в язык не обходится без статей в блогах.  Вот ссылки на
некоторые интересные статьи на эту тему:
 - Серия из 3-х статей ([[http://www.objectcommando.com/blog/2010/03/26/clojure-protocols-part-1/][1]], [[http://www.objectcommando.com/blog/2010/03/29/clojure-protocols-part-2/][2]], [[http://www.objectcommando.com/blog/2010/04/12/clojure-protocols-part-3/][3]]) о протоколах в блоге Object Commando;
 - [[http://freegeek.in/blog/2010/05/clojure-protocols-datatypes-a-sneak-peek/][Краткое введение]] в протоколы, написанное Baishampayan Ghose;
 - [[http://formpluslogic.blogspot.com/2010/08/clojure-protocols-and-expression.html][Clojure Protocols and Expression Problem]];
 - Два постинга от Sean Devlin -- [[http://fulldisclojure.blogspot.com/2010/08/thoughts-on-protocols.html][Protocol Implementation Awesomeness]] и
   [[http://fulldisclojure.blogspot.com/2010/08/partially-implemented-protocols.html][Partially Implemented Protocols]];
 - [[http://blog.higher-order.net/2010/05/05/circuitbreaker-clojure-1-2/][Пример реализации паттерна "Circuit Breaker"]] с помощью протоколов;
 - [[http://kotka.de/blog/2010/03/memoize_done_right.html#protocols][Пример использования протоколов]] для мемоизации;
 - [[http://bestinclass.dk/index.clj/2010/04/prototurtle-the-tale-of-the-bleeding-turtle.html][Еще пример]] использования протоколов для реализации turtle graphics;
 - [[http://kirindave.tumblr.com/post/658770511/monkey-patching-gorilla-engineering-protocols-in][Небольшое сравнение]] Monkey Patching в Ruby с протоколами в Clojure;
 - Пример реализации стека с помощью протоколов ([[http://www.viksit.com/content/stack-implementation-clojure-using-protocols-and-records][1]], [[http://www.viksit.com/content/stack-implementation-clojure-ii-functional-approach][2]]), написанный Viksit Gaur;

 

; ================================================================================

 - http://richhickey.github.com/clojure/clojure.core-api.html#clojure.core/deftype
 - http://richhickey.github.com/clojure/clojure.core-api.html#clojure.core/defrecord
 - http://richhickey.github.com/clojure/clojure.core-api.html#clojure.core/reify
 - http://richhickey.github.com/clojure/clojure.core-api.html#clojure.core/defprotocol
 - http://richhickey.github.com/clojure/clojure.core-api.html#clojure.core/extend
 - http://richhickey.github.com/clojure/clojure.core-api.html#clojure.core/extend-protocol
 - http://richhickey.github.com/clojure/clojure.core-api.html#clojure.core/extend-type

 - http://github.com/richhickey/clojure/blob/0d1b2b19065350c5c072b63e912b2415a2c869e6/src/clj/clojure/core/protocols.clj
 - http://github.com/richhickey/clojure/blob/e660e467789ccc8e9922948b3498939e0239fc7c/src/clj/clojure/gvec.clj

 - http://gist.github.com/306174 - пример использования протоколов, написанный Rich Hickey 

 - http://gist.github.com/420036

 - http://groups.google.com/group/clojure/browse_thread/thread/b8620db0b7424712

;  LocalWords:  defprotocol reify datatype protocols datatypes data types AOT
;  LocalWords:  Halloway Stuart injection patching monkey gen-interface proxy

Footnotes: 
[1] Стоит однако отметить, что протоколы не реализуют monkey patching и внедрение методов
    (injection) в существующие типы данных.

[2] Возможность реализации абстракций на Clojure и высокая скорость работы протоколов
    позволит в будущем написать Clojure на самой Clojure, без использования исходного кода
    на Java.

[3] Люди знакомые с Haskell могут рассматривать протоколы как некоторое подобие типов
    классов (typeclasses) в этом языке, правда при этом нельзя определять реализации по
    умолчанию для методов.

;  LocalWords:  gen-class ahead-of-time instanceof
