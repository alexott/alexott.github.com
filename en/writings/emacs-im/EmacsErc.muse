#title Пакет Erc
#keywords

<contents>

* Основные возможности пакета *Erc*

Пакет *Erc* предоставляет для пользователя множество возможностей, вот основные:

 - Поддержку работы с несколькими каналами и серверами. Каждый канал работает в своем
   буфере;
 - Уведомления;
 - Дополнения имен пользователей;
 - Поддержку разных языков;
 - Отслеживание активности на каналах;
 - Расширение возможностей, за счет написания скриптов;
 - Подсветку ключевых слов и различных действий;
 - Взаимодействовать с другими средствами обмена сообщениями, используя BitlBee (более
   подробно о настройке Erc для использования вместе с BitlBee смотрите страницу
   http://www.emacswiki.org/cgi-bin/wiki?BitlBee);
 - и многое, многое другое.

Пакет работает как с GNU Emacs[1], так и с XEmacs.

* Установка пакета

Исходные тексты *Erc* доступны по адресу [[http://sourceforge.net/projects/erc/][http://sourceforge.net/projects/erc/]].  Необходимо
только раскрыть полученный архив, и поместить несколько команд в ваш файл инициализации,
например вот так:

<src lang="emacs-lisp">
(add-to-list 'load-path "path_to_erc_dir")
(require 'erc)
</src>
    
Это минимальный набор команд, необходимых для загрузки данного пакета. Но *Erc*
предоставляет намного больше возможностей, поэтому у человека, который часто пользуется
данным пакетом, файл инициализации выглядит намного сложнее.  Вы можете найти такие
примеры на Emacs WiKi, или в разделе [[#init-file][Пример файла настройки]]. А более подробно про
настройку я расскажу в разделе [[#customization][Настройка пакета]].

* Основные операции

Начала работы вам необходимо набрать команды =M-x erc-select=, которая запросит у вас имя
сервера, порт и другие параметры. Вы можете задать эти параметры один раз произведя
настройку клиента (см. раздел [[#customization][Настройка пакета]]).  В зависимости от настройки, клиент может
сразу подключиться к нужным вам каналам -- это выполняется пакетом *erc-autojoin*, который
поставляется с *Erc*.

После того, как вы подключились к IRC-серверу, вы можете выполняться обычные команды IRC
-- подключение к новым каналам, получение информации и много других вещей. Команды
вводятся в строке, которая начинается с =ERC>=. Окно канала может выглядеть как изображено
на рисунке ниже, кроме того, вы можете использовать стандартные команды Emacs для
разделения фрейма на несколько окон и отображать в них разные каналы.

<div id="screenshot">
[[../../../common/writings/emacs-im/emacs-erc-window.png]]
</div>

Во время работы, erc изменяет строку состояния, в которой отображает имя канала и сервера,
а также изменение статуса других каналов, в виде сокращения =#= и первой буквы имени канала,
и разным цветом, синим -- когда кто-то заходит на канал или покидает в него, и красным
когда кто-то беседует на канале. В верхней строке окна отображается название канала,
текущий лаг, и тема канала. Кроме этого, erc позволяет использовать стандартные механизмы
дополнения имен пользователей и каналов, при их наборе.

Для того, чтобы закончить работу с IRC, наберите команды =erc-quit-server= (=C-c C-q=).

* Модули Erc

В составе *Erc* идет некоторое количество модулей, которые расширяют основную
функциональность пакета. Для каждого из этих модулей пользователь может выполнить
дополнительную настройку, управляющую его поведением. Часть модулей загружается
автоматически, а некоторые требуют индивидуальной загрузки. Список автоматически
загружаемых модулей хранится в переменной =erc-modules=.

Ниже приведен список наиболее часто используемых модулей, и того какие настройки для них
могут выполняться.

** erc-autojoin

Данный пакет позволяет запоминать на какие каналы заходил пользователь используя команды
=/JOIN= и =/PART=, и при следующем сеансе использования erc восстановить сохраненную
конфигурацию.  Список автоматически подключаемых каналов сохраняется в переменной
=erc-autojoin-channels-alist=.  Данная переменная состоит из списков вида "имя сервера"
"канал1" "канал2"..., например:

<src lang="emacs-lisp">
(setq erc-autojoin-channels-alist
   '(("freenode.net" "#emacs" "#arch" "#squiddev")))
</src>
      
      
По умолчанию, данный режим включен, и используется.

** erc-button

Данный модуль позволяет создать нажимаемые кнопки на основе текста буфера.  По умолчанию
данный режим включен, и используется для организации нажимаемых кнопок для самых разных
объектов, таких как:

 - адресов сайтов (URL's);
 - запросов к Google;
 - имен пользователей IRC;
 - RFC (что позволяет сразу перейти к нужному документу);
 - разделов документации в формате Info;
 - интернет-времени.
      
Пользователи могут определять и свои типы, используя механизм сокращений (abbrevs). Кроме
этого, пользователь имеет возможность перехода между кнопками, используя сочетание =C-c C-w
C-b= для перехода на предыдущую кнопку, и =C-c C-w C-f= для перехода на следующую.

** erc-track

Данный модуль позволяет отслеживать изменения в буферах Erc -- данный режим включен по
умолчанию. При использовании данного модуля, в строке статуса отображается список каналов,
в которых произошли изменения.  По умолчанию, отслеживается вся активность -- вход новых
посетителей, выход с канала, и изменение имени, что не всегда нужно знать. С помощью
переменной =erc-track-exclude-types= вы можете исключить некоторые команды из списка
отслеживаемой активности. Например, вот так:

<src lang="emacs-lisp">
(setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT"))
</src>
      
      
Для перехода в буфер, в котором, в последнем была какая-либо активность, вы можете
использовать сочетание клавиш =C-c C-space= или =C-c C-@=.  В том случае, если нет больше
активных каналов, данное сочетание переключает вас в тот буфер, в котором вы работали
перед этим.

** emacs-completion

Данный модуль позволяет использовать дополнение имен каналов и посетителей, а также команд
*Erc*, используя клавишу TAB.  Этот модуль разрешен по умолчанию, и для своей работы
использует программируемый механизм дополнений, который реализуется библиотекой =pcomplete=,
которая обычно поставляется с Emacs.  В том случае, если у вас нет этой библиотеки, вы все
равно можете воспользоваться возможностями дополнения, переключившись на использование
старого механизма, правда это не рекомендуется делать -- лучше установите библиотеку
*pcomplete*.

** erc-fill

По умолчанию *Erc* позволяет красиво заполнять и выравнивать отображаемый текст.  По
умолчанию используется режим заполнения, с переменным префиксом, зависящим от длины имени
посетителя, который написал данное сообщение. Однако вы можете изменить эту настройку с
помощью установки переменной =erc-fill-prefix=, в которой вы можете задать данные для
заполнения -- например, несколько пробелов подряд.  Кроме этого, существуют и другие
варианты заполнения, про которые вы можете прочитать на [[http://www.emacswiki.org/cgi-bin/wiki/ErcFilling][Emacs WiKi]].

** erc-stamp

Кроме всего прочего, *Erc* позволяет вам вставлять в текст буферов временные пометки, для
того, чтобы вам было удобней просматривать журналы бесед, или точно находить нужную
беседу.  По умолчанию данный модуль не подгружается автоматически, так что вам необходимо
добавить его к списку загружаемых модулей.  Для настройки отображения можно задать
несколько переменных, которые будут описывать вид отображаемых временных пометок, и другие
параметры.

** erc-netsplit

Данный модуль обеспечивает определение отключение от сети целых IRC-серверов (так
называемый netsplit), и подключение ранее отключенных серверов. Вы можете выполнять свой
код в данных случаях, воспользовавшись хуками =erc-netsplit-hook= и =erc-netjoin-hook=.

** erc-autoaway

Иногда вы отходите от клавиатуры на длительный срок, и можете забыть сообщить серверу, что
вы отсутствуете. Чтобы это делалось автоматически, с *Erc* поставляется модуль *erc-autoaway*,
который сам изменит режим после заданного отрезка времени. Данный модуль не загружается
автоматически, так что вам нужно самим подключить его, с помощью команд, подобных этим:

<src lang="emacs-lisp">
(require 'erc-autoaway)
(setq erc-autoaway-idle-seconds 600)
(setq erc-auto-discard-away t)
</src>

первая команда подгружает сам модуль, вторая задает через сколько времени вы будете
считаться отсутствующим, а последняя задает режим автоматического выхода из режима
отсутствия, если вы что-то напишете в каком-либо из буферов.

** erc-log

*Erc* позволяет вам сохранять журналы бесед на IRC. Для этого существует модуль
*erc-log*. Однако, данная возможность не подключается автоматически, а требует ручной
загрузки, например вот так:

<src lang="emacs-lisp">
(require 'erc-log)
(setq erc-log-channels-directory "~/.irc/logs/")
</src>
      
первая команда загружает нужный модуль, а вторая задает расположение для журнальных
файлов.

Сохранение журналов может производиться несколькими способами. Для обычных
пользователей, наиболее приемлемым будет использование команды

<src lang="emacs-lisp">
  (setq erc-save-buffer-on-part t)
</src>

что приведет к сохранению журналов при выходе из канала. Однако пользователи могут явно
сохранить журналы с помощью сочетания клавиш =C-c C-l= или явно выполнив команду =M-x
erc-save-buffer-in-logs=. Вы можете также поместить временные метки в сохраняемые журналы
-- это контролируется с помощью переменной =erc-hide-timestamps=.

*Erc* умеет восстанавливать часть содержимого предыдущих сессий используя журнальные
файлы. Если вы хотите, чтобы в буфере отображались старые разговоры, то установите
переменную =erc-log-insert-log-on-open= в истинное значение. По умолчанию, данная переменная
равна =nil=.

Более подробную информацию о настройке журналирования, а также о возможных проблемах, и
способах их решения читайте на [[http://www.emacswiki.org/cgi-bin/wiki/ErcLogging][Emacs WiKi]].

** erc-nickserv

В некоторых IRC-сетях вы можете зарегистрировать свое имя, и таким образом избежать
возможных конфликтов между пользователями.  Эта возможность реализуется с помощью сервиса
под названием *NickServ*. По умолчанию, когда вы входите в такую сеть, в ответ на
приглашение сервера, Erc в мини-буфере запрашивает у вас пароль для регистрации.  Чтобы
избежать повторяющихся действий, был разработан модуль *erc-nickserv*, который идет в
поставке Erc, но не загружается автоматически.  Настройку этого модуля можно выполнить с
помощью следующих команд:

<src lang="emacs-lisp">
(require 'erc-nickserv)
(erc-nickserv-mode t)
(setq erc-prompt-for-nickserv-password nil)
(setq erc-nickserv-passwords
   '((freenode     (("nick" . "password")))))

</src>
      
Первые две команды загружают модуль и включают соответствующий режим. Третья команда
отключает запрос пароля у пользователя при запросе от сервера.  Ну а четвертая команда
задает параметры ассоциативного списка, описывающего сервера, имена и пароли для них. Для
каждого из серверов, вы можете задать одно или несколько имен, и соответствующие пароли
для них.  Заметьте, что в качестве ключа списка задается символ, соответствующий IRC-сети.
Отображение между именами сетей и доменными именами серверов хранится в переменной
=erc-networks=, которую вы при необходимости можете изменять.

** erc-truncate

В том случае, если вы постоянно пользуетесь IRC, размеры буферов с разговорами, могут
расти очень быстро, и поэтому может быть желательно держать их в рамках определенных
размеров. Для этого используется модуль *erc-truncate*, которые следит за размерами буферов
каналов, и при необходимости выбрасывает лишние данные. Данный модуль поставляется с erc,
но не загружается автоматически.

Параметры модуль контролируются несколькими переменными.  Переменная =erc-max-buffer-size=
задает максимальный размер буфера, в байтах.  А если установлена переменная
=erc-truncate-buffer-on-save=, то обрезание буферов будет происходить при сохранении
журналов.  Вы также можете явно выполнить обрезание буферов, используя команду =M-x
erc-truncate-buffer=.

** erc-dcc и erc-xdcc

Для *Erc* реализована поддержка прямой передачи данных между клиентами (DCC), которая
реализуется с помощью модуля *erc-dcc*.  Данный модуль не загружается автоматически, так что
вы должны сделать это сами.  После загрузки этого модуля, вам будут доступны команды =/dcc=,
которые вы можете использовать для разговоров, и для передачи файлов между клиентами.

Кроме этого, в *Erc* реализована возможность организации файловых сервисов, на основе IRC.
Эта возможность реализуется с помощью модуля *erc-xdcc*.

** Прочие модули

Кроме описанных выше модулей существуют еще и другие:

 - *erc-bbdb* -- для интеграции erc и BBDB;
 - *erc-notify* -- для организации оповещения, когда определенный пользователь входит или
   выходит из сети;
 - *erc-smileys* -- для преобразования smileys в изображения с соответствующими эмоциями;
 - *erc-sound* -- для проигрывания звуков при некоторых событиях;
 - *erc-nicklist* -- отображает список имен для данного канала в отдельном буфере;
 - *erc-speedbar* -- обеспечивает интеграцию erc и speedbar;
 - *erc-chess* -- позволяет играть в шахматы с другими пользователями на IRC;
 - *erc-lang* -- реализует новую команду =/lang= для выбора языка на канале;
 - *erc-list* -- обеспечивает быстрый механизм получения списка каналов;
 - *erc-menu* -- добавляет меню к буферам *Erc*, что может быть очень удобно, особенно для
   начинающих пользователей;
 - *erc-speak* -- позволяет проговаривать содержимое разговоров с помощью Emacspeak;
 - *erc-page* -- обеспечивает обработку =/ctcp page= команд;
 - *erc-replace* -- выполняет замены в тексте сообщений.
  
#customization
* Настройка клиента

Настройку *Erc* можно выполнить используя команду =M-x customize-group erc=.  Появившееся окно
настройки позволяет вам задать основные параметры клиента, а также перейти к настройку
разных подсистем клиента. Но кроме визуальной настройки, вы можете и сами определять
порядок инициализации, используя Emacs Lisp.

** Настройка auto-query

*Erc* позволяет настроить свое поведение в отношении личных сообщений.  По умолчанию, они
отображаются в буфере сервера, что не всегда удобно, когда ты разговариваешь с несколькими
людьми.  Однако, с помощью переменной =erc-auto-query= вы можете изменить поведение *Erc*.
Среди разрешенных значений:

 - ='buffer= --  показывать личные сообщения в отдельном буфере;
 - ='window= --  показывать новые сообщения в новом, выбранном окне;
 - ='window-noselect= --  то же, что и предыдущее, но без перехода в новое окно;
 - ='bury= --  создает новый буфер, но не переходит в него;
 - ='frame= --  открывает новый фрейм.
      
Вы можете создавать такие буфера не только для личных сообщений, но и для уведомлений
сервера. Это делается добавлением соответствующего хука.

** Игнорирование и скрытие лишней информации

С помощью *Erc* вы можете делать часть информации невидимой. Это относится как к посетителям
серверов, так и к различным уведомлениям, поступающим от самих серверов.

Например, чтобы не отображать данные о входе и выходе с каналов, вы можете использовать
переменную =erc-hide-list=, в качестве значения которой задается список игнорируемых
команд. Например, вот так:

<src lang="emacs-lisp">
(setq erc-hide-list '("JOIN" "PART"))
</src>
      
Для временного игнорирования сообщений от какого-либо посетителя, вы можете использовать
команду =/IGNORE=, но она будет действовать только до окончания сессии.  Для установки
постоянного игнорирования, вам необходимо в переменной =erc-ignore-list= задать список имен
пользователей, или регулярных выражений, которые будут приводить к игнорированию сообщений
от посетителей, чьи имена и сетевые адреса подпадают под заданное выражение.

Кроме этого, вы можете скрывать часть содержимого, основываясь на более сложных вещах,
например, если кто-то произносит определенные фразы, или разговаривает с роботами, засоряя
канал ненужным текстом.  Как это сделать описано на странице [[http://www.emacswiki.org/cgi-bin/wiki/ErcIgnoring][Emacs WiKi]].

** Настройка подсветки

*Erc* позволяет вам подсвечивать различные части сообщений на канале. Вы можете подсвечивать
текст, имена пользователей, при этом по умолчанию есть разделение на "друзей" и "дураков"
:-) Вы можете задать список имен, и они будут отображаться с заданным оформлением. По
умолчанию этот режим отключен, но вы можете его легко включить с помощью команды =M-x
customize-group= =erc-match=. В этой группе вы также обнаружите опции для настройки списков
друзей, подсветки вашего собственного имени, а также можете задать подсветку произвольного
текста.  Для настройки параметров отображения, воспользуйтесь группой настройки =erc-faces=.

** Настройка кодировок каналов

*Erc* позволяет своим пользователям использовать разные кодовые страницы для разных каналов
(конечно, это только для тех пользователей, которые используют Emacs с поддержкой mule).
Используя переменную =erc-encoding-coding-alist= вы можете задать соответствие между именами
каналов, и кодировками, которые используются на этих каналах. Например, я могу нормально
общаться на немецко-говорящих каналах, хотя на остальных каналах будет использоваться
кодировка koi8-r.

** Хуки

По реализации *Erc*, по большей части управляется событиями, которые обрабатываются
соответствующими хуками.  Существующие хуки можно разделить на несколько больших групп:

 - Хуки для сообщений сервера;
 - Хуки для =/ctcp= команд;
 - Хуки для отображения и ввода;
 - Прочие хуки.

*** Хуки для сообщений сервера

Стандарт для IRC определяет, что сервер должен посылать команды клиентам в специальном
формате. Сама команда может быть либо трехзначным числом, либо именем команды. При
получении данных команд *Erc* запускает соответствующий обработчик, и при его выполнении
также запускает соответствующий хук, который именуется =erc-server-команда-hook=.

*** Хуки для команд =/ctcp=

Для команд =/ctcp= существует два вида хуков -- когда вы получаете запрос на выполнение
команды, и когда вы получаете ответ о выполнении команды.  Соответственно запускаются хуки
=erc-ctcp-query-команда-hook= и =erc-ctcp-reply-команда-hook=.

*** Хуки для отображения и ввода 

Эти хуки также делятся на две группы -- для отображения, и для обработки ввода.

К хукам отображения относятся: 

 - =erc-insert-pre-hook= -- вызывается перед вставкой сообщения в буфер;
 - =erc-insert-modify-hook= -- вызывается когда текст уже вставлен, но при этом, буфер в
   которые вставлен текст, сужается до самого текста;
 - =erc-insert-post-hook= -- вызывается после вставки текста, но может обрабатывать весь
   буфер.
        
К хукам ввода относятся:

 - =erc-send-pre-hook= -- вызывается перед отправкой введенного пользователем сообщения;
 - =erc-send-modify-hook= -- вызывается после вставки текста в буфер, но при этом, буфер в
   которые вставлен текст, сужается до самого текста;
 - =erc-send-post-hook= -- вызывается после вставки текста, но может обрабатывать весь
   буфер.
        
=erc-send-modify-hook= и =erc-send-post-hook= никаким образом не влияют на отправляемый на
сервер текст, и в основном могут использоваться для изменения параметров отображения
текста в буфере.

*** Прочие хуки

 - =erc-mode-hook= -- вызывается для каждого буфера erc -- буферов каналов, буферов серверов
   и т.п.;
 - =erc-timer-hook= -- вызывается при получении любого события от сервера;
 - =erc-before-connect= и =erc-after-connect= -- вызываются перед подключением к конкретному
   серверу, а также после выдачи сервером сообщения дня (MOTD).
          
#init-file       
** Пример файла инициализации Erc

Ниже приведен пример настройки *Erc*, который используется у меня. Я буду писать комментарии
сразу в коде, чтобы сделать его понятным:

<src lang="emacs-lisp">
;; здесь мы просто загружаем erc
(add-to-list 'load-path "~/emacs/erc")
(require 'erc)

;; загружаем авто-подключение к каналам, и задаем список каналов для
;; подключения
(require 'erc-autojoin)
(erc-autojoin-mode t)
(setq erc-autojoin-channels-alist
   '(("relay2" "#dansguardian" "#emacs" "#arch" "#linux.de"
               "#c.de" "#squiddev")))

;; 
(require 'erc-fill)
(erc-fill-mode t)

;; задаем персональные данные, хотя их можно задать и через 
;; M-x customize-group erc
(setq erc-user-full-name "Alex Ott")
(setq erc-email-userid "alexott@gmail.com")

;; часть относящаяся к логированию переговоров на каналах
;; нужно ли вставлять старый лог в окно канала?
(setq erc-log-insert-log-on-open nil)
;; логировать переговоры на каналах?
(setq erc-log-channels t)
;; где будут храниться логи
(setq erc-log-channels-directory "~/.irclogs/")
;; сохранять ли логи при возникновении PART
(setq erc-save-buffer-on-part t)
;; убирать или нет временные отметки?
(setq erc-hide-timestamps nil)
;; максимальный размер буфера канала
(setq erc-max-buffer-size 500000)
</src>
      
большую часть использованных переменных можно установить воспользовавшись командами
настройки Emacs, я показал этот пример только для наглядности.  Вы можете найти большое
количество примеров настройки на страницах [[http://www.emacswiki.org/cgi-bin/emacs-en/EmacsIRCClient][Emacs WiKi]].

* Дополнительная информация 

Вы можете найти огромное количество информации о *Erc* на страницах Emacs WiKi по адресу
[[http://www.emacswiki.org/cgi-bin/emacs-en/EmacsIRCClient][http://www.emacswiki.org/cgi-bin/emacs-en/EmacsIRCClient]].  Там вы сможете найти множество
советов по настройке клиента, а также по интеграции его с различными приложениями,
например, клиентом для игры в шахматы.

<div id="rule">[[./index][Back to main page]]</div>

Footnotes: 
[1] Пакет входит в поставку GNU Emacs версии 22, за исключением некоторых модулей, которым
    требуется наличие пакетов, не входящих в поставку GNU Emacs.

