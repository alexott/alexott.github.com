#title Support for the Scheme programming language
#keywords scheme, emacs, gnu emacs, xemacs, bigloo, guile, plt scheme, mzscheme

The Scheme language traditionally has very good support in Emacs.  This support is
provided by the set of packages, that either could work with different implementation of
Scheme (*scheme-mode*, *cmuscheme*, *quack*), or could work only with concrete implementations
of language (*xscheme*, *gds*, *bee-mode*, *gambit*).  Usually, packages, implemented for concrete
implementations of Scheme, have more features, comparing with packages, designed for work
with different Scheme's implementations.

In this article I'll try to describe all packages, related to the Scheme support.  First,
I'll describe packages, working with all implementations of Scheme, and in the last
sections, I'll describe packages, created for concrete implementations.

<contents>

#scheme-mode
* Scheme-mode

*Scheme-mode*, that is distributed with Emacs, is modification of the *lisp-mode*, adapted to
work with the Scheme programming language.  This package implements following
functionality:
 - syntax highlighting;
 - work with language expressions;
 - indenting of source code;
 - highlighting of the paired brackets.

There are several packages, built on the top of the *scheme-mode* -- [[#cmuscheme][cmuscheme]], [[#xscheme][xscheme]],
etc., that extends it functionality by adding functions for code execution directly from
Emacs buffers, etc.

As *scheme-mode* is based on the *lisp-mode*, it has same source code editing commands, as
*lisp-mode*, so please look to the [[./EmacsLisp#lisp-mode][corresponding section]] of article, describing work with
Lisp.

This mode is enabled automatically for all files with standard extensions of Scheme source
code -- =.scm=, =.ss=, etc.  To enable this mode for other files, you need to add following
piece of code into your initialization file (replacing =.scm= with needed extension):

<src lang="emacs-lisp">
(add-to-list 'auto-mode-alist '("\\.scm$" . scheme-mode))
</src>

If you want to change behaviour of the package, you can set additional parameters in the
function, specified in the =scheme-mode-hook=, and that will called during enabling of this
mode in concrete buffer.  Besides this, some of parameters you can set using standard
customization commands.  Corresponding customization group is called =scheme=.

#cmuscheme
* Cmuscheme

The *cmuscheme* package was written by Olin Shivers long time ago, but it's still one of the
most popular packages for work with Scheme.  This package implements interactive work with
interactive Scheme interpreters.  This interactive work is implemented via the *comint*
package, included into Emacs distribution.

** Customization of the package

Installation of package is pretty simple -- just put into your initialization file
following lines of code:

<src lang="emacs-lisp">
(autoload 'run-scheme "cmuscheme" "Run an inferior Scheme" t)
(setq scheme-program-name "mzscheme")
</src>

and package will automatically loaded when you call the =run-scheme= command first time.
Second line of example is used to set name of the Scheme interpreter, that you can replace
with any other name.  All settings for this package is also available via customization
group with name =cmuscheme=.

In the interpreter buffer, that is created by package, the special major mode is used --
=inferior-scheme-mode=, that you can customize with =inferior-scheme-mode-hook=.  Besides
this, if there is =~/.emacs_SCHEMENAME= file, or =~/.emacs.d/init_SCHEMENAME.scm= file (where
=SCHEMENAME= is a name of Scheme interpreter), then Scheme expressions from them will
executed right after start of interpreter.

** Work with package

Main command of the package is =run-scheme=, that run selected Scheme interpreter, and
allows to interactively execute Scheme expressions without leaving Emacs.

You can control which portion of source code (selected region, function's definition, or
concrete expression) will evaluated by using different commands, defined in the package --
the =scheme-send-definition= command (=C-c C-e= or =C-M-x= key bindings) pass to interpreter
definition of current function; the =scheme-send-region= command (=C-c C-r=) allows to
executed source code from selected region; the =scheme-send-last-sexp= command (=C-x C-e=) is
used to evaluation of expression, before the current point; and the =scheme-load-file=
command (=C-c C-l=) allows to load to interpreter whole file -- it allows to load
expressions from any file, specified by user, not only from current buffer.

The Scheme interpreter is run in the separate buffer that is called =*scheme*=[1], to which
results of evaluations is also printed.  To quick switch to this buffer from the buffer
with source code, there is the =switch-to-scheme= command (=C-c C-z=).  Besides this, as it's
often need to execute some code and look to the results of its execution, package defines
two additional commands that evaluate code and switch to =*scheme*= buffer -- the
=scheme-send-definition-and-go= command (=C-c M-e)= for evaluation of current definition, and
the =scheme-send-region-and-go= command (=C-c M-r=) for evaluation of selected code.

To work with Scheme macros, the package implements the =scheme-expand-current-form= command
(=C-c C-x=), that allows to expand definition of the current macro into corresponding code
in Scheme.  Code expansion is performed by interpreter and printed to the =*scheme*= buffer.
And if your Scheme implementation, supports compilation of source code, then you can use
the =scheme-compile-file= command (=C-c C-k=) and the =scheme-compile-definition= command (=C-c
M-c=), that perform compilation of the file or current definition.

As was mentioned above, in the interpreter's buffer the special major mode is used --
=inferior-scheme-mode= that allows to use all commands of  [[EmacsDevelMisc#comint][comint]] mode, and some additional
*cmuscheme* commands -- =scheme-compile-file= (=C-c C-k=), =scheme-load-file= (=C-c C-l=),
=scheme-send-last-sexp= (=C-x C-e=) & =scheme-send-definition= (=C-M-x=).

#quack
* Quack

The Quack package is an extension for the *cmuscheme* package, and it implements different
additional features (most of them is designed for work with [[http://www.plt-scheme.org][PLT Scheme]]):
 - separate menu, from which user can access documentation about language, interpreter &
   SRFI, and also search for description of function with name under point;
 - new sets of expressions for *font-lock* highlighting -- for PLT Scheme and extended
   scheme for other implementations;
 - ability to use Greek *lambda* symbol for lambda-expressions (examples are below);
 - additional options & commands for insertion of opening & closing brackets;
 - extensions for source code indenting, with ability to set different schemes for
   different Scheme implementations;
 - extended version of the =run-scheme= command, that knows about different Scheme
   implementations and names of their interpreters, and that also remember name of last
   run interpreter;
 - extended version of the =switch-to-scheme= command;
 - ability to view content of the =.plt= collections, and commands for open of *Dired* buffer
   for given collection.

** Installation & customization

This package is written by Neil Van Dyke, and available for download from [[http://www.neilvandyke.org/quack/][author's site]].
Package is installed by copying files to directory, where Emacs could find them, and
putting following command into initialization file:

<src lang="emacs-lisp">
(require 'quack)
</src>

All settings could be set via customization group with name =quack=, or using the =Quack=
menu.  These settings allow to specify URLs for manuals & SRFIs, which prefix key will be
used for Quack's commands, etc.

For PLT Scheme users is recommended to download manuals for this implementation from the
[[http://download.plt-scheme.org/doc/][project's site]], and install them into *doc* collection.  Location of the PLT Scheme
collections is defined either by the =quack-pltcollect-dirs= variable, in which you need to
list all of directories with collections, or by =PLTHOME= and/or =PLTCOLLECTS= environment
variables.

To proper work of the package, the =wget= program is also required -- it will used for
access to SRFI.

** Work with package

After loading of package, several additional commands become available to use.  User can
run these commands either via key bindings, and/or direct call via =M-x=, or selecting them
via the =Quack= menu.

For work with documentation the package provides several commands.  The =quack-view-manual=
command (=C-c C-q m=) is used to show documentation in a web-browser.  This command allows
to view not only base Scheme documentation, but also documentation for concrete
implementations.  To show SRFI's there is sepearate command -- =quack-view-srfi= (=C-c C-q
s=), that asks a number of document, and shows it in browser.  For PLT Scheme users there
is also the =quack-view-keyword-docs= command (=C-c C-q k=), that shows documentation for
given keyword (*work of this command is depend on the proper installation of the PLT
Scheme*).

As was mentioned above, the package provides the =run-scheme= command (=C-c C-q r=), that
allows to run  Scheme interpreters, selecting them from list  (and including run of them
with all needed options), and also remembers last user's choice.

For users of PLT Scheme also provided additional commands for work with collections.  The
=quack-find-file= command (=C-c C-q f=) opens file, using its name from current context.  For
example, if you'll run this command while you staying on expression =(require (lib
"list.ss"))=, then package will suggest to open file =list.ss= from *mzlib* collection.
Besides this, there is the =quack-dired-pltcollect= command, that allows to open *Dired*
buffer for given PLT Scheme collection (when typing name of collection, user can use names
completion).

This package also implements several commands, that change source code formatting, making
work with it more comfortable.  The =quack-tidy-buffer= command (=C-c C-q t=) performs
re-inditing of source code, replace tabs with spaces, removes unneeded empty lines, and
removes spaces at the end of lines, and so on.  The =quack-toggle-lambda= command (=C-c C-q
l=) changes definition of the current function from =(define (func args) ...)= to =(define
func (lambda (args) ..))=, that allows to show lambda character in the source code (if this
is enabled in options), for example:

[[../../../common/writings/emacs-devenv/quack-lambda.png]]

* The GCA package

The *GCA* package is created for effective work with source code written in Scheme language.
It was designed for work with [[http://practical-scheme.net/gauche/index.html][Gauche Scheme]], but it could be used with other
implementations.  As the *quack* package, it extends commands of the *cmuscheme* package. This
package provides following features:
 - insertion of source code snippets, using templates;
 - show function's descriptions;
 - completions of names;

This package could be downloaded from the [[http://homepage.mac.com/naoki.koguro/prog/gca/gca-20060903.tar.gz][author's site]], but it almost hasn't
documentation, and existing is written in Japan.  In English is available only
[[http://subtech.g.hatena.ne.jp/antipop/20071108/1194528967][very short description]] with example of configuration, and links to the source code &
videos, showing work with package.

#gds
* The GDS package

The *gds* package extends the *cmuscheme* package with following features:
 - completion of the names (that are known for corresponding Guile process);
 - access to built-in Guile commands -- =help= & =apropos=;
 - debugging of source code -- show of values for variables & stack, step-by-step
   execution, etc.

This package was developed for Guile Scheme, and has dependencies on the Guile's features.
You can find detailed information in the [[http://www.gnu.org/software/guile/manual/html_node/Using-Guile-in-Emacs.html][Guile manual]].

This package differs from other packages -- instead of communication via standard
input/output, it uses simple network protocol for data transmission.  This approach allows
to implement more features, but it also requires a dedicated Scheme process (the *gds*
server), that will be used for communication with other processes.

** Installation and customization

The *gds* package is distributed together with latest versions of the Guile Scheme, so you
just need to add directory with package to the Emacs's search path, and add following line
to your initialization file:

<src lang="emacs-lisp">
(require 'gds)
</src>

This command will load the package, and spawn separate process, that will responsible for
communication with Scheme interpreters.  I need to mention, that this will require, that
special package written in Scheme will available in the Guile's search path.  If this
package is located in non-standard place, you can specify its location with
=gds-scheme-directory= variable, or initialization will fail.

Other settings could be specified via the =gds= customization group.

** Work with source code

For source code evaluation the *gds* package uses same key bindings as *cmuscheme* package.
The only exception is the =gds-eval-expression= command (=C-c C-e=), that evaluates expression
entered in mini-buffer.

The most important features, implemented by  *gds* are completion of names of
functions & variables, getting help information for concrete symbols, and/or search for
symbol using part of name.

Completion of names is performed by =gds-complete-symbol= command (=M-TAB=), that tries to
find all known symbols, whose names are match to string before point.  If only one name
was found, then it inserted immediately, but if there are several names, then new buffer
will displayed, where user can select needed name.

To get help information for concrete symbol you can use the =gds-help-symbol= command (=C-h
g=), that displays same information as direct evaluation of the =(help SYMBOL)= expression in
Guile interpreter.  User is prompted for a name, and as default the name under point is
used.  If you don't remember precise symbol's name, then you can use the =gds-apropos=
command (=C-h G=), that performs =(apropos REGEXP)= in Guile interpreter, and displays list of
symbols, whose names are matched to the entered regex.

** Debugging

Developer can explicitly control execution of the *gds* from debugged program.  To do this,
he should add some code to his program, that will lead to pass of data to *gds* server.  You
can find more information about this in the [[http://www.gnu.org/software/guile/manual/html_node/GDS-Getting-Started.html#GDS-Getting-Started][Guile manual]].

To use *gds* features during interactive work, user should explicitly specify which modules
should be loaded to provide work with *gds*.  For example, following code will load all
modules, that are necessary for work:

<src lang="scheme">
(use-modules (ice-9 gds-client))
(named-module-use! '(guile-user) '(ice-9 session))
(gds-accept-input #f))
</src>

After execution of this code, you'll able to work with *gds*.  To set break point in
procedure with name =proc_name=, use following code, that should be evaluated in the buffer
with source code:

<src lang="scheme">
(install-trap (make <procedure-trap>
                     #:behaviour gds-debug-trap
                     #:procedure proc_name))
</src>

and after call of given procedure, you'll get in *gds* buffer following trace:

<example>
 Calling procedure:
 => s  [proc_name]
    s  [primitive-eval (proc_name)]


 --:**  PID XXXXX         (Guile-Debug)--All--------
</example>

In this buffer you can navigate through stack, view its state, continue execution of
program (including step-by-step execution).  There are several commands, that provide
execution of different tasks in stack buffer.

For navigation through call stack, user can use following keys: =u=, =C-p= or up arrow keys
are used to move up in the call stack, and selecting next frame (the =gds-up= command), =d=,
=C-n= and down arrow keys are used to move down through call stack (=gds-down=), and the =RET=
key is used for selecting of the frame under point.  Selection of some frame lead to show
of corresponding part of source code.  Besides this, some commands will use environment,
corresponding to selected frame..

Following commands could be used for perform different operations in stack buffer:
 =gds-evaluate= (the =e= key) :: allow to evaluate expression, using environment for selected
   frame.  Result of expression is shown in the echo area;
 =gds-frame-info= (=i=) :: shows information about selected frame -- line in file with source
   code, frame type, etc.;
 =gds-frame-args= (=A=) :: shows frame arguments;
 =gds-proc-source= (=S=) :: shows source code for called procedure.  This is very useful when
   procedure was created by anonymous lambda-expression, as such procedures are shown as
   =<procedure #f (...)>= in call stack, so you couldn't understand what will executed next.

To continue execution of program, user can use following commands:
 =gds-go= (=g=, =c= or =q=) :: continue execution of program;
 =gds-step-file= (=SPC=) :: execute next operation in same source file, as selected stack
  frame.  Functions from other files are executed without stopping;
 =gds-step-into= (=i=) :: execute next operation with entering into called procedure;
 =gds-step-over= (=o=) :: execute program until end of current stack frame.

Using these functions developer can get detailed information about program's state, and
has ability to find and fix errors.

* Scheme48

the *scheme48* package is also built on top of the *cmuscheme*, and it extends it with support
for Scheme48 implementation.  This package extends *font-lock* with support of keywords and
operators, specific for Scheme48.  It also introduce new key bindings for expressions
evaluation.

You can download this package from [[http://www.emacswiki.org/cgi-bin/wiki/Scheme48Mode][EmacsWiKi]], and install it like another packages -- copy
it in directory, where Emacs will find it, and add load command to your initialization
file.

#xscheme
* Xscheme

The *xscheme* package has almost same features as *cmuscheme* -- it allows to perform code
evaluation without leaving the buffer with source code.  Besides this, it also allows to
view call stack, if something goes wrong.

This package works only with MIT Scheme, as it uses some of features, available only in
this implementation.  The package is distributed together with  Emacs, and to use it, you
just need to add following command to your initialization file:

<src lang="emacs-lisp">
(require 'xscheme)
</src>

After loading of the package, user can run interpreter with the =start-scheme= command, and
use corresponding commands for evaluation of code in interpreter.  To evaluate expression
before point, user can use either =advertised-xscheme-send-previous-expression= command (=C-x
C-e=), or the =xscheme-send-previous-expression= command (=M-RET=).  Commands
=xscheme-send-definition= (=C-M-x= or =M-z=), =xscheme-send-region= (=C-M-z=), and
=xscheme-send-buffer= (=M-o=) pass to interpreter definition of current function, selected
region, or whole buffer.  To switch to interpreter buffer, user can use the
=xscheme-select-process-buffer= command (=C-c C-s=).

#gambit
* Support for Gambit-C

For the Gambit Scheme implementation there is also separate package, based on the
*cmuscheme*, and implementing several operations, supported only for Gambit -- debugging,
compilation, etc.  This package has name *gambit*, and distributed together with
[[http://dynamo.iro.umontreal.ca/~gambit/][Gambit Scheme]].  Additional information about Gambit Scheme, and the *gambit* package, you
can find in [[http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/Documentation][documentation]].

Installation procedure is standard -- put =gambit.el= into some directory, where Emacs will
find it, and add following lines into initialization file:

<src lang="emacs-lisp">
(autoload 'gambit-inferior-mode "gambit" "Hook Gambit mode into cmuscheme.")
(autoload 'gambit-mode "gambit" "Hook Gambit mode into scheme.")
(add-hook 'inferior-scheme-mode-hook (function gambit-inferior-mode))
(add-hook 'scheme-mode-hook (function gambit-mode))
(setq scheme-program-name "gsi -:d-")
</src>

Gambit interpreter is run with =run-scheme= command, implemented in *cmuscheme*, but the
*gambit* package add to it procedures for output filtering, allowing to get information
about source file.  After run of interpreter, user can use standard [[#cmuscheme][cmuscheme]] key bindings
for evaluation and compilation of code -- =C-x C-e=, =C-c C-l=, =C-c C-k=, etc.

In addition to *cmuscheme* commands, the *gambit* package provides several commands, that
could be used for debugging of source code:
 =gambit-continue= (=F8= или =C-c c=) :: continue execution of the code.  The same as  =,c=
   in interpreter;
 =gambit-crawl-backtrace-newer= (=F9= или =C-c ]=) :: switch to previous stack frame. The same
   as =,-= in interpreter;
 =gambit-crawl-backtrace-older= (=F10= или =C-c [=) :: switch to next stack frame. The same as
   =,+= in interpreter;
 =gambit-step-continuation= (=F11= или =C-c s=) :: execute one operation with entering into
   calling function.  The same as =,s= in interpreter;
 =gambit-leap-continuation= (=F12= или =C-c l=) :: execute one operation without entering into
   calling function. The same as =,l= in interpreter;
 =gambit-kill-last-popup= (=C-c _=) :: delete window, that was created for displaying of
   source code.

There also more short key bindings for these commands: =M-c=, =M-[=, =M-]=, =M-s=, =M-l= and =M-_=,
but they aren't activated by default, as they doesn't match to Emacs guidelines for key
bindings.  To enable them, you need to execute following expression (and put it into
initialization file):

<src lang="emacs-lisp">
(setq gambit-repl-command-prefix "\e")
</src>

#bee-mode
* Bee-mode (bmacs)

The *bmacs* package -- это реализация интегрированной программной среды для работы с
[[http://www-sop.inria.fr/mimosa/fp/Bigloo/][Bigloo Scheme]].  Данный пакет реализует следующие возможности:
 - отладку кода;
 - профилирование;
 - автоматическое создание и обновление файлов Makefile;
 - навигация по коду;
 - интеграция с системами контроля версий;
 - просмотр документации;
 - интерактивное выполнение кода;
 - раскрытие макросов;
 - некоторая поддержка грамотного стиля программирования (literate programming).

Для работы этого пакета требуется наличие некоторого количества дополнительных утилит,
большинство из которых поставляется вместе с Bigloo.  Документацию можно найти на
[[http://www-sop.inria.fr/mimosa/fp/Bigloo/doc/bigloo-31.html][сайте проекта]], либо в составе дистрибутива.

** Installation & basic customization

Данный пакет поставляется в составе Bigloo Scheme и находится в подкаталоге =bmacs=
дистрибутива.  Для установки пакета надо перейти в этот каталог и там выполнить команду:

<src lang="sh">
make
make install EMACSDIR=<your site lisp>
</src>

которая установит необходимые файлы в то место, которое вы указали.  После этого, вы
можете добавить следующие строки в ваш файл инициализации для автоматической загрузки
пакета при открытии файлов с исходными текстами[2]:

<src lang="emacs-lisp">
(autoload 'bdb "bdb" "bdb mode" t)
(autoload 'bee-mode "bee-mode" "bee mode" t)
(setq auto-mode-alist
      (append '(("\\.scm$" . bee-mode)
                ("\\.sch$" . bee-mode)
                ("\\.scme$" . bee-mode)
                ("\\.bgl$" . bee-mode)
                ("\\.bee$" . bee-mode))
              auto-mode-alist))
</src>

Настройки пакета могут быть установлены используя группу настройки =bee=, которая
обеспечивает задание настроек для *bee-mode*, и групп *dbg* & *bug*, используемых для задания
настроек отладчика.

** Work with source code

После загрузки *bee-mode* пользователь может выполнять основные команды используя
соответствующие иконки тулбара, или выбирая нужные пункты из меню =Bee=, которое появляется
при запуске режима.

Для расстановки отступов в соответствии с принятыми для Bigloo соглашениями, пакет
*bee-mode* определяет несколько функций:  =bee-indent-sexp= (=C-M-q=) расставляет отступы для
текущего выражения, =bee-indent-define= (=C-c TAB C-d=) делает это для текущего определения
функции, =bee-indent-last-sexp= (=C-c TAB C-l=) расставляет отступы для выражения перед
курсором и т.д.

Очень важный набор функций, используемых при работе с исходным кодом, это функции поиска
определений функций и переменных.  Чтобы найти определение переменной, вы можете
воспользоваться функцией =bee-tags-find= (=C-x 5 .=) или =bee-tags-find-variable= (=C-c C-d f=).
А для поиска определения модуля существует функция =bee-find-module= (=C-c C-d m=).  Кроме
того, *bee-mode* переопределяет два сочетания клавиш -- =M-.= & =M-,=, которые привязываются к
функциям =bee-tag-find= и =bee-tags-find-next=, что позволяет находить определения функций и
классов.

Для упрощения работы с модулями, *bee-mode* определяет набор функций, которые управляют
списком модулей импортируемых текущим исходным кодом -- функция =bee-import-binding= (=C-c
RET i=), а также списком функций и переменных, экспортируемых из текущего модуля --
=bee-export-function= (=C-c RET f=) и =bee-export-variable= (=C-c RET v=).  Кроме того, существует
отдельная функция, которая позволяет импортировать символы из файлов на языке C --
=bee-import-c-file= (=C-c RET c=), а также она обновляет =Makefile=, добавляя зависимость для
компиляции соответствующего кода.

Пакет также обеспечивает некоторую поддержку так называемого грамотного программирования
(literate programming).  Реализуемая поддержка не является полной, но по крайней мере
позволяет вставлять в код ссылки на описания модулей и функций.  Это достигается за счет
использования ключевых слов =@path=, =@node= & =@deffn= в комментариях для модуля и описаний
функций.  Ключевые слова =@path= & =@node= определяют файл и раздел документации, описывающих
данный модуль и указываются в комментарии для объявления модуля.  А ключевое слово =@deffn=
указывается в комментарии для функции.  Используя эти ключевые слова, разработчик получает
возможность быстрого перехода к соответствующим разделам и описаниям функций, что
позволяет улучшить документирование кода.

** Compilation &  execution of source code

Также как и другие пакеты, *bee-mode* позволяет выполнять код Scheme непосредственно из
буфера Emacs.  Для запуска интерпретатора необходимо выполнить функцию
=ude-repl-other-frame= (=C-c C-r C-r=), выбрать соответствующую иконку тулбара (*Repl*), или
соответствующий пункт меню.

И после загрузки интерпретатора, пользователь может выполнять код используя следующие
функции:
 - =ude-repl-send-buffer= (=C-c C-r b=) передает для вычисления весь буфер;
 - =ude-repl-send-region= (=C-c C-r r=), передает интерпретатору выделенный блок кода;
 - =bee-repl-send-define= (=C-c C-r d=) используется для выполнения текущего определения
   (=define=);
 - =bee-repl-send-last-sexp= (=C-c C-r l=) вычисляет значение выражения перед курсором;
 - =bee-repl-send-toplevel-sexp= (=C-c C-r t=) используется для вычисления всего текущего
   выражения.

Очень часто при использовании макросов необходима возможность их раскрытия.  Также как и
для работы с обычным кодом, *bee-mode* реализует набор функций для раскрытия макросов в
вашем коде (при этом, весь буфер будет просканирован на предмет наличия определений
макросов):
 - =bee-expand-buffer= (=C-c C-e C-e=) приводит к раскрытию макросов в текущем буфере;
 - =bee-expand-region= (=C-c C-e C-r=) раскрывает макросы в выделенном коде;
 - =bee-expand-define= (=C-c C-e C-d=) раскрывает макросы в текущем определении (=define=)
 - =bee-expand-last-sexp= (=C-c C-e C-l=) производит раскрытие макросов в выражении перед
   курсором;
 - =bee-expand-toplevel-sexp= (=C-c C-e C-t=) раскрывает макросы в текущем выражении.

Для компиляции программ необходимо наличие файла =Makefile=, который описывает зависимости
между модулями и указывает флаги компиляции.  Для проекта необходимо наличие так
называемого корневого каталога -- *bee-mode* пытается определить корневой каталог проекта
путем поиска одного из файлов =Makefile=, =.afile= или =.etags=, или корневой каталог может быть
установлен с помощью функции =ude-user-set-root-directory= (=C-c C-p C-r=) или соответствующей
кнопки тулбара.

После того, как корневой каталог задан, =Makefile= может быть сгенерирован с помощью функции
=ude-generate-makefile= (=C-c C-c a= или =C-c C-c C-l=), которая запросит у пользователя имя
исполняемого модуля, в который будет скомпилирован данный исходный код.   В том случае,
если =Makefile= уже существует, то эти же сочетания клавиш обновляют его, а также
перестраивают файлы  =.afile= и =.etags=.  Кроме того, имеется набор функций для
редактирования =Makefile= -- =ude-edit-makefile= (=C-c C-c e=), обновления =Makefile= --
=ude-update-makefile= (=C-c C-c u=), переключения между отладочной и окончательной версиями
программы -- =ude-makefile-debug-mode= (=C-c C-c C-d=) & =ude-makefile-final-mode= (=C-c C-c C-f=)
и другие.

Когда =Makefile= существует, то появляется возможность компиляции кода с помощью функции
=ude-mode-compile-from-menu= (=C-c C-c C-c=)[3].  Прервать компиляцию можно с помощью функции
=kill-compilation= (=C-c C-c k=).

И после того, как компиляция закончится, можно выполнить исполняемый модуль с помощью
функции =ude-execute= (=C-c C-c C-r=).

** Debugging & profiling

Вместе с пакетом Bigloo поставляется и отладчик, который позволяет производить отладку на
уровне исходного кода.  *bee-mode* поддерживает взаимодействие с этим отладчиком в Emacs.
Для запуска отладчика надо выполнить функцию =bee-debug= (=C-c C-b C-b=) или выбрать
соответствующую иконку тулбара, или пункт меню.   Но запуск отладчика не приводит к
автоматическому подключению к нему, поэтому необходимо явно выполнить функцию
=bee-toggle-connect-buffer= (=C-c C-b c=) чтобы связать текущий буфер с отладчиком, что
позволит устанавливать точки останова и выполнять прочие задачи находясь в буфере с
исходным текстом.

Профилирование программ поддерживается автоматически, если вы пользуетесь генерацией
=Makefile=.  Чтобы провести профилирование кода, необходимо его сначала скомпилировать с
поддержкой профилирования, что выполняется функцией =bee-profiler-start= (=C-c C-p c=).  А
после компиляции, вы можете выполнить функцию =bee-profiler-inspect= (=C-c C-p i=), что
приведет к запуску программы, и затем к запуску утилиты =bglprof=, которая соберет данные о
выполнении, и вы получите их в удобном для анализа виде.

** Other commands

Пакет предоставляет возможности по получению справочной информации.  Это может быть
сделано путем запуска функции =bee-doc-visit= (=C-c C-d i=) или нажатия на иконку =Info= в
тулбаре.  Эта функция ведет себя по разному в зависимости от текущего положения курсора --
если курсор находится на идентификаторе, то выдается документация для данного
идентификатора, если выделен регион кода, то будет выдана документация для данного
региона.  В противном случае, у пользователя будет запрошено имя интересующего раздела
документации, и показан выбранный раздел.

Информация, показываемая пользователю берется из файлов в формате Info, которые
поставляются вместе с Bigloo.  Кроме того, документация ищется в каталогах текущего
проекта, и они добавляются автоматически. Кроме того, пользователь может указать
дополнительные файлы документации, в которых будет производиться поиск.

Пакет *bmacs* также представляет некоторое количество функций для работы с системами
контроля версий, которые позволяют оперировать данными на уровне проектов.  Но в связи с
появлением новых систем контроля версий, и соответствующих интерфейсов для них, эти
функции становятся не особо востребованными.

Кроме того, существует множество дополнительных функций, реализованных данным пакетом,
например, поддержка работы с кодом, написанным на языке C, и т.п., но описание этих
возможностей лежит за границами данной статьи.

* Support for Scheme in SLIME

Замечательный [[./EmacsSLIME][пакет SLIME]], созданный для работы с кодом на языке Lisp, также имеет
рудиментальную поддержку работы с языком Scheme.  В настоящий момент поддерживаются лишь
два диалекта Scheme -- *Kawa* & *MIT Scheme*.  Для остальных диалектов поддержка может быть
добавлена реализацией протокола, используемого *SLIME* для общения с конкретной реализацией
языка[4].

Для использования *SLIME* со Scheme, вам необходимо выполнить базовую настройку пакета, как
это описано в разделе посвященном этому пакету, а затем загрузить необходимые
компоненты[5].  В общем виде это делается следующим образом:

<src lang="emacs-lisp">
(add-hook 'slime-load-hook (lambda () (require 'slime-scheme)))
</src>

Эта команда установит хуки необходимые для работы со *SLIME*, но для каждого из
поддерживамых диалектов вам может понадобиться выполнить дополнительную настройку в
соответствии с инструкциями, изложенными в соответствующем файле -- =swank-kawa.scm= или
=swank-mit-scheme.scm=.

А все остальное, касающееся работы со *SLIME*, [[./EmacsSLIME][описано в соответствующем разделе]].

; ======================================================================

<div id="rule">[[./index][To main page]]</div>

Footnotes:
[1] По умолчанию разрешается иметь только один запущенный процесс Scheme.  Но вы можете
    воспользоваться пакетом [[http://www.emacswiki.org/cgi-bin/wiki/RunSchemeHere][scheme-here.el]], если вам необходимо выполнение нескольких
    процессов одновременно.

[2] Кроме того, в поставке *bmacs* также имеются пакеты *cee*, предназначенный для
    редактирования кода на языке C, используемого для написания расширений Bigloo,
    *bug-mode*, обеспечивающий поддержку отладчика Bigloo, и *ude* (Unix Development
    Environment), реализующий поддержку компиляции, и различных утилит, используемых в
    работе с Bigloo.

[3] Стоит отметить, что если =Makefile= не существует, то эта функция приводит к запуску
    компиляции исполняемого модуля из одного файла.

[4] Так называемый *swank*-модуль.

[5] Все компоненты, относящиеся к Scheme, находятся в подкаталоге =contrib= дистрибутива
    *SLIME*, так что не забудьте добавить его в пути поиска.

;  LocalWords:  Makefile Repl makefile etags ude afile bglprof фрейма
;  LocalWords:  xscheme GDS dired PLT SRFI srfi cmuscheme wget PLTHOME dirs src
;  LocalWords:  PLTCOLLECTS emacs lang Dyke plt xemacs func ss bmacs gds Bigloo

