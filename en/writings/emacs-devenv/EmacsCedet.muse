#title The Gentle introduction to Cedet
#keywords c, c++, emacs, cedet, programming, semantic, ede, ide, integrated development environment

This article doesn't pretend to represent detailed description of the customizing of Emacs
as development environment (this is theme for [[emacs-devenv/index][separate article]]) -- I tried to write a
small description of the [[http://cedet.sf.net][Cedet]]'s customization to work with C & C++, although most of
description will also applicable for other languages, supported by Cedet.

<contents>

* What is Cedet?

The Cedet package is a collection of several packages, implementing different functions,
but used for one task -- provide functionality for work with source code written in
different programming languages:

 - Semantic is a basis for building of syntactic analyzers for different programming
   languages, that allows to provide common representation for information extracted from
   code, written in different languages.  Using this information, Cedet & other packages
   ([[http://jdee.sourceforge.net/][JDEE]] and [[http://ecb.sf.net][ECB]]), can implement functions, required for modern development environment
   (something like Eclipse, NetBeans, etc.);
 - SemanticDB is included into Semantic, and implements interfaces to different storage
   modules, that keeps information, that is needed for names completion, source code
   navigation, etc.  Syntactic information could be saved between Emacs sessions, so it
   reduce need for re-parsing of not modified source code.;
 - Senator -- implements navigation in source code file, using information, extracted by
   Semantic;
 - Srecode -- package for source code generation, using syntactic information, including
   information, obtained from  Semantic;
 - EDE -- implements set of extensions, that allow to work with projects -- control list
   of the targets to build, perform build of project, etc.  Besides this, using notion of
   the project, you can have more precise control about Semantic's operations -- name
   completions, and so on;
 - Speedbar -- is used to display information about current buffer, using different
   sources of information -- Semantic, some specialized information providers (for texinfo
   & html, for example), etc.
 - Eieio -- implementation of CLOS-like (Common Lisp Object System) infrastructure for
   Emacs Lisp;
 - Cogre -- library for drawing of UML-like diagrams in Emacs buffer, with basic
   integration with Semantic.

* Installation of the Cedet

Currently it's better to use development version of the Cedet, that is available from
repository at [[http://sourceforge.net/cvs/?group_id=17886][Sourceforge.net]].  After downloading of code, you need to compile the package
with following commands:

<src lang="sh">
find . -name Makefile|xargs touch
make clean ; make -k all
</src>

The first command is necessary, as =Makefile= files, that are used to build, are generated
from =Projects.ede= files, and when you fetch them from repository, they have wrong date,
and this lead to the build errors.[1]

* Customization

The loading of package is performed with the =cedet.el= script, so all you need to do -- is
just add following line to the your Emacs initialization file[2]:

<src lang="emacs-lisp">
(load-file "~/emacs/cedet/common/cedet.el")
</src>

If you plan to use projects, then you need to switch corresponding mode on -- it's
implemented by EDE package:

<src lang="emacs-lisp">
(global-ede-mode t)
</src>

** Semantic's customization

Depending on your requirements, you can use one of the commands, described below, to load
corresponding set of features (these commands are listed in increasing order, and each
command include features of previous commands):

 - =semantic-load-enable-minimum-features= -- enables only minimum of necessary features --
   keep syntactic information for current buffer up-to date, storing of syntactic
   information for later use (Semanticdb), and loading of corresponding information with
   Semanticdb and Ebrowse;
 - =semantic-load-enable-code-helpers= -- enables =senator-minor-mode= for navigation in
   buffer, =semantic-mru-bookmark-mode= for storing positions of visited tags, and
   =semantic-idle-summary-mode=, that shows information about tag under point;
 - =semantic-load-enable-gaudy-code-helpers= -- enables =semantic-stickyfunc-name= that
   displays name of current function in topmost line of buffer, =semantic-decoration-mode=
   to decorate tags, using different faces, and =semantic-idle-completion-mode= for
   automatic generation of possible names completions, if user stops his work for some
   time;
 - =semantic-load-enable-excessive-code-helpers= -- enables =which-func-mode=, that shows name
   of current function in status line;
 - =semantic-load-enable-semantic-debugging-helpers= -- enables several modes, that are
   useful when you debugging Semantic -- displaying of parsing errors, its state, etc.

So, you need to add call to one of these commands right after command, that performs
loading of Cedet.  For example:

<src lang="emacs-lisp">
(semantic-load-enable-excessive-code-helpers)
</src>

To use additional features for names completion, and displaying of information for tags &
classes, you also need to load the =semantic-ia= package.  This could be performed with
following command:

<src lang="emacs-lisp">
(require 'semantic-ia)
</src>

After loading of this package, you'll get access to commands, described below.

*** System header files

To normal work with system-wide libraries, Semantic should has access to system include
files, that contain information about functions & data types, implemented by these
libraries.

If you use GCC for programming in C & C++, then Semantic can automatically find path,
where system include files are located.  To do this, you need to load =semantic-gcc= package
with following command:

<src lang="emacs-lisp">
(require 'semantic-gcc)
</src>

You can also explicitly specify additional paths for look up of include files (and these
paths also could vary for specific modes).  To add path to list of system include paths,
you can use the =semantic-add-system-include=, that accepts two parameters -- string with
path to include files, and symbol, representing name of major mode, for which this path
will used.  For example:

<src lang="emacs-lisp">
(semantic-add-system-include "~/exp/include/boost_1_37" 'c++-mode)
</src>

*** Optimization of Semantic's work

To optimize work with tags, you can use several techniques:
 - limit search by setting of the EDE project, as this described below;
 - explicitly specify a list of root directories for your projects, so Semantic will use
   limited number of databases with syntactic information;
 - explicitly generate tags databases for often used directories (=/usr/include=,
   =/usr/local/include=, etc.) with the =semanticdb-create-ebrowse-database= or
   =semanticdb-create-cscope-database= commands;
 - limit search by customization of the =semanticdb-find-default-throttle= variable for
   concrete modes -- for example, don't use information from system include files, by
   removing =system= symbol from list of objects to search for =c-mode=:
<src lang="emacs-lisp">
(setq-mode-local c-mode semanticdb-find-default-throttle
								 '(project unloaded system recursive))
</src>

Besides this, you can point to Semantic, that it should extract syntactic information for
current buffer only when Emacs is idle.  To do this, you need to enable
=semantic-idle-scheduler-mode=, and customize the =semantic-idle-scheduler-idle-time=
variable, that specify idle time (in seconds).

*** Integration with imenu

The Semantic package could be integrated with the *imenu* package, that allows to display
menu with list of functions, variables, etc.  To enable this feature, you need to add
following code into your initialization file:

<src lang="emacs-lisp">
(defun my-semantic-hook ()
  (imenu-add-to-menubar "TAGS"))
(add-hook 'semantic-init-hooks 'my-semantic-hook)
</src>

** Customization of Semanticdb

If you had used standard procedure of Cedet's loading, then Semanticdb will loaded
automatically.  Otherwise, you can load and enable it with following commands:

<src lang="emacs-lisp">
(require 'semanticdb)
(global-semanticdb-minor-mode 1)
</src>

To customize Semanticdb you need to specify some number of variables, that are used to
specify path, where databases will stored, and some other parameters.  These variables
could be set via =semanticdb= customization group.

Кроме того, Semanticdb может использовать базы данных, сгенерированные внешними утилитами
-- =gtags= из состава [[http://www.gnu.org/software/global/][GNU Global]], =ctags=, =ebrowse= & =cscope=.  Для активации этой поддержки, вы
можете использовать следующий код:

<src lang="emacs-lisp">
;; если вы хотите включить поддержку gnu global
(require 'semanticdb-global)
(semanticdb-enable-gnu-global-databases 'c-mode)
(semanticdb-enable-gnu-global-databases 'c++-mode)

;; включить поддержку ctags 
(semantic-load-enable-all-exuberent-ctags-support)
</src>

** How to customize  Semantic to work with C & C++ projects

Для правильной работы Semantic с кодом на С & C++ рекомендуется воспользоваться пакетом
EDE (работа с проектами и т.п.) также из поставки CEDET.  Для этих языков, EDE определяет
специальный тип проекта -- =ede-cpp-root-project=, который предоставляет Semantic
дополнительную информацию, используемую для анализа исходных текстов вашего проекта, и
последующего использования информации только для вашего проекта.  Для этого, необходимо
включить соответствующий режим при загрузке пакета.

Для определения проекта используется следующий код:

<src lang="emacs-lisp">
(ede-cpp-root-project "Test"
											:name "Test Project"
											:file "~/work/project/CMakeLists.txt"
											:include-path '("/"
																			"/Common"
																			"/Interfaces"
																			"/Libs"
																			 )
											:system-include-path '("~/exp/include")
											:spp-table '(("isUnix" . "")
																	 ("BOOST_TEST_DYN_LINK" . "")))
</src>

В качестве параметра =:file= вам надо указать любой из файлов, находящихся в корневом
каталоге проекта.  Этот файл никак не анализируется, а служит только отправной точкой для
поиска файлов.   

Для поиска подключаемых файлов используется каталоги из двух списков, которые могут быть
определены в проекте.  Параметр =:system-include-path= используется для задания списка
полных путей каталогов, в которых будет производиться поиск "системных" подключаемых
файлов.  А параметр =:include-path= задает список каталогов, относительно корневого каталога
проекта, в которых будет производиться поиск подключаемых файлов, специфичных для вашего
проекта (заметьте, что имена начинаются со знака =/=, что означает, что имена задаются
относительно корневого каталога проекта).  Вместо явного задания каталогов, вы также
можете задать функцию, которая будет заниматься поиском файлов вашего проекта.  Об этом вы
можете прочитать в руководстве EDE.

Еще один параметр, который может быть задан в проекте -- список определений, которые будут
использоваться при обработке кода препроцессором.  Параметр =:spp-table= позволяет
определить список пар, состоящих из имени символа и свзяанного с ним значения.  В нашем
примере мы определяем два символа =isUnix= и =BOOST_TEST_DYN_LINK=, которые будут переданы
препроцессору, что позволит произвести правильный разбор кода.  Более подробно про эти
определения вы можете прочитать в документации на переменную
=semantic-lex-c-preprocessor-symbol-map=.

* Work with Semantic

С точки зрения пользователя Semantic реализует несколько основных функции -- дополнение
имен, получение информации о тагах (переменных, функциях и т.д.) и навигацию по исходному
коду.  Часть команд реализуется пакетом =semantic-ia=, часть пакетом Senator, и часть --
ядром самого Semantic.

Часть команд не имеет стандартных привязок клавиш, поэтому вам лучше самим выбрать удобные
для вас привязки и привязать к ним нужные команды, например вот так:

<src lang="emacs-lisp">
(defun my-cedet-hook ()
  (local-set-key [(control return)] 'semantic-ia-complete-symbol)
  (local-set-key "\C-c?" 'semantic-ia-complete-symbol-menu)
  (local-set-key "\C-c>" 'semantic-complete-analyze-inline)
  (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle))
(add-hook 'c-mode-common-hook 'my-cedet-hook)
</src>

*Я хотел бы отметить, что работа над Semantic ведется достаточно активно, и в случае
неправильной работы каких-либо компонент, просьба отправлять примеры кода в список
рассылки cedet-devel -- автор реагирует на баг-репорты достаточно оперативно.*

** Names completion

Дополнение имен функций и классов -- достаточно востребованная и часто используемая
функция[3].  В составе Semantic идет два пакета реализующих данную функциональность --
=semantic-ia= и Senator.  Функции реализованные в составе =semantic-ia= используют для
определения списка возможных дополнений функцию =semantic-analyze-possible-completions=,
которая учитывает достаточно много параметров -- области видимости определений, и т.п., и
кроме того, она может быть переопределена пользователем для более точной генерации списка
имен.  В то время как функции Senator используют более простой механизм определения списка
возможных дополнений (в основном используя информацию об определениях в текущем файле),
что иногда ведет к неправильному его формированию, хотя и работает намного быстрее чем
функции =semantic-ia=.

Использование функции =semantic-ia-complete-symbol= при наборе кода приведет к дополнению
соответствующего имени -- функции, переменной или переменной-члена класса, в зависимости
от контекста в котором она была вызвана.  Если существует несколько вариантов, то имя
будет дополнено до наибольшей общей части имени, а при повторном вызове команды, будет
показан буфер со списком всех возможных вариантов имени.  Пользователь может также
воспользоваться функцией =semantic-ia-complete-symbol-menu=, которая также анализирует
контекст в котором она вызвана, и отображает варианты дополнений в виде графического меню,
перемещаясь по которому пользователь может выбрать нужный вариант дополнения[4].  Кроме
того, существует функция =semantic-ia-complete-tip=, которая отображает список возможных
дополнений в виде всплывающей подсказки (tooltip).

Как упоминалось выше, Senator также предоставляет функции для дополнения имен, которые
работают более быстро, но учитывают меньше параметров при генерации списка дополнений.
Функция =senator-complete-symbol= (=C-c , TAB=) дополняет имя для текущего тага, при этом она
сразу подставляет имя первого варианта из списка всех возможных вариантов.  Если вам это
не подходит, то вы можете продолжать вызывать эту функцию для перебора всех вариантов
дополнения имен (что не всегда удобно). В том случае, если вариантов имен много, или вы
хотите посмотреть полный список функций и переменных для какого-то класса, то лучше
воспользоваться функцией =senator-completion-menu-popup= (=C-c , SPC=), которая отображает
список возможных вариантов дополнений в виде графического меню.

Помимо этого, для отдельных языков пользователь может включить специальный режим --
=semantic-idle-completions-mode= (или воспользоваться функцией
=global-semantic-idle-scheduler-mode= чтобы включить его для всех режимов) при котором
дополнения имен начинают показываться спустя некоторое время бездействия.  При этом, в
качестве варианта предлагается первое значение из списка возможных дополнений, и
пользователь может использовать клавишу =TAB= для перебора вариантов.

Для языков с C-подобным синтаксисом, пользователь может воспользоваться командой
=semantic-complete-self-insert=, привязанной к клавишам =.= и =>=, как это показано ниже.

<src lang="emacs-lisp">
(defun my-c-mode-cedet-hook ()
 (local-set-key "." 'semantic-complete-self-insert)
 (local-set-key ">" 'semantic-complete-self-insert))
(add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
</src>

Использование этого кода приведет к тому, что при нажатии =.= или =>= после переменных,
экземпляров класса, будет показан список возможных дополнений для данного класса.

** Getting information about tags

Пакет =semantic-ia= реализует несколько команд, которые позволяют разработчику получать
информацию о классах, функциях и переменных.  В качестве документации используются
комментарии, извлеченные из исходного кода, в том числе и используемые для генерации
документации с помощью Doxygen.  В настоящее время реализованы следующие функции:

 =semantic-ia-show-doc= :: показывает документацию для функции или переменной чье имя
   находится под курсором.  Документация показывается в отдельном буфере.  Для переменных
   показывается их объявление, включающее тип, и строка документации, если она есть.  Для
   функций показывается их прототип, и документация по аргументам функции и возвращаемому
   значению;
 =semantic-ia-show-summary= :: показывает документацию для символа под курсором, но при
   информация отображается в мини-буфере, так что пользователь увидит только объявление
   переменной или функции;
 =semantic-ia-describe-class= :: запрашивает у пользователя имя класса и возвращает список
   функций и переменных определенных в данном классе и всех родительских классах.

** Source code navigation

Одной из самых полезных функций для навигации является функция =semantic-ia-fast-jump=,
которая позволяет переходить к объявлению переменной или функции, чье имя находится под
курсором.  Вернуться назад вы сможете использовав функцию =semantic-mrub-switch-tag= (=C-x
B=), которая доступна при использовании =semantic-mru-bookmark-mode=.

Также в Semantic определено две функции для перехода к объявлению функции или переменной
находящемся в текущем файле -- =semantic-complete-jump-local= (=C-c , j=), или в области
видимости всего проекта -- =semantic-complete-jump= (=C-c , J=).  Обе эти функции позволяют
ввести имя функции или переменной (включая локальные для функций), используя механизмы
дополнения имен, и перейти к данному определению.

Функция =semantic-analyze-proto-impl-toggle= позволяет "прыгать" между объявлением функции и
ее реализацией для языков, поддерживающих раздельное объявление и реализацию.  Еще одной
полезной функцией является =semantic-decoration-include-visit=, которая позволяет
переключиться в заголовочный файл, чье имя находится под курсором.

Senator также реализует несколько функций для навигации в исходном коде.  Сюда относятся
функции =senator-next-tag= (=C-c , n=) и =senator-previous-tag= (=C-c , p=), которые перемещаются
к следующему или предыдущему тагу, а также функция =senator-go-to-up-reference= (=C-c , u=),
которая переходит к "родительскому" тагу  (например, для функции-члена класса,
"родительским" тагом будет объявление класса).

** Search for places where function is called

Недавно в Semantic была добавлена полезная команда -- =semantic-symref=, которая позволяет
найти где символ, чье имя находится под курсором, используется в проекте.  В том случае,
если вы хотите найти данные для символа с произвольным именем, то вам стоит
воспользоваться функцией =semantic-symref-symbol=, которая позволяет вам ввести имя символа
вручную.

При этом, если вхождения символа в соответствующей базе данных (GNU Global и т.п.) не
найдены, то команда попытается найти использование заданного символа с помощью команды
=find-grep=.  В итоге создается вот такой вот буфер с найдеными результатами, используя
который пользователь может перемещаться к нужным частям кода:

<div id="screenshot">
[[../../../common/writings/emacs-devenv/cedet-symref.png]]
</div>

** Folding of the source code

Поскольку Semantic имеет практически полную синтаксическую информацию об исходных текстах,
то это позволяет реализовать практически такую же функциональность по свертыванию кусков
кода, которая реализуется пакетом *hideshow*.  Для получения этой функциональности вам
необходимо добавить следующий код в ваш файл инициализации:

<src lang="emacs-lisp">
(global-semantic-folding-mode 1)
</src>

и выполнить настройку переменной =global-semantic-tag-folding-mode=.  Это приведет к
появлению небольших треугольников в области значков (*fringle*), нажимая на которые можно
сворачивать или разворачивать соответствующий кусок текста (не только исходного текста, но
и комментариев и других объектов).

В Senator также имеется схожая функциональность, но она в основном предназначена для
работы с объектами верхнего уровня -- функциями, классами и т.п.  Сворачивание участка
кода производится с помощью функции =senator-fold-tag= (=C-c , -=), а разворачивание с помощью
функции =senator-unfold-tag= (=C-c , +=).

** Other Senator's commands

Пакет Senator определяет некоторое количество команд для работы с тагами -- вырезать или
скопировать текущий таг, вставить его в другом месте, и т.д.  Для вырезания текущего тага
(обычно это определение функции) определена функция =senator-kill-tag= (=C-c , C-w=).
Вставить таг целиком в другом месте можно с помощью стандартной комбинации клавиш =C-y=, в
то время как функция =senator-yank-tag= (=C-c , C-y=) вставляет лишь определение данного тага,
без тела.  Еще одной полезной функцией является =senator-copy-tag= (=C-c , M-w=), которая
копирует текущий таг для последующей вставки (с помощью =C-c , C-y=), что очень удобно для
вставки объявлений функций в заголовочных файлах, а полный текст скопированного тага,
вставляется с помощью =C-y=.

Senator позволяет изменить поведение стандартных функций поиска (=re-search-forward=,
=isearch-forward= и др.) при работе с исходным кодом таким образом, что функции будут
производить поиск только в соответствующих тага.  Чтобы включить этот режим вы можете
использовать функцию =senator-isearch-toggle-semantic-mode= (=C-c , i=), а с помощью функции
=senator-search-set-tag-class-filter= (=C-c , f=) вы можете ограничить пространство поиска
только указанными классами тагов -- =function= для функций, =variable= для переменных, и т.д.

Вы также можете воспользоваться поиском по тагам не переключаясь явно в режим ограничения
поиска.  Вам нужно лишь вызвать одну из функций: =senator-search-forward= или
=senator-search-backward=.
         
* Work with Srecode

Пакет Srecode позволяет пользователю определять различные шаблоны, но в отличии от других
систем для работы с шаблонами, вставка новых кусков текста, может сильно зависеть от
текущего контекста, например, вставка пары =get/set= может производиться только внутри
объявления класса, или вставка объявления новой функции может производиться только вне
какой-либо другой функции.

Основной командой, используемой для вставки шаблонов, является функция =srecode-insert=,
которая привязана к сочетанию клавиш =C-c / /=.  Эта функция запросит у вас имя шаблона,
которое вы можете ввести, используя механизмы дополнения.  В зависимости от текущего
контекста, список доступных шаблонов может меняться.  Если вы хотите вставить тот же самый
шаблон еще раз, то в можете воспользоваться командой =srecode-insert-again= (=C-c / .=),
которая вставит последний использованный шаблон.

Шаблоны также могут определять собственные привязки клавиш -- для них зарегистрирован
диапазон сочетаний =C-c / [a..z]=, и пользователь может указать в шаблоне какая клавиша
будет к нему привязана -- например, для C++ использование сочетания =C-c / c= приведет к
вставке шаблона для класса.  

Сочетания клавиш, использующие заглавные буквы, зарезервированы для шаблонов и команд,
определенных в Srecode.  Например, =C-c / G= (=srecode-insert-getset=) вставляет пару функций
=get/set= для заданной переменной-члена класса, а =C-c / E= (=srecode-edit=) используется для
редактирования шаблонов.  Число этих команд регулярно меняется, поэтому для получения
полного их списка, лучше посмотреть в документацию.

Кроме шаблонов поставляемых вместе с Cedet, пользователь может определять собственные
шаблоны и сохранять их в каталоге =~/.srecode=, где Cedet найдет их автоматически.  Про
создание шаблонов вы можете прочитать в руководстве для данного пакета, которое входит в
состав документации, поставляемой вместе с Cedet.

* Additional packages

Вместе с Cedet поставляется некоторое количество дополнительных пакетов, часто находящихся
в каталоге =contrib= дистрибутива, который автоматически добавляется в пути поиска пакетов,
поэтому загрузка нужных пакетов производится без дополнительных действий.

** The eassist package

Пакет *eassist* реализует несколько дополнительных команд, которые в своей работе используют
информацию, полученную от Semantic.  По умолчанию эти команды не имеют предопределенных
привязок клавиш, поэтому вам необходимо самим назначить нужные клавиши, если вы планируте
пользоваться этими командами.

Функция =eassist-list-methods=, запущенная в файле с исходным кодом, показывает список
функций в этом файле, позволяя выполнить быстрый переход к выбранной функции.

При разработке на языках C и C++ полезной может оказаться функция =eassist-switch-h-cpp=,
которая выполняет переключение между подключаемым файлом и файлом реализации (если они
имеют одинаковые имена, но разные расширения файлов).


<div id="rule">[[./index][To main page]]</div>

Footnotes: 

[1] First line is need only when you build package from CVS

[2] На моей странице вы можете найти мой [[http://xtalk.msk.su/~ott/common/emacs/rc/emacs-rc-cedet.el.html][файл инициализации Cedet]], который можно
    использовать в качестве базы для дальнейшей работы (хотя там достаточно много
    лишнего).

[3] Существует также функция =semantic-complete-analyze-inline=, которая отображает список
    возможных дополнений в отдельном окне, часто более удобно чем использование
    графического меню.

[4] В том случае, если дополнение имен работает неправильно, то попробуйте
    проанализировать почему это происходит, и лишь затем отправлять сообщение об ошибке в
    список рассылки.  Описание процесса отладки вы можете найти в Semantic User Guide в
    разделе *Smart Completion Debugging*.

;  LocalWords: emacs ede cedet localwords lang autoloads Makefile xargs ECB src
;  LocalWords:  Speedbar JDEE LocalWords CVS тагах Senator Semantic Srecode SPC

;  LocalWords:  semantic-ia emacs-lisp my-cedet-hook senator-complete-symbol
;  LocalWords:  semantic-analyze-proto-impl-toggle semantic-ia-complete-symbol
;  LocalWords:  semantic-complete-analyze-inline senator-completion-menu-popup
;  LocalWords:  semantic-ia-complete-symbol-menu semantic-complete-self-insert
;  LocalWords:  semantic-analyze-possible-completions TAB tooltip fringle C-c
;  LocalWords:  semantic-ia-complete-tip semantic-idle-completions-mode Cedet's
;  LocalWords:  my-c-mode-cedet-hook semantic-ia-show-doc senator-fold-tag
;  LocalWords:  global-semantic-tag-folding-mode global-semantic-folding-mode
;  LocalWords:  hideshow senator-unfold-tag senator-copy-tag senator-pulse-tag
;  LocalWords:  senator-search-set-tag-class-filter Semantic's Semanticdb
;  LocalWords:  senator-isearch-toggle-semantic-mode
