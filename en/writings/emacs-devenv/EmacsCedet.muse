#title The Gentle introduction to Cedet
#keywords c, c++, emacs, cedet, programming, semantic, ede, ide, integrated development environment

This article doesn't pretend to represent detailed description of the customizing of Emacs
as development environment (this is theme for [[emacs-devenv/index][separate article]]) -- I tried to write a
small description of the [[http://cedet.sf.net][Cedet]]'s customization to work with C & C++, although most of
description will also applicable for other languages, supported by Cedet.

<contents>

* What is Cedet?

The Cedet package is a collection of several packages, implementing different functions,
but used for one task -- provide functionality for work with source code written in
different programming languages:

 - Semantic is a basis for building of syntactic analyzers for different programming
   languages, that allows to provide common representation for information extracted from
   code, written in different languages.  Using this information, Cedet & other packages
   ([[http://jdee.sourceforge.net/][JDEE]] and [[http://ecb.sf.net][ECB]]), can implement functions, required for modern development environment
   (something like Eclipse, NetBeans, etc.);
 - SemanticDB is included into Semantic, and implements interfaces to different storage
   modules, that keeps information, that is needed for names completion, source code
   navigation, etc.  Syntactic information could be saved between Emacs sessions, so it
   reduce need for re-parsing of not modified source code.;
 - Senator -- implements navigation in source code file, using information, extracted by
   Semantic;
 - Srecode -- package for source code generation, using syntactic information, including
   information, obtained from  Semantic;
 - EDE -- implements set of extensions, that allow to work with projects -- control list
   of the targets to build, perform build of project, etc.  Besides this, using notion of
   the project, you can have more precise control about Semantic's operations -- name
   completions, and so on;
 - Speedbar -- is used to display information about current buffer, using different
   sources of information -- Semantic, some specialized information providers (for texinfo
   & html, for example), etc.
 - Eieio -- implementation of CLOS-like (Common Lisp Object System) infrastructure for
   Emacs Lisp;
 - Cogre -- library for drawing of UML-like diagrams in Emacs buffer, with basic
   integration with Semantic.

* Installation of the Cedet

Currently it's better to use development version of the Cedet, that is available from
repository at [[http://sourceforge.net/cvs/?group_id=17886][Sourceforge.net]].  After downloading of code, you need to compile the package
with following commands:

<src lang="sh">
find . -name Makefile|xargs touch
make clean ; make -k all
</src>

The first command is necessary, as =Makefile= files, that are used to build, are generated
from =Projects.ede= files, and when you fetch them from repository, they have wrong date,
and this lead to the build errors.[1]

* Customization

The loading of package is performed with the =cedet.el= script, so all you need to do -- is
just add following line to the your Emacs initialization file[2]:

<src lang="emacs-lisp">
(load-file "~/emacs/cedet/common/cedet.el")
</src>

If you plan to use projects, then you need to switch corresponding mode on -- it's
implemented by EDE package:

<src lang="emacs-lisp">
(global-ede-mode t)
</src>

** Semantic's customization

В зависимости от того, какие возможности вы хотите получить от Semantic, вы можете
воспользоваться одной из команд для загрузки соответствующих наборов функциональности (они
перечислены в порядке возрастания реализованных функций, и каждый следующий включает в
себя предыдущие наборы функциональности):

 - =semantic-load-enable-minimum-features= -- включает только необходимый минимум
   возможностей -- поддержание актуальности синтаксической информации для текущего буфера,
   сохранение синтаксической информации для последующего использования (Semanticdb) и
   подгрузку существующей информации Semanticdb и Ebrowse;
 - =semantic-load-enable-code-helpers= -- включает =senator-minor-mode= для навигации по
   буферу, =semantic-mru-bookmark-mode= для запоминания и навигации между тагами, и
   =semantic-idle-summary-mode=, который показывает информацию для тага под курсором;
 - =semantic-load-enable-gaudy-code-helpers= -- включает =semantic-stickyfunc-name= для
   отображения имени текущей функции в самой верхней строке буфера,
   =semantic-decoration-mode= для декорирования тагов, используя различные аттрибуты, и
   =semantic-idle-completion-mode= для генерации списка возможных дополнений имен, если
   пользователь останавливает свою работу на некоторое время;
 - =semantic-load-enable-excessive-code-helpers= -- подключает =which-func-mode=, который
   отображает имя текущей функции в строке состояния;
 - =semantic-load-enable-semantic-debugging-helpers= -- включает несколько режимов, которые
   полезны при отладке Semantic -- показ ошибок разбора кода, состояния парсера и т.п.

Таким образом, вам необходимо поместить вызов одной из функций в файл инициализации после
загрузки Cedet.  Например, вот так

<src lang="emacs-lisp">
(semantic-load-enable-excessive-code-helpers)
</src>

Чтобы использовать возможности по дополнению имен и показу информации о функциях и
классах, вам необходимо загрузить пакет =semantic-ia= с помощью следующей команды:

<src lang="emacs-lisp">
(require 'semantic-ia)
</src>

После загрузки этого пакета, вы получите возможность использования соответствующего
функционала, описанного ниже.

*** System header files

Если вы используете GCC для программирования на C & C++, то пакет может автоматически
получить данные о нахождении системных подключаемых файлов.  Для этого вам нужно загрузить
пакет =semantic-gcc= с помощью следующей команды:

<src lang="emacs-lisp">
(require 'semantic-gcc)
</src>

Вы также можете явно задать дополнительные пути поиска подключаемых файлов, которые будут
использоваться при работе в определенном режиме.  Для этого используется команда
=semantic-add-system-include=, которой передается два параметра -- путь к заголовочным
файлам, и имя режима в котором этот путь будет использоваться.  Например:

<src lang="emacs-lisp">
(semantic-add-system-include "~/exp/include/boost_1_37" 'c++-mode)
</src>

*** Optimization of Semantic's work

Для оптимизации поиска тагов вы можете использовать несколько приемов:
 - Ограничить область поиска путем настройки проекта EDE, как это описано ниже;
 - Явно указать список корневых каталогов для ваших проектов, так что Semantic будет
   использовать ограниченное количество баз тагов;
 - Заранее сгенерировать базы данных тагов для часто используемых каталогов (=/usr/include=,
   =/usr/local/include=, и т.п.) с помощью команд =semanticdb-create-ebrowse-database= или
   =semanticdb-create-cscope-database=;
 - Ограничить диапазон поиска с помощью настройки переменной
   =semanticdb-find-default-throttle= для конкретных режимов, например, не использовать
   информацию о системных подключаемых файлов, убрав директиву =system= из списка объектов
   поиска для режима =c-mode=:
<src lang="emacs-lisp">
(setq-mode-local c-mode semanticdb-find-default-throttle
								 '(project unloaded system recursive))
</src>

Кроме того, вы можете указать Semantic, что он должен извлекать синтаксическую информацию
из текущего буфера только тогда, когда Emacs ничего не делает.  Для этого вам необходимо
включить =semantic-idle-scheduler-mode=, а для настройки времени ожидания (в секундах)
используется переменная =semantic-idle-scheduler-idle-time=.

*** Integration with imenu

Пакет Semantic умеет интегрироваться с пакетом *imenu*, который позволяет отображать меню со
списком функций переменных и т.п. информацией.  Для включения этой поддержки, вам
необходимо добавить следующий код в файл инициализации:

<src lang="emacs-lisp">
(defun my-semantic-hook ()
  (imenu-add-to-menubar "TAGS"))
(add-hook 'semantic-init-hooks 'my-semantic-hook)
</src>

** Customization of Semanticdb

Если вы использовали стандартный механизм загрузки компонентов Cedet, то Semanticdb будет
загружен автоматически.  Иначе, вы можете загрузить и включить его с помощью следующих
команд:

<src lang="emacs-lisp">
(require 'semanticdb)
(global-semanticdb-minor-mode 1)
</src>

Для настройки поведения Semanticdb используется некоторое количество переменных, которые
позволяет указать вам куда сохранять данные, а также другие параметры.  Эти переменные
можно настроить через группу настройки =semanticdb=.

Кроме того, Semanticdb может использовать базы данных, сгенерированные внешними утилитами
-- =gtags= из состава [[http://www.gnu.org/software/global/][GNU Global]], =ctags=, =ebrowse= & =cscope=.  Для активации этой поддержки, вы
можете использовать следующий код:

<src lang="emacs-lisp">
;; если вы хотите включить поддержку gnu global
(require 'semanticdb-global)
(semanticdb-enable-gnu-global-databases 'c-mode)
(semanticdb-enable-gnu-global-databases 'c++-mode)

;; включить поддержку ctags 
(semantic-load-enable-all-exuberent-ctags-support)
</src>

** How to customize  Semantic to work with C & C++ projects

Для правильной работы Semantic с кодом на С & C++ рекомендуется воспользоваться пакетом
EDE (работа с проектами и т.п.) также из поставки CEDET.  Для этих языков, EDE определяет
специальный тип проекта -- =ede-cpp-root-project=, который предоставляет Semantic
дополнительную информацию, используемую для анализа исходных текстов вашего проекта, и
последующего использования информации только для вашего проекта.  Для этого, необходимо
включить соответствующий режим при загрузке пакета.

Для определения проекта используется следующий код:

<src lang="emacs-lisp">
(ede-cpp-root-project "Test"
											:name "Test Project"
											:file "~/work/project/CMakeLists.txt"
											:include-path '("/"
																			"/Common"
																			"/Interfaces"
																			"/Libs"
																			 )
											:system-include-path '("~/exp/include")
											:spp-table '(("isUnix" . "")
																	 ("BOOST_TEST_DYN_LINK" . "")))
</src>

В качестве параметра =:file= вам надо указать любой из файлов, находящихся в корневом
каталоге проекта.  Этот файл никак не анализируется, а служит только отправной точкой для
поиска файлов.   

Для поиска подключаемых файлов используется каталоги из двух списков, которые могут быть
определены в проекте.  Параметр =:system-include-path= используется для задания списка
полных путей каталогов, в которых будет производиться поиск "системных" подключаемых
файлов.  А параметр =:include-path= задает список каталогов, относительно корневого каталога
проекта, в которых будет производиться поиск подключаемых файлов, специфичных для вашего
проекта (заметьте, что имена начинаются со знака =/=, что означает, что имена задаются
относительно корневого каталога проекта).  Вместо явного задания каталогов, вы также
можете задать функцию, которая будет заниматься поиском файлов вашего проекта.  Об этом вы
можете прочитать в руководстве EDE.

Еще один параметр, который может быть задан в проекте -- список определений, которые будут
использоваться при обработке кода препроцессором.  Параметр =:spp-table= позволяет
определить список пар, состоящих из имени символа и свзяанного с ним значения.  В нашем
примере мы определяем два символа =isUnix= и =BOOST_TEST_DYN_LINK=, которые будут переданы
препроцессору, что позволит произвести правильный разбор кода.  Более подробно про эти
определения вы можете прочитать в документации на переменную
=semantic-lex-c-preprocessor-symbol-map=.

* Work with Semantic

С точки зрения пользователя Semantic реализует несколько основных функции -- дополнение
имен, получение информации о тагах (переменных, функциях и т.д.) и навигацию по исходному
коду.  Часть команд реализуется пакетом =semantic-ia=, часть пакетом Senator, и часть --
ядром самого Semantic.

Часть команд не имеет стандартных привязок клавиш, поэтому вам лучше самим выбрать удобные
для вас привязки и привязать к ним нужные команды, например вот так:

<src lang="emacs-lisp">
(defun my-cedet-hook ()
  (local-set-key [(control return)] 'semantic-ia-complete-symbol)
  (local-set-key "\C-c?" 'semantic-ia-complete-symbol-menu)
  (local-set-key "\C-c>" 'semantic-complete-analyze-inline)
  (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle))
(add-hook 'c-mode-common-hook 'my-cedet-hook)
</src>

*Я хотел бы отметить, что работа над Semantic ведется достаточно активно, и в случае
неправильной работы каких-либо компонент, просьба отправлять примеры кода в список
рассылки cedet-devel -- автор реагирует на баг-репорты достаточно оперативно.*

** Names completion

Дополнение имен функций и классов -- достаточно востребованная и часто используемая
функция[3].  В составе Semantic идет два пакета реализующих данную функциональность --
=semantic-ia= и Senator.  Функции реализованные в составе =semantic-ia= используют для
определения списка возможных дополнений функцию =semantic-analyze-possible-completions=,
которая учитывает достаточно много параметров -- области видимости определений, и т.п., и
кроме того, она может быть переопределена пользователем для более точной генерации списка
имен.  В то время как функции Senator используют более простой механизм определения списка
возможных дополнений (в основном используя информацию об определениях в текущем файле),
что иногда ведет к неправильному его формированию, хотя и работает намного быстрее чем
функции =semantic-ia=.

Использование функции =semantic-ia-complete-symbol= при наборе кода приведет к дополнению
соответствующего имени -- функции, переменной или переменной-члена класса, в зависимости
от контекста в котором она была вызвана.  Если существует несколько вариантов, то имя
будет дополнено до наибольшей общей части имени, а при повторном вызове команды, будет
показан буфер со списком всех возможных вариантов имени.  Пользователь может также
воспользоваться функцией =semantic-ia-complete-symbol-menu=, которая также анализирует
контекст в котором она вызвана, и отображает варианты дополнений в виде графического меню,
перемещаясь по которому пользователь может выбрать нужный вариант дополнения[4].  Кроме
того, существует функция =semantic-ia-complete-tip=, которая отображает список возможных
дополнений в виде всплывающей подсказки (tooltip).

Как упоминалось выше, Senator также предоставляет функции для дополнения имен, которые
работают более быстро, но учитывают меньше параметров при генерации списка дополнений.
Функция =senator-complete-symbol= (=C-c , TAB=) дополняет имя для текущего тага, при этом она
сразу подставляет имя первого варианта из списка всех возможных вариантов.  Если вам это
не подходит, то вы можете продолжать вызывать эту функцию для перебора всех вариантов
дополнения имен (что не всегда удобно). В том случае, если вариантов имен много, или вы
хотите посмотреть полный список функций и переменных для какого-то класса, то лучше
воспользоваться функцией =senator-completion-menu-popup= (=C-c , SPC=), которая отображает
список возможных вариантов дополнений в виде графического меню.

Помимо этого, для отдельных языков пользователь может включить специальный режим --
=semantic-idle-completions-mode= (или воспользоваться функцией
=global-semantic-idle-scheduler-mode= чтобы включить его для всех режимов) при котором
дополнения имен начинают показываться спустя некоторое время бездействия.  При этом, в
качестве варианта предлагается первое значение из списка возможных дополнений, и
пользователь может использовать клавишу =TAB= для перебора вариантов.

Для языков с C-подобным синтаксисом, пользователь может воспользоваться командой
=semantic-complete-self-insert=, привязанной к клавишам =.= и =>=, как это показано ниже.

<src lang="emacs-lisp">
(defun my-c-mode-cedet-hook ()
 (local-set-key "." 'semantic-complete-self-insert)
 (local-set-key ">" 'semantic-complete-self-insert))
(add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
</src>

Использование этого кода приведет к тому, что при нажатии =.= или =>= после переменных,
экземпляров класса, будет показан список возможных дополнений для данного класса.

** Getting information about tags

Пакет =semantic-ia= реализует несколько команд, которые позволяют разработчику получать
информацию о классах, функциях и переменных.  В качестве документации используются
комментарии, извлеченные из исходного кода, в том числе и используемые для генерации
документации с помощью Doxygen.  В настоящее время реализованы следующие функции:

 =semantic-ia-show-doc= :: показывает документацию для функции или переменной чье имя
   находится под курсором.  Документация показывается в отдельном буфере.  Для переменных
   показывается их объявление, включающее тип, и строка документации, если она есть.  Для
   функций показывается их прототип, и документация по аргументам функции и возвращаемому
   значению;
 =semantic-ia-show-summary= :: показывает документацию для символа под курсором, но при
   информация отображается в мини-буфере, так что пользователь увидит только объявление
   переменной или функции;
 =semantic-ia-describe-class= :: запрашивает у пользователя имя класса и возвращает список
   функций и переменных определенных в данном классе и всех родительских классах.

** Source code navigation

Одной из самых полезных функций для навигации является функция =semantic-ia-fast-jump=,
которая позволяет переходить к объявлению переменной или функции, чье имя находится под
курсором.  Вернуться назад вы сможете использовав функцию =semantic-mrub-switch-tag= (=C-x
B=), которая доступна при использовании =semantic-mru-bookmark-mode=.

Также в Semantic определено две функции для перехода к объявлению функции или переменной
находящемся в текущем файле -- =semantic-complete-jump-local= (=C-c , j=), или в области
видимости всего проекта -- =semantic-complete-jump= (=C-c , J=).  Обе эти функции позволяют
ввести имя функции или переменной (включая локальные для функций), используя механизмы
дополнения имен, и перейти к данному определению.

Функция =semantic-analyze-proto-impl-toggle= позволяет "прыгать" между объявлением функции и
ее реализацией для языков, поддерживающих раздельное объявление и реализацию.  Еще одной
полезной функцией является =semantic-decoration-include-visit=, которая позволяет
переключиться в заголовочный файл, чье имя находится под курсором.

Senator также реализует несколько функций для навигации в исходном коде.  Сюда относятся
функции =senator-next-tag= (=C-c , n=) и =senator-previous-tag= (=C-c , p=), которые перемещаются
к следующему или предыдущему тагу, а также функция =senator-go-to-up-reference= (=C-c , u=),
которая переходит к "родительскому" тагу  (например, для функции-члена класса,
"родительским" тагом будет объявление класса).

** Search for places where function is called

Недавно в Semantic была добавлена полезная команда -- =semantic-symref=, которая позволяет
найти где символ, чье имя находится под курсором, используется в проекте.  В том случае,
если вы хотите найти данные для символа с произвольным именем, то вам стоит
воспользоваться функцией =semantic-symref-symbol=, которая позволяет вам ввести имя символа
вручную.

При этом, если вхождения символа в соответствующей базе данных (GNU Global и т.п.) не
найдены, то команда попытается найти использование заданного символа с помощью команды
=find-grep=.  В итоге создается вот такой вот буфер с найдеными результатами, используя
который пользователь может перемещаться к нужным частям кода:

<div id="screenshot">
[[../../../common/writings/emacs-devenv/cedet-symref.png]]
</div>

** Folding of the source code

Поскольку Semantic имеет практически полную синтаксическую информацию об исходных текстах,
то это позволяет реализовать практически такую же функциональность по свертыванию кусков
кода, которая реализуется пакетом *hideshow*.  Для получения этой функциональности вам
необходимо добавить следующий код в ваш файл инициализации:

<src lang="emacs-lisp">
(global-semantic-folding-mode 1)
</src>

и выполнить настройку переменной =global-semantic-tag-folding-mode=.  Это приведет к
появлению небольших треугольников в области значков (*fringle*), нажимая на которые можно
сворачивать или разворачивать соответствующий кусок текста (не только исходного текста, но
и комментариев и других объектов).

В Senator также имеется схожая функциональность, но она в основном предназначена для
работы с объектами верхнего уровня -- функциями, классами и т.п.  Сворачивание участка
кода производится с помощью функции =senator-fold-tag= (=C-c , -=), а разворачивание с помощью
функции =senator-unfold-tag= (=C-c , +=).

** Other Senator's commands

Пакет Senator определяет некоторое количество команд для работы с тагами -- вырезать или
скопировать текущий таг, вставить его в другом месте, и т.д.  Для вырезания текущего тага
(обычно это определение функции) определена функция =senator-kill-tag= (=C-c , C-w=).
Вставить таг целиком в другом месте можно с помощью стандартной комбинации клавиш =C-y=, в
то время как функция =senator-yank-tag= (=C-c , C-y=) вставляет лишь определение данного тага,
без тела.  Еще одной полезной функцией является =senator-copy-tag= (=C-c , M-w=), которая
копирует текущий таг для последующей вставки (с помощью =C-c , C-y=), что очень удобно для
вставки объявлений функций в заголовочных файлах, а полный текст скопированного тага,
вставляется с помощью =C-y=.

Senator позволяет изменить поведение стандартных функций поиска (=re-search-forward=,
=isearch-forward= и др.) при работе с исходным кодом таким образом, что функции будут
производить поиск только в соответствующих тага.  Чтобы включить этот режим вы можете
использовать функцию =senator-isearch-toggle-semantic-mode= (=C-c , i=), а с помощью функции
=senator-search-set-tag-class-filter= (=C-c , f=) вы можете ограничить пространство поиска
только указанными классами тагов -- =function= для функций, =variable= для переменных, и т.д.

Вы также можете воспользоваться поиском по тагам не переключаясь явно в режим ограничения
поиска.  Вам нужно лишь вызвать одну из функций: =senator-search-forward= или
=senator-search-backward=.
         
* Work with Srecode

Пакет Srecode позволяет пользователю определять различные шаблоны, но в отличии от других
систем для работы с шаблонами, вставка новых кусков текста, может сильно зависеть от
текущего контекста, например, вставка пары =get/set= может производиться только внутри
объявления класса, или вставка объявления новой функции может производиться только вне
какой-либо другой функции.

Основной командой, используемой для вставки шаблонов, является функция =srecode-insert=,
которая привязана к сочетанию клавиш =C-c / /=.  Эта функция запросит у вас имя шаблона,
которое вы можете ввести, используя механизмы дополнения.  В зависимости от текущего
контекста, список доступных шаблонов может меняться.  Если вы хотите вставить тот же самый
шаблон еще раз, то в можете воспользоваться командой =srecode-insert-again= (=C-c / .=),
которая вставит последний использованный шаблон.

Шаблоны также могут определять собственные привязки клавиш -- для них зарегистрирован
диапазон сочетаний =C-c / [a..z]=, и пользователь может указать в шаблоне какая клавиша
будет к нему привязана -- например, для C++ использование сочетания =C-c / c= приведет к
вставке шаблона для класса.  

Сочетания клавиш, использующие заглавные буквы, зарезервированы для шаблонов и команд,
определенных в Srecode.  Например, =C-c / G= (=srecode-insert-getset=) вставляет пару функций
=get/set= для заданной переменной-члена класса, а =C-c / E= (=srecode-edit=) используется для
редактирования шаблонов.  Число этих команд регулярно меняется, поэтому для получения
полного их списка, лучше посмотреть в документацию.

Кроме шаблонов поставляемых вместе с Cedet, пользователь может определять собственные
шаблоны и сохранять их в каталоге =~/.srecode=, где Cedet найдет их автоматически.  Про
создание шаблонов вы можете прочитать в руководстве для данного пакета, которое входит в
состав документации, поставляемой вместе с Cedet.

* Additional packages

Вместе с Cedet поставляется некоторое количество дополнительных пакетов, часто находящихся
в каталоге =contrib= дистрибутива, который автоматически добавляется в пути поиска пакетов,
поэтому загрузка нужных пакетов производится без дополнительных действий.

** The eassist package

Пакет *eassist* реализует несколько дополнительных команд, которые в своей работе используют
информацию, полученную от Semantic.  По умолчанию эти команды не имеют предопределенных
привязок клавиш, поэтому вам необходимо самим назначить нужные клавиши, если вы планируте
пользоваться этими командами.

Функция =eassist-list-methods=, запущенная в файле с исходным кодом, показывает список
функций в этом файле, позволяя выполнить быстрый переход к выбранной функции.

При разработке на языках C и C++ полезной может оказаться функция =eassist-switch-h-cpp=,
которая выполняет переключение между подключаемым файлом и файлом реализации (если они
находятся в одном каталоге)


<div id="rule">[[./index][To main page]]</div>

Footnotes: 

[1] First line is need only when you build package from CVS

[2] На моей странице вы можете найти мой [[http://xtalk.msk.su/~ott/common/emacs/rc/emacs-rc-cedet.el.html][файл инициализации Cedet]], который можно
    использовать в качестве базы для дальнейшей работы (хотя там достаточно много
    лишнего).

[3] Существует также функция =semantic-complete-analyze-inline=, которая отображает список
    возможных дополнений в отдельном окне, часто более удобно чем использование
    графического меню.

[4] В том случае, если дополнение имен работает неправильно, то попробуйте
    проанализировать почему это происходит, и лишь затем отправлять сообщение об ошибке в
    список рассылки.  Описание процесса отладки вы можете найти в Semantic User Guide в
    разделе *Smart Completion Debugging*.

;  LocalWords: emacs ede cedet localwords lang autoloads Makefile xargs ECB src
;  LocalWords:  Speedbar JDEE LocalWords CVS тагах Senator Semantic Srecode SPC

;  LocalWords:  semantic-ia emacs-lisp my-cedet-hook senator-complete-symbol
;  LocalWords:  semantic-analyze-proto-impl-toggle semantic-ia-complete-symbol
;  LocalWords:  semantic-complete-analyze-inline senator-completion-menu-popup
;  LocalWords:  semantic-ia-complete-symbol-menu semantic-complete-self-insert
;  LocalWords:  semantic-analyze-possible-completions TAB tooltip fringle C-c
;  LocalWords:  semantic-ia-complete-tip semantic-idle-completions-mode
;  LocalWords:  my-c-mode-cedet-hook semantic-ia-show-doc senator-fold-tag
;  LocalWords:  global-semantic-tag-folding-mode global-semantic-folding-mode
;  LocalWords:  hideshow senator-unfold-tag senator-copy-tag senator-pulse-tag
;  LocalWords:  senator-search-set-tag-class-filter Semantic's
;  LocalWords:  senator-isearch-toggle-semantic-mode
