#title The Gentle introduction to Cedet
#keywords c, c++, emacs, cedet, programming, semantic, ede, ide, integrated development environment

This article doesn't pretend to represent detailed description of the customizing of Emacs
as development environment (this is theme for [[emacs-devenv/index][separate article]]) -- I tried to write a
small description of the [[http://cedet.sf.net][Cedet]]'s customization to work with C & C++, although most of
description will also applicable for other languages, supported by Cedet.

<contents>

* What is Cedet?

The Cedet package is a collection of several packages, implementing different functions,
but used for one task -- provide functionality for work with source code written in
different programming languages:

 - Semantic is a basis for building of syntactic analyzers for different programming
   languages, that allows to provide common representation for information extracted from
   code, written in different languages.  Using this information, Cedet & other packages
   ([[http://jdee.sourceforge.net/][JDEE]] and [[http://ecb.sf.net][ECB]]), can implement functions, required for modern development environment
   (something like Eclipse, NetBeans, etc.);
 - SemanticDB is included into Semantic, and implements interfaces to different storage
   modules, that keeps information, that is needed for names completion, source code
   navigation, etc.  Syntactic information could be saved between Emacs sessions, so it
   reduce need for re-parsing of not modified source code.;
 - Senator -- implements navigation in source code file, using information, extracted by
   Semantic;
 - Srecode -- package for source code generation, using syntactic information, including
   information, obtained from  Semantic;
 - EDE -- implements set of extensions, that allow to work with projects -- control list
   of the targets to build, perform build of project, etc.  Besides this, using notion of
   the project, you can have more precise control about Semantic's operations -- name
   completions, and so on;
 - Speedbar -- is used to display information about current buffer, using different
   sources of information -- Semantic, some specialized information providers (for texinfo
   & html, for example), etc.
 - Eieio -- implementation of CLOS-like (Common Lisp Object System) infrastructure for
   Emacs Lisp;
 - Cogre -- library for drawing of UML-like diagrams in Emacs buffer, with basic
   integration with Semantic.

* Installation of the Cedet

Currently it's better to use development version of the Cedet, that is available from
repository at [[http://sourceforge.net/cvs/?group_id=17886][Sourceforge.net]].  After downloading of code, you need to compile the package
with following commands:

<src lang="sh">
find . -name Makefile|xargs touch
make clean ; make -k all
</src>

The first command is necessary, as =Makefile= files, that are used to build, are generated
from =Projects.ede= files, and when you fetch them from repository, they have wrong date,
and this lead to the build errors.[1]

* Customization

The loading of package is performed with the =cedet.el= script, so all you need to do -- is
just add following line to the your Emacs initialization file[2]:

<src lang="emacs-lisp">
(load-file "~/emacs/cedet/common/cedet.el")
</src>

If you plan to use projects, then you need to switch corresponding mode on -- it's
implemented by EDE package:

<src lang="emacs-lisp">
(global-ede-mode t)
</src>

** Semantic's customization

Depending on your requirements, you can use one of the commands, described below, to load
corresponding set of features (these commands are listed in increasing order, and each
command include features of previous commands):

 - =semantic-load-enable-minimum-features= -- enables only minimum of necessary features --
   keep syntactic information for current buffer up-to date, storing of syntactic
   information for later use (Semanticdb), and loading of corresponding information with
   Semanticdb and Ebrowse;
 - =semantic-load-enable-code-helpers= -- enables =senator-minor-mode= for navigation in
   buffer, =semantic-mru-bookmark-mode= for storing positions of visited tags, and
   =semantic-idle-summary-mode=, that shows information about tag under point;
 - =semantic-load-enable-gaudy-code-helpers= -- enables =semantic-stickyfunc-name= that
   displays name of current function in topmost line of buffer, =semantic-decoration-mode=
   to decorate tags, using different faces, and =semantic-idle-completion-mode= for
   automatic generation of possible names completions, if user stops his work for some
   time;
 - =semantic-load-enable-excessive-code-helpers= -- enables =which-func-mode=, that shows name
   of current function in status line;
 - =semantic-load-enable-semantic-debugging-helpers= -- enables several modes, that are
   useful when you debugging Semantic -- displaying of parsing errors, its state, etc.

So, you need to add call to one of these commands right after command, that performs
loading of Cedet.  For example:

<src lang="emacs-lisp">
(semantic-load-enable-excessive-code-helpers)
</src>

To use additional features for names completion, and displaying of information for tags &
classes, you also need to load the =semantic-ia= package.  This could be performed with
following command:

<src lang="emacs-lisp">
(require 'semantic-ia)
</src>

After loading of this package, you'll get access to commands, described below.

*** System header files

To normal work with system-wide libraries, Semantic should has access to system include
files, that contain information about functions & data types, implemented by these
libraries.

If you use GCC for programming in C & C++, then Semantic can automatically find path,
where system include files are located.  To do this, you need to load =semantic-gcc= package
with following command:

<src lang="emacs-lisp">
(require 'semantic-gcc)
</src>

You can also explicitly specify additional paths for look up of include files (and these
paths also could vary for specific modes).  To add path to list of system include paths,
you can use the =semantic-add-system-include=, that accepts two parameters -- string with
path to include files, and symbol, representing name of major mode, for which this path
will used.  For example:

<src lang="emacs-lisp">
(semantic-add-system-include "~/exp/include/boost_1_37" 'c++-mode)
</src>

*** Optimization of Semantic's work

To optimize work with tags, you can use several techniques:
 - limit search by setting of the EDE project, as this described below;
 - explicitly specify a list of root directories for your projects, so Semantic will use
   limited number of databases with syntactic information;
 - explicitly generate tags databases for often used directories (=/usr/include=,
   =/usr/local/include=, etc.) with the =semanticdb-create-ebrowse-database= or
   =semanticdb-create-cscope-database= commands;
 - limit search by customization of the =semanticdb-find-default-throttle= variable for
   concrete modes -- for example, don't use information from system include files, by
   removing =system= symbol from list of objects to search for =c-mode=:
<src lang="emacs-lisp">
(setq-mode-local c-mode semanticdb-find-default-throttle
								 '(project unloaded system recursive))
</src>

Besides this, you can point to Semantic, that it should extract syntactic information for
current buffer only when Emacs is idle.  To do this, you need to enable
=semantic-idle-scheduler-mode=, and customize the =semantic-idle-scheduler-idle-time=
variable, that specify idle time (in seconds).

*** Integration with imenu

The Semantic package could be integrated with the *imenu* package, that allows to display
menu with list of functions, variables, etc.  To enable this feature, you need to add
following code into your initialization file:

<src lang="emacs-lisp">
(defun my-semantic-hook ()
  (imenu-add-to-menubar "TAGS"))
(add-hook 'semantic-init-hooks 'my-semantic-hook)
</src>

** Customization of Semanticdb

If you had used standard procedure of Cedet's loading, then Semanticdb will loaded
automatically.  Otherwise, you can load and enable it with following commands:

<src lang="emacs-lisp">
(require 'semanticdb)
(global-semanticdb-minor-mode 1)
</src>

To customize Semanticdb you need to specify some number of variables, that are used to
specify path, where databases will stored, and some other parameters.  These variables
could be set via =semanticdb= customization group.

Besides this, Semanticdb can use databases generated by external utilities -- =gtags= from
[[http://www.gnu.org/software/global/][GNU Global]], =ctags=, =ebrowse= & =cscope=.  To activate this you can use following code:

<src lang="emacs-lisp">
;; if you want to enable support for gnu global
(require 'semanticdb-global)
(semanticdb-enable-gnu-global-databases 'c-mode)
(semanticdb-enable-gnu-global-databases 'c++-mode)

;; enable support for ctags 
(semantic-load-enable-all-exuberent-ctags-support)
</src>

** How to customize  Semantic to work with C & C++ projects

To proper work of  Semantic with С & C++ code is recommended to use the EDE package (work
with projects, etc.).  For these languages, the EDE package defines special project type
-- =ede-cpp-root-project=, that provides additional information to Semantic, that will used
to analyze source code of your project.   To use this feature, you need to enable
corresponding mode -- =global-ede-mode=, as shown above.  

To define a project, you need to use following code:

<src lang="emacs-lisp">
(ede-cpp-root-project "Test"
											:name "Test Project"
											:file "~/work/project/CMakeLists.txt"
											:include-path '("/"
																			"/Common"
																			"/Interfaces"
																			"/Libs"
																			 )
											:system-include-path '("~/exp/include")
											:spp-table '(("isUnix" . "")
																	 ("BOOST_TEST_DYN_LINK" . "")))
</src>

You can use any file at root directory of the project, as an argument to =:file= parameter.
This file isn't analyzed, but it's only used as an anchor to search a files from projects.

To searching of include files, Semantic uses directories from two lists, that could be
defined in project.  The =:system-include-path= parameter is used to specify list of the
full paths that will searched for "system" include files.  Another parameter --
=:include-path= specifies the list of directories, relative to the project's root directory,
that will searched for your include files (if names are starting with =/=, this means, that
name is specified relative to root directory).  Instead of specifying of the paths lists,
you can also provide function, that will perform a search for include files in your
project.  You can read about it in the EDE's manual.

Another parameter, that could be specified in project's definition is a list of
definitions, that will be used during preprocessing of the code.  The =:spp-table= parameter
allows to specify list of pairs, consisting from symbol's name & value, defined for it.
In our example above, we define two symbols -- =isUnix= and =BOOST_TEST_DYN_LINK=, that will
passed to preprocessor, and this allows to perform proper parsing of the code.  More
information about these definitions you can find in documentation for the
=semantic-lex-c-preprocessor-symbol-map= variable.

* Work with Semantic

From the user's point of view, Semantic implements several major functions -- name
completions, obtaining information about tags (variables, functions, etc.), and navigation
in source code.  Some of commands are implemented by =semantic-ia= package, other, by
Senator package, and rest of them, are implemented by Semantic's kernel.

Some of commands have no standard key bindings, so you it's better to select key bindings,
that are comfortable to you, and bind needed commands to them, for example, like this:

<src lang="emacs-lisp">
(defun my-cedet-hook ()
  (local-set-key [(control return)] 'semantic-ia-complete-symbol)
  (local-set-key "\C-c?" 'semantic-ia-complete-symbol-menu)
  (local-set-key "\C-c>" 'semantic-complete-analyze-inline)
  (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle))
(add-hook 'c-mode-common-hook 'my-cedet-hook)
</src>

*I want to mention, that Semantic's development is pretty active, and if something doesn't
work, or works wrong, then please, send examples of code to the cedet-devel mailing list
-- the Cedet's author, answers pretty operative.*

** Names completion

Name completions for names of functions & classes is pretty often used feature[3].  There
are two packages inside Semantic that implement this functionality -- =semantic-ia= and
Senator.  Functions, implemented by =semantic-ia= use the
=semantic-analyze-possible-completions= function to create a list of all possible names
completion, and this function take into account many parameters, and it could be also
extended by user to provide more precise list of names.  At the same time, functions from
Senator package use more simple methods to create a list of all possibles completions
(usually use information about only definitions in current file), and this sometime lead
to the wrong completion of names.

If you execute the =semantic-ia-complete-symbol= command when you typing code, then its
execution will lead to completion of corresponding name -- name of function, variable, or
class member, depending on current context.  If there are several variants of name, then
this name will completed to most common part of it, and if you'll call this command second
time, then buffer with all possible completions will shown.  User can also use the
=semantic-ia-complete-symbol-menu= command, that also analyze current context, and displays
list of possible completions as a graphical menu, from which the needed name could be
selected by user[4].  Besides this, there is =semantic-ia-complete-tip= command, that
displays list of possible completions as tooltip.

As was mentioned above, the Senator package, also provides functions for names completion,
that work fast, but with less precision, as they use few parameters during computation of
names for completions. The =senator-complete-symbol= command (=C-c , TAB=) completes name for
current tag, and insert first found completion as result.  If it substitute wrong name,
then you can insert second name from completion list by repeating this command, and so on.
If there are lot of the possible names, or you want to see full list of functions and
variables for some class, then it's better to use the =senator-completion-menu-popup=
command (=C-c , SPC=), that displays list of all possible completions as a graphical menu.

Besides these commands, for some languages user can explicitly enable special mode --
=semantic-idle-completions-mode= (or use the =global-semantic-idle-scheduler-mode= to enable
it for all supported languages) -- in this mode names completions are shown automatically
if user stops its work for a some time (idle time).  By default, only first possible
completion is shown, and user can use the =TAB= key to navigate through list of possible
completions.

For C-like languages, user can use the =semantic-complete-self-insert= command, bound to the
=.= and/or =>= keys, as this show below:

<src lang="emacs-lisp">
(defun my-c-mode-cedet-hook ()
 (local-set-key "." 'semantic-complete-self-insert)
 (local-set-key ">" 'semantic-complete-self-insert))
(add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
</src>

Use of this setting will lead to execution of =semantic-complete-self-insert= command when
user will press =.= or =>= after variables, that are class or structure instances, and
displaying of list of possible completions for given class or structure.

** Getting information about tags

The =semantic-ia= package implements several commands, that allows to get information about
classes, functions & variables.  As documentation are used comments, extracted from source
code, including comments, written for Doxygen.  Now following functions are implemented:

 =semantic-ia-show-doc= :: shows documentation for function or variable, whose names is
   under point.  Documentation is shown in separate buffer.  For variables this function
   shows their declaration, including type of variable, and documentation string, if it
   available.  For functions, function's prototype is shown, including documentation for
   arguments and returning value (if comments are available);
 =semantic-ia-show-summary= :: shows documentation for name under point, but information is
   shown in the mini-buffer, so user will see only variable's declaration or function's
   prototype;
 =semantic-ia-describe-class= :: asks user for a name of the class, and return list of
   functions & variables, defined in given class, and all its parent classes.

** Navigation in source code 

One of the most useful commands for navigation in source code is the =semantic-ia-fast-jump=
command, that allows to jump to declaration of variable or function, whose name is under
point.  You can return back by using the =semantic-mrub-switch-tag= command (=C-x B=), that is
available when you use the =semantic-mru-bookmark-mode= minor mode.

Semantic also provides two additional commands for jumping to function or variable,
defined in current file -- =semantic-complete-jump-local= (=C-c , j=), or defined in current
project -- =semantic-complete-jump= (=C-c , J=).  Both commands allow to enter name of
function or variable (including local variables for functions) and jump to given
definition (you can use name completion when entering the name).

The =semantic-analyze-proto-impl-toggle= command allows to switch between function's
declaration and its implementation in languages, that allows to have separate declaration
and implementation of functions.  Another useful command is
=semantic-decoration-include-visit=, that allows to switch to the include file, whose name
is under point.

Senator also implements several commands for navigation in source code.  This is commands
=senator-next-tag= (=C-c , n=) and =senator-previous-tag= (=C-c , p=), that move cursor to the
next or previous tag, and also the =senator-go-to-up-reference= command (=C-c , u=), that move
cursor to the "parent" tag (for example, for class member function, "parent" tag is class
declaration).

** Search for places where function is called

Not so long ago a very useful command was implemented in Semantic -- =semantic-symref=, that
allows to find places, where symbol, whose name is under point, is used in the project.
If you want to find usage of symbol with any name, you can use the =semantic-symref-symbol=,
that allows to explicitly specify name of the symbol.

If references to given name weren't found in the corresponding database (GNU Global,
etc.), then this command tries to find them with the =find-grep= command.  As result of
execution of these commands, a new buffer with results will created, and user can use them
to jump to found places:

<div id="screenshot">
[[../../../common/writings/emacs-devenv/cedet-symref.png]]
</div>

** Folding of the source code

As Semantic has almost full syntactic information about source code, this allows it to
implement folding functionality, similar to implemented by *hideshow* package.  To enable
this feature, you need to add following line of code to your initialization file:

<src lang="emacs-lisp">
(global-semantic-folding-mode 1)
</src>

and perform customization of the =global-semantic-tag-folding-mode= variable.  This will
lead to displaying of small triangles at the *fringle* field, and you'll able to fold and
unfold pieces of code pressing on them (not only pieces source code, but also comments,
and other objects).

Senator also has similar functionality, but it usually used for top-level objects --
functions, class declarations, etc.  You can fold piece of code with the =senator-fold-tag=
command (=C-c , -=), and unfold with =senator-unfold-tag= (=C-c , +=).

** Other commands implemented in Senator

The Senator package defines number of commands for work with tags, that allows to cut or
copy tag, and insert it in another place, and so on.  To cut current tag (usually this is
function's declaration or implementation) the =senator-kill-tag= command (=C-c , C-w=) is
defined.  You can insert tag with standard key binding =C-y=, while the =senator-yank-tag=
command (=C-c , C-y=) inserts only tag's declaration, without body. Another useful command
is =senator-copy-tag= (=C-c , M-w=), that copies (you can use =C-c , C-y= key binding), that's
very handy when you want to insert function's declaration into header file.

Senator allows to change behaviour of standard search commands (=re-search-forward=,
=isearch-forward= and other), when you work with source code, such way, so they will perform
search only in given tags.  To enable this mode you can use the
=senator-isearch-toggle-semantic-mode= command(=C-c , i=), and with the
=senator-search-set-tag-class-filter= command (=C-c , f=) you can limit search to given tag's
types -- =function= for functions, =variable= for variables, etc.

You can also perform tags search without enabling this mode -- you just need to call
corresponding function -- =senator-search-forward= or =senator-search-backward=.
         
* Work with Srecode

Пакет Srecode позволяет пользователю определять различные шаблоны, но в отличии от других
систем для работы с шаблонами, вставка новых кусков текста, может сильно зависеть от
текущего контекста, например, вставка пары =get/set= может производиться только внутри
объявления класса, или вставка объявления новой функции может производиться только вне
какой-либо другой функции.

Основной командой, используемой для вставки шаблонов, является функция =srecode-insert=,
которая привязана к сочетанию клавиш =C-c / /=.  Эта функция запросит у вас имя шаблона,
которое вы можете ввести, используя механизмы дополнения.  В зависимости от текущего
контекста, список доступных шаблонов может меняться.  Если вы хотите вставить тот же самый
шаблон еще раз, то в можете воспользоваться командой =srecode-insert-again= (=C-c / .=),
которая вставит последний использованный шаблон.

Шаблоны также могут определять собственные привязки клавиш -- для них зарегистрирован
диапазон сочетаний =C-c / [a..z]=, и пользователь может указать в шаблоне какая клавиша
будет к нему привязана -- например, для C++ использование сочетания =C-c / c= приведет к
вставке шаблона для класса.  

Сочетания клавиш, использующие заглавные буквы, зарезервированы для шаблонов и команд,
определенных в Srecode.  Например, =C-c / G= (=srecode-insert-getset=) вставляет пару функций
=get/set= для заданной переменной-члена класса, а =C-c / E= (=srecode-edit=) используется для
редактирования шаблонов.  Число этих команд регулярно меняется, поэтому для получения
полного их списка, лучше посмотреть в документацию.

Кроме шаблонов поставляемых вместе с Cedet, пользователь может определять собственные
шаблоны и сохранять их в каталоге =~/.srecode=, где Cedet найдет их автоматически.  Про
создание шаблонов вы можете прочитать в руководстве для данного пакета, которое входит в
состав документации, поставляемой вместе с Cedet.

* Additional packages

Вместе с Cedet поставляется некоторое количество дополнительных пакетов, часто находящихся
в каталоге =contrib= дистрибутива, который автоматически добавляется в пути поиска пакетов,
поэтому загрузка нужных пакетов производится без дополнительных действий.

** The eassist package

Пакет *eassist* реализует несколько дополнительных команд, которые в своей работе используют
информацию, полученную от Semantic.  По умолчанию эти команды не имеют предопределенных
привязок клавиш, поэтому вам необходимо самим назначить нужные клавиши, если вы планируте
пользоваться этими командами.

Функция =eassist-list-methods=, запущенная в файле с исходным кодом, показывает список
функций в этом файле, позволяя выполнить быстрый переход к выбранной функции.

При разработке на языках C и C++ полезной может оказаться функция =eassist-switch-h-cpp=,
которая выполняет переключение между подключаемым файлом и файлом реализации (если они
имеют одинаковые имена, но разные расширения файлов).


<div id="rule">[[./index][To the main page]]</div>

Footnotes: 

[1] First line is need only when you build package from CVS

[2] На моей странице вы можете найти мой [[http://xtalk.msk.su/~ott/common/emacs/rc/emacs-rc-cedet.el.html][файл инициализации Cedet]], который можно
    использовать в качестве базы для дальнейшей работы (хотя там достаточно много
    лишнего).

[3] Существует также функция =semantic-complete-analyze-inline=, которая отображает список
    возможных дополнений в отдельном окне, часто более удобно чем использование
    графического меню.

[4] В том случае, если дополнение имен работает неправильно, то попробуйте
    проанализировать почему это происходит, и лишь затем отправлять сообщение об ошибке в
    список рассылки.  Описание процесса отладки вы можете найти в Semantic User Guide в
    разделе *Smart Completion Debugging*.

;  LocalWords: emacs ede cedet localwords lang autoloads Makefile xargs ECB src
;  LocalWords:  Speedbar JDEE LocalWords CVS тагах Senator Semantic Srecode SPC
;  LocalWords:  semantic-ia emacs-lisp my-cedet-hook senator-complete-symbol ia
;  LocalWords:  semantic-analyze-proto-impl-toggle semantic-ia-complete-symbol
;  LocalWords:  semantic-complete-analyze-inline senator-completion-menu-popup
;  LocalWords:  semantic-ia-complete-symbol-menu semantic-complete-self-insert
;  LocalWords:  semantic-analyze-possible-completions TAB tooltip fringle C-c
;  LocalWords:  semantic-ia-complete-tip semantic-idle-completions-mode Cedet's
;  LocalWords:  my-c-mode-cedet-hook semantic-ia-show-doc senator-fold-tag impl
;  LocalWords:  global-semantic-tag-folding-mode global-semantic-folding-mode
;  LocalWords:  hideshow senator-unfold-tag senator-copy-tag senator-pulse-tag
;  LocalWords:  senator-search-set-tag-class-filter Semantic's Semanticdb EDE's
;  LocalWords:  senator-isearch-toggle-semantic-mode isearch symref proto mrub
;  LocalWords:  variable's Doxygen devel inline
