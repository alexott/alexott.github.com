#title Work with Erlang
#keywords emacs, erlang, distel, erlang-mode, erlware-mode

<contents>

Basic support of Erlang in Emacs is provided by *erlang-mode* package, that comes with
Erlang distribution.  This package implements base operations for work with Erlang's
source code -- syntax highlighting, indentation, etc.

Besides this, there are also other packages -- they provide implementation of useful
operations, not existing in *erlang-mode* -- debugging, profiling, etc.  The *Distel*[1]
package is an add-on to the *erlang-mode*, while *erlware-mode* package is a fork of the
*erlang-mode*, with implementation of additional commands.

#erlang-mode
* erlang-mode

The *erlang-mode* package comes with Erlang distribution, and available for use right after
Erlang's installation.  Documentation for this package is available either from
[[http://www.erlang.org/doc/man/erlang_mode.html][Erlang's site]], or from Erlang's manual pages, accessible with =erl -man erlang_mode=
command.  Documentation has detailed description of all commands.

Almost all commands, implemented by package are available to user via =Erlang= menu, and
most often used also have key bindings (described below) for quick access to them.

#erlang-customize
** Installation and customization of the package

Installation of the package is quite simple -- you need to specify path to the *erlang-mode*
(usually this is sub-directory inside Erlang's distribution), and load package
=erlang-start=, as here, for example:

<src lang="emacs-lisp">
(add-to-list 'load-path ".....")
(require 'erlang-start)

(add-to-list 'auto-mode-alist '("\\.erl?$" . erlang-mode))
(add-to-list 'auto-mode-alist '("\\.hrl?$" . erlang-mode))

(setq erlang-root-dir "/opt/local/lib/erlang")
(add-to-list 'exec-path "/opt/local/lib/erlang/bin")
(setq erlang-man-root-dir "/opt/local/lib/erlang/man")
</src>

in this example, we additionally set list of file extensions, that will be associated with
*erlang-mode*.  And we also change list of directories where search for executable files is
performed, so all Erlang's utilities will work without any problems.  Another two
variables -- =erlang-root-dir= and =erlang-man-root-dir= set root directory of Erlang's
distribution, and directory, where manual pages for Erlang are stored.

Besides this, user can tune package's behaviour with =erlang-mode-hook=, for example with
following code:

<src lang="emacs-lisp">
(defun my-erlang-mode-hook ()
	;; when starting an Erlang shell in Emacs, default in the node name
	(setq inferior-erlang-machine-options '("-sname" "emacs"))
	;; add Erlang functions to an imenu menu
	(imenu-add-to-menubar "imenu")
	;; customize keys
	(local-set-key [return] 'newline-and-indent)
	)
;; Some Erlang customizations
(add-hook 'erlang-mode-hook 'my-erlang-mode-hook)
</src>

This code sets list of options, that will passed to Erlang process, and also change key
bindings for *erlang-mode*, and add list of defined Erlang's functions into menu, generated
by *Imenu* package.

** Work with source code

*erlang-mode* provides to user set of the commands for work with source code.  This set
includes commands for source code navigation, code editing & indenting.

When you work with source code of function, consisting from several clauses (parts), then
you can use command =erlang-generate-new-clause= (it bound to =C-c C-j=) to insert new clause
in current point -- this command takes name of function from previous clause, and after
inserting name, it put cursor in argument list.  If most of function's parameters are same
as in previous clause, then you can use the =erlang-clone-arguments= (=C-c C-y=) command to
copy parameters from previous clause and inserting them into current expression.

Depending on than current context, keys '<code>,</code>', '<code>;</code>',
'<code><</code>' and '<code>></code>' have different behaviour.  So, if you at the end of
expression, and press =;=, then template for new expression will be inserted, as you
explicitly call =erlang-generate-new-clause= command.  And, if you press =,= at the end of
expression, then this will lead to moving to new line and setting proper indent for code.

To make Erlang's source code more readable user can use the =erlang-align-arrows= (=C-c C-a=)
command, that aligns all arrows (=->=) after clauses -- this makes code more readable, as
clauses boundaries are explicitly shown.

Users is often need to mark source code of function or current clause.  *erlang-mode*
defines two commands for these operations: the =erlang-mark-clause= command (=M-h= or =C-c M-h=)
is used to mark current clause, while the =erlang-mark-function= command (=M-C-h=) could be
used to mark whole function.

To work with comments there are several commands.  To comment out selected region, user
can use the =comment-region= command (=C-c C-c=), that will insert one comment sign (=%=) into
start of each line.  If you want to delete comment from selected region, you can execute
the =erlang-uncomment-region= command (=C-c C-u=).  You can also use the =comment-dwim= command
(=M-;=) to mark selected region, or insert one line comment into end of existing line of
code.

Besides this, *erlang-mode* provides the =erlang-fill-paragraph= command (=M-q=) that tries to
properly format current paragraph with commentary, and increase readability of the source
code.

*erlang-mode* also provides number of commands for proper indenting of source code.  By
pressing to =TAB= key you run the =erlang-indent-command= command, that will set proper
indentation for current line of code.  For selected region you can use standard command
=indent-region= (=M-C-\=).  There are also separate commands for set indentation for current
clause -- =erlang-indent-clause=, function -- =erlang-indent-function= (=C-c C-q=) and for whole
buffer -- =erlang-indent-current-buffer=.

** Navigation in source code

In addition to standard commands for navigation inside source code -- next/previous
bracket, etc., *erlang-mode* implements several additional commands that allow to navigate
between Erlang's objects -- clauses & functions.  Commands =erlang-beginning-of-function=
(=C-a M-a=) and =erlang-end-of-function= (=C-a M-e=) move cursor to start or end of current
Erlang's function[2], and commands =erlang-beginning-of-clause= (=M-C-a=) and
=erlang-end-of-clause= (=M-C-e=) move cursor to start/end of the current clause.

*erlang-mode* also extends set of standard commands for work with tags.  To use these
commands, you'll need to create special file =TAGS=, that could be generated either with
=etags= command from Emacs's distribution, either with =tags= module from Erlang's
distribution.

Using existing =TAGS= file you can use standard commands to work with tags -- =find-tag=
(=M-.=), =tags-apropos=, =tags-search= (=C-x t s=) and other.  *erlang-mode* add following commands
-- =erlang-find-tag=, that works like =find-tag=, but allows to specify name of the module
where search will performed (if tag is specified as =module:= or =module:tag=),
=erlang-find-next-tag= (=M-+=), that search for next tag with given name, and two commands --
=erlang-find-tag-other-frame= (=C-x 5 .=) and =erlang-find-tag-other-window= (=C-x 4 .=), that
open tag's definition in new frame or window.

Use can also use the =erlang-complete-tag= command (=M-TAB=) to complete names of existing
functions using data, collected in =TAGS= file.

** Code templates

To make work of user more easy, *erlang-mode* has number of code templates (snippets), that
could be inserted into source code using the =Skeletons= items from =Erlang= menu, or directly
calling =tempo-template-erlang-XXX=, where =XXX= is a name of the template.  To insert
templates the *tempo* package included into Emacs.  Currently, package provides following
templates:
 - snippets for simple constructions, like =if=, =case=, =receive=, etc.;
 - snippets for "standard" file headers -- module name, module's author, etc.;
 - snippets for different standard servers (*behaviour* in Erlang's terminology) --
   =gen_server=, =application=, =gen_fsm=, etc.

** Compilation and work with =erl=

User can execute Erlang's commands interactively using =erl= process running in the Emacs's
buffer (process is running with =comint=, so user can use standard commands of this package,
for example, navigation through history of commands with =M-p= & =M-n= keys).  This process is
also used by *erlang-mode* to compile source code.

To run new =erl= process, user can use the =erlang-shell= command, but it will implicitly run
when user run compilation of source code, or try to switch to =*erlang*= buffer with
=erlang-shell-display= command (=C-c C-z=).

Compilation and loading of compiled code is performed with =erlang-compile= command (=C-c
C-k=).  If user gives prefix argument to this command, then compilation will performed with
options =debug_info= & =export_all=.  To view compilation results, user can run
=erlang-compile-display= command (=C-c C-l=).  To move between errors, the =erlang-next-error=
command (=C-x `=) is could be used.  In this case, if you want to move to first error, you
need to give prefix argument to this command, for example with =C-u C-x `=.

* erlware-mode

*erlware-mode* package is replacement for *erlang-mode*, using it as a base, but adding
following new functionality:
 - code templates are changed -- now they contain information for =edoc= utility;
 - started work on the integration with *Sinan* & *Faxien* projects, that allows to make
   installation & maintenance of Erlang's packages more easy.

This package is available from [[http://www.erlware.org/tools/erlware-mode/index.html][project's site]], and its installation & customization isn't
differs from  [[#erlang-customize][erlang-mode's installation & customization]].

Execution of basic commands also not differs from execution of the *erlang-mode* commands.
Description of new commands will added in future, as they will released.

* distel

The *distel* package, available from http://code.google.com/p/distel/, is a library in Emacs
Lisp, that allows to write Emacs code in distributed style, and also allows to communicate
with code, written in Erlang.  This allows to implement set of commands, not existing in
*erlang-mode*, that allow to perform following tasks:
 - search for function's definitions & access to actual documentation;
 - module's & function's names completion, using actual information from Erlang
   environment;
 - direct evaluation of the code snippets;
 - base support for source code refactoring;
 - debugging of Erlang programs;
 - display information about  Erlang processes and work with them;
 - code profiling.

Short review of package features you can find at [[http://bc.tech.coop/blog/070528.html][article of Bill Clementson]].  Package
comes together with very detailed documentation, describing both basic concepts, and
functions, implemented in package.

** Installation & customization of distel

To install package, you need to download it from the [[http://code.google.com/p/distel/][project's site]] and unpack it into
selected place, and than add following code into initialization file:

<src lang="emacs-lisp">
(add-to-list 'load-path "~/emacs/distel/elisp")
(require 'distel)
(distel-setup)
</src>

This code will perform loading and base customization of the package.  In additional we
can perform more precise customization using hooks.  For example, following code[3] will
add new key bindings to mode, that is used to interactive work with Erlang, making this
work more comfortable:

<src lang="emacs-lisp">
;; A number of the erlang-extended-mode key bindings are useful in the shell too
(defconst distel-shell-keys
  '(("\C-\M-i"   erl-complete)
    ("\M-?"      erl-complete)	
    ("\M-."      erl-find-source-under-point)
    ("\M-,"      erl-find-source-unwind) 
    ("\M-*"      erl-find-source-unwind) 
    )
  "Additional keys to bind when in Erlang shell.")

(add-hook 'erlang-shell-mode-hook
					(lambda ()
						;; add some Distel bindings to the Erlang shell
						(dolist (spec distel-shell-keys)
							(define-key erlang-shell-mode-map (car spec) (cadr spec)))))
</src>

** Work with source code

The *distel* package add to *erlang-mode* several commands for work with source code.  But i
need to mention, that some of them requires running Erlang environment, and when you'll
execute them first time, they will ask you for a name of the node, that will be used to
get all necessary information.  User can switch between nodes with the =erl-choose-nodename=
command(=C-c C-d n=).  And for checking availability of the concrete node the =erl-ping=
command(=C-c C-d g==) could be used.  The command will ask you for name of the node, and if
it available, it will load to node all modules are needed to work with *distel*.  Name of
the current node is displayed in the status line.

Besides direct execution of commands, user can run them from the =Distel= item in =Erlang=
menu.
 
*Distel* implements its own set of commands for completion of modules & functions names.  To
get this information, package retrieve it from running Erlang environment.  To use name
completion you can run =erl-complete= command (=M-TAB= or =M-?=).  If already entered part of
name corresponds several names, then package will create a new buffer and user should
select between suggested variants.

Также, переопределяются и команды работы с тагами, но в отличии от *erlang-mode* вам нет
необходимости регулярно обновлять файл =TAGS=, поскольку *distel* позволяет найти определение
функции используя информацию от среды выполнения.  Для перехода к определению нужной
функции вы можете использовать команду =erl-find-source-under-point= (=M-.=) -- по умолчанию,
эта команда в качестве имени функции берет то имя, которое находится под курсором.  Но вы
можете изменить это поведение, если передадите префиксный аргумент (=C-u=), или если
переменная =distel-tags-compliant= имеет не-=nil= значение -- в этом случае, у вас запросят
имя функции, определение которой вы хотите найти.  Чтобы вернуться назад, к точке вызова,
вы можете использовать команду =erl-find-source-unwind= (=M-,= или =M-*=).

Кроме того, в *distel* есть рудиментальные возможности по рефакторингу кода.  С помощью
команды =erl-refactor-subfunction= (=C-c C-d f=) пользователь может выделить часть кода
(пользователю необходимо выделить нужный блок с помощью стандартных команд) функции в
отдельную функцию.  При выполнении данной команды, у пользователя будет запрошено название
новой функции, будет определен список переменных, используемых в данной функции, и
выделенная часть кода будет заменена на вызов новой функции.  Сама новая функция будет
помещена в буфер обмена, откуда она может быть вставлена с помощью команды =yank= (=C-y=).
Пример использования данной функции вы можете найти в документации *distel*.

** Obtaining information from documentation

Для более удобной работы с документацией, пакет *distel* использует внешние программы,
написанные на Erlang, которые выполняют предварительную обработку документации, и затем
используют полученные данные для ее отображения.

Для обработки документации в формате HTML, имеется модуль =otp_doc=, который выполняет
анализ файлов, и генерирует набор пар "сигнатура функции/ссылка на документацию".
С помощью команды =erl-find-sig= пользователь может получить список сигнатур функций,
соответствующих заданному выражению, а затем может воспользоваться командой =erl-find-doc=
для отображения документации (для этого необходимо наличие пакета *w3m*).  В том случае если
имеется несколько функций, соответствующих запросу, то пользователь должен будет выбрать
нужную функцию из списка.

Пользователь может также получить краткую документацию по загруженным модулям.  Для этого
используется дополнительный модуль =fdoc=, который также, как и =otp_doc=, проводит анализ
исходных текстов загруженных модулей и сохраняет собранные данные для последующего
использования.  Получить описание модуля или функции из базы данных =fdoc= можно с помощью
команды =erl-fdoc-describe= (=C-c C-d d=).  А с помощью команды =erl-fdoc-apropos= (=C-c C-d a=)
можно получить перечень функций, чьи названия или комментарий соответствуют заданному
регулярному выражению.  В том случае, если одна из команд получает префиксный аргумент,
она вначале выполняет перестройку базы данных =fdoc=, и только затем выполняет требуемую
операцию.
  
** Execution and profiling of code

*Distel* расширяет набор команд *erlang-mode* предназначенных для выполнения кода Erlang.  С
помощью команды =erl-eval-expression= (=C-c C-d :=) пользователь может ввести в мини-буфере
выражение на Erlang и получить результаты его вычисления.  В том случае, если пользователь
выделил регион кода, то этот код будет предложен в качестве значения по умолчанию.  Кроме
того, определены две команды, которые позволяют перегружать модули на выбранном узле.  Это
команда =erl-reload-module= (=C-c C-d L=), которая заново загружает модуль с заданным именем,
и команда =erl-reload-modules= (=C-c C-d r=), которая заново загружает все обновленные
используемые модули.

Более мощные возможности по интерактивному выполнению кода Erlang реализованы в рамках так
называемых "интерактивных сессий" -- аналоге буфера =*scratch*= в Emacs, которые позволяют
вводить и выполнять отдельные выражения Erlang не создавая выделенных файлов с исходным
кодом (пример работы вы можете увидеть на скриншоте ниже).  Для начала работы в этом
режиме, необходимо выполнить команду =erl-ie-show-session= (=C-c C-d e=), которая либо создаст
новый, либо переключит в существующий буфер в котором пользователь может вводить команды.
По умолчанию, буфер имеет название =*ie sessions имя_узла*=.  Внутри этого буфера,
пользователь может вводить выражения и определения функций.  Для вычисления выражения,
которое находится перед курсором, используется команда =erl-ie-eval-expression= (=C-j=), а для
вычисления определения функции -- команда =erl-ie-eval-defun= (=C-M-x=).

<div id="screenshot">
[[../../../common/writings/emacs-devenv/distel-ie-sessions.png]]
</div>

Также как и для документации, для профилирования используется существующий модуль Erlang
-- =fprof=.  Для работы с ним *distel* предоставляет две команды.  С помощью команды =fpropf=
(=C-c C-d p=) пользователь может ввести выражение Erlang и получить результаты выполнения
этого выражения в режиме профилирования.  А с помощью команды =fprof-analyse= (=C-c C-d P=)
можно загрузить файл с уже имеющимися данными профилирования, и проводить их анализ в
удобной форме.   После проведения анализа, пользователь получает доступ к буферу, в
котором перечислены все использованные в работе функции, и для каждой из них приводится
следующая информация: =Calls= -- общее количество вызовов данной функции; =ACC= -- сколько
времени (в миллисекундах) было затрачено на выполнение данной функции, включая вызов
других функций, вызванных из нее; =Own= -- сколько времени выполнялась сама функция, без
учета других функций, вызванных из нее.  Пример вывода результатов профайлинга вы можете
увидеть на рисунке ниже.

<div id="screenshot">
[[../../../common/writings/emacs-devenv/distel-fprof.png]]
</div>

** Work with debugger

; TODO: добавить скриншот отладчика

Для реализации возможности отладки приложений, *distel* использует те же модули, что и
отладчик, идущий в составе Erlang.  Для того, чтобы воспользоваться отладкой, необходимо
скомпилировать модули с добавлением отладочной информации (необходимо явно указать ключ
=+debug-info= компилятору =erlc= или выполнить команду =erlang-compile= с префиксным
аргументом).

При работе отладчика создаются отдельные буфера для отображения списка отлаживаемых
(интерпретируемых) процессов (буфер =Monitor=) и отдельные буфера для каждого из
интерпретируемых модулей, которые выполняются в пошаговом режиме (буфер =Attach=).

Для того, чтобы получить возможность отладки текущего модуля, вам необходимо переключить
его в режим интерпретации, что выполняется с помощью команды =edb-toggle-interpret= (=C-c C-d
i=), после этого, вы можете расставлять в исходном тексте точки останова с помощью
=edb-toggle-breakpoint= (=C-x SPC=).

Сама отладка производится в буфере =Attach=, в который можно попасть через буфер =Monitor=.
Чтобы переключиться в буфер =Monitor=, вы можете воспользоваться командой =edb-monitor= (=C-c
C-d m=).  В этом буфере отображается список отлаживаемых процессов и пользователю доступно
несколько команд: =RET= переключает в буфер =Attach=, соответствующий выбранному процессу; =q=
скрывает буфер монитора, а =k= удаляет буфер монитора, удаляет все точки останова и
отключается от модуля отладки на выбранном узле.

Буфер =Attach= позволяет выполнять пошаговое выполнение кода конкретного модуля.  В нем
отображается исходный код модуля и метка, показывающая следующую выполняемую строку (в том
случае, если выполнение было остановлено на какой-то из точек останова).  В этом буфере
пользователю доступны следующие команды:

|| функция || клавиша || описание
| =edb-attach-step= | =SPC= | выполнить следующее выражение, с заходом в вызываемую функцию (если это вызов функции)
| =edb-attach-next= | =n= | выполнить следующее выражение, без захода в вызываемую функцию
| =edb-attach-continue= | =c= | продолжить выполнение до следующей точки останова
| =edb-attach-up= | =u= | показать предыдущий фрейм стека
| =edb-attach-down= | =d= | показать следующий фрейм стека
| =edb-toggle-breakpoint= | =b= | переключить точку останова на текущей строке
| =edb-attach-help= | =h= | показать справку по пользованию данным буфером
|  | =q= | удалить буфер =Attach= без завершения отлаживаемого процесса

Во время отладки пользователь может изменять исходный код модулей, поэтому расстановка
точек останова в исходном тексте, и в выполняемом процессе может отличаться.  Для того,
чтобы их синхронизировать, *distel* имеет в своем составе команду =edb-synch-breakpoints= (=C-c
C-d s=), которую необходимо использовать после перекомпиляции и перезагрузки модуля.  Кроме
того, для перезагрузки модулей рекомендуется использовать команду =erl-reload-module=, а не
загружать его вручную, поскольку эта команда позволяет сохранить все установленные точки
останова и флаги интерпретации модулей.

Еще одной возможностью *distel* полезной для отладки является то, что пакет может сохранить
текущее состояние отладчика, и затем восстановить его на выбранном узле, что крайне
полезно в тех случаях, когда вам необходимо перезапустить узел Erlang и продолжить отладку
с того места, где вы остановились.  Для выполнения этой задачи, пакет определяет две
команды: =edb-save-dbg-state= (=C-c C-d S=) для сохранения состояния отладчика, и
=edb-restore-dbg-state= (=C-c C-d R=) для его восстановления.

** Приложения для работы со средой выполнения Erlang

Кроме описанных выше приложений, в составе *distel* поставляется еще несколько утилит,
которые могут быть полезными для разработчика, активно работающего с Erlang. Например,
сюда можно отнести менеджер процессов выполняемых на узле Erlang, к которому сейчас
подключен *distel*.

Менеджер процессов запускается командой =erl-process-list= (=C-c C-d l=) и создает буфер, в
который выводится различная информация о выполняемых процессах (пример показан на
скриншоте ниже).  В данном буфере пользователь может выполнять различные команды, которые
позволяют получать более подробную информацию о процессе (=RET= или =i=), просматривать
содержимое очереди сообщений (=m=), выполнять трассировку процесса (=b=).  Пользователь может
даже завершить процесс воспользовавшись командой =k=.  Чтобы покинуть этот буфер необходимо
нажать =q=, а чтобы обновить информацию -- =u=.

<div id="screenshot">
[[../../../common/writings/emacs-devenv/distel-proc-monitor.png]]
</div>

** Programming with distel

*Distel* позволяет писать на Emacs Lisp приложения в стиле Erlang, а также взаимодействовать
с процессами, запущенными на узлах Erlang.  Краткое введение в программирование с помощью
*distel* вы можете найти в статье [[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.4770][Distel: Distributed Emacs Lisp]] и/или
[[http://bc.tech.coop/blog/070719.html][статье в блоге Bill Clementson]].

*  Flymake's customization for work with Erlang

Пакет *flymake*, входящий в поставку Emacs, позволяет выполнять проверку корректности кода
на лету.  Erlang пока не входит в список языков, поддерживаемых "из коробки", но мы можем
достаточно легко исправить это упущение[4].

Если вы еще не использовали *flymake*, то во первых вам необходимо загрузить его с помощью
следующей команды:

<src lang="emacs-lisp">
(require 'flymake)
</src>

Затем нам необходимо написать процедуру, которая будет правильно инициализировать *flymake*,
так чтобы он мог работать с кодом на Erlang.  Эта процедура будет захватывать код по мере
набора и будет передавать его скрипту на Erlang, который и будет проверять код на наличие
ошибок.  Процедура выглядит следующим образом:

<src lang="emacs-lisp">
(defun flymake-erlang-init ()
  (let* ((temp-file (flymake-init-create-temp-buffer-copy
										 'flymake-create-temp-inplace))
				 (local-file (file-relative-name
											temp-file
											(file-name-directory buffer-file-name))))
    (list "~/emacs/bin/eflymake" (list local-file))))
</src>

Путь к скрипту указывается в теле процедуры, так что вам необходимо изменить путь в том
случае, если он находится в другом месте.  Сам скрипт достаточно прост -- он получает имя
файла и пытается выполнить компиляцию кода, возвращая список ошибок и предупреждений: 

<src lang="erlang">
#!/usr/bin/env escript
-export([main/1]).

main([File_Name]) ->
    compile:file(File_Name, [warn_obsolete_guard, warn_unused_import,
    			    		   warn_shadow_vars, warn_export_vars,
					   strong_validation, report]).
</src>

После написания процедуры и скрипта, нам необходимо указать *flymake*, что он должен
использовать указанную процедуру для проверки файлов с расширением =.erl=, что делается с
помощью следующего кода.

<src lang="emacs-lisp">
(add-to-list 'flymake-allowed-file-name-masks
						 '("\\.erl\\'" flymake-erlang-init))
</src>

На этом подготовительные действия заканчиваются и вы можете либо разрешить использовать
*flymake* глобально, с помощью добавления хука открытия файла:

<src lang="emacs-lisp">
(add-hook 'find-file-hook 'flymake-find-file-hook)
</src>

либо явно включать режим *flymake* для нужных режимов, например, вот так:

<src lang="emacs-lisp">
(defun my-erlang-mode-hook ()
	(flymake-mode 1))
(add-hook 'erlang-mode-hook 'my-erlang-mode-hook)
</src>

После этого, при открытии файла с расширением =.erl= режим *flymake* будет включаться
автоматически, и вы будете видеть результаты проверки по мере набора вашего кода.  По
умолчанию, строки содержащие ошибки выделяются светло-розовым цветом, а строки, вызывающие
появление предупреждений -- светло-голубым[5].  Пример вы можете увидеть на скриншоте:

[[../../../common/writings/emacs-devenv/erlang-flymake.png]]

В данном примере, функции =some_wrong_function= не существует, и поэтому Erlang не может ее
найти и рапортует об ошибке.  А объявление функции подсвечено из-за того, что параметр =Fun=
не используется в теле функции, что приводит к получению предупреждения.

* The wrangler package

Пакет *wrangler* реализует базовую функциональность по рефакторингу программ написанных на
Erlang.  Пакет доступен с [[http://www.cs.kent.ac.uk/projects/forse/][сайта проекта]], но работа пока находится в самом начале, и сами
авторы не рекомендуют использовать его для серьезной работы.  Документация на пакет может
быть найдена [[http://www.cs.kent.ac.uk/projects/forse/wrangler/doc/overview-summary.html][тут]].

; I’ve when playing around a bit with Wrangler—an Erlang refactoring package for Emacs. I
; like what I’ve seen of it so far but turning it on and off is a little ugly. Typing M-x
; erlang-refactor-on and M-x erlang-refactor-off gets tiresome after the third time.

; So I whipped up a function to toggle Wrangler on and off:

; <src lang="emacs-lisp">
; (setq erlang-refactor-status 0)
; (defun toggle-erlang-refactor ()
;   (interactive)
;   (cond ((= erlang-refactor-status 0)
; 	 (call-interactively 'erlang-refactor-on)
; 	 (setq erlang-refactor-status 1))
; 	((= erlang-refactor-status 1)
; 	 (call-interactively 'erlang-refactor-off)
; 	 (setq erlang-refactor-status 0))))
; </src>

; I dropped this into =distel_config.el= and bound it to C-c C-r like so:


; <src lang="emacs-lisp">
; (global-set-key (kbd "C-c C-r") 'toggle-erlang-refactor)
; </src>

; Voila! Instant refactor mode toggle with two keystrokes.

; ** Verification
; http://www.it.uu.se/research/group/hipe/dialyzer/

* ESense

[[http://esense.sourceforge.net/][Пакет ESense]] (ErlangSense) реализует для связки Emacs + Erlang нечто подобное функции
Intellisense в Visual Studio.  Пакет реализует следующие возможности:
 - дополнение имен модулей, функций, названий записей и полей в записях, а также имен макросов;
 - переход к содержимому подключаемого (через =-include=) заголовочного файла;
 - переход к определению функции в исходном коде;
 - открытие документации на выбранную функцию или показ краткой подсказки в всплывающем
   окне.

Этот пакет может использоваться как дополнительный режим при редактировании исходного кода
Erlang, а также при работе с кодом в буфере в котором выполненяются команды Erlang.

** Installation & customization

Скачать пакет *ESense* можно с [[http://esense.sourceforge.net/][сайта проекта]].  Для его работы требуется наличие модуля
разбора HTML из состава веб-сервера [[http://yaws.hyber.org/][Yaws]][6].  Скачанный пакет необходимо развернуть и с
помощью =make= скомпилировать код на Erlang, который будет использоваться для индексации
модулей.  

После этого вам необходимо поместить файлы с расширением =.el= в то место, где их найдет
Emacs, и добавить следующий код в ваш файл инициализации:

<src lang="emacs-lisp">
(require 'esense-start)
(setq esense-indexer-program "/path/to/esense.sh")
</src>

Вам необходимо изменить значение второй строки таким образом, чтобы она указывала на
расположение скрипта =esense.sh=, который используется для индексации кода.  Прочие
настройки могут быть заданы используя группу настройки =esense=.

Перед первым запуском вам необходимо сгенерировать первоначальные индексы, которые будут
использоваться пакетом в процессе работы.  Эта задача выполняется с помощью скрипта
=esense.sh=, в качестве параметра которому передается каталог с исходным кодом. (В первую
очередь рекомендуется построить индексы для исходных текстов Erlang, поскольку наличие
информации для некоторых модулей необходимо для работы пакета).  Индексные файлы по
умолчанию сохраняются в каталоге =~/.esense=.

После генерации индекса, вы можете или перезапустить Emacs, или выполнить команду
=esense-initialize=, которая обновит информацию о существующих индексных файлах.  После
генерации индексов для исходных текстов, вы можете сгенерировать индексы для документации
в формате HTML, так что ссылки на нее смогут использоваться в процессе работы.

** Work with package

По умолчанию, *ESense* использует клавишу =F1= (команда =esense-do-something-at-point=) для
выполнения практически всех операций.  В зависимости от положения курсора, пакет выполняет
одно из следующих действий:
 - если курсор находится в конце символа, то пакет пытается дополнить имя символа (имя
   модуля или функции из конкретного модуля).  Если существует несколько вариантов
   дополнения, то пакет отображает окно, в котором перечисляются все возможные варианты.
   В этом окне пользователь может перемещаться с помощью клавиш курсора, и выбрать нужный
   вариант с помощью клавиши =RET= или сочетания =C-m=;
 - если курсор находится на символе (функции, макросе или записи), то пакет показывает
   документацию для данного символа в всплывающем окне (tooltip);
 - если курсор находится на списке параметров, то показывается документация на
   соответствующий параметр функции;
 - если курсор находится на строке с директивой =-include=, то будет показан соответствующий
   заголовочный файл.

Нажатие комбинации =C-F1= приведет к вызову команды =esense-go-to-documentation=, что приведет
к переходу к месту определения символа, находящегося под курсором (вернуться назад можно с
помощью стандартной для =etags= комбинации =M-*=).  А комбинация =M-F1=
(=esense-go-to-function-documentation=) запросит имя функции и выполнит переход к ее
определению.

Нажатие клавиш =:=, =#=, =.= и =?= также приводят к выдаче списка возможных вариантов для функций
из модуля, имен записей, членов записей или макросов, соответственно.
 
; ======================================================================

<div id="rule">[[./index][На главную страницу]]</div>

Footnotes: 
[1] На самом деле, этот пакет является реализацией Erlang-подобного стиля программирования
    для Emacs Lisp.  *erlang-extended-mode*, реализуемый этим пакетом, построен на основе
    библиотеки, обеспечивающей взаимодействие с процессами Erlang.

[2] Вы также можете задать числовой префикс для этих команд, что обеспечит пропуск
    соответствующего количества функций Erlang.

[3] Этот код был опубликован в блоге [[http://bc.tech.coop/blog/][Bill Clementson]]

[4] Данный раздел основан на информации, полученной из [[http://weblog.hypotheticalabs.com/?p=265][блога Hypothetical Labs]].

[5] Вы можете сами указать нужные цвета, отредактировав параметры начертаний
    =flymake-errline= & =flymake-warnline=.

[6] Вам может понадобиться добавить каталог где установлен *Yaws* в список каталогов, где
    будет производиться поиск выполняемых модулей.  Это может быть сделано путем помещения
    команды code:add_path с нужным каталогом в файл инициализации =~/.erlang=.

;  LocalWords:  flymake Erlang erl init src erlang lang flymake-errline Distel
;  LocalWords:  flymake-warnline distel erlang-mode M-TAB C-d C-c node nil dir
;  LocalWords:  esense ESense Erlang's erlware Imenu emacs fsm refactoring
;  LocalWords:  nodename
