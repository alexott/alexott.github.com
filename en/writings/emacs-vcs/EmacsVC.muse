#title VC package
#keywords emacs, vc, cvs, subversion, rcs, version control, hg, mercurial, darcs

<contents>

The *VC* package provides to user ability to work with different version control systems
(VCS) via unified user interfaces.  Now it supports following VCS (via VCS-specific
modules): *rcs*, *CVS*, *MetaCVS*, *Subversion*, *GNU Arch*, *sccs*, *Darcs*, *SourceSafe*, *ClearCase*, *Git*
and *Mercurial* (some of them available only in GNU Emacs 22.0, development repository of
GNU Emacs or at author's sites)[1].

* Basic concepts and approaches

Design of *VC* package took many things from the design of *rcs* version control system.  So
many concepts tightly coupled with concepts of this VCS.

When file is under control of VCS, then we say that it "registered" in VCS.  For each file
exists "main" file, that contain data and history of changes.  For each "main" file could
exists "work" file, that could be modified.  In some VCS you need to block work file
before add any change.  In other VCS you can add changes to your copy of work file, and
than explicitly commit changes to repository.  For systems, that require explicit locking
of files, to add a change to a file, you need to switch file from read-only state to
read-write state.  And usually, in such systems, only one user can make changes into
locked files, and other users should wait until that user finish modification of files and
remove block on file(s).

When you work with *VC* some information about its state is displayed in status line.
Information is represented in following form: at first is short name of VCS, used for
current file, next is displayed symbol, describing file's state, and then file's version
number is displayed.  If state symbol is equal to =-=, then file is not blocked or changed.
If file is blocked or modified, then symbol is changed to =:=.  If file is blocked by other
user, then status field will displayed as =:user:=.

* Work with package

** Basic work sequence

The main function of *VC* package is =vc-next-action= (=C-x v v=), that performs next logical
command of version control system.  Depending on used VCS, order of commands in this
sequence could differ.  For systems, that require blocking of file (*rcs*, *sccs*, and *CVS*
with corresponding setup), order of executions is following:
 - if file is not registered in VCS, then register it;
 - if file is registered, but not blocked, then fetch latest version from repository and
   block it;
 - if file was blocked by current user, but not changed, then it fetches new version and
   updates buffer;
 - if file was changed, then display a new buffer to enter comment about change, and
   commit changes;
 - if file was blocked by other user, then *VC* tries to block it.
      
For systems, that doesn't support explicit blocking, order of execution is slightly different:
 - if file is not registered in VCS, then register it, but doesn't commit it;
 - if file already was added, but not committed, then commit it;
 - if file was changed, then display a new buffer to enter comment about change, and
   commit changes;
 - if file was changed in repository, then ask user, and perform merging of changes in
   your copy of work file.

User can pass prefix argument to =vc-next-action= function.  Passing of this argument allow
user to change behaviour of function -- for example, user can set version number for new
file, or for file, that will fetched from repository, or change version control system (if
file was registered in different VCS).  

Entering of commit message is performed in special buffer with name =*VC-Log*=.  User can
enter message, and commit changes by pressing =C-c C-c=.  If you doesn't want to commit
changes, just leave this buffer without pressing =C-c C-c=.  And if you want use same commit
message for several files, then you can use =M-n=, =M-p=, =M-s= and =M-r= key bindings, that allow
you to navigate in messages history.

** Work with changes

User can use *VC* to view changes, that he did during work with files.  To get list of
changes between work copy and latest committed version, user can use =vc-diff= function
(<code>C-x v =</code>).  If user runs this function with prefix argument, then he can
obtain list of changes between any two versions. The =vc-version-other-window= function (=C-x
v ~=) allows to get from repository any version of file, and show it in separate buffer.
In some VCS you can obtain annotated versions of files, and *VC* also support this feature
with =vc-annotate= function, that bound to =C-x v g=.  With annotated version you can see who
make concrete changes, in which version they was made, etc.

User can cancel with =vc-revert-buffer= function (=C-x v u=), that remove changes and return
current file to actual version from repository.  After execution of =vc-revert-buffer= file
is not blocked, so you need to block it to make new changes.

** Work with files
 
Registration of file in repository is performed with =vc-register= function (=C-x v i=).
Selection of version control systems depends on several parameters.  If in the directory
there are files, already registered in some VCSs, then file will registered in this
system.  If in directory there are files, registered in several VCSs, then file will
registered in system, that is first in the list =vc-handled-backends=.  And if there are no
registered files in directory, then *VC* take first name from =vc-handled-backends= list.  For
example, you can register file in *CVS* only if you explicitly specify name of VCS. By
default, new file gets version number equal 1.1.  You can set another version number if
you supply prefix argument to =vc-register= function.  If =vc-initial-comment= variable has
non-=nil= value, then this function also ask user for comment, that will used as description
of this file.

The  *VC* package also supports renaming of registered files.  To do this you can use
=vc-rename-file= function, that renames you working file, and also "main" file.  This
function also update all snapshots, so they will point to the correct file name. But you
couldn't use this function for blocked files.

User can also get information about current file by using =vc-print-log= function, that
bound to =C-x v l=.  This command shows history of changes together with text of comments
for each of change.

** Use VC together with Dired

Functions, that was described before, was designed to work with separate files.  But for
big projects it's often need to work with sets of files -- see which files was modified,
display list of changes for whole project, etc.  To allow user to do this, *VC* package
implements special mode -- =vc-dired-mode=.  To create a buffer, that work in this mode,
user could use =vc-directory= function (=C-x v d=).  The buffer, created by this command, has
almost no differs from usual *Dired's* buffer.  In this buffer user can see recursive list
of files, registered in VCS.

During work with *Dired's* buffer we can display data in short or full mode.  In short
display mode, in buffer are displayed only modified or not updated files.  In full display
mode, in buffer are displayed all files registered in VCS.  User can switch between short
and full display modes with =v t= key binding.  In buffer also displayed information about
user, who had blocked file (for systems, that support this feature) or file status (for
all other systems).  In the buffer with =vc-dired-mode= work all *Dired's* functions and keys,
except =v= key, that is used as prefix key for all *VC* functions.  For user available all *VC*
functions, as described in other section, but they doesn't use =C-x= prefix, and could be
applied for file sets.

** Work with branches

Как и другие пакеты для интеграции с системами контроля версий, пакет *VC* поддерживает
работу с разными ветвями версий.  Пакет поддерживает создание ветвей, переключение между
ними, а также слияние изменений между разными ветвями.  Для переключения на другую ветвь
разработки пользователю необходимо лишь задать префиксный аргумент для команды
=vc-next-action=.  Пользователь может указывать не конкретную версию, а лишь номер ветви.
Следующая работа будет производиться именно в этой ветви.  Создание новой версии
производится аналогичным образом -- необходимо лишь при подтверждении изменений с помощью
команды =vc-next-action= указать новый номер версии используя префиксный аргумент.  Если
пользователь укажет номер для не существующей ветви, то она будет создана.  После создания
ветви, все остальные действия будут производиться в рамках этой ветви.  Для работы с
другой веткой, пользователь должен явно переключиться на нее.  

Для слияния изменений используется команда =vc-merge=, которая привязана к сочетанию клавиш
=C-x v m=.  Данная команда запрашивает у вас откуда необходимо брать изменения, и применяет
их к вашей рабочей версии.  Если вы ничего не ввели в ответ на запрос, то будут взяты
изменения из ветви с которой вы работаете, если они были подтверждены за время работы с
вашим файлом.  Если во время работы возникают конфликты, то пакет оповещает пользователя
об этом, и помечает конфликты в файле, или даже может запустить *Ediff* для их разрешения.
Вы можете воспользоваться командой =vc-resolve-conflicts= для разрешения возникших
конфликтов.  Она запускает новую сессию *Ediff*, где вы можете просматривать возникшие
конфликты, и применять или отвергать предлагаемые изменения.

** Work with remote repositories

Некоторые системы контроля версий поддерживают концепцию центрального репозитория, который
хранит "главные" файлы, а также историю изменений.  Репозиторий может быть локальным, или
располагаться на удаленном сервере.  *VC* автоматически распознает тот случай, когда
репозиторий располагается на удаленном сервере, и принимает некоторые действия, которые
позволяют более комфортно работать с данными, особенно в тех случаях, когда связь является
медленной и нестабильной.  При первом редактировании файла, создается локальная копия
изменяемого файла.  Это позволяет выполнять команды получения списка изменений, или отмены
внесенных изменений, без какого-либо сетевого взаимодействия.  Создаваемая копия файла
имеет имя =FILE.~VERSION.~=.  При подтверждении изменений в репозиторий, локальная копия
удаляется.  Пользователи также могут создавать резервные копии вручную, используя команду
=vc-version-other-window=, разница между резервными копиями созданными автоматически и
вручную, лишь в лишнем знаке точка перед знаком =~=.  Многие команды *VC* могут использовать
любую из резервных копий.
    
** Work with snapshots

"Снимок" (snapshot) -- это именованный набор версий файлов, который может рассматриваться
как отдельная единица.  Некоторые системы контроля версий сами поддерживают концепцию
"снимков", тогда пакет *VC* использует эти возможности.  Для прочих систем контроля версий,
пакет *VC* сам реализует поддержку "снимков".  В этом случае, эти "снимки" видны только при
использовании пакета *VC*.  Для работы со "снимками" пакет *VC* определяет две команды.
Команда =vc-create-snapshot= (сочетание =C-x v s=) создает "снимок" на базе версий файлов
находящихся в текущем каталоге, или ниже.  Команда =vc-retrieve-snapshot= (сочетание клавиш
=C-x v r=) позволяет пользователю получить "снимок" с заданным именем.  Многие команды
пакета *VC* позволяют использовать имена "снимков" в качестве аргументов вместо номеров
версий файлов.  Это особенно полезно просмотре списка изменений между релизами программ.

** Other functions

Обычно, для файлов находящихся под управлением системы контроля версий, для каждого файла
ведется отдельный список изменений.  Но в проектах GNU списки изменений ведутся для всего
проекта, или для отдельных каталогов.  Для организации взаимодействия между этими двумя
подходами, пакет *VC* определяет отдельную команду =vc-update-change-log= (она привязана к
сочетанию =C-x v a=), которая обновляет общий список изменений на основании списка изменений
для отдельных файлов.  При использовании префиксов, данная команда позволяет обновить
общий список изменений, только изменениями для отдельных файлов.  Вы можете вставлять в
файлы специальные идентификационные заголовки.  Эти заголовки зависят от конкретной
используемой системы контроля версий, и в некоторых системах, они используются для
служебных целей.  Для вставки такого заголовка, вы можете использовать команду
=vc-insert-headers= (сочетание клавиш =C-x v h=).  *VC* автоматически выбирает заголовок
подходящий для системы контроля версий.  Заголовки хранятся в переменных вида
=vc-BACKEND-header=, так что вы можете изменять их значения, для вставки собственных
заголовков.

* Customization

User can customize behaviour of *VC* package using standard Emacs's customization routines.
He just need to execute =M-x customize-group vc= to do this.  Some of options, applicable
for all supported VCSs, but some are applicable only to concrete backends.  Full
description of customization variables you can find in *VC's* manual.

* Additional information 

Detailed description of *VC* package is provided as part of Emacs's documentation.  Besides
this, you can find more information about  *VC* package at  [[http://www.emacswiki.org/cgi-bin/wiki/CategoryVersionControl][Emacs WiKi]].

Some of modules, that provides integration of *VC* with concrete VCS are not included into
GNU Emacs or XEmacs distributions.  You can find them on the author's sites:
 - *vc-darcs* -- http://www.emacswiki.org/elisp/vc-darcs.el
 - *vc-vss* -- http://www.chezmarshall.freeserve.co.uk/elisp/vcvss.html
 - *vc-clearcase* -- http://www.fukt.hk-r.se/~flognat/vc/

<div id="rule">[[./index][Back to main page]]</div>

;  LocalWords:  VCS rcs CVS MetaCVS VCSs

Footnotes: 
[1] Some modules lacks implementation of some commands, provided by *VC*.  For example,
    *vc-arch* doesn't support =vc-cancel-version= function, and some other, not so important.

