#title Work with Git from Emacs
#keywords emacs, git

<contents>

Creation and popularity of *Git* closely related to development of Linux.  At first it was
used to provide support of Linux kernel development, but now it's used in the many other
open source projects.  As on these projects, are working many peoples over Earth, this
version control system support distributed style of work[1].

We can work with *Git* using several packages -- either use modules for *VC* и *DVC* packages,
or use packages *git.el*, *emacs-git*, *magit* & *egg* packages.  In first case we work with *Git*
through standard interfaces of *VC* & *DVC*. And other packages implement interfaces, that
allow user to use full *Git's* functionality.  In this article I'll describe these packages.

* The git.el package

** Installation of package

Installation of *git.el* is very simple -- it comes in the *Git's* distribution in
=contrib/emacs/= subdirectory.  To compile package you need just run =make= command, that
could also be used to install the package (by default, package is installed into
=$HOME/share/emacs/site-lisp=, but you can change this behaviour by passing =emacslispdir=
parameter to =make=, or just copy all files to the directory, where Emacs can find them).

To use *git.el*, you need to put following line into your initialization file:

<src lang="emacs-lisp">
(require 'git)
</src>

and after executing it, you'll get all commands, provided by this package.

** Work with git.el

Work with package always starts with execution of =git-status= command, that ask user about
directory name in which it will search for *Git* repository, and after that, perform
analysis of repository state.  After analysis of repository state, package creates
=*git-status*= buffer, that will used to perform commands on files. Example of work with
this buffer you can see on picture below (at the bottom of picture you can see output of
=diff= command).  In this buffer enabled =git-status-mode=, that defines some set of commands
(and corresponding key bindings, many of them match the key bindings of *PCL-CVS* package.
This make transition to *Git* more easy).  All commands available only in this buffer, and
couldn't be used outside of it.
    
<div id="screenshot">
[[../../../common/writings/emacs-vcs/git-status.png]]
</div>
     
User can navigate in buffer with arrow keys, or with commands =git-next-file= (keys =n= and
=SPC=) and =git-prev-file= (=p= key).  For many commands user can specify numeric prefix (as for
many Emacs commands), that will change behaviour of command.

By default, all commands are executed on file, where cursor is located.  But user can also
select several files and commands will executed on selected files.  Selection is performed
with following commands and key bindings: =m= key (=git-mark-file=) mark current file and move
cursor one line below, =M= key (=git-mark-all=) marks all files in this buffer.  To remove
selection mark you can use =u= key (=git-unmark-file=) or =DEL= key (=git-unmark-file-up=), but
first command after removing of selection move cursor one string bellow, but the second,
to one string upper.  To remove selection mark from all files you can use =git-unmark-all=
command (=M-DEL= key binding).  To inverse selection you can use =git-toggle-all-marks=
command(=T= key).

As in the *PCL-CVS*, you can open current file with the =git-find-file= command (key =RET= or
=f=).  To open file to view you can use =v= key (=git-view-file=).  In case, if you've got
conflicts during merging, you can run conflict resolving command -- =git-resolve-file= (=R=
key).

You can add new files to repository with =git-add-file= command (=a= key), and remove with
=git-remove-file= command (=r= key).  To get reed from not needed files existing in directory,
but not registered in repository, you can put them into list of ignored files.  This could
be done with =git-ignore-file= command (=i=).  

Committing of changes is performed with =git-commit-file= command (=c= key), and reverting of
changes -- with =git-revert-file= command (=U= key).  User can view change log for repository
with =git-log-file= command (=l= key).
    
The =d= key is prefix key for all commands, related to work with changes.  Most important
command among them is the =git-diff-file= command, that you can call with <code>=</code> or
<code>d =</code> keys.  The =git-diff-file-base= command (=d b=) allow to find differences
between current and base file.  With =git-diff-file-idiff= command (=d e=) you can
interactively view for changes in current file. And the =git-find-file-imerge= command (=d E=)
allows user to open current file for interactive application of changes.  Other commands
allow to view changes relative to main branch -- =git-diff-file-merge-head= command (=d h=),
relative to versions of files before merges -- =git-diff-file-mine= command (=d m=), etc.
Full list of commands you can get from help for this mode.

Other command allow to refresh status buffer -- =git-refresh-status= command (=g= key), resign
from the buffer -- =git-status-quit= (=q=), remove processed files from list --
=git-remove-handled= command (=x=) and get help about mode -- =git-help= (=h= or =?= keys).

** Customization

You can customize package with standard customization routines of Emacs.  Corresponding
customization group has name =git= and allow to specify different *Git* settings and faces
used for display data.

#git-emacs
* The git-emacs package

The *git-emacs* package implements almost the same functionality, as the *git.el* package, but
it also has some improvements, mostly in the user interface.[2] The [[http://tsgates.cafe24.com/git/git-emacs.html][package's home page]]
contains detailed illustrated user manual, so user can quickly start to work with this
package.

** Installation and customisation

You can download the *git-emacs* package, together with auxiliary packages, from the
[[http://github.com/tsgates/git-emacs/tree/master][developer's repository]], and after download, just put them in corresponding directory, and
add following line of code in Emacs's initialisation file:

<src lang="emacs-lisp">
(require 'git-emacs)
</src>

Initial customisation of package could be performed with the =git-config-init= command, that
will set several variables, that are necessary for work with *Git*.  Values for other
variables could be installed via customisation group with name =git=.

** Work with existing repository

User can start to work with existing repository by running the =git-status= command, and
after execution a new buffer will be created.  This buffer is used to display information
about repository's state.  For this buffer the =git-status-mode= major mode is used, and
there are lot of commands for work with files and repository itself.  Commands could be
executed via key bindings, or by using corresponding items in =Emacs-Git= menu, that will
displayed when =git-status-mode= is enabled.

Navigation between buffer's objects is could be performed with several commands: besides
traditional commands like =n= (=git---status-view-next-line=) and =p=
(=git--status-view-prev-line=), that are used to move to next and previous file, there are
also commands =N= (=git--status-view-next-meaningfull-line=) and =P=
(=git--status-view-prev-meaningfull-line=), that move cursor between modified files.  Also
exists commands to move to first -- the =<= key (=git--status-view-first-line=), and last --
the =>= key (=git--status-view-last-line=) line in files list.

As in other packages for work with version control systems, user can open file by moving
to it, and pressing =o= or =RET= keys (=git--status-view-open-file=).  Besides this, user can
open file for view with =v= key (=git--status-view-view-file=).

Operations could be performed as with separate files, and with groups of marked files.  To
set mark on concrete file you can use =m= key (=git--status-view-mark-and-next=).  To remove
mark from file user can use =u= key (=git--status-view-unmark-and-next=), that removes mark
and move cursor to the next file.  The =SPC= key (=git--status-view-toggle-and-next=) is used
to toggle mark on file.  Besides this, with the =*= key(=git--status-view-mark-reg=) user can
mark files, whose names match to given regular expression.

To perform operations on files there are several commands.  Addition and removal of files
is performed with commands =git--status-view-add= (the =a= key) and =git--status-view-rm= (the =d=
key).  If you want to rename file, you can use the =git--status-view-rename= command, that
is bound to =r= key.  And sometime, when in directory exists files, not registered in
repository, you can use special command to put them into list of ignored objects.  This
command is bound to =i= key (=git--status-view-add-ignore=), and execution of this command
will lead to creation of new entry in the =.gitignore= file.

** Creation of new repositories

The *git-emacs* package allows to create new repositories using two different ways -- by
cloning existing repository, or by importing files from the given archive file.

To clone existing repository exists the =git-clone= command, that asks user for a name of
directory, where new repository will created, URL of existing repository, and if
necessary, then also ask for user's name and e-mail.  After entering of all needed
information, the asynchronous process of cloning will run, and after it will finished,
user will see message in mini-buffer.

To import files from archive file, user can run the =git-init-from-archive= command, that
after run will ask for archive file name, name for directory for new repository, and other
needed data, and starts process of import of files from archive.  And at the end of this
process, user should enter message with description of this change, and confirm import
with =C-c C-c= keybinding, as for normal commit.

** Work with changes

To view changes in repository, user can execute command =git--status-view-diff-file= (the
<code>=</code> key), that will create a new buffer, containing changes in current file.
This operation could be also performed with global =git-diff= command.  Both commands ask
user for revision number to compare with, and than use *ediff* to display changes.

To commit changes to repository exists command =git-commit-all= (the =c= key)[3], that after
run, will create a new buffer, where user can enter description of the change, and finish
operation with =C-c C-c= keys.

Often is required to merge changes from other branches of development.  This task could be
performed with the =git-merge= command, that , when executed, will ask for name of branch or
tag from which you want to merge changes, and than, after confirmation of your choice, the
merge will executed.  And if during merge process, repository become to conflicting state,
then user can use the =!= key (=git--status-view-resolve-merge=) to start process of conflicts
resolving, using =ediff-merge=.

** History of changes

To get information about history of changes in repository, the *git-emacs* package defines
several commands: the =git-history= command is used to get history of changes for whole
project.  And to get information about history of changes in concrete files, user can use
the =git-log= command.  Both these commands create a separate buffer, that contains detailed
information about changes.

Users, who like the =gitk= utility, can run it directly from Emacs.  This could be done
either directly from the status buffer, using the =k= key (=git--status-view-gitk=), either
using the =gitk= command.

User also can see information about which parts of file was changed in concrete version.
In *Git* user can obtain this information with the =git blame= command, and for integration
with Emacs the *git-blame* package was created (it's described [[#git-blame][below]]).  User can obtain this
information by navigating to needed file in the status buffer, and pressing the =?= key
(=git--status-view-blame=).  This will lead to opening of file and enabling in it the
=git-blame-mode= minor mode, that is used to display corresponding information.

** Work with tags & branches

The *git-emacs* package also supports work with several branches of development in the same
repository.  To work with them, user can run the =git-branch= command, and after it
execution, a new buffer will created, holding list of all existing branches in current
repository.  User can work with branches using key bindings, or items from the =Git-Branch=
menu, that is displayed when buffer is created.  The current branch is always marked with
=*= symbol.

Pressing of the =c= key will lead to prompting of user for a name and creation of new
branch.  To switch to another branch user can navigate to needed item in list, and
pressing =s= or =RET=.  And from this buffer, user can also delete unneeded branches by
pressing the =d= key.

If you hadn't performed the =git-branch= command, then you can still create a new branch.
This could be done with =git-create-branch= or =git-checkout-to-new-branch= commands.

User also can work with branches directly from the status buffer.  Pressing to the =z= key
(=git-branch=) will lead to creation of a new buffer, as when user directly execute the
=git-branch= command.  And to switch to another branch, user can simply press the =b= key
(=git--status-view-switch-branch=).

Work with tags is also pretty simple -- you need to execute one of the =git-tag= or
=git-snapshot= commands, that will ask for tag name, and create it.  And later you can
return to given tag by executing the =git-checkout= command and specifying name of tag.  You
can also use tags as a starting point of new branches.  To do this, you need to specify
name of the tag as a parameter for the =git-checkout-to-new-branch= command.

#magit
* The magit package

The [[http://zagadka.vm.bytemark.co.uk/magit/][magit]] package provides interface for work with *Git* from Emacs.  Comparing with other
packages, this package provides more precise mapping of *Git's* ideology to Emacs interface,
but use slightly different, comparing with other packages, set of key bindings, so it's
recommended to read user's manual first.

** Installation and customisation

Installation of package is very simple -- you need to retrieve sources from the
repository, specified on the [[http://zagadka.vm.bytemark.co.uk/magit/][project's home page]], and install it, using following
commands:

<src lang="sh">
sh ./autogen.sh
./configure [опции]
make && make install
</src>

After installation, just add following line to your initialisation file:

<src lang="emacs-lisp">
(autoload 'magit-status "magit" nil t)
</src>

This command will load package when on first call of the =magit-status= command.

** Basics of work with package

Like in other version control support packages, work with repository is starting by
executing one command.  For *magit* package this is the =magit-status= command, that, when
executed, will ask for name of directory with repository, and than will create a new
buffer with name =*magit: directory_name*=, that will hold information about actual state of
repository.  All commands are executed from this buffer, either by using key bindings,
either via the =Magit= menu.  The buffer =*magit: directory_name*= will look like this:

<div id="screenshot">
[[../../../common/writings/emacs-vcs/magit-status.png]]
</div>

This buffer contains several lists of objects, matching to different states of objects in
*Git's* repository: 
 - unknown objects (*untracked*)
 - saved (*stashed*) objects
 - modified object, but not added to commit list (*unstaged*)
 - modified objects, added to commit list (*staged*)
 - committed changes, but not pushed to source repository (*unpushed*).

Besides this, if lists *staged* & *unstaged* aren't exists, then all modified files are listed
in list with status *changed*.

Между объектами можно перемещаться с помощью клавиш курсора или клавиш =n= & =p=.  Кроме того,
пользователь может быстро перемещаться между списками объектов с разными состояниями с
помощью клавиш =1= (=magit-jump-to-untracked=), =2= (=magit-jump-to-unstaged=), =3=
(=magit-jump-to-staged=) и =4= (=magit-jump-to-unpushed=).

Некоторые операции, которые можно выполнять над объектами, напрямую зависят от того, в
каком состоянии этот объект находится.  Так, например, клавиша =k= (=magit-discard-item=)
приведет к удалению неизвестного объекта, а при применении к измененному объекту, лишь
приведет к откату сделанных изменений.  Она также может использоваться для удаления
сохраненных (*stashed*) изменений.

Кроме удаления неизвестных файлов, можно также поместить их в список игнорирования.  Для
этого определены две команды: =i= (=magit-ignore-item=) помещает текущий объект в файл
=.gitignore=, а =I= (=magit-ignore-item-locally=) вносит его в файл =.git/info/exclude=, который
используется для игнорирования файлов только для текущего репозитория.  Кроме того, если
перед нужно клавишей задать префиксный аргумент, то у пользователя будет запрошено имя
игнорируемого файла, что удобно для ввода масок игнорируемых файлов.

И как обычно, открыть нужный объект в новом буфере можно с помощью клавиши =RET=
(=magit-visit-item=).  

** Работа с изменениями

Подтверждение изменений производится одной из двух команд -- =c= (=magit-log-edit=) или =C=
(=magit-add-log=).  Они обе открывают новый буфер в котором пользователь может ввести
описание изменения, но при этом они немного отличаются оформлением описания.  Для первой
команды пользователь может ввести текст в произвольной форме, тогда как во втором случае,
в буфер вставляется имя файла, что позволяет оформлять описания в виде принятом для файлов
=ChangeLog=.

Но стоит отметить, что изменения подтверждаются немного по разному в зависимости от
состояния репозитория.  Если существует только список измененных файлов (*changed*), то
подтверждаются все изменения из данного списка.  Если пользователь хочет подтвердить
только некоторые изменения, то ему стоит перенести их в список объектов для подтверждения
(*staged*), и уже затем выполнять операцию подтверждения изменений.  Для внесения объекта в
список подтверждения, пользователь может воспользоваться клавишей =s= (=magit-stage-item=),
которая помещает измененный объект в нужный список (для неизвестных файлов это
эквивалентно добавлению файла в репозиторий), удалить из которого можно с помощью клавиши
=u= (=magit-unstage-item=).  Для добавления всех объектов в список подтверждения, определена
клавиша =S= (=magit-stage-all=), и противоположная ей по действию клавиша =U=
(=magit-unstage-all=).

Кроме того, пакет может сохранять сделанные изменения, чтобы их можно было применить
позднее.  Это удобно в тех случаях, если вы не хотите подтверждать изменения в
репозиторий, но вам требуется выполнить какую-нибудь операцию требующую наличие "чистого"
репозитория.  Для этого определена команда =magit-stash=, привязанная к клавише =z=, которая
помещает изменения в список сохраненных (*stashed*) изменений.  После этого, можно выполнить
нужные операции, и после их выполнения, заново применить изменения к рабочим файлам (это
делается с помощью клавиши =a=).  И как упоминалось выше, удалить сохраненные изменения
можно с помощью клавиши =k=.

Пакет *magit* умеет показывать сделанные изменения несколькими способами.  Для просмотра
изменений в конкретном объекте можно воспользоваться клавишей =TAB= (=magit-toggle-section=),
которая показывает изменения сделанные в объекте, на котором находится курсор.  Эта же
клавиша используется и для скрытия показанных изменений.

Для просмотра изменений, внесенных в текущую ветку разработки определена команда =d=
(=magit-diff-working-tree=), которая запросит у пользователя имя ветки с которой надо
провести сравнение, и создаст новый буфер, содержащий изменения.  Для сравнения между
двумя произвольными ветками имеется команда =D= (=magit-diff=), которая запрашивает у
пользователя имена двух веток.  Листать содержимое буфера, создаваемого обоими командами
можно с помощью клавиш =SPC= (вперед) и =DEL= (назад).

И наконец, пользователь может вернуться к определенному подтвержденному состоянию
репозитория с помощью команды =x= (=magit-reset-head=), которая вернет репозиторий к
указанному состоянию (по умолчанию это предыдущее подтвержденное состояние).  Для большего
удобства определена команда =X= (=magit-reset-working-tree=), которая откатывает все сделанные
изменения и восстанавливает состояние на время последнего подтвержденного изменения.

** Работа с историей изменений

Просмотр истории изменений производится командами =l= (=magit-log-head=) и =L= (=magit-log=).
Первая команда отображает историю изменений для текущей ветки разработки, а вторая команда
-- для заданного отрезка истории, данные о котором запрашиваются у пользователя.  Пример
вывода истории изменений вы можете увидеть на рисунке ниже.  При этом стоит отметить, что
*magit* старается отображать изменения в разных ветках, примерно так, как это делает =gitk=.

<div id="screenshot">
[[../../../common/writings/emacs-vcs/magit-history.png]]
</div>

Перемещаясь по истории изменений пользователь может получать подробную информацию о
конкретном изменении нажав на клавишу =RET=.  Кроме этого, можно посмотреть сделанные
изменения между двумя произвольными подтвержденными изменениями.  Для этого, необходимо
отметить одно из нужных изменений с помощью клавиши =.= (=magit-mark-item=), и перейдя ко
второму изменению, нажать на клавишу <code>=</code> (=magit-diff-with-mark=).  Это приведет
к созданию нового буфера, в котором будут отображены соответствующие данные.

Пользователь может выполнять различные операции над конкретными изменениями.  С помощью
команды =a= (=magit-apply-item=) можно применить выбранное изменение к текущей ветке
разработки.  Только стоит отметить, что при выполнении этой команды, пользователю
необходимо будет явно подтвердить изменения, или воспользоваться командой =A=
(=magit-cherry-pick-item=), которая также применит выбранные изменения, но при этом еще и
выполнит подтверждение в репозиторий.  А для отмены изменений сделанных каким-то
конкретным подтверждением изменений можно воспользоваться командой =v= (=magit-revert-item=),
которая аккуратно применит патч в обратном порядке.

Кроме истории изменений репозитория, пользователь может просматривать записи в локальной
истории (*reflog*).  Для этого можно воспользоваться командой =h= (=magit-reflog-head=), которая
отображает *reflog* для текущей ветки разработки, или =H= (=magit-reflog=), которая может
показать данные для двух произвольных точек в истории.  Обе команды создают буфер с
историей изменений, в котором также могут выполняться команды для работы с изменениями,
описанные выше.

Также пакет *magit* реализует набор команд, предназначенных для переписывания истории
изменений, которые позволяют более удобно работать с историей, чем при использовании
сочетания команд =x= (reset head) и =a= (cherry pick).  Данный набор команд имеет общий
префикс =r=.  Для начала работы необходимо нажать =r s=, и у вас будет запрошено имя ревизии,
с которой вы хотите начать работу.  При этом все последующие изменения будут помещены в
специальный список *ожидающих* (*pending*) изменений.  Затем можно использовать команды =a=, =A= &
=v= для применения изменений в нужном вам порядке.  При этом, примененные изменения меняют
свой статус с знака =*= на знак =.= (точка).  Вы также можете явно изменить статус изменения
на нужный, используя команды =r .= и =r *=.

Если у вас что-то пошло не так, то вы можете вернуться к началу работы по переписыванию
истории нажав =r a=.  И завершить работу по переписыванию истории изменений можно с помощью
сочетания =r f=, которое применит все оставшиеся изменения в их обычном порядке, и закончит
работу по переписыванию истории изменений.

** Таги, ветки и сторонние репозитории

Пакет *magit* предоставляет достаточный набор средств для работы с ветками, тагами и
сторонними репозиториями, так что практически все операции можно выполнять не покидая
Emacs.  

Для создания тагов используются команды =t= (=magit-tag=) и =T= (=magit-annotated-tag=).  Они обе
запрашивают у пользователя имя тага, который нужно создать, но вторая команда позволяет
пользователю ввести описание тага, что иногда очень удобно.  После ввода всей необходимой
информации, пакет создает нужный таг, основываясь на текущем состоянии репозитория.

Работа с ветками также достаточно проста.  Для создания новой ветки и переключения в нее
может использоваться команда =B= (=magit-create-branch=) -- она запрашивает у пользователя
лишь имя нужной ветки.  А для переключения между существующими ветками можно
воспользоваться командой =b= (=magit-checkout=), которая запрашивает имя существующей ветки
(можно воспользоваться дополнением имен веток) и переключается в нее.  И для выполнения
=git rebase= пользователь должен использоваться командой =R= (=magit-rebase-step=).

Между ветками можно проводить слияние изменений.  Для автоматического слияния изменений из
указанной ветки можно использовать команду =M= (=magit-automatic-merge=), которая применит все
изменения и подтвердит их в репозиторий.  А если вы хотите просматривать изменения перед
их слиянием, то вам стоит воспользоваться командой =m= (=magit-manual-merge=).  Обе эти
команды получают в качестве аргумента имя ветки из которой будет производиться слияние. 

Пакет предоставляет несколько базовых команд для работы со сторонними репозиториями.
Команда =f= (=magit-remote-update=) получает из стороннего репозитория (*origin*) список
изменений, отсутствующих в текущем репозитории.  Эти изменения можно получить и применить
к текущему репозиторию с помощью команды =F= (=magit-pull=).  Кроме того, если у пользователя
правильно проведена настройка репозитория, то можно воспользоваться командой =P=
(=magit-push=), которая выполнит загрузку изменений в удаленный репозиторий (в данный момент
это только оригинальный репозиторий (*origin*).

Также недавно в пакет была добавлена базовая поддержка =git svn=.  Если существующий
репозиторий был создан на основе проекта из Subversion, то пользователю становятся
доступными две команды: =N r= (=magit-svn-rebase=) приводит к выполнению команды =git svn
rebase=, которая производит синхронизацию с Subversion, и =N c= (=magit-svn-dcommit=), которая
помещает подтвержденные изменения из репозитория Git в репозиторий Subversion.

* Пакет egg

Пакет *egg* является форком пакета [[#magit][magit]], описанного выше.  Основным отличием от *magit*
является улучшение пользовательского интерфейса (пример интерфейса для работы с историей
изменений вы можете видеть на рисунке ниже), остальной функционал примерно соответствует
пакету *magit*.  Пакет доступен для загрузки с [[http://github.com/bogolisk/egg/tree/master][сайта разработчика]].

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egg-history.png]]
</div>


* Auxiliary packages

В данном разделе приводятся краткие описания вспомогательных пакетов, которые реализуют
функционал, отсутствующий в многих из пакетов для работы с *git*.

#git-blame
** git-blame

Данный пакет написан David Kågedal и его можно скачать вместе с пакетом *git-emacs*,
описанного [[#git-emacs][выше]].  Для загрузки пакета поместите в файл инициализации следующую команду:

<src lang="emacs-lisp">
(require 'git-blame)
</src>

или вот эту, если вы хотите, чтобы пакет загрузился только при первом обращении к нему:

<src lang="emacs-lisp">
(autoload 'git-blame-mode "git-blame" "Minor mode for incremental blame for Git." t)
</src>

Для того, чтобы воспользоваться пакетом, пользователь должен включить в нужном буфере
вспомогательный режим =git-blame-mode=.  Это приведет к изменению оформления буфера --
каждая строка будет иметь свое собственное оформление, в зависимости от того, в какой
версии происходило ее изменение.  При этом, при перемещении по буферу, в мини-буфере будет
отображаться информация о версии, в которой изменялась данная строка.

** gitsum

Пакет *gitsum* предназначен для выполнения частичных коммитов в репозиторий *git*, так, как
это делается при работе с *darcs* через пакет [[./EmacsDarcs][darcsum]].  Для установки пакет, его нужно
скачать из [[http://github.com/chneukirchen/gitsum/tree/master][репозитория]], поместить в каталог, где его найдет Emacs, и добавить следующую
команду в файл инициализации:

<src lang="emacs-lisp">
(require 'gitsum)
</src>

Пакет *gitsum* предоставляет пользователю одну команду -- =gitsum=, которая позволяет
выполнять частичные коммиты используя Emacs.  Для проведения этой операции, пользователю
необходимо выполнить данную команду, находясь в каком-то из файлов, репозитория *git*.
После ее выполнения, появится буфер, в котором будут отображены изменения, сделанные в
данном репозитории.  

В данном буфере пользователь может перемещаться как между отдельными изменениями (с
помощью клавиш =n= и =p=), так и между измененными файлами (с помощью клавиш =N= и =P=).  Те
изменения, которые вы не хотите включать в данный коммит, могут быть удалены используя
клавишу =k=.  В том случае, если вы не хотите включать все изменения из конкретного файла,
то вы можете воспользоваться клавишей =K= для их исключения из коммита.  После завершения
выбора, достаточно нажать =c= или =C-c C-c= для того, чтобы подтвердить изменения в
репозиторий (после ввода сообщения).  Кроме этого, есть еще одно сочетание клавиш, которое
может быть полезным -- =C-c C-s=, которое позволяет разделить конкретное изменение на два, и
использовать их по отдельности.

Хотелось бы также отметить, что пакет *gitsum* умеет интегрироваться с пакетом *git.el* и его
можно использовать из буфера статуса, запуская с помощью клавиши =s=.

** egit

Данный пакет реализует функциональность, пока отсутствующую в пакете *git.el*.  В основном
это расширения для работы с историей изменений и конкретными изменениями.  Для установки
пакета, его нужно скачать из [[http://github.com/jimhourihan/egit/tree/master][репозитория]], поместить в пути поиска, и добавить следующие
команды в файл инициализации:

<src lang="emacs-lisp">
(autoload 'egit "egit" "Emacs git history" t)
(autoload 'egit-file "egit" "Emacs git history file" t)
(autoload 'egit-dir "egit" "Emacs git history directory" t)
</src>

В пакете определены три команды, которые имеют сходную функциональность, но отличаются
объектом применения.  Команда =egit= работает с репозиторием, =egit-dir= -- с каталогом в
репозитории, а =egit-file= с конкретным файлом в репозитории.  Единственным отличием
является то, что =egit= запрашивает у пользователя информацию о имени ветке или таге, а
также количество записей в истории, которое нужно отобразить.

Все три команды создают отдельный буфер, в котором показывается история изменений, и в
котором определен специальный режим =egit-mode=, позволяющий пользователю выполнять команды
над отдельными изменениями.  Команды могут выполняться как с помощью сочетаний клавиш, так
и через меню =EGit=, которое появляется при создании буфера.  Пример работы в данном буфере
вы можете увидеть на рисунке ниже.

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egit.png]]
</div>

Для перемещения в буфере можно использовать клавиши =n= (=C-n=) и =p= (=C-p=) или клавиши
управления курсором.  По умолчанию, при перемещении между записями, пакет показывает
базовую информацию о текущем изменении -- имя автора, дату изменения, краткое описание
изменения и т.п.  Кроме этого, пользователь может увидеть полный текст описания изменения
(клавиша =RET= или стрелка вправо), список измененных файлов (клавиша =f=) и сами изменения
(клавиша =d=) внесенные в файлы (пример можно увидеть на рисунке ниже).

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egit-diff.png]]
</div>

Помимо просмотра истории, пользователь может заново применить выбранные изменения с
помощью команды =egit-cherry-pick= (клавиша =c=), что приведет к выполнению команды =git
cherry-pick= с нужными флагами.  Также можно откатить изменения сделанные в конкретном
патче -- это выполняется с помощью команды =egit-revert=, для которой нет привязки клавиш
(все-таки она слишком разрушительна), но которую можно вызвать через меню.


<div id="rule">[[./index][To main page]]</div>

Footnotes: 
[1] Although we can use it for work in centralized environment

[2] Стоит отметить некоторые неудобства возникающие при использовании данного пакета --
    некоторые команды пересекаются с командами пакета *git.el*, так что использовать их
    одновременно не получится.  И во вторых, пакет принудительно включает глобальный режим
    *ido-mode*, что не всегда удобно для пользователей, использующих другие пакеты.

[3] Эту команду можно выполнять не только из буфера статуса, но и воспользовавшись
    глобальной привязкой клавиш =C-x v v=.

;  LocalWords:  gitignore SPC RET unmark
