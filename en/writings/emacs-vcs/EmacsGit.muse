#title Work with Git from Emacs
#keywords emacs, git

<contents>

Creation and popularity of *Git* closely related to development of Linux.  At first it was
used to provide support of Linux kernel development, but now it's used in the many other
open source projects.  As on these projects, are working many peoples over Earth, this
version control system support distributed style of work[1].

We can work with *Git* using several packages -- either use modules for *VC* и *DVC* packages,
or use packages *git.el*, *emacs-git*, *magit* & *egg* packages.  In first case we work with *Git*
through standard interfaces of *VC* & *DVC*. And other packages implement interfaces, that
allow user to use full *Git's* functionality.  In this article I'll describe these packages.

* The git.el package

** Installation of package

Installation of *git.el* is very simple -- it comes in the *Git's* distribution in
=contrib/emacs/= subdirectory.  To compile package you need just run =make= command, that
could also be used to install the package (by default, package is installed into
=$HOME/share/emacs/site-lisp=, but you can change this behaviour by passing =emacslispdir=
parameter to =make=, or just copy all files to the directory, where Emacs can find them).

To use *git.el*, you need to put following line into your initialization file:

<src lang="emacs-lisp">
(require 'git)
</src>

and after executing it, you'll get all commands, provided by this package.

** Work with git.el

Work with package always starts with execution of =git-status= command, that ask user about
directory name in which it will search for *Git* repository, and after that, perform
analysis of repository state.  After analysis of repository state, package creates
=*git-status*= buffer, that will used to perform commands on files. Example of work with
this buffer you can see on picture below (at the bottom of picture you can see output of
=diff= command).  In this buffer enabled =git-status-mode=, that defines some set of commands
(and corresponding key bindings, many of them match the key bindings of *PCL-CVS* package.
This make transition to *Git* more easy).  All commands available only in this buffer, and
couldn't be used outside of it.
    
<div id="screenshot">
[[../../../common/writings/emacs-vcs/git-status.png]]
</div>
     
User can navigate in buffer with arrow keys, or with commands =git-next-file= (keys =n= and
=SPC=) and =git-prev-file= (=p= key).  For many commands user can specify numeric prefix (as for
many Emacs commands), that will change behaviour of command.

By default, all commands are executed on file, where cursor is located.  But user can also
select several files and commands will executed on selected files.  Selection is performed
with following commands and key bindings: =m= key (=git-mark-file=) mark current file and move
cursor one line below, =M= key (=git-mark-all=) marks all files in this buffer.  To remove
selection mark you can use =u= key (=git-unmark-file=) or =DEL= key (=git-unmark-file-up=), but
first command after removing of selection move cursor one string bellow, but the second,
to one string upper.  To remove selection mark from all files you can use =git-unmark-all=
command (=M-DEL= key binding).  To inverse selection you can use =git-toggle-all-marks=
command(=T= key).

As in the *PCL-CVS*, you can open current file with the =git-find-file= command (key =RET= or
=f=).  To open file to view you can use =v= key (=git-view-file=).  In case, if you've got
conflicts during merging, you can run conflict resolving command -- =git-resolve-file= (=R=
key).

You can add new files to repository with =git-add-file= command (=a= key), and remove with
=git-remove-file= command (=r= key).  To get reed from not needed files existing in directory,
but not registered in repository, you can put them into list of ignored files.  This could
be done with =git-ignore-file= command (=i=).  

Committing of changes is performed with =git-commit-file= command (=c= key), and reverting of
changes -- with =git-revert-file= command (=U= key).  User can view change log for repository
with =git-log-file= command (=l= key).
    
The =d= key is prefix key for all commands, related to work with changes.  Most important
command among them is the =git-diff-file= command, that you can call with <code>=</code> or
<code>d =</code> keys.  The =git-diff-file-base= command (=d b=) allow to find differences
between current and base file.  With =git-diff-file-idiff= command (=d e=) you can
interactively view for changes in current file. And the =git-find-file-imerge= command (=d E=)
allows user to open current file for interactive application of changes.  Other commands
allow to view changes relative to main branch -- =git-diff-file-merge-head= command (=d h=),
relative to versions of files before merges -- =git-diff-file-mine= command (=d m=), etc.
Full list of commands you can get from help for this mode.

Other command allow to refresh status buffer -- =git-refresh-status= command (=g= key), resign
from the buffer -- =git-status-quit= (=q=), remove processed files from list --
=git-remove-handled= command (=x=) and get help about mode -- =git-help= (=h= or =?= keys).

** Customization

You can customize package with standard customization routines of Emacs.  Corresponding
customization group has name =git= and allow to specify different *Git* settings and faces
used for display data.

#git-emacs
* Пакет git-emacs

Пакет *git-emacs* во реализует примерно те же функции, что и пакет *git.el*, но имеет
некоторые улучшения, в основном в области пользовательского интерфейса.[2]
[[http://tsgates.cafe24.com/git/git-emacs.html][Домашняя страница]] проекта содержит достаточно подробный иллюстрированный мануал, так что
пользователь может быстро научиться пользоваться данным пакетом.

** Установка и настройка

Скачать пакет, и сопутствующие пакеты можно из [[http://github.com/tsgates/git-emacs/tree/master][репозитория разработчика]], и скачав,
поместите их в нужный каталог, и добавьте следующую команду в файл инициализации:

<src lang="emacs-lisp">
(require 'git-emacs)
</src>

Первоначальную настройку пакета можно выполнить с помощью команды =git-config-init=, которая
установит несколько переменных, необходимых для работы Git.  Значение остальных
переменных, можно установить используя группу настройки с именем =git=.

** Работа с существующим репозиторием

Работа с существующим репозиторием начинается с выполнения команды =git-status=,
выполнение которой создаст буфер, в котором будут отображена информация о состоянии
репозитория.  В данном буфере действует специальный режим =git-status-mode= и определены
команды для выполнения оперций над файлами и репозиторием в целом.  Команды можно
выполнять с помощью соответствующих привязок клавиш или используя соответствующие пункты
меню =Emacs-Git=, которое появляется при включении данного режима.

Перемещение по буферу производится помощью нескольких команд -- к традиционным =n=
(=git---status-view-next-line=) и =p= (=git--status-view-prev-line=), которые осуществляют
переход к следующему или предыдущему файлу, были добавлены команды =N=
(=git--status-view-next-meaningfull-line=) и =P= (=git--status-view-prev-meaningfull-line=),
которые выполняют переход между измененными файлами.  Кроме того, определены команды для
перехода на первую -- клавиша =<= (=git--status-view-first-line=) и последнюю -- клавиша =>=
(=git--status-view-last-line=) строки списка файлов.

Также как и в других пакетах, пользователь может открыть нужный файл путем перемещения к
нему и нажатия =o= или (команда =git--status-view-open-file=).  Кроме того, пользователь может
открыть файл только для просмотра с помощью клавиши =v= (=git--status-view-view-file=).

Операции могут выполняться как с отдельными файлами, так и с группами отмеченных файлов.
Установка пометки на конкретный файл может выполняться клавишей =m=
(=git--status-view-mark-and-next=).  Для снятия пометки можно воспользоваться клавишей =u=
(=git--status-view-unmark-and-next=) снимает пометку с текущего файла и перемещается к
следующему.  Клавиша =SPC= (=git--status-view-toggle-and-next=) используется в качестве
переключателя отметки файла, изменяя его статус на противоположный.  Кроме того, можно
использовать клавишу =*= (=git--status-view-mark-reg=), которая позволяет отмечать файлы, чьи
имена подпадают под регулярное выражение, введенное пользователем.

Операции с файлами производятся с помощью нескольких команд.  Добавление и удаление файлов
производится командами =git--status-view-add= (клавиша =a=) и =git--status-view-rm= (клавиша =d=).
Если необходимо переименовать файл, то для этого определена команда
=git--status-view-rename=, привязанная к клавише =r=.  Но иногда в каталоге, содержащем
репозиторий, образуются файлы, нужные для работы, но которые нет необходимости помещать в
репозиторий.  В этом случае, пользователь может поместить их в список игнорирования, нажав
на клавишу =i= (=git--status-view-add-ignore=), что приведет к созданию соответствующей записи
в файле =.gitignore=.

** Создание новых репозиториев

Пакет *git-emacs* позволяет создавать новые репозитории двумя способами: клонированием
существующего репозитория, или путем импорта файлов из указанного архива.

Для клонирования существующих репозиториев имеется команда =git-clone=, которая запрашивает
у пользователя имя каталога где будет создан новый репозиторий, адрес репозитория, и если
необходимо, то имя и e-mail пользователя, и запустит асинхронный процесс клонирования, о
завершении которого пользователь будет оповещен сообщением в мини-буфере.

Для импорта файлов из архива, пользователь может воспользоваться командой
=git-init-from-archive=, которая запросит имя архива, имя каталога где будет создан
репозиторий, и прочие данные, и затем запустит процесс импорта данных, в конце которого
пользователь должен ввести описание данного изменения, и подтвердить его путем нажатия =C-c
C-c= как при обычном подтверждении измененных данных.

** Работа с изменениями

Увидеть сделанные изменения пользователь может воспользовавшись командой
=git--status-view-diff-file= (клавиша <code>=</code>), которая отобразит буфер, содержащий
изменения сделанные в выбранном файле.  Эту же операцию можно выполнить и с помощью
глобальной команды =git-diff=.  Обе команды запрашивают у пользователя имя версии с которой
будет производиться сравнение, и затем используют *ediff* для работы со сделанными
изменениями.

Подтверждение сделанных изменений в репозиторий производится с помощью команды
=git-commit-all= (клавиша =c=)[3], выполнение которой открывает новый буфер, в котором
пользователь может ввести описание изменения, и завершить подтверждение путем нажатия
сочетания клавиш =C-c C-c=.

Достаточно часто возникает задача слияния изменений из других веток.  Эта задача может
быть выполнена с помощью команды =git-merge=, запустив которую вы можете выбрать имя ветки
или тага, из которого будете выполнять слияние, и затем, после подтверждения своего
выбора, слияние будет произведено путем выполнения соответствующей команды *git*.  А если в
процессе слияния разных веток, репозиторий оказался в состоянии конфликта, то пользователь
может использовать клавишу =!= (=git--status-view-resolve-merge=) для того, чтобы начать
процесс разрешения конфликтов с помощью =ediff-merge=.

** История изменений

Для получения информации об истории изменений, пакет *git-emacs* определяет несколько
команд: команда =git-history= используется для получения информации об истории изменений
всего проекта.  А для получения информации об изменениях в конкретных файлах, пользователь
может использовать команду =git-log=.  Обе этих команды создают отдельный буфер, содержащих
подробную информацию о сделанных изменениях.

Пользователи привыкшие к использованию утилиты =gitk= могут использовать ее не покидая
Emacs.  Эту утилиту можно запустить как напрямую, из буфера статуса, используя клавишу =k=
(=git--status-view-gitk=), так и явно выполнив команду =gitk=.

Пользователь также может получать информацию о том, какая часть документа была изменена в
конкретных версиях.  В *git* это реализуется командой =git blame=, а для ее интеграции с Emacs
был создан пакет *git-blame*, описанный [[#git-blame][ниже]].  Пользователь может получить эту информацию,
переместившись к нужному файлу в буфере статуса, и нажав клавишу =?=
(=git--status-view-blame=) -- это приведет к открытию нужного файла и включению в нем
вспомогательного режима =git-blame-mode=.

** Работка с ветками и тагами

Пакет *git-emacs* поддерживает работу с несколькими ветками разработки, существующих в одном
репозитории.  Для этого определена команда =git-branch= при выполнении которой будет создан
отдельный буфер со списком веток, существующих в текущем репозитории.  В данном буфере
пользователь может выполнять команды либо с помощью клавиш, либо используя меню
=Git-Branch=, которое появляется при создании этого буфера.  Текущая ветка всегда отмечена с
помощью знака =*=.

Нажатие клавишы =c= приведет к запросу имени новой ветки, имени базовой ветки и после этого,
к созданию новой ветки разработки.  Выбор другой ветки разработки может быть осуществлен
путем перехода к нужной ветке и нажатия клавиш =s= или =RET=.  Также из этого буфера можно
удалить ненужные ветки.  Это делается с помощью клавиши =d=.

В том случае, если вы не выполняли команду =git-branch= вы все равно можете создавать новые
ветки.  Это может быть выполнено с помощью команд =git-create-branch= или
=git-checkout-to-new-branch=.

Команды работы с ветками можно выполнить и из буфера статуса.  Нажатие на клавишу =z=
(=git-branch=) приведет к созданию буфера, как при выполнении команды =git-branch=.  А
переключиться на другую ветку разработки можно с помощью клавиши =b=
(=git--status-view-switch-branch=).
 
Работа с тагами также достаточно проста.  Вам необходимо выполнить команду =git-tag= или
=git-snapshot=, которые запросят у вас имя тага, и создадут его.  После этого, вы можете
вернуться к нужной версии, выполнив команду =git-checkout= и указав имя нужного тага.  Кроме
этого, вы можете использовать в качестве стартовой точки для новых веток.  Для этого,
нужно при выполнении команды =git-checkout-to-new-branch= указать нужный таг в качестве
основы для новой ветки.

#magit
* magit

Пакет [[http://zagadka.vm.bytemark.co.uk/magit/][magit]] является еще одной реализацией интерфейса для работы с *Git* из Emacs.  По
сравнению с другими пакетами, он предоставляет более точное отображение идеологии *Git*, и
немного отличающиеся наборы клавиш, так что сначала рекомендуется прочитать руководство
пользователя, которое поставляется вместе с пакетом.

** Установка и настройка

Установка пакета проста -- вам необходимо скачать исходные тексты из репозитория, адрес
которого указан на [[http://zagadka.vm.bytemark.co.uk/magit/][домашней странице]] проекта, и установить его, используя следующую
последовательность команд:

<src lang="sh">
sh ./autogen.sh
./configure [опции]
make && make install
</src>

После установки, добавьте в файл инициализации следующую строку:

<src lang="emacs-lisp">
(autoload 'magit-status "magit" nil t)
</src>

которая выполнит загрузку пакета при первом вызове команды =magit-status=.

** Основы работы

Аналогично многим другим режимам, работа с репозиторием начинается с выполнения отдельной
команды.  Для данного пакета это команда =magit-status=, выполнение которой приводит к
запросу имени каталога с репозиторием, и созданию буфера =*magit: имя_каталога*=, который
содержит текущее состояние репозитория, и из которого выполняются все операции используя
специальные клавиши или меню =Magit=.  Примерный вид буфера =*magit: имя_каталога*= вы можете
увидеть на рисунке ниже.

<div id="screenshot">
[[../../../common/writings/emacs-vcs/magit-status.png]]
</div>

Данный буфер содержит несколько списков файлов, соответствующих разным состояниям объектов
в репозитории *Git*: 
 - неизвестные объекты (*untracked*)
 - сохраненные (*stashed*) объекты
 - измененные объекты, но не добавленные в список для следующего подтверждения изменений
   (*unstaged*)
 - объекты, добавленные в список следующего подтверждения изменений (*staged*)
 - подтвержденные изменения, но не синхронизированные с исходным репозиторием (*unpushed*).

Кроме того, если списков *staged* и *unstaged* не существует, то измененные файлы показываются
в списке *changed*.

Между объектами можно перемещаться с помощью клавиш курсора или клавиш =n= & =p=.  Кроме того,
пользователь может быстро перемещаться между списками объектов с разными состояниями с
помощью клавиш =1= (=magit-jump-to-untracked=), =2= (=magit-jump-to-unstaged=), =3=
(=magit-jump-to-staged=) и =4= (=magit-jump-to-unpushed=).

Некоторые операции, которые можно выполнять над объектами, напрямую зависят от того, в
каком состоянии этот объект находится.  Так, например, клавиша =k= (=magit-discard-item=)
приведет к удалению неизвестного объекта, а при применении к измененному объекту, лишь
приведет к откату сделанных изменений.  Она также может использоваться для удаления
сохраненных (*stashed*) изменений.

Кроме удаления неизвестных файлов, можно также поместить их в список игнорирования.  Для
этого определены две команды: =i= (=magit-ignore-item=) помещает текущий объект в файл
=.gitignore=, а =I= (=magit-ignore-item-locally=) вносит его в файл =.git/info/exclude=, который
используется для игнорирования файлов только для текущего репозитория.  Кроме того, если
перед нужно клавишей задать префиксный аргумент, то у пользователя будет запрошено имя
игнорируемого файла, что удобно для ввода масок игнорируемых файлов.

И как обычно, открыть нужный объект в новом буфере можно с помощью клавиши =RET=
(=magit-visit-item=).  

** Работа с изменениями

Подтверждение изменений производится одной из двух команд -- =c= (=magit-log-edit=) или =C=
(=magit-add-log=).  Они обе открывают новый буфер в котором пользователь может ввести
описание изменения, но при этом они немного отличаются оформлением описания.  Для первой
команды пользователь может ввести текст в произвольной форме, тогда как во втором случае,
в буфер вставляется имя файла, что позволяет оформлять описания в виде принятом для файлов
=ChangeLog=.

Но стоит отметить, что изменения подтверждаются немного по разному в зависимости от
состояния репозитория.  Если существует только список измененных файлов (*changed*), то
подтверждаются все изменения из данного списка.  Если пользователь хочет подтвердить
только некоторые изменения, то ему стоит перенести их в список объектов для подтверждения
(*staged*), и уже затем выполнять операцию подтверждения изменений.  Для внесения объекта в
список подтверждения, пользователь может воспользоваться клавишей =s= (=magit-stage-item=),
которая помещает измененный объект в нужный список (для неизвестных файлов это
эквивалентно добавлению файла в репозиторий), удалить из которого можно с помощью клавиши
=u= (=magit-unstage-item=).  Для добавления всех объектов в список подтверждения, определена
клавиша =S= (=magit-stage-all=), и противоположная ей по действию клавиша =U=
(=magit-unstage-all=).

Кроме того, пакет может сохранять сделанные изменения, чтобы их можно было применить
позднее.  Это удобно в тех случаях, если вы не хотите подтверждать изменения в
репозиторий, но вам требуется выполнить какую-нибудь операцию требующую наличие "чистого"
репозитория.  Для этого определена команда =magit-stash=, привязанная к клавише =z=, которая
помещает изменения в список сохраненных (*stashed*) изменений.  После этого, можно выполнить
нужные операции, и после их выполнения, заново применить изменения к рабочим файлам (это
делается с помощью клавиши =a=).  И как упоминалось выше, удалить сохраненные изменения
можно с помощью клавиши =k=.

Пакет *magit* умеет показывать сделанные изменения несколькими способами.  Для просмотра
изменений в конкретном объекте можно воспользоваться клавишей =TAB= (=magit-toggle-section=),
которая показывает изменения сделанные в объекте, на котором находится курсор.  Эта же
клавиша используется и для скрытия показанных изменений.

Для просмотра изменений, внесенных в текущую ветку разработки определена команда =d=
(=magit-diff-working-tree=), которая запросит у пользователя имя ветки с которой надо
провести сравнение, и создаст новый буфер, содержащий изменения.  Для сравнения между
двумя произвольными ветками имеется команда =D= (=magit-diff=), которая запрашивает у
пользователя имена двух веток.  Листать содержимое буфера, создаваемого обоими командами
можно с помощью клавиш =SPC= (вперед) и =DEL= (назад).

x               magit-reset-head
X               magit-reset-working-tree



** Работа с историей изменений

Просмотр истории изменений производится командами =l= (=magit-log-head=) и =L= (=magit-log=).
Первая команда отображает историю изменений для текущей ветки разработки, а вторая команда
-- для заданного отрезка истории, данные о котором запрашиваются у пользователя.  Пример
вывода истории изменений вы можете увидеть на рисунке ниже.  При этом стоит отметить, что
*magit* старается отображать изменения в разных ветках, примерно так, как это делает =gitk=.

<div id="screenshot">
[[../../../common/writings/emacs-vcs/magit-history.png]]
</div>

Перемещаясь по истории изменений пользователь может получать подробную информацию о
конкретном изменении нажав на клавишу =RET=.  Кроме этого, можно посмотреть сделанные
изменения между двумя произвольными подтвержденными изменениями.  Для этого, необходимо
отметить одно из нужных изменений с помощью клавиши =.= (=magit-mark-item=), и перейдя ко
второму изменению, нажать на клавишу <code>=</code> (=magit-diff-with-mark=).  Это приведет
к созданию нового буфера, в котором будут отображены соответствующие данные.

Пользователь может выполнять различные операции над конкретными изменениями.  С помощью
команды =a= (=magit-apply-item=) можно применить выбранное изменение к текущей ветке
разработки.  Только стоит отметить, что при выполнении этой команды, пользователю
необходимо будет явно подтвердить изменения, или воспользоваться командой =A=
(=magit-cherry-pick-item=), которая также применит выбранные изменения, но при этом еще и
выполнит подтверждение в репозиторий.  А для отмены изменений сделанных каким-то
конкретным подтверждением изменений можно воспользоваться командой =v= (=magit-revert-item=),
которая аккуратно применит патч в обратном порядке.

Кроме истории изменений репозитория, пользователь может просматривать записи в локальной
истории (*reflog*).  Для этого можно воспользоваться командой =h= (=magit-reflog-head=), которая
отображает *reflog* для текущей ветки разработки, или =H= (=magit-reflog=), которая может
показать данные для двух произвольных точек в истории.  Обе команды создают буфер с
историей изменений, в котором также могут выполняться команды для работы с изменениями,
описанные выше.

Также пакет *magit* реализует набор команд, предназначенных для переписывания истории
изменений, которые позволяют более удобно работать с историей, чем при использовании
сочетания команд =x= (reset head) и =a= (cherry pick).  Данный набор команд имеет общий
префикс =r=.  Для начала работы необходимо нажать =r s=, и у вас будет запрошено имя ревизии,
с которой вы хотите начать работу.  При этом все последующие изменения будут помещены в
специальный список *ожидающих* (*pending*) изменений.  Затем можно использовать команды =a=, =A= &
=v= для применения изменений в нужном вам порядке.  При этом, примененные изменения меняют
свой статус с знака =*= на знак =.= (точка).  Вы также можете явно изменить статус изменения
на нужный, используя команды =r .= и =r *=.

Если у вас что-то пошло не так, то вы можете вернуться к началу работы по переписыванию
истории нажав =r a=.  И завершить работу по переписыванию истории изменений можно с помощью
сочетания =r f=, которое применит все оставшиеся изменения в их обычном порядке, и закончит
работу по переписыванию истории изменений.

** Таги, ветки и удаленные репозитории

t               magit-tag
T               magit-annotated-tag

B               magit-create-branch
b               magit-checkout

m               magit-manual-merge
M               magit-automatic-merge

R               magit-rebase-step

N r magit-svn-rebase
N c magit-svn-dcommit

P               magit-push
F               magit-pull
f               magit-remote-update


** Прочие команды

q               quit-window
$               magit-display-process
g               magit-refresh
G               magit-refresh-all
?               magit-describe-item


   Naturally, Magit runs the `git' command to do most of the work.  The
=*magit-process*= buffer contains the transcript of the most recent
command.  You can switch to it with `$'.



* egg

Пакет *egg* является форком пакета [[#magit][magit]], описанного выше.  Основным отличием от *magit*
является улучшение пользовательского интерфейса (пример интерфейса для работы с историей
изменений вы можете видеть на рисунке ниже), остальной функционал примерно соответствует
пакету *magit*.  Пакет доступен для загрузки с [[http://github.com/bogolisk/egg/tree/master][сайта разработчика]].

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egg-history.png]]
</div>


* Auxiliary packages

В данном разделе приводятся краткие описания вспомогательных пакетов, которые реализуют
функционал, отсутствующий в многих из пакетов для работы с *git*.

#git-blame
** git-blame

Данный пакет написан David Kågedal и его можно скачать вместе с пакетом *git-emacs*,
описанного [[#git-emacs][выше]].  Для загрузки пакета поместите в файл инициализации следующую команду:

<src lang="emacs-lisp">
(require 'git-blame)
</src>

или вот эту, если вы хотите, чтобы пакет загрузился только при первом обращении к нему:

<src lang="emacs-lisp">
(autoload 'git-blame-mode "git-blame" "Minor mode for incremental blame for Git." t)
</src>

Для того, чтобы воспользоваться пакетом, пользователь должен включить в нужном буфере
вспомогательный режим =git-blame-mode=.  Это приведет к изменению оформления буфера --
каждая строка будет иметь свое собственное оформление, в зависимости от того, в какой
версии происходило ее изменение.  При этом, при перемещении по буферу, в мини-буфере будет
отображаться информация о версии, в которой изменялась данная строка.

** gitsum

Пакет *gitsum* предназначен для выполнения частичных коммитов в репозиторий *git*, так, как
это делается при работе с *darcs* через пакет [[./EmacsDarcs][darcsum]].  Для установки пакет, его нужно
скачать из [[http://github.com/chneukirchen/gitsum/tree/master][репозитория]], поместить в каталог, где его найдет Emacs, и добавить следующую
команду в файл инициализации:

<src lang="emacs-lisp">
(require 'gitsum)
</src>

Пакет *gitsum* предоставляет пользователю одну команду -- =gitsum=, которая позволяет
выполнять частичные коммиты используя Emacs.  Для проведения этой операции, пользователю
необходимо выполнить данную команду, находясь в каком-то из файлов, репозитория *git*.
После ее выполнения, появится буфер, в котором будут отображены изменения, сделанные в
данном репозитории.  

В данном буфере пользователь может перемещаться как между отдельными изменениями (с
помощью клавиш =n= и =p=), так и между измененными файлами (с помощью клавиш =N= и =P=).  Те
изменения, которые вы не хотите включать в данный коммит, могут быть удалены используя
клавишу =k=.  В том случае, если вы не хотите включать все изменения из конкретного файла,
то вы можете воспользоваться клавишей =K= для их исключения из коммита.  После завершения
выбора, достаточно нажать =c= или =C-c C-c= для того, чтобы подтвердить изменения в
репозиторий (после ввода сообщения).  Кроме этого, есть еще одно сочетание клавиш, которое
может быть полезным -- =C-c C-s=, которое позволяет разделить конкретное изменение на два, и
использовать их по отдельности.

Хотелось бы также отметить, что пакет *gitsum* умеет интегрироваться с пакетом *git.el* и его
можно использовать из буфера статуса, запуская с помощью клавиши =s=.

** egit

Данный пакет реализует функциональность, пока остсутствующую в пакете *git.el*.  В основном
это расширения для работы с историей изменений и конкретными изменениями.  Для установки
пакета, его нужно скачать из [[http://github.com/jimhourihan/egit/tree/master][репозитория]], поместить в пути поиска, и добавить следующие
команды в файл инициализации:

<src lang="emacs-lisp">
(autoload 'egit "egit" "Emacs git history" t)
(autoload 'egit-file "egit" "Emacs git history file" t)
(autoload 'egit-dir "egit" "Emacs git history directory" t)
</src>

В пакете определены три команды, которые имеют сходную функциональность, но отличаются
объектом применения.  Команда =egit= работает с репозиторием, =egit-dir= -- с каталогом в
репозитории, а =egit-file= с конкретным файлом в репозитории.  Единственным отличием
является то, что =egit= запрашивает у пользователя информацию о имени ветке или таге, а
также количество записей в истории, которое нужно отобразить.

Все три команды создают отдельный буфер, в котором показывается история изменений, и в
котором определен специальный режим =egit-mode=, позволяющий пользователю выполнять команды
над отдельными изменениями.  Команды могут выполняться как с помощью сочетаний клавиш, так
и через меню =EGit=, которое появляется при создании буфера.  Пример работы в данном буфере
вы можете увидеть на рисунке ниже.

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egit.png]]
</div>

Для перемещения в буфере можно использовать клавиши =n= (=C-n=) и =p= (=C-p=) или клавиши
управления курсором.  По умолчанию, при перемещении между записями, пакет показывает
базовую информацию о текущем изменении -- имя автора, дату изменения, краткое описание
изменения и т.п.  Кроме этого, пользователь может увидеть полный текст описания изменения
(клавиша =RET= или стрелка вправо), список измененных файлов (клавиша =f=) и сами изменения
(клавиша =d=) внесенные в файлы (пример можно увидеть на рисунке ниже).

<div id="screenshot">
[[../../../common/writings/emacs-vcs/egit-diff.png]]
</div>

Помимо просмотра истории, пользователь может заново применить выбранные изменения с
помощью команды =egit-cherry-pick= (клавиша =c=), что приведет к выполнению команды =git
cherry-pick= с нужными флагами.  Также можно откатить изменения сделанные в конкретном
патче -- это выполняется с помощью команды =egit-revert=, для которой нет привязки клавиш
(все-таки она слишком разрушительна), но которую можно вызвать через меню.



<div id="rule">[[./index][To main page]]</div>

Footnotes: 
[1] Although we can use it for work in centralized environment

[2] Стоит отметить некоторые неудобства возникающие при использовании данного пакета --
    некоторые команды пересекаются с командами пакета *git.el*, так что использовать их
    одновременно не получится.  И во вторых, пакет принудительно включает глобальный режим
    *ido-mode*, что не всегда удобно для пользователей, использующих другие пакеты.

[3] Эту команду можно выполнять не только из буфера статуса, но и воспользовавшись
    глобальной привязкой клавиш =C-x v v=.
