#title How to use Maven to build Clojure code
#keywords maven, clojure, build tool

This article describes how to use Maven to build projects, written in Clojure (or in
Clojure & Java).

<contents>

* What is Maven?

[[http://maven.apache.org][Maven]] is a software project management and comprehension tool.  It implements dependency
resolving (with automatic download from repositories), building & testing of code,
deploying of software, etc.  Maven's functionality is extensible with plugins, so it's
possible to use it not only for Java code (primary goal of this tool), but also for code,
written in other languages. You can read more about Maven in [[http://www.sonatype.com/products/maven/documentation/book-defguide][following books]] (freely
available).

Maven differs from other tools, such as Ant -- it describes *what* we want to do, in
contrast with Ant, that describes *how* to do something.  Maven describes tasks to execute
in declarative style, and all described tasks are performed by corresponding plugins.

Description of software lifecycle and project's information are stored in =pom.xml= file,
that should exist in root directory of the project (and in root directories of
sub-projects, if your project is separated into several modules).  Project's information
includes name, identifier and version of the project, and often includes other
information: URL of project's site, information about source code repository (so you can
use =mvn scm:update= goal to update code, for example), etc.

Project Object Model (POM) defines set of stages for project's lifecycle -- lifecycle
phases.  Each of lifecycle phase could include several tasks (goals), that define what
will performed on given stage of lifecycle.  There are several common stages: compilation
(=compile=), testing (=test=), creation of package (=package=) and installation (=install=).  Each
of these lifecycle phases has dependencies on other phases, that should be executed before
its invocation (compilation should be executed before testing, testing before packaging,
etc.).

Usually developer uses phase's name to invoke build process.  For example, =mvn package= or
=mvn install=, etc.  But developer can also invoke concrete Maven's goal.  To do this, he
should specify name of plugin, that implements concrete goal, and task name in given
plugin.  For example, =mvn clojure:run= will run Clojure and execute script, specified in
configuration.  We need to mention, that list of goals, that are executed for concrete
lifecycle phase isn't constant -- you can change this list by modifying plugin's
configuration.

* Maven and Clojure

Clojure's support in Maven is implemented by [[http://github.com/talios/clojure-maven-plugin][clojure-maven-plugin]], that is available in
Maven's central repository, so it automatically when it required.  As a base for your
projects you can use =pom.xml= file from [[http://github.com/talios/clojure-maven-example][clojure-maven-example]] project.

If you already have =pom.xml= in your project, then to enable this plugin you need to add
following code into =<plugins>= section of =pom.xml=:

<src lang="nxml">
  <plugin>
    <groupId>com.theoryinpractise</groupId>
    <artifactId>clojure-maven-plugin</artifactId>
    <version>1.3.2</version>
  </plugin>
</src>

*Attention:* version number could be changed as development continues.  To find latest
plugin's version number you can use sites [[http://mvnrepository.com/artifact/com.theoryinpractise/clojure-maven-plugin][mvnrepository]] or [[http://jarvana.com/jarvana/][Jarvana]], that contains
information about packages, registered in Maven's repositories.

Declaration of this plugin will give you all functionality -- compilation, testing &
running of code, written in Clojure.  But out of box you'll need to use full goals names,
such as =clojure:compile=, =clojure:test= & =clojure:run=.  Although you can make your life
easier if you'll add these goals into list of goals of concrete lifecycle phases (=compile=
and =test=).  To do this you need to add section =<executions>= into plugin's description, as
in following example:

<src lang="nxml">
 <plugin>
   <groupId>com.theoryinpractise</groupId>
   <artifactId>clojure-maven-plugin</artifactId>
   <version>1.3.2</version>
   <executions>
     <execution>
       <id>compile</id>
       <phase>compile</phase>
       <goals>
         <goal>compile</goal>
       </goals>
     </execution>
     <execution>
       <id>test</id>
       <phase>test</phase>
       <goals>
         <goal>test</goal>
       </goals>
     </execution>        
   </executions>
 </plugin>
</src>

In this case, source code, written in Clojure will compiled -- this useful if you
implement =gen-class= that will be used from Java, or if you don't want to provide source
code for your application.  But sometimes it much better just to pack source code into
jar, and it will compiled during loading of package.  This allows to avoid binary
incompatibility between different versions of Clojure.  To put source code into jar, you
need to add following code into =resources= section:

<src lang="nxml">
 <resource>
   <directory>src/main/clojure</directory>
 </resource>
</src>

By default Clojure's source code is placed in the =src/main/clojure= directory of the
project with sub-directories, according to structure of your program. While source for
tests are placed in the =src/test/clojure= directory.  These default values could be changed
in [[#configure][plugin's configuration]].

** Goals, defined in =clojure-maven-plugin=

clojure-maven-plugin implements several commands (goals) that could be divided into two
groups:

 - Goals that works with source code (usually they are linked with corresponding phases of
   lifecycle, as it shown above):
  =clojure:compile= :: implements compilation of source code, written in Clojure;
  =clojure:test= :: executes tests, written in Clojure.

 - Goals, related to execution of project's code:
  =clojure:run= :: executes script (or scripts) defined by =script= and/or =scripts=
   configuration directives.  This goals is often to run project with proper dependencies;
  =clojure:repl= :: run Clojure REPL with all dependencies, specified in project.  If
   necessary, it also executes script, specified in configuration option =replScript= -- you
   can put some initialization code into it.  If the JLine library was listed in
   dependencies, then it will loaded automatically, making your work in REPL more
   comfortable;
  =clojure:swank= :: run Swank server, so you can connect to it from Emacs Slime.  By
   default, this server is running on port 4005 (this value could be changed with system
   option =clojure.swank.port=);
  =clojure:nailgun= :: run Nailgun server, so you can connect to it from Vim with
    [[http://kotka.de/projects/clojure/vimclojure.html][vimclojure]].  By default, this server is running on port 2113 (this value could be
    changed with system option =clojure.nailgun.port=).

** Clojure-related repositories

There are several Clojure-related repositories.  First, this is
http://build.clojure.org/releases/ with release versions of Clojure and =clojure-contrib=,
and http://build.clojure.org/snapshots/, with experimental versions.  Second popular
repository is [[http://clojars.org][Clojars]], that is used by Clojure community to publish their projects[1].

To use these repositories you need to add following code into =repositories= section in
=pom.xml=:

<src lang="nxml">
 <repository>
   <id>clojure-releases</id>
   <url>http://build.clojure.org/releases</url>
 </repository>
 <repository>
   <id>clojars</id>
   <url>http://clojars.org/repo/</url>
 </repository>
</src>

In this example we add repository with release versions of Clojure, and if you want to use
bleeding edge version, then you need to change first address to
http://build.clojure.org/snapshots/.

** Dependencies

Maven автоматически скачивает все необходимые зависимости из репозитория по умолчанию и
репозиториев указанных пользователем (как это показано выше).  Скачанные пакеты помещаются
в домашний каталог пользователя и могут использоваться другими проектами без
дополнительного скачивания их из интернета.  Пакет однозначно идентифицируется сочетанием
трех параметров -- название группы (=groupId=), артифакта (=artifactId=) и версии.

Для использования Clojure в своем проекте, то вам как минимум надо указать зависимость от
языка.  Кроме самой Clojure, очень часто используется набор библиотек =clojure-contrib=,
поэтому их часто указывают вместе.  В настоящее время стабильной версией обоих пакетов
является версия 1.1.0, которая находится в release-репозитории Clojure.  Для подключения
этих зависимостей в ваш проект, добавьте следующие строки в раздел =dependencies= в файле
=pom.xml=:

<src lang="nxml">
 <dependency>
   <groupId>org.clojure</groupId>
   <artifactId>clojure</artifactId>
   <version>1.1.0</version>
 </dependency>
 <dependency>
   <groupId>org.clojure</groupId>
   <artifactId>clojure-contrib</artifactId>
   <version>1.1.0</version>
 </dependency>
</src>

Если же вы хотите пользоваться самой последней версией языка, то вы должны подключить
соответствующий репозиторий (snapshots) и использовать версию (=1.2.0-SNAPSHOTS= (или другую
текущую на данный момент) вместо версии =1.1.0=.

Для выполнения некоторых задач перечисленных ниже, может понадобиться указать
дополнительные зависимости:
 - если вы будете использовать =clojure:swank=, то вам надо указать зависимость от пакета
  =swank-clojure=:
<src lang="nxml">
 <dependency>
  <groupId>swank-clojure</groupId>
  <artifactId>swank-clojure</artifactId>
  <version>1.2.0-SNAPSHOT</version>
</dependency>
</src>
 - если вы планируете использовать =clojure:nailgun=, то вам необходимо скачать дистрибутив
   с сайта [[http://kotka.de/projects/clojure/vimclojure.html][vimclojure]], собрать его как описано в документации и установить в свой
   локальный репозиторий Maven.  И после этого, вы можете добавить зависимость от
   =vimclojure= с помощью следующих строк:
<src lang="nxml">
 <dependency>
  <groupId>de.kotka</groupId>
  <artifactId>vimclojure</artifactId>
  <version>X.X.X</version>
 </dependency>
</src>
 - Наличие библиотеки JLine не обязательно, но полезно если вы будете работать в REPL --
   эта библиотека реализует историю команд, редактирование введенного текста и т.п.
   Наличие этой библиотеки определяется автоматически при запуске команды =mvn
   clojure:repl=, поэтому ее можно добавить в список зависимостей с помощью следующего
   кода:
<src lang="nxml">
 <dependency>
  <groupId>jline</groupId>
  <artifactId>jline</artifactId>
  <version>0.9.94</version>
 </dependency>
</src>

#configure
** Plugin's configuration

Разработчик имеет возможность управлять настройками плагина, такими как, расположение
исходных кодов, названия скриптов, которые запускаются при тестировании или выполнении и
т.д.  Для изменения какого-либо параметра, вам необходимо добавить его в раздел
=configuration= в описании плагина.  Например, вот так можно задать название скрипта,
который будет запущен для выполнения тестов:

<src lang="nxml">
 <plugin>
   <groupId>com.theoryinpractise</groupId>
   <artifactId>clojure-maven-plugin</artifactId>
   <version>1.3.2</version>
   <configuration>
     <testScript>src/test/clojure/unapalabra/test.clj</testScript>
   </configuration>
   .....
 </plugin>
</src>

Вот список параметров, относящихся к исходному коду и компиляции:
  =sourceDirectories= :: определяет список каталогов (каждый из которых должен быть обернут в
  таг =sourceDirectory=) с исходным кодом на Clojure, который будет помещен в результирующий
  пакет (и откомпилирован, при задании соответствующих опций);
 =testSourceDirectories= :: определяет список каталогов (каждый из которых должен быть
  обернут в таг =testSourceDirectory=) с тестами, написанными на Clojure;
 =warnOnReflection= :: параметр (со значениями =true= или =false=), который определяет -- будут
  ли выводиться предупреждения о вызовах функций, вызов которых требует использования
  определения типа во время выполнения (reflection).

Кроме этого, вы можете ограничить список пространств имен (namespaces) для которых будет
выполняться компиляция и/или тестирование кода.  Для этого, вам в директиве =namespaces=
необходимо перечислить нужные пространства имен (каждое из них должно быть обернуто в
директиву =namespace=).  Вы можете использовать регулярные выражения для указания всех
пространств имен в нужном пакете, а также с помощью знака =!= вы можете указывать названия
пространств имен, которые необходимо исключить из списка.  В дополнение к этому имеются
две директивы: =compileDeclaredNamespaceOnly= и =testDeclaredNamespaceOnly= (со значениями
=true= или =false=), которые указывают на то, будут ли ограничения по названиям имен
применяться при компиляции или тестировании.

Еще несколько опций конфигурации используются для задания параметров выполнения кода и/или
тестов:
 =script= и =scripts= :: указывает один (=script=) или несколько (=scripts= со вложенными
  директивами =script=) файлов с кодом, которые будут запущены при выполнении задачи
  =clojure:run=;
 =testScript= :: указывает на файл, который будет запущен при выполнении задачи
  =clojure:test=.  В том случае, если файл не указан, будет сгенерирован временный скрипт,
  который выполнит поиск тестов и запустит их на выполнение;
 =replScript= :: указывает на файл, который содержит код, который будет запущен при
  выполнении задачи =clojure:repl=.  Данный код будет выполнен до перехода в REPL, так что в
  него можно поместить необходимые инструкции по инициализации вашей рабочей среды;
 =runWithTests= :: данная директива (с возможными значениями true или false) определяет,
  будет ли выполняться тестирование при запуске кода или REPL.  Вы также можете
  переопределить указанное значение, указав нужное значение в командной строке Maven,
  например, вот так: <code>mvn clojure:repl -Dclojure.runwith.test=false</code>;
 =clojureOptions= :: в данной директиве указываются опции, которые будут переданы процессу
  =java= при любом выполнении кода -- REPL, запуске скрипта, тестировании.

* Conclusion

В принципе, информации изложенной в данной заметке должно хватить для начала использования
Maven вместе с Clojure.  В том случае, если у вас проект только на Clojure, и вы не
собираетесь использовать всю мощь Maven, то может быть стоит обратить внимание на утилиту
[[./ClojureLein][Leiningen]] которая написана специально для сборки проектов на Clojure.  Еще одним
интересным проектом является [[http://polyglot.sonatype.org/][Polyglot Maven]], целью которого является создание DSL (Domain
Specificl Languages) на разных языках (Clojure, Scala, Groovy) для описания конфигураций
Maven (для Clojure язык практически совпадает с языком, реализованным в Leiningen). 

Дополнительные примеры использования Maven с Clojure вы можете найти в проектах [[http://github.com/liebke/incanter/tree/1.0.x][Incanter]]
(как пример проекта, состоящего из нескольких модулей), [[http://github.com/relevance/labrepl][labrepl]] и [[http://github.com/talios/clojure-maven-example][clojure-maven-example]], а
также в следующих заметках (на английском языке):
 - [[http://muckandbrass.com/web/display/~cemerick/2010/03/25/Why+using+Maven+for+Clojure+builds+is+a+no-brainer][Why using Maven for Clojure builds is a no-brainer]] (которая также включает видео,
   показывающая работу с clojure-maven-plugin
 - [[http://pupeno.com/blog/how-to-create-a-clojure-application/][How to create a Clojure application]]
 - [[http://stuartsierra.com/2009/09/03/mavens-not-so-bad][Maven’s Not So Bad]]


;  LocalWords:  Maven mvn scm update  xml pom plugin src clojureOptions Script compile
;  LocalWords:  testSourceDirectories sourceDirectories sourceDirectory test
;  LocalWords:  testSourceDirectory testScript replScript runWithTests sgml
;  LocalWords:  namespaces compileDeclaredNamespaceOnly clojure-maven-plugin
;  LocalWords:  testDeclaredNamespaceOnly Leiningen Clojure Maven's plugins
;  LocalWords:  lifecycle LocalWords plugin's REPL JLine contrib clojure

[1] Clojars also provides downloading of Clojure & =clojure-contrib=, so you can add only
    one entry into list of repositories.

