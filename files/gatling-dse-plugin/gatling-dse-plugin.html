<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-07-25 Wed 18:04 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Performance testing of DSE with gatling-dse-plugin</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Alex Ott" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Performance testing of DSE with gatling-dse-plugin</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org78fb00a">1. Introduction</a></li>
<li><a href="#orga41f683">2. Basics of simulation's creation</a>
<ul>
<li><a href="#org36dd1af">2.1. Declaring simulation</a></li>
<li><a href="#orgbc2d247">2.2. Preparing environment</a>
<ul>
<li><a href="#org0e49e2d">2.2.1. Setting up connection/session/protocol</a></li>
<li><a href="#orgc5a9a25">2.2.2. Preparing CQL statements</a></li>
</ul>
</li>
<li><a href="#orga800908">2.3. Defining feeders</a></li>
<li><a href="#org66f1ee8">2.4. Defining scenario</a></li>
<li><a href="#org81354bf">2.5. Setup simulation</a></li>
</ul>
</li>
<li><a href="#org806f66c">3. Building simulation</a>
<ul>
<li><a href="#orga36d5e7">3.1. Building complete package with Maven</a></li>
</ul>
</li>
<li><a href="#org67499ba">4. Executing simulation</a></li>
<li><a href="#org374ccfb">5. Checking results</a></li>
<li><a href="#orge6be0d0">6. Example of simulation</a>
<ul>
<li><a href="#orgc0e19f4">6.1. Data structure</a></li>
<li><a href="#orgf065bf5">6.2. Preparing environment</a></li>
<li><a href="#org6582f07">6.3. Defining feeders</a></li>
<li><a href="#org775a020">6.4. Defining scenario</a></li>
<li><a href="#org2000077">6.5. Setup/execute simulation</a></li>
<li><a href="#orgee76e98">6.6. Running simulation</a></li>
<li><a href="#orgdb89727">6.7. Checking results</a></li>
</ul>
</li>
<li><a href="#org7b5104c">7. Additional information</a></li>
</ul>
</div>
</div>

<div id="outline-container-org78fb00a" class="outline-2">
<h2 id="org78fb00a"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Traditionally, to perform load testing of DSE &amp; Cassandra the <a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/tools/toolsCStress.html">cassandra-stress</a> tool was used - it's included into Cassandra's distribution, and needs only the configuration file to run. This is enough for simple types of testing, but does not allow to perform very complex testing with accessing multiple tables, generation of real-looking data, tuning individual queries, etc.
</p>

<p>
<a href="http://gatling.io/">Gatling</a> is popular tool for load testing of web applications that builds an embedded domain-specific language (DSL) on top of Scala (so basic knowledge of Scala is required).  One of the main advantages of Gatling is that it allows to build complex scenarios, consisting of multiple steps and generate realistic workloads because test's creator have the full control on how data generated.  You can also use assertions to check that response time meets your SLAs, and checks that will perform additional check of returned data. 
</p>

<p>
For a long time, there was <a href="https://github.com/gatling-cql/GatlingCql">GatlingCql plugin</a> that allowed to execute CQL statements from Gatling simulations, but it wasn't very actively developed in the last years, and it doesn't support full set of DSE functionality.
</p>

<p>
In April 2018, DataStax testing team open sourced its own implementation of <a href="https://github.com/datastax/gatling-dse-plugin">Gatling plugin for DSE</a> that could be used to create real-looking emulations. Besides plugin, testing team also open sourced 2 other projects:
</p>
<ul class="org-ul">
<li><a href="https://github.com/datastax/gatling-dse-stress">gatling-dse-stress</a> - it simplifies creation of simulations by providing implementation of feeders, and additional helper functions;</li>
<li><a href="https://github.com/datastax/gatling-dse-simcatalog">gatling-dse-simcatalog</a> - catalog of already implemented simulations that could be reused to build the new one.</li>
</ul>

<p>
Both of them will be described in a separate blog post.
</p>
</div>
</div>

<div id="outline-container-orga41f683" class="outline-2">
<h2 id="orga41f683"><span class="section-number-2">2</span> Basics of simulation's creation</h2>
<div class="outline-text-2" id="text-2">
<p>
Before we starting, we need to understand some of the Gatling's concepts:
</p>
<ul class="org-ul">
<li><b>Feeder</b> is data generator that is used to populate user session;</li>
<li><b>Session</b> keeps the user's data generated by feeder, together with additional data that could be added via API, or other methods;</li>
<li><b><a href="https://gatling.io/docs/current/general/scenario/">Scenario</a></b> defines a set of actions that should be executed, emulating real user's behaviour, etc.;</li>
<li><b><a href="https://gatling.io/docs/current/general/simulation_structure">Simulation</a></b> combines together feeders and scenarios, and defines what kind workload will be used (constant, increasing, etc.), what configuration to use, etc.;</li>
<li><b><a href="https://gatling.io/docs/current/general/assertions/">Assertions</a></b> are used to verify that global statistics like response time or number of failed requests matches expectations for a whole simulation.</li>
</ul>

<p>
The code of simulation is usually organized in following manner, similar to other <a href="https://gatling.io/docs/current/quickstart/">Gatling simulations</a>:
</p>
<ul class="org-ul">
<li>Declaring simulation;</li>
<li>Preparing environment:
<ul class="org-ul">
<li>Setting up DSE connection, create session, and instance of Gatling protocol;</li>
<li>(optional) Create schema;</li>
<li>Preparing necessary CQL statements;</li>
</ul></li>
<li>Defining the feeder(s) that will generate test data;</li>
<li>Defining scenario(s);</li>
<li>Setup/execute simulation (if necessary, add assertions to check against desired SLAs).</li>
</ul>
</div>

<div id="outline-container-org36dd1af" class="outline-3">
<h3 id="org36dd1af"><span class="section-number-3">2.1</span> Declaring simulation</h3>
<div class="outline-text-3" id="text-2-1">
<p>
First, you need to have a number of imports at the beginning of file - we need to import classes for Gatling, DSE Java driver, and gatling-dse-plugin (Note, that we import all classes from <code>com.datastax.driver.core</code> except the <code>Session</code>, because it will clash with Gatling's <code>Session</code> class):
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">import</span> com.datastax.driver.core.<span style="color: #008b8b;">ConsistencyLevel</span>.<span style="color: #a020f0;">_</span>
<span style="color: #a020f0;">import</span> com.datastax.driver.core.{<span style="color: #008b8b;">Session</span> <span style="color: #a020f0;">=&gt;</span> <span style="color: #a020f0;">_</span>, <span style="color: #a020f0;">_</span>}
<span style="color: #a020f0;">import</span> com.datastax.driver.dse.{<span style="color: #008b8b;">DseCluster</span>, <span style="color: #008b8b;">DseSession</span>}
<span style="color: #a020f0;">import</span> com.datastax.gatling.plugin.<span style="color: #008b8b;">DsePredef</span>.<span style="color: #a020f0;">_</span>
<span style="color: #a020f0;">import</span> com.datastax.gatling.plugin.<span style="color: #008b8b;">DseProtocolBuilder</span>
<span style="color: #a020f0;">import</span> io.gatling.core.<span style="color: #008b8b;">Predef</span>.<span style="color: #a020f0;">_</span>
<span style="color: #a020f0;">import</span> io.gatling.core.scenario.<span style="color: #008b8b;">Simulation</span>
<span style="color: #a020f0;">import</span> io.gatling.core.structure.<span style="color: #008b8b;">ScenarioBuilder</span>
</pre>
</div>

<p>
Then you need to create a class that extends the <code>io.gatling.core.scenario.Simulation</code> class, like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">class</span> <span style="color: #0000ee;">MySimulation</span> <span style="color: #a020f0;">extends</span> <span style="color: #0000ee;">Simulation</span>
{
<span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">implementation ...</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbc2d247" class="outline-3">
<h3 id="orgbc2d247"><span class="section-number-3">2.2</span> Preparing environment</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Preparing of the execution environment usually consists of 2 steps - establishing session to DSE cluster, and preparing queries that will be executed during test.  In some cases, like data load tests, the preparation stage may also take care for creation of necessary tables - when session is established, you can execute arbitrary CQL statements by using <code>session.execute</code>.
</p>
</div>

<div id="outline-container-org0e49e2d" class="outline-4">
<h4 id="org0e49e2d"><span class="section-number-4">2.2.1</span> Setting up connection/session/protocol</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
To initialize connection to DSE cluster &amp; instantiate the Gatling's protocol, we need, as usual, create the <code>DseCluster</code> instance, and create an instance of <code>DseSession</code> from it. The last step is creation of the <code>DseProtocolBuilder</code> object that will be used to setup the simulation (at last step).  The code could be from simple code like this (with hardcoded IP address):
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">clusterBuilder</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">DseCluster</span>.<span style="color: #008b8b;">Builder</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cluster</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseCluster</span> <span style="color: #a020f0;">=</span> clusterBuilder.addContactPoint(<span style="color: #008b00;">"127.0.0.1"</span>).build()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">dseSession</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseSession</span> <span style="color: #a020f0;">=</span> cluster.connect()

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cqlConfig</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseProtocolBuilder</span> <span style="color: #a020f0;">=</span> cql.session(dseSession)
</pre>
</div>

<p>
to more complex, like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">clusterBuilder</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">DseCluster</span>.<span style="color: #008b8b;">Builder</span>

clusterBuilder.
  withSocketOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">SocketOptions</span>().
    setKeepAlive(<span style="color: #008b8b;">true</span>).
    setTcpNoDelay(<span style="color: #008b8b;">true</span>)).
  withQueryOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">QueryOptions</span>().
    setDefaultIdempotence(<span style="color: #008b8b;">true</span>).
    setPrepareOnAllHosts(<span style="color: #008b8b;">true</span>).
    setReprepareOnUp(<span style="color: #008b8b;">true</span>).
    setConsistencyLevel(<span style="color: #008b8b;">LOCAL_ONE</span>)).
  withPoolingOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">PoolingOptions</span>().
    setCoreConnectionsPerHost(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">1</span>).
    setMaxConnectionsPerHost(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">2</span>).
    setNewConnectionThreshold(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">30000</span>).
    setMaxRequestsPerConnection(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">30000</span>))

<span style="color: #008b8b;">System</span>.getProperty(<span style="color: #008b00;">"contactPoints"</span>, <span style="color: #008b00;">"127.0.0.1"</span>).split(<span style="color: #008b00;">","</span>)
  .foreach(clusterBuilder.addContactPoint)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cluster</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseCluster</span> <span style="color: #a020f0;">=</span> clusterBuilder.build()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">dseSession</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseSession</span> <span style="color: #a020f0;">=</span> cluster.connect()

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cqlConfig</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseProtocolBuilder</span> <span style="color: #a020f0;">=</span> cql.session(dseSession)
</pre>
</div>

<p>
As you can see from this code, we can configure all necessary parameters, such as connection pooling, default query options, etc.  To avoid hard-coding the list of the DSE cluster's contact points, the default value (<code>127.0.0.1</code>) could be overwritten by specifying the Java's system property <code>contactPoints</code> (as comma-separated list of hosts).
</p>

<p>
After the <code>DseSession</code> object is created, it's then used to obtain an instance of the `DseProtocolBuilder` that will be used to configure simulation at the last step of the whole process.
</p>
</div>
</div>

<div id="outline-container-orgc5a9a25" class="outline-4">
<h4 id="orgc5a9a25"><span class="section-number-4">2.2.2</span> Preparing CQL statements</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
To reach optimal performance it's always recommended to prepare queries if they are used multiple times.  And it's done the same way as in normal Java/Scala code - by calling the <code>prepare</code> function on the <code>session</code> object, like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">insertPrepared</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(<span style="color: #008b00;">"INSERT INTO ks.table(col1, col2, col3) VALUES(?,?,?)"</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga800908" class="outline-3">
<h3 id="orga800908"><span class="section-number-3">2.3</span> Defining feeders</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Definition of feeder is really important for success of your load test - it should generate data with distribution maximally close to the expected (or already existing) data distribution inside the tables. 
</p>

<p>
Gatling's <code>Feeder</code> type is just an alias for <code>Iterator[Map[String, T]]</code> type - this means that we can use any implementation that produce instances of the <code>Map[String, T]</code> class. The simplest approach to it is to use <code>Iterator.continually</code> with function that will generate instances of the <code>Map</code> class, something like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">random</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">java</span>.util.<span style="color: #008b8b;">Random</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">feeder</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">Iterator</span>.continually({
  <span style="color: #008b8b;">Map</span>(
    <span style="color: #008b00;">"col1"</span> -&gt; <span style="color: #008b8b;">UUID</span>.randomUUID(),
    <span style="color: #008b00;">"col2"</span> -&gt; random.nextInt()
  )})
</pre>
</div>

<p>
Gatling provides <a href="https://gatling.io/docs/current/session/feeder/">several feeder implementations</a> - they can feed data from CSV, JSON, Redis, JDBC, and other sources, and allows to apply necessary transformations for input data - for example, CSV feeder only returns <code>String</code> instances, and you may need to convert some fields to numbers, or other types.  
</p>

<p>
Sometimes, when you work with DSE, you'll need to define your own feeders with more complex implementation.  This is usually required when your tables use the user-defined types (UDTs).  In this case, you can't simply create a value, but you need to fetch necessary metadata from database to create an instances of the UDT.  This task is not really complex as you may see in <a href="https://gist.github.com/bradfordcp/9a10fdb0588e00c3fc69716eb1edac68">following example</a>, but requires some coding to create correct object instances.
</p>

<p>
When you're plug in the feeder into scenario, the data generated by feeder is merged with already existing data in the user's session object.  This allows us to use multiple feeders in the same scenario - this is especially useful when you have an existing library of feeder's implementations, and can reuse them in new tests.
</p>

<p>
<b>Note</b>: Quite often, the <a href="https://github.com/DiUS/java-faker">Java Faker</a> library is used for generation of people/company names, domains, addresses, numbers, dates, etc.  Using this library it's possible to generate much more realistically looking data than by using standard random generators.
</p>
</div>
</div>

<div id="outline-container-org66f1ee8" class="outline-3">
<h3 id="org66f1ee8"><span class="section-number-3">2.4</span> Defining scenario</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The <a href="https://gatling.io/docs/current/general/scenario">scenario</a> is defined by using <code>scenario</code> function that accepts the name of scenario as an argument, and then this instance is populated with feeders, structure elements (<code>exec</code>, <code>pause</code>, &#x2026;), and other components, such as groups, loops, conditionals, etc.  The <code>exec</code> accepts the action definition, or function that should transform the user's session object.  There are multiple implementations of actions, like, <code>http</code> that comes together with Gatling and used to execute HTTP requests.  The gatling-dse-plugin adds the <code>cql</code> action that is used to execute queries against DSE. The action alone doesn't do anything, so you need to specify an additional parameters by calling different functions on the action object - you can execute raw CQL with <code>executeCql</code>, execute prepared query with <code>executePrepared</code>, etc.
</p>

<p>
In the simplest case, scenario could look as following - we add feeder to it &amp; executing one CQL statement per session (we're using Gatling's string interpolation to feed data into string):
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadDataSimple</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"loadDataSimple"</span>)
  .feed(feeder)
  .exec(cql(<span style="color: #008b00;">"InsertData"</span>)
      .executeCql(s<span style="color: #008b00;">"insert into table x(col1) values('</span><span style="color: #a0522d;">${col}</span><span style="color: #008b00;">'"</span>))
</pre>
</div>

<p>
In more complex cases scenario could look as following:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadData</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"loadData"</span>)
  .feed(feeder)
  .group(<span style="color: #008b00;">"Insert"</span>)(
    exec(cql(<span style="color: #008b00;">"InsertOAuth"</span>)
      .executePrepared(insertPrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>, <span style="color: #008b00;">"ttl"</span>)))
      .exec(cql(<span style="color: #008b00;">"insertUser"</span>)
        .executePrepared(insertPrepared2)
        .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>, <span style="color: #008b00;">"ttl"</span>)))
  )
  .pause(<span style="color: #008b8b;">1</span>) <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">wait 1 second before rotating token...</span>
  .group(<span style="color: #008b00;">"Update"</span>)(
    exec(cql(<span style="color: #008b00;">"updateOAuth"</span>)
      .executePrepared(updatePrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"token_id"</span>)))
      .exec(cql(<span style="color: #008b00;">"updateUser"</span>)
        .executePrepared(updatePrepared2)
        .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"token_id"</span>)))
  )
</pre>
</div>

<p>
In this case scenario consists of 2 groups with pause between them, and every group consists of execution of 2 prepared queries for insertion &amp; update of data. The <code>withParams</code> function is used to specify parameters that will be bound into the query.  You can either specify a list of key names in the session object, or you can specify a variable number of session expressions that will be bound into query.
</p>

<p>
If you have many tests &amp; complex scenarios you may consider to refactor scenarios into individual steps by defining the number of the <code>ChainBuilder</code> instances that are later wired into scenario, like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">part1</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ChainBuilder</span> <span style="color: #a020f0;">=</span>
  exec(cql(<span style="color: #008b00;">"updateOAuth"</span>)
    .executePrepared(updatePrepared)
    .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"token_id"</span>)))
    .exec(cql(<span style="color: #008b00;">"updateUser"</span>)
      .executePrepared(updatePrepared2)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"token_id"</span>)))

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadData</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"loadData"</span>)
  .feed(feeder)
  .exec(part1)
</pre>
</div>

<p>
You can find more examples on how you can structure your tests in the <a href="https://gatling.io/docs/current/advanced_tutorial/">Gatling's advanced tutorial</a>.
</p>
</div>
</div>

<div id="outline-container-org81354bf" class="outline-3">
<h3 id="org81354bf"><span class="section-number-3">2.5</span> Setup simulation</h3>
<div class="outline-text-3" id="text-2-5">
<p>
After you defined the scenario, you can setup it for execution - this is done by defining <code>setUp</code> where you need to  inject necessary load into scenario, and then specifying which protocol(s) to use.  For example, following example use our <code>loadData</code> scenario with 3 injection profiles:
</p>
<ul class="org-ul">
<li>perform the load test with 25% of concurrent users during 1/4 of the total test duration time (configured elsewhere) - this step is used to warm up the database, etc.;</li>
<li>do nothing for 1 minute, so DB can catch up with GC, compactions, etc.;</li>
<li>perform full-scale test with configured number of concurrent users during the configured test duration time.</li>
</ul>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    constantUsersPerSec(concurrentSessionCount / <span style="color: #008b8b;">4</span>) during (testDuration / <span style="color: #008b8b;">4</span>),
    nothingFor(<span style="color: #008b8b;">FiniteDuration</span>(<span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">TimeUnit</span>.<span style="color: #008b8b;">MINUTES</span>)),
    constantUsersPerSec(concurrentSessionCount) during testDuration
  )
).protocols(cqlConfig)
</pre>
</div>

<p>
Gatling provides several implementation of injection profiles - with constant number of concurrent users per second (with <code>constantUsersPerSec</code>), with increasing number of users per second from one number to another number (with <code>rampUsersPerSec</code>), injection of given number of users at once (with <code>atOnceUsers</code>), etc.  Please check <a href="https://gatling.io/docs/current/general/simulation_setup/#injection">Gatling's documentation for more information</a>.  You need to select injection profile that matches your needs - for example, you can use <code>constantUsersPerSec</code> profile for load tests where you want to make sure that there are no performance problems with code, or use <code>rampUsersPerSec</code> profile to detect what is the maximal number of users your system can handle.
</p>

<p>
The <code>protocols</code> function specifies what protocol implementation should be used for given test scenario - we've created an instance of protocol for CQL, but you can also use multiple protocols at the same time, for example, if you want to test mixed application that makes both CQL &amp; HTTP queries.
</p>
</div>
</div>
</div>

<div id="outline-container-org806f66c" class="outline-2">
<h2 id="org806f66c"><span class="section-number-2">3</span> Building simulation</h2>
<div class="outline-text-2" id="text-3">
<p>
There are several ways to build &amp; execute your simulation:
</p>
<ul class="org-ul">
<li>Build the complete package together with Gatling, and execute it - this method is described below;</li>
<li><p>
Build the package without Gatling (but with all other dependencies), copy resulting package into Gatling's <code>lib</code> directory &amp; execute it with command like this:
</p>

<div class="org-src-container">
<pre class="src src-shell">java -cp conf:<span style="color: #ff00ff;">`echo lib/*.jar | sed 's/ /:/g'`</span> io.gatling.app.Gatling <span style="color: #008b00;">\</span>
   -s com.datastax.demos.gatling.GatlingLoadSim -rf results
</pre>
</div>

<p>
where the <code>-s</code> flag specifies the name of Simulation class, and <code>-rf</code> specifies the folder to put results.
</p>

<p>
For this case, the <code>pom.xml</code> file looks almost the same way as when we're building the package with Gatling, but declaring the <code>gatling-charts-highcharts</code> dependency as <code>provided</code>;
</p></li>

<li>Copy the source code for your simulation into <code>user-files/simulations</code> directory of Gatling's distribution, and execute it via <code>bin/gatling.sh</code> script that will compile source code, and run it. (This approach unfortunately won't work out of the box because of the <a href="https://docs.datastax.com/en/developer/java-driver-dse/1.6/faq/#why-am-i-encountering-an-illegal-cyclic-reference-error-when-using-the-driver-with-scala">existing problem with Scala compiler &amp; <code>DseCluster</code> class</a> - our testing team sent a pull request to Gatling that should allow to handle this problem, but it could be available only in the next version of Gatling). You also need to copy all necessary dependencies, such as, <code>gatling-dse-plugin</code>, etc. into <code>lib</code> directory of unpacked Gatling distribution;</li>
<li>folder <a href="https://gatling.io/docs/current/extensions/maven_plugin/">gatling-maven-plugin</a> or <a href="https://gatling.io/docs/current/extensions/sbt_plugin/">gatling-sbt-plugin</a> to execute simulations (there is also unofficial <a href="https://gatling.io/docs/current/extensions/">Gradle plugins</a>).  By using these plugins you can easier integrate Gatling-based load tests into your projects.</li>
</ul>
</div>

<div id="outline-container-orga36d5e7" class="outline-3">
<h3 id="orga36d5e7"><span class="section-number-3">3.1</span> Building complete package with Maven</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The official builds of the <code>gatling-dse-plugin</code> are available at <a href="https://repo.datastax.com/public-repos/com/datastax/gatling/plugin/">DataStax's Maven repository</a>, so to use it in your project, you need to add corresponding declaration to your <code>pom.xml</code> file:
</p>

<div class="org-src-container">
<pre class="src src-nxml">&lt;<span style="color: #b22222;">repositories</span>&gt;
  &lt;<span style="color: #b22222;">repository</span>&gt;
    &lt;<span style="color: #b22222;">id</span>&gt;DataStax-Repo&lt;/<span style="color: #b22222;">id</span>&gt;
    &lt;<span style="color: #b22222;">url</span>&gt;https://repo.datastax.com/public-repos/&lt;/<span style="color: #b22222;">url</span>&gt;
  &lt;/<span style="color: #b22222;">repository</span>&gt;
&lt;/<span style="color: #b22222;">repositories</span>&gt;
</pre>
</div>

<p>
Then you need to include necessary dependencies for gatling-dse-plugin &amp; Gatling itself (you can find the latest version of the plugin on GitHub):
</p>

<div class="org-src-container">
<pre class="src src-nxml">&lt;<span style="color: #b22222;">dependency</span>&gt;
  &lt;<span style="color: #b22222;">groupId</span>&gt;com.datastax.gatling.plugin&lt;/<span style="color: #b22222;">groupId</span>&gt;
  &lt;<span style="color: #b22222;">artifactId</span>&gt;gatling-dse-plugin_2.12&lt;/<span style="color: #b22222;">artifactId</span>&gt;
  &lt;<span style="color: #b22222;">version</span>&gt;1.3.2&lt;/<span style="color: #b22222;">version</span>&gt;
&lt;/<span style="color: #b22222;">dependency</span>&gt;
&lt;<span style="color: #b22222;">dependency</span>&gt;
  &lt;<span style="color: #b22222;">groupId</span>&gt;io.gatling.highcharts&lt;/<span style="color: #b22222;">groupId</span>&gt;
  &lt;<span style="color: #b22222;">artifactId</span>&gt;gatling-charts-highcharts&lt;/<span style="color: #b22222;">artifactId</span>&gt;
  &lt;<span style="color: #b22222;">version</span>&gt;2.3.1&lt;/<span style="color: #b22222;">version</span>&gt;
<span style="color: #7f7f7f;">&lt;!--  </span><span style="color: #7f7f7f;">uncomment this if you want to build package just for your application, without Gatling inside  </span><span style="color: #7f7f7f;">--&gt;</span>
<span style="color: #7f7f7f;">&lt;!--      </span><span style="color: #7f7f7f;">&lt;scope&gt;provided&lt;/scope&gt; </span><span style="color: #7f7f7f;">--&gt;</span> 
&lt;/<span style="color: #b22222;">dependency</span>&gt;
</pre>
</div>

<p>
And add <a href="https://github.com/alexott/gatling-dse-examples/blob/master/plugin-sim/pom.xml#L44">necessary pieces</a> to compile the Java code &amp; pack everything into one jar file when you execute the <code>mvn package</code> command.
</p>
</div>
</div>
</div>

<div id="outline-container-org67499ba" class="outline-2">
<h2 id="org67499ba"><span class="section-number-2">4</span> Executing simulation</h2>
<div class="outline-text-2" id="text-4">
<p>
Execution of packaged simulation is just simple - specify the path to the packaged jar file, and specify the name of the simulation class plus necessary parameters:
</p>

<div class="org-src-container">
<pre class="src src-shell">java -cp &lt;packaged-jar-file&gt; [system properties] io.gatling.app.Gatling -s &lt;simulation-class&gt; [-rf &lt;results-directory&gt;]
</pre>
</div>

<p>
where:
</p>
<ul class="org-ul">
<li><code>io.gatling.app.Gatling</code> - name of the Gatling's main class;</li>
<li><code>-s</code> flag specifies the name of Simulation class;</li>
<li><code>-rf</code> flat specifies the folder to put results.</li>
<li><code>system properties</code> list of additional parameters that your simulation will consume (if it's implemented).</li>
</ul>

<p>
For example, here is the command line that was used to run the example simulation described below (please note that I've included <code>gatling-charts-highcharts-bundle-2.3.0/conf</code> into class path to re-use the Gatling's configuration files):
</p>

<div class="org-src-container">
<pre class="src src-shell">java -cp &lt;path-to&gt;/gatling-charts-highcharts-bundle-2.3.0/conf:target/gatling-plugin-sim-0.0.1-jar-with-dependencies.jar <span style="color: #008b00;">\</span>
    -DcontactPoints=192.168.0.10 -DtestDuration=2 -DconcurrentSessionCount=10000 <span style="color: #008b00;">\</span>
    io.gatling.app.Gatling -s com.datastax.demos.gatling.GatlingLoadSim -rf results
</pre>
</div>

<p>
During the execution of the simulation, the current statistics is printed to the screen - it shows the number of executed requests globally &amp; per group, current &amp; execution time, number of active/waiting/finished users, and other information, like overall progress.  The status <code>OK</code> shows the number of successfully executed requests, and <code>KO</code> shows the number of failed requests (0 in our example):
</p>

<pre class="example">
================================================================================
2018-07-24 16:11:47                                          55s elapsed
---- Requests ------------------------------------------------------------------
&gt; Global                                                   (OK=807192 KO=0     )
&gt; Insert / InsertOAuth                                     (OK=204531 KO=0     )
&gt; Insert / insertUser                                      (OK=202970 KO=0     )
&gt; Update / updateOAuth                                     (OK=200815 KO=0     )
&gt; Update / updateUser                                      (OK=198876 KO=0     )

---- loadData ------------------------------------------------------------------
[####################--                                                    ] 27%
          waiting: 509979 / active: 11145  / done:198876
================================================================================
</pre>

<p>
<b>Note</b>: It's important to track the number of active users here - if it's grows very fast, then your system isn't able to handle so much load, and number of simultaneous users should be decreased.
</p>

<p>
When simulation finishes, something like this will be printed to the screen:
</p>

<pre class="example">
Simulation com.datastax.demos.gatling.GatlingLoadSim completed in 157 seconds
Parsing log file(s)...
Parsing log file(s) done
Generating reports...

================================================================================
---- Global Information --------------------------------------------------------
&gt; request count                                    2880000 (OK=2880000 KO=0     )
&gt; min response time                                      0 (OK=0      KO=-     )
&gt; max response time                                    696 (OK=696    KO=-     )
&gt; mean response time                                   165 (OK=165    KO=-     )
&gt; std deviation                                        143 (OK=143    KO=-     )
&gt; response time 50th percentile                        152 (OK=152    KO=-     )
&gt; response time 75th percentile                        262 (OK=262    KO=-     )
&gt; response time 95th percentile                        422 (OK=422    KO=-     )
&gt; response time 99th percentile                        552 (OK=552    KO=-     )
&gt; mean requests/sec                                18227.848 (OK=18227.848 KO=-     )
---- Response Time Distribution ------------------------------------------------
&gt; t &lt; 800 ms                                       2880000 (100%)
&gt; 800 ms &lt; t &lt; 1200 ms                                   0 (  0%)
&gt; t &gt; 1200 ms                                            0 (  0%)
&gt; failed                                                 0 (  0%)
================================================================================

Reports generated in 62s.
Please open the following file: &lt;some-path...&gt;/results/gatlingloadsim-1532441452451/index.html
</pre>

<p>
This screen includes basic statistics about execution of simulation - number of requests, minimal/maximal/percentiles of response time, etc.  This information is often enough to get a quick understanding of your system's performance, and you can also find more information in the generated HTML report described in the next session.
</p>

<p>
<b>Note</b>: as you may see, the test was completed in 157 seconds, although the test duration was specified as 120 seconds (2 minutes).
</p>

<p>
To get correct results from load testing we need to perform test enough time, so the things like garbage collection, compaction, etc. will happen during that time, and we'll see how this can influence performance of the system.
</p>
</div>
</div>

<div id="outline-container-org374ccfb" class="outline-2">
<h2 id="org374ccfb"><span class="section-number-2">5</span> Checking results</h2>
<div class="outline-text-2" id="text-5">
<p>
When simulation finishes Gatling may generate an HTML report that will be put as separated directory under directory specified as <code>-rf</code> command-line flag.  The directory name has format <code>gatlingloadsim-&lt;timestamp&gt;</code>, and full path to the entry file is printed as part of final message (see above).  This report has 2 parts:
</p>
<ul class="org-ul">
<li><b>Global</b>, that provides information about whole simulation (with some statistics about individual groups &amp; actions);</li>
<li><b>Details</b>, that provides information about individual actions.</li>
</ul>

<p>
Here is what you'll see the HTML report (the page is split into separate images to make it more readable).  All graphs also have tooltips that shows more details about individual graph points.
</p>

<p>
First part of the Global page includes information about overall requests number, and numbers for individual groups/actions, together with statistics for every part:
</p>


<div class="figure">
<p><img src="./gatling-plugin-global-results.png" alt="gatling-plugin-global-results.png" />
</p>
</div>

<p>
Most important numbers here are response times, especially the 99th percentile &amp; max response time, together with number of requests per second &amp; number of requests executed with error.
</p>

<p>
Next section shows the number of active users in the executed simulation - in this example I've used <code>rampUsersPerSec</code> injection that increase the number of simultaneous users over the time until it reach given value (here from 2,000 to 10,000 over the 2 minutes).  As you can see on the graph, at some point of time this number is started to increase, so it's clear sign that system can't handle more users without increasing response latency.  (You can see the graphs for other <code>constantUsersPerSec</code> injection at the end of this section):
</p>


<div class="figure">
<p><img src="./gatling-plugin-active-users.png" alt="gatling-plugin-active-users.png" />
</p>
</div>

<p>
Next 2 sections show the data about response times - overall distribution of response time values &amp; how the response time percentiles are changed during execution of the simulation.  Please note, that the second part for convenience shows the number of active users:
</p>


<div class="figure">
<p><img src="./gatling-plugin-response-time.png" alt="gatling-plugin-response-time.png" />
</p>
</div>

<p>
And the last 2 sections shows the data about number of request/response over the time: 
</p>


<div class="figure">
<p><img src="./gatling-plugin-throughput-stats.png" alt="gatling-plugin-throughput-stats.png" />
</p>
</div>

<p>
The Details part allows use to look to the results for individual tests, like, inserts or updates of individual tables.  The structure of information is almost the same as for Global part.
</p>


<div class="figure">
<p><img src="./gatling-plugin-individual-details.png" alt="gatling-plugin-individual-details.png" />
</p>
</div>


<p>
We can compare graphs from above, that were generated for simulation with <code>rampUsersPerSec</code> injection with graphs from simulation with <code>constantUsersPerSec</code> injection.   The first graph shows data for 10,000 simultaneous users - you can notice that number of active users is increasing over the time until it reach specified period of time, and then is decreasing when simulation doesn't create new users. You may also notice that latency is quite high, even for 50th percentile.  This is a clear sign that the system is overloaded, although it's able to handle about 20,000 requests per second.
</p>



<div class="figure">
<p><img src="./gatling-const-load-overloaded.png" alt="gatling-const-load-overloaded.png" />
</p>
</div>

<p>
We can try the same simulation with 5,000 simultaneous users, and we can notice the difference - all latencies went down, and number of active users is almost on the same level, except the initial period of time.  But in this case we're able to handle only slightly more then 10,000 requests per second.
</p>


<div class="figure">
<p><img src="./gatling-const-load-good.png" alt="gatling-const-load-good.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-orge6be0d0" class="outline-2">
<h2 id="orge6be0d0"><span class="section-number-2">6</span> Example of simulation</h2>
<div class="outline-text-2" id="text-6">
<p>
This section contains a full example of the Gatling-based simulation for testing of the loading of data into DSE.  We're implementing something like OAuth token management (<b>this is just an example, not real application!</b>).  During execution of simulation, we'll insert data into tables, and then updates the parts of the data several seconds later.
</p>

<p>
Full source code for this simulation is located in the directory <code>plugin-sim</code> of the
<a href="https://github.com/alexott/gatling-dse-examples">https://github.com/alexott/gatling-dse-examples</a> repository.
</p>
</div>

<div id="outline-container-orgc0e19f4" class="outline-3">
<h3 id="orgc0e19f4"><span class="section-number-3">6.1</span> Data structure</h3>
<div class="outline-text-3" id="text-6-1">
<p>
We'll have data in the 2 tables with similar structure, but with different primary key - one table will keep individual OAuth tokens, and second table will store OAuth tokens issued for specific user, so we can revoke all of them if necessary.  The tables are in the <code>gatling</code> keyspace with table structure defined as:
</p>

<pre class="example">
CREATE TABLE oauth_tokens (
 id uuid,
 nonce int,
 user text,
 created timestamp,
 expires timestamp,
 attributes frozen&lt;map&lt;text, text&gt;&gt;,
 
 PRIMARY KEY(id)
);

CREATE TABLE user_tokens (
 user text,
 id uuid,
 nonce int,
 created timestamp,
 expires timestamp,
 attributes frozen&lt;map&lt;text, text&gt;&gt;,

 PRIMARY KEY(user, id)
);

</pre>

<p>
The full schema specification is in the <a href="https://github.com/alexott/gatling-dse-examples/blob/master/plugin-sim/cql/create-schema.cql">cql/create-schema.cql</a> file, and could be created by using following command (modify keyspace names, and replication strategy if necessary):
</p>

<div class="org-src-container">
<pre class="src src-shell">cqlsh &lt;DSE-IP&gt; -f cql/create-schema.cql
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf065bf5" class="outline-3">
<h3 id="orgf065bf5"><span class="section-number-3">6.2</span> Preparing environment</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The necessary imports, etc. are matching to the examples shown at the begin of the article, so we just concentrate on pieces of code:
</p>

<p>
First we need to setup connection, establish connection &amp; create configuration object that will be used to setup simulation:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">clusterBuilder</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">DseCluster</span>.<span style="color: #008b8b;">Builder</span>

clusterBuilder.
  withSocketOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">SocketOptions</span>().
    setKeepAlive(<span style="color: #008b8b;">true</span>).
    setTcpNoDelay(<span style="color: #008b8b;">true</span>)).
  withQueryOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">QueryOptions</span>().
    setDefaultIdempotence(<span style="color: #008b8b;">true</span>).
    setPrepareOnAllHosts(<span style="color: #008b8b;">true</span>).
    setReprepareOnUp(<span style="color: #008b8b;">true</span>).
    setConsistencyLevel(<span style="color: #008b8b;">LOCAL_ONE</span>)).
  withPoolingOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">PoolingOptions</span>().
    setCoreConnectionsPerHost(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">1</span>).
    setMaxConnectionsPerHost(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">2</span>).
    setNewConnectionThreshold(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">30000</span>).
    setMaxRequestsPerConnection(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">30000</span>))

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">srvList</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">System</span>.getProperty(<span style="color: #008b00;">"contactPoints"</span>, <span style="color: #008b00;">"127.0.0.1"</span>).split(<span style="color: #008b00;">","</span>).toList
srvList.foreach(clusterBuilder.addContactPoint)

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cluster</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseCluster</span> <span style="color: #a020f0;">=</span> clusterBuilder.build()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">dseSession</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseSession</span> <span style="color: #a020f0;">=</span> cluster.connect()

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cqlConfig</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseProtocolBuilder</span> <span style="color: #a020f0;">=</span> cql.session(dseSession)
</pre>
</div>

<p>
After that we'll need to create necessary prepared statements:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">insertPrepared</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(
  <span style="color: #008b00;">"insert into gatling.oauth_tokens(id, nonce, user, created, expires, attributes) values(?,?,?,?,?,?) using TTL ?"</span>);
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">insertPrepared2</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(
  <span style="color: #008b00;">"insert into gatling.user_tokens(id, nonce, user, created, expires, attributes) values(?,?,?,?,?,?) using TTL ?"</span>)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">updatePrepared</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(
  <span style="color: #008b00;">"update gatling.oauth_tokens using TTL ? set nonce = ? where id = ?"</span>)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">updatePrepared2</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(
  <span style="color: #008b00;">"update gatling.user_tokens using TTL ? set nonce = ? where user = ? and id = ?"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org6582f07" class="outline-3">
<h3 id="org6582f07"><span class="section-number-3">6.3</span> Defining feeders</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Definition of feeder is very important for our use case.  We need to create real-world looking authentication token IDs &amp; user names.  For token IDs we're just generating random UUIDs, and for user names are generated by using methods from Java Faker library. Other fields are generated by appropriate methods just to fill enough space in table. Every record also gets the TTL of the 30 minutes:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">def</span> <span style="color: #b22222;">random</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ThreadLocalRandom</span> <span style="color: #a020f0;">=</span> {
  <span style="color: #008b8b;">ThreadLocalRandom</span>.current()
}

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">defaultTTL</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">30</span> * <span style="color: #008b8b;">60</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">30 minutes</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">faker</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">Faker</span>()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">feeder</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">Iterator</span>.continually({
  <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">timestamp</span> <span style="color: #a020f0;">=</span> java.time.<span style="color: #008b8b;">Instant</span>.now()
  <span style="color: #008b8b;">Map</span>(
    <span style="color: #008b00;">"token_id"</span> -&gt; <span style="color: #008b8b;">UUID</span>.randomUUID(),
    <span style="color: #008b00;">"user"</span> -&gt; faker.name().username(),
    <span style="color: #008b00;">"nonce1"</span> -&gt; random.nextInt(),
    <span style="color: #008b00;">"nonce2"</span> -&gt; random.nextInt(),
    <span style="color: #008b00;">"created"</span> -&gt; timestamp.toEpochMilli,
    <span style="color: #008b00;">"expires"</span> -&gt; timestamp.plusSeconds(defaultTTL).toEpochMilli,
    <span style="color: #008b00;">"attrs"</span> -&gt; <span style="color: #008b8b;">Map</span>(
      <span style="color: #008b00;">"code"</span> -&gt; faker.code.isbn13(),
      <span style="color: #008b00;">"address"</span> -&gt; faker.address().fullAddress()
    ),
    <span style="color: #008b00;">"ttl"</span> -&gt; defaultTTL
  )
}
)
</pre>
</div>

<p>
Be very careful with data types - they need to match the actual data types in table's definitions.  For example, timestamp could be specified as <code>java.util.Date</code>, <code>Long</code>, or <code>String</code> - in our example we're using <code>Long</code> type for timestamps.
</p>
</div>
</div>

<div id="outline-container-org775a020" class="outline-3">
<h3 id="org775a020"><span class="section-number-3">6.4</span> Defining scenario</h3>
<div class="outline-text-3" id="text-6-4">
<p>
As was mentioned above, our scenario includes two inserts into separate tables, and two updates of the <code>nonce</code> field in both tables, simulating rotation of the authentication token.  Our scenario consists of feeder, two groups for inserts/updates, and pause between them:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadData</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"loadData"</span>)
  .feed(feeder)
  .group(<span style="color: #008b00;">"Insert"</span>)(
    exec(cql(<span style="color: #008b00;">"InsertOAuth"</span>)
      .executePrepared(insertPrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>, <span style="color: #008b00;">"ttl"</span>)))
      .exec(cql(<span style="color: #008b00;">"insertUser"</span>)
        .executePrepared(insertPrepared2)
        .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>, <span style="color: #008b00;">"ttl"</span>)))
  )
  .pause(<span style="color: #008b8b;">1</span>) <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">wait 1 second before rotating token...</span>
  .group(<span style="color: #008b00;">"Update"</span>)(
    exec(cql(<span style="color: #008b00;">"updateOAuth"</span>)
      .executePrepared(updatePrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"token_id"</span>)))
      .exec(cql(<span style="color: #008b00;">"updateUser"</span>)
        .executePrepared(updatePrepared2)
        .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"token_id"</span>)))
  )
</pre>
</div>

<p>
Every group &amp; individual actions have names, so we can easily get information for any of them in the report.
</p>
</div>
</div>

<div id="outline-container-org2000077" class="outline-3">
<h3 id="org2000077"><span class="section-number-3">6.5</span> Setup/execute simulation</h3>
<div class="outline-text-3" id="text-6-5">
<p>
To make our test more flexible, we can pass the number of concurrent users &amp; test duration (in minutes) as system properties with names <code>concurrentSessionCount</code> &amp; <code>testDuration</code> correspondingly:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">testDuration</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">FiniteDuration</span>(java.lang.<span style="color: #008b8b;">Long</span>.getLong(<span style="color: #008b00;">"testDuration"</span>, <span style="color: #008b8b;">5</span>), <span style="color: #008b8b;">TimeUnit</span>.<span style="color: #008b8b;">MINUTES</span>)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">concurrentSessionCount</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">Int</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">Integer</span>.getInteger(<span style="color: #008b00;">"concurrentSessionCount"</span>, <span style="color: #008b8b;">100</span>)
</pre>
</div>

<p>
For our experiment we'll use different injection profiles to show difference on how results could look like:
</p>
<ul class="org-ul">
<li><p>
using <code>rampUsersPerSec</code> to emulate increase in number of concurrent users from 30% to 100% of target:
</p>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    rampUsersPerSec(concurrentSessionCount / <span style="color: #008b8b;">3</span>) to (concurrentSessionCount) during testDuration
  )
).protocols(cqlConfig)
</pre>
</div></li>

<li><p>
using <code>constantUsersPerSec</code> to create load with the same number of concurrent users:
</p>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    constantUsersPerSec(concurrentSessionCount) during testDuration
  )
).protocols(cqlConfig)
</pre>
</div></li>

<li><p>
using <code>constantUsersPerSec</code> to create load with the same number of concurrent users, but with separate <span class="underline">warm up</span> stage under 25% of load during 1/4 of test time:
</p>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    constantUsersPerSec(concurrentSessionCount / <span style="color: #008b8b;">4</span>) during (testDuration/<span style="color: #008b8b;">4</span>),
    nothingFor(<span style="color: #008b8b;">FiniteDuration</span>(<span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">TimeUnit</span>.<span style="color: #008b8b;">MINUTES</span>)),
    constantUsersPerSec(concurrentSessionCount) during testDuration
  )
).protocols(cqlConfig)
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgee76e98" class="outline-3">
<h3 id="orgee76e98"><span class="section-number-3">6.6</span> Running simulation</h3>
<div class="outline-text-3" id="text-6-6">
<p>
We can use following command to run the simulation, specifying necessary parameters (it's the same as was shown above):
</p>

<div class="org-src-container">
<pre class="src src-shell">java -cp &lt;path-to&gt;/gatling-charts-highcharts-bundle-2.3.0/conf:target/gatling-plugin-sim-0.0.1-jar-with-dependencies.jar <span style="color: #008b00;">\</span>
    -DcontactPoints=192.168.0.10 -DtestDuration=10 -DconcurrentSessionCount=5000 <span style="color: #008b00;">\</span>
    io.gatling.app.Gatling -s com.datastax.demos.gatling.GatlingLoadSim -rf results
</pre>
</div>

<p>
In this case we're running test for 10 minutes with maximal number of concurrent users equal to 5000.
</p>
</div>
</div>

<div id="outline-container-orgdb89727" class="outline-3">
<h3 id="orgdb89727"><span class="section-number-3">6.7</span> Checking results</h3>
<div class="outline-text-3" id="text-6-7">
<p>
When using <code>rampUsersPerSec</code> we get following graph for response time &amp; number of requests per second:
</p>


<div class="figure">
<p><img src="./gatling-load-rampup.png" alt="gatling-load-rampup.png" />
</p>
</div>

<p>
As you can see, as the number of concurrent users started to increase, the 99th response time (and other percentiles as well) is increased from ~100ms to 350-500ms.
</p>

<p>
If we're putting the constant load of without pre-warm of the database, we get following graphs:
</p>


<div class="figure">
<p><img src="./gatling-load-constant.png" alt="gatling-load-constant.png" />
</p>
</div>


<p>
For constant load with pre-warm we've got following results - as you can see, even 50th percentile is quite high in this setup:
</p>


<div class="figure">
<p><img src="./gatling-load-constant-with-warmup.png" alt="gatling-load-constant-with-warmup.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7b5104c" class="outline-2">
<h2 id="org7b5104c"><span class="section-number-2">7</span> Additional information</h2>
<div class="outline-text-2" id="text-7">
<p>
This tutorial contains just enough information to start writing tests for DSE using Gatling.   Gatling's site has quite <a href="https://gatling.io/docs/current/">detailed documentation</a> on how you can use it.  The <a href="https://gatling.io/docs/current/cheat-sheet/">Gatling cheatsheet</a> page is also very useful resource when you just need to look to the syntax of particular function.
</p>

<p>
gatling-dse-plugin's <a href="https://github.com/datastax/gatling-dse-plugin/wiki">wiki pages</a> contain more information on how to use this plugin to test DSE Graph, some information about implementation, etc. 
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Alex Ott</p>
<p class="date">Created: 2018-07-25 Wed 18:04</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
