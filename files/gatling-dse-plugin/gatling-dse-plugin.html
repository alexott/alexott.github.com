<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-08-18 Sat 10:04 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Performance testing of DSE with gatling-dse-plugin</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Alex Ott" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Performance testing of DSE with gatling-dse-plugin</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgcf99a3e">1. Introduction</a></li>
<li><a href="#org1627b12">2. Basics of simulation's creation</a>
<ul>
<li><a href="#org8720e51">2.1. Declaring simulation</a></li>
<li><a href="#orgdae5a9b">2.2. Prepare environment</a>
<ul>
<li><a href="#org5378eb4">2.2.1. Setup connection/session/protocol</a></li>
<li><a href="#org333a6b1">2.2.2. Prepare CQL statements</a></li>
</ul>
</li>
<li><a href="#org605e9d2">2.3. Define feeder(s)</a></li>
<li><a href="#orgc2158b7">2.4. Define scenario</a></li>
<li><a href="#org9ed8171">2.5. Setup simulation</a></li>
</ul>
</li>
<li><a href="#org2cd9d78">3. Building simulation</a>
<ul>
<li><a href="#orgdef739e">3.1. Building complete package with Maven</a></li>
</ul>
</li>
<li><a href="#org00e6141">4. Executing simulation</a></li>
<li><a href="#org6ef6583">5. Checking results</a></li>
<li><a href="#org0f4d312">6. Simulation examples</a>
<ul>
<li><a href="#org2db9dba">6.1. Data structure</a></li>
<li><a href="#org057c407">6.2. Simulation for loading data into database</a>
<ul>
<li><a href="#org1e3288d">6.2.1. Prepare environment</a></li>
<li><a href="#org6742b4e">6.2.2. Define feeders</a></li>
<li><a href="#orga8f3e3b">6.2.3. Define scenario</a></li>
<li><a href="#org1ea42bf">6.2.4. Setup/execute simulation</a></li>
<li><a href="#org81cdaad">6.2.5. Run simulation</a></li>
<li><a href="#org87744f5">6.2.6. Check results</a></li>
</ul>
</li>
<li><a href="#orga02f098">6.3. Simulation of mixed load</a></li>
</ul>
</li>
<li><a href="#orgdb4f14c">7. Additional information</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgcf99a3e" class="outline-2">
<h2 id="orgcf99a3e"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Traditionally, to perform load testing of DSE &amp; Cassandra the <a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/tools/toolsCStress.html">cassandra-stress</a> tool was used - it's included into Cassandra's distribution, and only needs a configuration file to run. This is enough for simple types of testing, but it does not allow to perform very complex testing with access to multiple tables, generation of real-looking data, tuning individual queries, etc.
</p>

<p>
<a href="http://gatling.io/">Gatling</a> is popular tool for load testing of web applications that provides an embedded domain-specific language (DSL) on top of Scala (so basic knowledge of Scala is required).  One of the main advantages of Gatling is that it allows to build complex scenarios, potentially consisting of multiple steps, and generate realistic workloads because test's author has complete control on how data is generated.  You can also use <b>assertions</b> to check that response time, and other parameters meets your SLAs, and <b>checks</b> that are used to perform additional check of returned data. 
</p>

<p>
For a long time, there was <a href="https://github.com/gatling-cql/GatlingCql">GatlingCql plugin</a> that allowed to execute CQL statements from Gatling simulations, but it wasn't very actively developed in the last years, and it doesn't support full set of DSE functionality, such as, Graph.
</p>

<p>
In April 2018 DataStax testing team open sourced its own implementation of <a href="https://github.com/datastax/gatling-dse-plugin">Gatling plugin for DSE</a> that could be used to create real-looking simulations. Besides plugin, testing team also open sourced two other projects:
</p>
<ul class="org-ul">
<li><a href="https://github.com/datastax/gatling-dse-stress">gatling-dse-stress</a> - it simplifies creation of simulations by providing implementation of feeders, configuration of connection to DSE, and additional helper functions;</li>
<li><a href="https://github.com/datastax/gatling-dse-simcatalog">gatling-dse-simcatalog</a> - catalog of already implemented simulations that could be reused to build the new one.</li>
</ul>

<p>
Both of these projects will be described in a separate article.
</p>
</div>
</div>

<div id="outline-container-org1627b12" class="outline-2">
<h2 id="org1627b12"><span class="section-number-2">2</span> Basics of simulation's creation</h2>
<div class="outline-text-2" id="text-2">
<p>
Before we start, we need to understand some of the Gatling's concepts:
</p>
<ul class="org-ul">
<li><b><a href="https://gatling.io/docs/current/general/scenario/">Scenario</a></b> defines a set of actions that should be executed, emulating real user's behaviour, etc.;</li>
<li><b><a href="https://gatling.io/docs/current/session/session_api/">Session</a></b> keeps the user's data, generated by feeder, together with additional data that could be added via API, or other methods;</li>
<li><b><a href="https://gatling.io/docs/current/session/feeder/">Feeder</a></b> is data generator that is used to populate user session. There could be multiple feeders defined for single session;</li>
<li><b><a href="https://gatling.io/docs/current/general/simulation_structure">Simulation</a></b> combines together scenario(s), and defines what kind workload will be used (constant, increasing, etc.), configuration, etc.;</li>
<li><b><a href="https://gatling.io/docs/current/general/assertions/">Assertions</a></b> are used to verify that global statistics, like response time, or number of failed requests, matches expectations for a whole simulation.</li>
</ul>

<p>
The code of simulation is usually organized in following manner, similar to other <a href="https://gatling.io/docs/current/quickstart/">Gatling simulations</a>:
</p>
<ul class="org-ul">
<li>Declare simulation;</li>
<li>Prepare environment:
<ul class="org-ul">
<li>Setup DSE connection, create session, and instance of Gatling protocol;</li>
<li>(optional) Create schema;</li>
<li>Prepare necessary CQL statements;</li>
</ul></li>
<li>Define feeder(s) that will generate test data;</li>
<li>Define scenario(s);</li>
<li>Setup/execute simulation (if necessary, add assertions to check against desired SLAs).</li>
</ul>
</div>

<div id="outline-container-org8720e51" class="outline-3">
<h3 id="org8720e51"><span class="section-number-3">2.1</span> Declaring simulation</h3>
<div class="outline-text-3" id="text-2-1">
<p>
First, you need to have a number of imports at the beginning of file - we need to import classes for Gatling, DSE Java driver, and gatling-dse-plugin (Note, that we import all classes from <code>com.datastax.driver.core</code> except the <code>Session</code> class, because it will clash with Gatling's <code>Session</code> class):
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">import</span> com.datastax.driver.core.<span style="color: #008b8b;">ConsistencyLevel</span>.<span style="color: #a020f0;">_</span>
<span style="color: #a020f0;">import</span> com.datastax.driver.core.{<span style="color: #008b8b;">Session</span> <span style="color: #a020f0;">=&gt;</span> <span style="color: #a020f0;">_</span>, <span style="color: #a020f0;">_</span>}
<span style="color: #a020f0;">import</span> com.datastax.driver.dse.{<span style="color: #008b8b;">DseCluster</span>, <span style="color: #008b8b;">DseSession</span>}
<span style="color: #a020f0;">import</span> com.datastax.gatling.plugin.<span style="color: #008b8b;">DsePredef</span>.<span style="color: #a020f0;">_</span>
<span style="color: #a020f0;">import</span> com.datastax.gatling.plugin.<span style="color: #008b8b;">DseProtocolBuilder</span>
<span style="color: #a020f0;">import</span> io.gatling.core.<span style="color: #008b8b;">Predef</span>.<span style="color: #a020f0;">_</span>
<span style="color: #a020f0;">import</span> io.gatling.core.scenario.<span style="color: #008b8b;">Simulation</span>
<span style="color: #a020f0;">import</span> io.gatling.core.structure.<span style="color: #008b8b;">ScenarioBuilder</span>
</pre>
</div>

<p>
Then you need to create a class that extends the <code>io.gatling.core.scenario.Simulation</code> class, like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">class</span> <span style="color: #0000ee;">MySimulation</span> <span style="color: #a020f0;">extends</span> <span style="color: #0000ee;">Simulation</span>
{
<span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">implementation ...</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdae5a9b" class="outline-3">
<h3 id="orgdae5a9b"><span class="section-number-3">2.2</span> Prepare environment</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Preparing of the execution environment usually consists of 2 steps - establishing session to DSE cluster, and preparing queries that will be executed during test.  In some cases, like data load tests, the preparation stage could also take care for creation of necessary tables (when session is established, you can execute arbitrary CQL statements via <code>session.execute</code>).
</p>
</div>

<div id="outline-container-org5378eb4" class="outline-4">
<h4 id="org5378eb4"><span class="section-number-4">2.2.1</span> Setup connection/session/protocol</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
To initialize connection to DSE cluster, and instantiate the Gatling's protocol, we need, as usual, create an instance of <code>DseCluster</code> class, and then obtain from it an instance of <code>DseSession</code>.  The last step is creation of a <code>DseProtocolBuilder</code> object that will be used to setup the simulation (at last step).  The code could be from simple code like this (with hardcoded IP address):
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">clusterBuilder</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">DseCluster</span>.<span style="color: #008b8b;">Builder</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cluster</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseCluster</span> <span style="color: #a020f0;">=</span> clusterBuilder.addContactPoint(<span style="color: #008b00;">"127.0.0.1"</span>).build()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">dseSession</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseSession</span> <span style="color: #a020f0;">=</span> cluster.connect()

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cqlConfig</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseProtocolBuilder</span> <span style="color: #a020f0;">=</span> cql.session(dseSession)
</pre>
</div>

<p>
to more complex, like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">clusterBuilder</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">DseCluster</span>.<span style="color: #008b8b;">Builder</span>

clusterBuilder.
  withSocketOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">SocketOptions</span>().
    setKeepAlive(<span style="color: #008b8b;">true</span>).
    setTcpNoDelay(<span style="color: #008b8b;">true</span>)).
  withQueryOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">QueryOptions</span>().
    setDefaultIdempotence(<span style="color: #008b8b;">true</span>).
    setPrepareOnAllHosts(<span style="color: #008b8b;">true</span>).
    setReprepareOnUp(<span style="color: #008b8b;">true</span>).
    setConsistencyLevel(<span style="color: #008b8b;">LOCAL_ONE</span>)).
  withPoolingOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">PoolingOptions</span>().
    setCoreConnectionsPerHost(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">1</span>).
    setMaxConnectionsPerHost(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">2</span>).
    setNewConnectionThreshold(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">30000</span>).
    setMaxRequestsPerConnection(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">30000</span>))

<span style="color: #008b8b;">System</span>.getProperty(<span style="color: #008b00;">"contactPoints"</span>, <span style="color: #008b00;">"127.0.0.1"</span>).split(<span style="color: #008b00;">","</span>)
  .foreach(clusterBuilder.addContactPoint)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cluster</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseCluster</span> <span style="color: #a020f0;">=</span> clusterBuilder.build()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">dseSession</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseSession</span> <span style="color: #a020f0;">=</span> cluster.connect()

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cqlConfig</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseProtocolBuilder</span> <span style="color: #a020f0;">=</span> cql.session(dseSession)
</pre>
</div>

<p>
As you can see from this code, we can configure all necessary parameters, such as connection pooling, default query options, etc.  To avoid hard-coding the list of the DSE cluster's contact points, the default value (<code>127.0.0.1</code>) could be overwritten by specifying the Java's system property <code>contactPoints</code> (as comma-separated list of hosts).
</p>

<p>
After the <code>DseSession</code> object is created, it's then used to obtain an instance of the <code>DseProtocolBuilder</code> that will be used to configure simulation at the last step of the whole process.
</p>
</div>
</div>

<div id="outline-container-org333a6b1" class="outline-4">
<h4 id="org333a6b1"><span class="section-number-4">2.2.2</span> Prepare CQL statements</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
To reach optimal performance it's always recommended to prepare queries if they are used multiple times.  In Gatling simulations  it's done the same way as in normal Java/Scala code - by calling the <code>prepare</code> function on the <code>session</code> object, like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">insertPrepared</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(<span style="color: #008b00;">"INSERT INTO ks.table(col1, col2, col3) VALUES(?,?,?)"</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org605e9d2" class="outline-3">
<h3 id="org605e9d2"><span class="section-number-3">2.3</span> Define feeder(s)</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Feeder(s) definition is really important for success of your load test - it should generate data with distribution maximally close to the expected (or already existing) data distribution inside the tables. 
</p>

<p>
Gatling's <code>Feeder</code> type is just an alias for <code>Iterator[Map[String, T]]</code> type - this means that we can use any implementation that produce instances of the <code>Map[String, T]</code> class. The simplest approach to it is to use <code>Iterator.continually</code> with function that will generate instances of the <code>Map</code> class, something like this (type here is <code>Map[String, Any]</code>):
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">random</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">java</span>.util.<span style="color: #008b8b;">Random</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">feeder</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">Iterator</span>.continually({
  <span style="color: #008b8b;">Map</span>(
    <span style="color: #008b00;">"col1"</span> -&gt; <span style="color: #008b8b;">UUID</span>.randomUUID(),
    <span style="color: #008b00;">"col2"</span> -&gt; random.nextInt()
  )})
</pre>
</div>

<p>
Gatling provides <a href="https://gatling.io/docs/current/session/feeder/">several implementations of feeders</a> - they can feed data from CSV, JSON, Redis, JDBC, and other sources, and allows to apply necessary transformations for input data.  For example, CSV feeder only returns <code>String</code> objects, and you may need to convert some fields to numbers, or other types.
</p>

<p>
Sometimes, when you work with DSE, you'll need to define your own feeders with more complex implementation.  This is usually required when your tables use the user-defined types (UDTs).  In this case, you can't simply create a value, but you need to fetch necessary metadata from database to create an instance of the UDT.  This task is not really complex, as you may see in <a href="https://gist.github.com/bradfordcp/9a10fdb0588e00c3fc69716eb1edac68">following example</a>, but requires some coding to create correct object instances.
</p>

<p>
When you're plug-in the feeder into scenario, the data generated by feeder is merged with data already existing in the user's session object.  This allows us to use multiple feeders in the same scenario - this is especially useful when you have an existing library of feeder's implementations, and can reuse them in new tests.
</p>

<p>
<b>Note</b>: Quite often, the <a href="https://github.com/DiUS/java-faker">Java Faker</a> library is used for generation of people/company names, domains, addresses, numbers, dates, etc.  Using this library it's possible to generate much more realistically looking data than by using standard random generators.  But we need to take into account that it could slow down the data generation (for example, in examples below, generation of user name, address &amp; book code adds almost 600 microseconds per call to data generation).
</p>
</div>
</div>

<div id="outline-container-orgc2158b7" class="outline-3">
<h3 id="orgc2158b7"><span class="section-number-3">2.4</span> Define scenario</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The <a href="https://gatling.io/docs/current/general/scenario">scenario</a> is defined by <code>scenario</code> function that accepts the name of scenario as an argument, and then this instance is populated with feeders, structure elements (<code>exec</code>, <code>pause</code>, &#x2026;), and other components, such as groups, loops, conditionals, etc.  The <code>exec</code> element accepts the action's definition, or function that should transform the user session object.  There are multiple implementations of actions, like, <code>http</code> that comes together with Gatling, and used to execute HTTP requests.  The gatling-dse-plugin adds the <code>cql</code> action that is used to execute queries against DSE. This action alone doesn't do anything, so you need to specify additional parameters by calling different functions on the action object.  You can execute raw CQL with <code>executeCql</code>, execute prepared query with <code>executePrepared</code>, plus some other.  You can also set query-specific options, by adding the call to functions like, <code>withConsistencyLevel</code>, <code>withDefaultTimestamp</code>, <code>withFetchSize</code>, etc.
</p>

<p>
In the simplest case, scenario could look as following: we create it, then add feeder to it, and executing one CQL statement per user session (we're using Gatling's string interpolation to feed data into string):
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadDataSimple</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"loadDataSimple"</span>)
  .feed(feeder)
  .exec(cql(<span style="color: #008b00;">"InsertData"</span>)
      .executeCql(s<span style="color: #008b00;">"insert into table x(col1) values('</span><span style="color: #a0522d;">${col}</span><span style="color: #008b00;">'"</span>))
</pre>
</div>

<p>
In more complex cases scenario could look as following:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadData</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"loadData"</span>)
  .feed(feeder)
  .group(<span style="color: #008b00;">"Insert"</span>)(
    exec(cql(<span style="color: #008b00;">"InsertOAuth"</span>)
      .executePrepared(insertPrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>, <span style="color: #008b00;">"ttl"</span>)))
      .exec(cql(<span style="color: #008b00;">"insertUser"</span>)
        .executePrepared(insertPrepared2)
        .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>, <span style="color: #008b00;">"ttl"</span>)))
  )
  .pause(<span style="color: #008b8b;">1</span>) <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">wait 1 second before rotating token...</span>
  .group(<span style="color: #008b00;">"Update"</span>)(
    exec(cql(<span style="color: #008b00;">"updateOAuth"</span>)
      .executePrepared(updatePrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"token_id"</span>)))
      .exec(cql(<span style="color: #008b00;">"updateUser"</span>)
        .executePrepared(updatePrepared2)
        .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"token_id"</span>)))
  )
</pre>
</div>

<p>
In this case scenario consists of 2 groups with pause between them, and every group includes execution of 2 prepared queries - for insertion and update of data correspondingly.  The <code>withParams</code> function is used to specify parameters that will be bound into the query.  You can either specify a list of key names from the session object, or you can specify a variable number of session expressions that will be bound into query.
</p>

<p>
If you have many tests and complex scenarios you may consider to refactor scenarios into individual steps by defining the number of the <code>ChainBuilder</code> instances that are later wired into scenario, like this:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">part1</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ChainBuilder</span> <span style="color: #a020f0;">=</span>
  exec(cql(<span style="color: #008b00;">"updateOAuth"</span>)
    .executePrepared(updatePrepared)
    .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"token_id"</span>)))
    .exec(cql(<span style="color: #008b00;">"updateUser"</span>)
      .executePrepared(updatePrepared2)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"token_id"</span>)))

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadData</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"loadData"</span>)
  .feed(feeder)
  .exec(part1)
</pre>
</div>

<p>
You can find more examples on how you can structure your tests in the <a href="https://gatling.io/docs/current/advanced_tutorial/">Gatling's advanced tutorial</a>.
</p>

<p>
Action may contain not only execution of the queries, but can also contain additional checks that could be added to query via  functions <code>withCheck</code> (or simply <code>check</code> for single check), or <code>withChecks</code> (for multiple checks).  gatling-dse-plugin provides a number of checks, for example, <code>rowCount</code> returns a number of fetched rows, <code>schemaInAgreement</code> returns current state of schema agreement in cluster, <code>resultSet</code> is returning the <code>ResultSet</code> instance for given query (there are also functions <code>allRows</code> &amp; <code>oneRow</code>), and many other. For example, result set could be stored in the session object with <code>saveAs</code> function implemented in Gatling, and then analyzed as a separate step (for example, to populate user session with data from database).  Here is the small example:
</p>

<div class="org-src-container">
<pre class="src src-scala">exec(cql(<span style="color: #008b00;">"SelectData"</span>)
  .executePrepared(selectPrepared)
  .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"id"</span>))
  .withChecks(resultSet.saveAs(<span style="color: #008b00;">"fetchedData"</span>),
       rowCount.greaterThan(<span style="color: #008b8b;">0</span>)
    )
  )
.exec({session<span style="color: #a020f0;">:</span> <span style="color: #0000ee;">Session</span> <span style="color: #a020f0;">=&gt;</span>
  <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">fetchedData</span> <span style="color: #a020f0;">=</span> session(<span style="color: #008b00;">"fetchedData"</span>).as[<span style="color: #008b8b;">ResultSet</span>].one
  <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">do something with fetched data...</span>
  session
})

</pre>
</div>

<p>
Full list of checks implemented by plugin you can find <a href="https://github.com/datastax/gatling-dse-plugin/wiki/Checks">on GitHub</a>.
</p>
</div>
</div>

<div id="outline-container-org9ed8171" class="outline-3">
<h3 id="org9ed8171"><span class="section-number-3">2.5</span> Setup simulation</h3>
<div class="outline-text-3" id="text-2-5">
<p>
After you defined the scenario, you can setup it for execution.  This is done by defining <code>setUp</code> where you need to inject necessary load into scenario, and then specify which protocol(s) to use.  For example, following example use our <code>loadData</code> scenario with 3 injection profiles:
</p>
<ul class="org-ul">
<li>perform the load test with 25% of concurrent users during 1/4 of the total test duration time (configured elsewhere) - this step is usually used to warm up the database;</li>
<li>do nothing for 1 minute, so DB can catch up with GC, compactions;</li>
<li>perform full-scale test with configured number of concurrent users during the configured test duration time.</li>
</ul>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    constantUsersPerSec(concurrentSessionCount / <span style="color: #008b8b;">4</span>) during (testDuration / <span style="color: #008b8b;">4</span>),
    nothingFor(<span style="color: #008b8b;">FiniteDuration</span>(<span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">TimeUnit</span>.<span style="color: #008b8b;">MINUTES</span>)),
    constantUsersPerSec(concurrentSessionCount) during testDuration
  )
).protocols(cqlConfig)
</pre>
</div>

<p>
Gatling provides several implementation of injection profiles:
</p>
<ul class="org-ul">
<li>with constant number of concurrent users per second (with <code>constantUsersPerSec</code>);</li>
<li>with increasing number of users per second from one number to another number (with <code>rampUsersPerSec</code>);</li>
<li>injection of given number of users at once (with <code>atOnceUsers</code>);</li>
<li>etc.</li>
</ul>

<p>
Please check <a href="https://gatling.io/docs/current/general/simulation_setup/#injection">Gatling's documentation for more information</a>.  You need to select injection profile that matches your needs.  For example, you can use <code>constantUsersPerSec</code> profile for load tests where you want to make sure that there are no performance problems with code, or use <code>rampUsersPerSec</code> profile to detect what is the maximal number of users your system can handle.
</p>

<p>
The <code>protocols</code> function specifies what protocol implementation should be used for given test scenario.  We've created an instance of protocol for CQL, but you can also use multiple protocols at the same time, for example, if you want to test mixed application that makes both CQL &amp; HTTP queries (for example, if you're using DSE Search functionality that only available via HTTP API).
</p>
</div>
</div>
</div>

<div id="outline-container-org2cd9d78" class="outline-2">
<h2 id="org2cd9d78"><span class="section-number-2">3</span> Building simulation</h2>
<div class="outline-text-2" id="text-3">
<p>
There are several ways to build &amp; execute your simulation:
</p>
<ul class="org-ul">
<li>Build the complete package together with Gatling, and execute it - this method is described below;</li>
<li><p>
Build the package without Gatling (but with all other dependencies - this should be faster to build), copy resulting package into Gatling's <code>lib</code> directory &amp; execute it with command like this:
</p>

<div class="org-src-container">
<pre class="src src-shell">java -cp conf:<span style="color: #ff00ff;">`echo lib/*.jar | sed 's/ /:/g'`</span> io.gatling.app.Gatling <span style="color: #008b00;">\</span>
   -s com.datastax.demos.gatling.GatlingLoadSim -rf results
</pre>
</div>

<p>
where the <code>-s</code> flag specifies the name of Simulation class, and <code>-rf</code> specifies the folder to put results.
</p>

<p>
For this case, the <code>pom.xml</code> file looks almost the same way as when we're building the package with Gatling, but need to declare the <code>gatling-charts-highcharts</code> dependency as <code>provided</code>;
</p></li>

<li>Copy the source code for your simulation into <code>user-files/simulations</code> directory of Gatling's distribution, and execute it via <code>bin/gatling.sh</code> script that will compile source code, and execute resulting class.  (This approach unfortunately won't work out of the box because of the <a href="https://docs.datastax.com/en/developer/java-driver-dse/1.6/faq/#why-am-i-encountering-an-illegal-cyclic-reference-error-when-using-the-driver-with-scala">existing problem with Scala compiler and <code>DseCluster</code> class</a>.  Our testing team sent a pull request to Gatling that should allow to handle this problem, but it could be available only in the next version of Gatling). You also need to copy all necessary dependencies, such as, <code>gatling-dse-plugin</code>, etc. into <code>lib</code> directory of unpacked Gatling distribution;</li>
<li>Use <a href="https://gatling.io/docs/current/extensions/maven_plugin/">gatling-maven-plugin</a> or <a href="https://gatling.io/docs/current/extensions/sbt_plugin/">gatling-sbt-plugin</a> to execute simulations (there is also unofficial <a href="https://gatling.io/docs/current/extensions/">Gradle plugins</a>).  By using these plugins you can easier integrate Gatling-based load tests into your projects.</li>
</ul>
</div>

<div id="outline-container-orgdef739e" class="outline-3">
<h3 id="orgdef739e"><span class="section-number-3">3.1</span> Building complete package with Maven</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The official builds of the <code>gatling-dse-plugin</code> are available at <a href="https://repo.datastax.com/public-repos/com/datastax/gatling/plugin/">DataStax's Maven repository</a>, so to use it in your project, you need to add corresponding declaration to your <code>pom.xml</code> file:
</p>

<div class="org-src-container">
<pre class="src src-nxml">&lt;<span style="color: #b22222;">repositories</span>&gt;
  &lt;<span style="color: #b22222;">repository</span>&gt;
    &lt;<span style="color: #b22222;">id</span>&gt;DataStax-Repo&lt;/<span style="color: #b22222;">id</span>&gt;
    &lt;<span style="color: #b22222;">url</span>&gt;https://repo.datastax.com/public-repos/&lt;/<span style="color: #b22222;">url</span>&gt;
  &lt;/<span style="color: #b22222;">repository</span>&gt;
&lt;/<span style="color: #b22222;">repositories</span>&gt;
</pre>
</div>

<p>
Then you need to include necessary dependencies for gatling-dse-plugin &amp; Gatling itself (you can find information about the latest version of the plugin on GitHub):
</p>

<div class="org-src-container">
<pre class="src src-nxml">&lt;<span style="color: #b22222;">dependency</span>&gt;
  &lt;<span style="color: #b22222;">groupId</span>&gt;com.datastax.gatling.plugin&lt;/<span style="color: #b22222;">groupId</span>&gt;
  &lt;<span style="color: #b22222;">artifactId</span>&gt;gatling-dse-plugin_2.12&lt;/<span style="color: #b22222;">artifactId</span>&gt;
  &lt;<span style="color: #b22222;">version</span>&gt;1.2.2&lt;/<span style="color: #b22222;">version</span>&gt;
&lt;/<span style="color: #b22222;">dependency</span>&gt;
&lt;<span style="color: #b22222;">dependency</span>&gt;
  &lt;<span style="color: #b22222;">groupId</span>&gt;io.gatling.highcharts&lt;/<span style="color: #b22222;">groupId</span>&gt;
  &lt;<span style="color: #b22222;">artifactId</span>&gt;gatling-charts-highcharts&lt;/<span style="color: #b22222;">artifactId</span>&gt;
  &lt;<span style="color: #b22222;">version</span>&gt;2.3.1&lt;/<span style="color: #b22222;">version</span>&gt;
<span style="color: #7f7f7f;">&lt;!--  </span><span style="color: #7f7f7f;">uncomment this if you want to build package just for your application, without Gatling inside  </span><span style="color: #7f7f7f;">--&gt;</span>
<span style="color: #7f7f7f;">&lt;!--      </span><span style="color: #7f7f7f;">&lt;scope&gt;provided&lt;/scope&gt; </span><span style="color: #7f7f7f;">--&gt;</span> 
&lt;/<span style="color: #b22222;">dependency</span>&gt;
</pre>
</div>

<p>
And add <a href="https://github.com/alexott/gatling-dse-examples/blob/master/plugin-sim/pom.xml#L44">necessary pieces</a> to compile the Scala code &amp; pack everything into one jar file when you execute the <code>mvn package</code> command.
</p>
</div>
</div>
</div>

<div id="outline-container-org00e6141" class="outline-2">
<h2 id="org00e6141"><span class="section-number-2">4</span> Executing simulation</h2>
<div class="outline-text-2" id="text-4">
<p>
Execution of packaged simulation is just simple - specify the path to the packaged jar file, and specify the name of the class with simulation, plus necessary parameters:
</p>

<div class="org-src-container">
<pre class="src src-shell">java -cp &lt;packaged-jar-file&gt; [system properties] io.gatling.app.Gatling -s &lt;simulation-class&gt; [-rf &lt;results-directory&gt;]
</pre>
</div>

<p>
where:
</p>
<ul class="org-ul">
<li><code>io.gatling.app.Gatling</code> - name of the Gatling's main class;</li>
<li><code>-s</code> flag specifies the name of Simulation class;</li>
<li><code>-rf</code> flat specifies the folder to put results.</li>
<li><code>system properties</code> list of additional parameters that your simulation will consume (if it's implemented).</li>
</ul>

<p>
For example, here is the command line that was used to run the example simulation described below (please note that I've included <code>gatling-charts-highcharts-bundle-2.3.0/conf</code> into class path to re-use the Gatling's configuration files):
</p>

<div class="org-src-container">
<pre class="src src-shell">java -cp &lt;path-to&gt;/gatling-charts-highcharts-bundle-2.3.0/conf:target/gatling-plugin-sim-0.0.1-jar-with-dependencies.jar <span style="color: #008b00;">\</span>
    -DcontactPoints=192.168.0.10 -DtestDuration=2 -DconcurrentSessionCount=10000 <span style="color: #008b00;">\</span>
    io.gatling.app.Gatling -s com.datastax.demos.gatling.GatlingLoadSim -rf results
</pre>
</div>

<p>
During execution of the simulation, current statistics is printed to the screen.  It shows the number of executed requests globally &amp; per group, current and execution time, number of active/waiting/finished users, and other information, like overall progress.  The status <code>OK</code> shows the number of successfully executed requests, and <code>KO</code> shows the number of failed requests (0 in our example):
</p>

<pre class="example">
================================================================================
2018-07-24 16:11:47                                          55s elapsed
---- Requests ------------------------------------------------------------------
&gt; Global                                                   (OK=807192 KO=0     )
&gt; Insert / InsertOAuth                                     (OK=204531 KO=0     )
&gt; Insert / insertUser                                      (OK=202970 KO=0     )
&gt; Update / updateOAuth                                     (OK=200815 KO=0     )
&gt; Update / updateUser                                      (OK=198876 KO=0     )

---- loadData ------------------------------------------------------------------
[####################--                                                    ] 27%
          waiting: 509979 / active: 11145  / done:198876
================================================================================
</pre>

<p>
<b>Note</b>: It's important to track the number of active users here - if it's grows very fast, then your system isn't able to handle so much load, and number of simultaneous users should be decreased.
</p>

<p>
When simulation finishes, something like this will be printed to the screen:
</p>

<pre class="example">
Simulation com.datastax.demos.gatling.GatlingLoadSim completed in 157 seconds
Parsing log file(s)...
Parsing log file(s) done
Generating reports...

================================================================================
---- Global Information --------------------------------------------------------
&gt; request count                                    2880000 (OK=2880000 KO=0     )
&gt; min response time                                      0 (OK=0      KO=-     )
&gt; max response time                                    696 (OK=696    KO=-     )
&gt; mean response time                                   165 (OK=165    KO=-     )
&gt; std deviation                                        143 (OK=143    KO=-     )
&gt; response time 50th percentile                        152 (OK=152    KO=-     )
&gt; response time 75th percentile                        262 (OK=262    KO=-     )
&gt; response time 95th percentile                        422 (OK=422    KO=-     )
&gt; response time 99th percentile                        552 (OK=552    KO=-     )
&gt; mean requests/sec                                18227.848 (OK=18227.848 KO=-     )
---- Response Time Distribution ------------------------------------------------
&gt; t &lt; 800 ms                                       2880000 (100%)
&gt; 800 ms &lt; t &lt; 1200 ms                                   0 (  0%)
&gt; t &gt; 1200 ms                                            0 (  0%)
&gt; failed                                                 0 (  0%)
================================================================================

Reports generated in 62s.
Please open the following file: &lt;some-path...&gt;/results/gatlingloadsim-1532441452451/index.html
</pre>

<p>
This includes basic statistics about execution of simulation: number of requests, minimal/maximal/percentiles of response time, etc.  This information is often enough to get a quick understanding of your system performance, and you can also find more information in the generated HTML report described below.
</p>

<p>
<b>Note</b>: as you may see, the test was completed in 157 seconds, although the test duration was specified as 120 seconds (2 minutes).  This is a signal that system don't have enough throughput, and need an additional time to finish processing of all scheduled user sessions.
</p>

<p>
To get correct results from load testing we need to perform test quite long enough, so the things like garbage collection, compaction, etc. will happen during that time, and we'll see how this can influence performance of our system.
</p>
</div>
</div>

<div id="outline-container-org6ef6583" class="outline-2">
<h2 id="org6ef6583"><span class="section-number-2">5</span> Checking results</h2>
<div class="outline-text-2" id="text-5">
<p>
When simulation finishes Gatling may generate an HTML report that will be put as separated directory under directory specified in the <code>-rf</code> command-line option.  The directory name has format <code>gatlingloadsim-&lt;timestamp&gt;</code>, and full path to the main file is printed as part of final message (see above).  This report has 2 parts:
</p>
<ul class="org-ul">
<li><b>Global</b>, that provides information about whole simulation (with some statistics about individual groups &amp; actions);</li>
<li><b>Details</b>, that provides information about individual actions.</li>
</ul>

<p>
Here is what you'll see the HTML report (the page is split into separate images to make it more readable).  All graphs also have tooltips that shows more details about individual graph points.
</p>

<p>
First part of the Global page includes information about overall requests number, and numbers for individual groups/actions, together with statistics for every part:
</p>


<div class="figure">
<p><img src="./gatling-plugin-global-results.png" alt="gatling-plugin-global-results.png" />
</p>
</div>

<p>
Most important numbers here are response times, especially the 99th percentile and max response time, together with number of requests per second, and number of requests executed with error.
</p>

<p>
Next section shows the number of active users in the executed simulation - in this example I've used <code>rampUsersPerSec</code> injection that increase the number of simultaneous users over the time until it reach given value (here from 2,000 to 10,000 over the 2 minutes).  As you can see on the graph, at some point of time this number is started to increase, so it's clear sign that system can't handle more users without increasing response latency.  (You can see the graphs for other <code>constantUsersPerSec</code> injection at the end of this section):
</p>


<div class="figure">
<p><img src="./gatling-plugin-active-users.png" alt="gatling-plugin-active-users.png" />
</p>
</div>

<p>
Next 2 sections show the data about response times - overall distribution of response time values, and how the response time percentiles are changed during execution of the simulation.  If you're using the complex scenario, the response time will be calculated for whole scenario - to check response time of individual queries you need to look into "Details" tab.  Please note, that the second graph, for convenience, shows the number of active users:
</p>


<div class="figure">
<p><img src="./gatling-plugin-response-time.png" alt="gatling-plugin-response-time.png" />
</p>
</div>

<p>
And the last 2 sections shows the data about number of requests/responses over the time: 
</p>


<div class="figure">
<p><img src="./gatling-plugin-throughput-stats.png" alt="gatling-plugin-throughput-stats.png" />
</p>
</div>

<p>
The Details part allows use to look to the results for individual tests, like, inserts or updates of individual tables.  The structure of information is almost the same as for Global part.
</p>


<div class="figure">
<p><img src="./gatling-plugin-individual-details.png" alt="gatling-plugin-individual-details.png" />
</p>
</div>


<p>
We can compare graphs from above, that were generated for simulation with <code>rampUsersPerSec</code> injection with graphs from simulation with <code>constantUsersPerSec</code> injection.   The first graph shows data for 10,000 simultaneous users - you can notice that number of active users is increasing over the time until it reach specified period of time, and then is decreasing when simulation stops creation of new users. You may also notice that latency is quite high, even for 50th percentile.  This is a clear sign that the system is overloaded, although it's able to handle about 20,000 requests per second.
</p>



<div class="figure">
<p><img src="./gatling-const-load-overloaded.png" alt="gatling-const-load-overloaded.png" />
</p>
</div>

<p>
We can try the same simulation with 5,000 simultaneous users, and we can notice the difference - all latencies went down, and number of active users is almost on the same level, except the initial period of time.  But in this case we're able to handle only slightly more than 10,000 requests per second.
</p>


<div class="figure">
<p><img src="./gatling-const-load-good.png" alt="gatling-const-load-good.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-org0f4d312" class="outline-2">
<h2 id="org0f4d312"><span class="section-number-2">6</span> Simulation examples</h2>
<div class="outline-text-2" id="text-6">
<p>
This section contains examples of the Gatling-based simulations for DSE load testing.  We're implementing something like OAuth token management (<b>this is just an example, not real application!</b>).
</p>

<p>
Full source code for these simulations is located in the directory <code>plugin-sim</code> of the
<a href="https://github.com/alexott/gatling-dse-examples">https://github.com/alexott/gatling-dse-examples</a> repository.
</p>
</div>

<div id="outline-container-org2db9dba" class="outline-3">
<h3 id="org2db9dba"><span class="section-number-3">6.1</span> Data structure</h3>
<div class="outline-text-3" id="text-6-1">
<p>
We'll have data in the 2 tables with similar structure, but with different primary key:  one table will keep individual OAuth tokens, and second table will store OAuth tokens issued for specific user, so we can revoke all of them if necessary.  The tables are in the <code>gatling</code> keyspace with table structure is defined as:
</p>

<pre class="example">
CREATE TABLE oauth_tokens (
 id uuid,
 nonce int,
 user text,
 created timestamp,
 expires timestamp,
 attributes frozen&lt;map&lt;text, text&gt;&gt;,
 
 PRIMARY KEY(id)
);

CREATE TABLE user_tokens (
 user text,
 id uuid,
 nonce int,
 created timestamp,
 expires timestamp,
 attributes frozen&lt;map&lt;text, text&gt;&gt;,

 PRIMARY KEY(user, id)
);

</pre>

<p>
The full schema specification is in the <a href="https://github.com/alexott/gatling-dse-examples/blob/master/plugin-sim/cql/create-schema.cql">cql/create-schema.cql</a> file, and could be created by using following command (modify keyspace names and replication strategy, if necessary):
</p>

<div class="org-src-container">
<pre class="src src-shell">cqlsh &lt;DSE-IP&gt; -f cql/create-schema.cql
</pre>
</div>
</div>
</div>

<div id="outline-container-org057c407" class="outline-3">
<h3 id="org057c407"><span class="section-number-3">6.2</span> Simulation for loading data into database</h3>
<div class="outline-text-3" id="text-6-2">
<p>
During execution of this simulation, we'll insert data into tables, and then updates the parts of the data several seconds later.  Source code is in the file <a href="https://github.com/alexott/gatling-dse-examples/blob/master/plugin-sim/src/main/scala/com/datastax/demos/gatling/GatlingDataLoadSim.scala">GatlingLoadSim.scala</a>.
</p>
</div>

<div id="outline-container-org1e3288d" class="outline-4">
<h4 id="org1e3288d"><span class="section-number-4">6.2.1</span> Prepare environment</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
The necessary imports, etc. are matching to the examples shown at the begin of the article, so we just concentrate on pieces of code:
</p>

<p>
First we need to setup connection, establish it, and create configuration object that will be used to setup simulation:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">clusterBuilder</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">DseCluster</span>.<span style="color: #008b8b;">Builder</span>

clusterBuilder.
  withSocketOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">SocketOptions</span>().
    setKeepAlive(<span style="color: #008b8b;">true</span>).
    setTcpNoDelay(<span style="color: #008b8b;">true</span>)).
  withQueryOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">QueryOptions</span>().
    setDefaultIdempotence(<span style="color: #008b8b;">true</span>).
    setPrepareOnAllHosts(<span style="color: #008b8b;">true</span>).
    setReprepareOnUp(<span style="color: #008b8b;">true</span>).
    setConsistencyLevel(<span style="color: #008b8b;">LOCAL_ONE</span>)).
  withPoolingOptions(<span style="color: #a020f0;">new</span> <span style="color: #0000ee;">PoolingOptions</span>().
    setCoreConnectionsPerHost(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">1</span>).
    setMaxConnectionsPerHost(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">2</span>).
    setNewConnectionThreshold(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">30000</span>).
    setMaxRequestsPerConnection(<span style="color: #008b8b;">HostDistance</span>.<span style="color: #008b8b;">LOCAL</span>, <span style="color: #008b8b;">30000</span>))

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">srvList</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">System</span>.getProperty(<span style="color: #008b00;">"contactPoints"</span>, <span style="color: #008b00;">"127.0.0.1"</span>).split(<span style="color: #008b00;">","</span>).toList
srvList.foreach(clusterBuilder.addContactPoint)

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cluster</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseCluster</span> <span style="color: #a020f0;">=</span> clusterBuilder.build()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">dseSession</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseSession</span> <span style="color: #a020f0;">=</span> cluster.connect()

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">cqlConfig</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">DseProtocolBuilder</span> <span style="color: #a020f0;">=</span> cql.session(dseSession)
</pre>
</div>

<p>
After that we'll need to create necessary prepared statements:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">insertPrepared</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(
  <span style="color: #008b00;">"insert into gatling.oauth_tokens(id, nonce, user, created, expires, attributes) values(?,?,?,?,?,?) using TTL ?"</span>);
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">insertPrepared2</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(
  <span style="color: #008b00;">"insert into gatling.user_tokens(id, nonce, user, created, expires, attributes) values(?,?,?,?,?,?) using TTL ?"</span>)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">updatePrepared</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(
  <span style="color: #008b00;">"update gatling.oauth_tokens using TTL ? set nonce = ? where id = ?"</span>)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">updatePrepared2</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">PreparedStatement</span> <span style="color: #a020f0;">=</span> dseSession.prepare(
  <span style="color: #008b00;">"update gatling.user_tokens using TTL ? set nonce = ? where user = ? and id = ?"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org6742b4e" class="outline-4">
<h4 id="org6742b4e"><span class="section-number-4">6.2.2</span> Define feeders</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
Definition of feeder is very important for our use case.  We need to create real-world looking authentication token IDs &amp; user names.  For token IDs we're just generating random UUIDs, and for user names are generated by using methods from Java Faker library. Other fields are generated by appropriate methods just to occupy enough space in table. Every record also gets the TTL of the 30 minutes:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">def</span> <span style="color: #b22222;">random</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ThreadLocalRandom</span> <span style="color: #a020f0;">=</span> {
  <span style="color: #008b8b;">ThreadLocalRandom</span>.current()
}

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">defaultTTL</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">30</span> * <span style="color: #008b8b;">60</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">30 minutes</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">faker</span> <span style="color: #a020f0;">=</span> <span style="color: #a020f0;">new</span> <span style="color: #0000ee;">Faker</span>()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">feeder</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">Iterator</span>.continually({
  <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">timestamp</span> <span style="color: #a020f0;">=</span> java.time.<span style="color: #008b8b;">Instant</span>.now()
  <span style="color: #008b8b;">Map</span>(
    <span style="color: #008b00;">"token_id"</span> -&gt; <span style="color: #008b8b;">UUID</span>.randomUUID(),
    <span style="color: #008b00;">"user"</span> -&gt; faker.name().username(),
    <span style="color: #008b00;">"nonce1"</span> -&gt; random.nextInt(),
    <span style="color: #008b00;">"nonce2"</span> -&gt; random.nextInt(),
    <span style="color: #008b00;">"created"</span> -&gt; timestamp.toEpochMilli,
    <span style="color: #008b00;">"expires"</span> -&gt; timestamp.plusSeconds(defaultTTL).toEpochMilli,
    <span style="color: #008b00;">"attrs"</span> -&gt; <span style="color: #008b8b;">Map</span>(
      <span style="color: #008b00;">"code"</span> -&gt; faker.code.isbn13(),
      <span style="color: #008b00;">"address"</span> -&gt; faker.address().fullAddress()
    ),
    <span style="color: #008b00;">"ttl"</span> -&gt; defaultTTL
  )
}
)
</pre>
</div>

<p>
Be very careful with data types - they need to match the actual data types in table's definitions.  For example, timestamp could be specified as <code>java.util.Date</code>, <code>Long</code>, or <code>String</code> - in our example we're using <code>Long</code> type for timestamps.
</p>
</div>
</div>

<div id="outline-container-orga8f3e3b" class="outline-4">
<h4 id="orga8f3e3b"><span class="section-number-4">6.2.3</span> Define scenario</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
As was mentioned above, our scenario includes two inserts into separate tables, and two updates of the <code>nonce</code> field in both tables, simulating rotation of the authentication token.  Our scenario consists of feeder, two groups for inserts/updates, and pause between them:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadData</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"loadData"</span>)
  .feed(feeder)
  .group(<span style="color: #008b00;">"Insert"</span>)(
    exec(cql(<span style="color: #008b00;">"InsertOAuth"</span>)
      .executePrepared(insertPrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>, <span style="color: #008b00;">"ttl"</span>)))
      .exec(cql(<span style="color: #008b00;">"insertUser"</span>)
        .executePrepared(insertPrepared2)
        .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>, <span style="color: #008b00;">"ttl"</span>)))
  )
  .pause(<span style="color: #008b8b;">1</span>) <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">wait 1 second before rotating token...</span>
  .group(<span style="color: #008b00;">"Update"</span>)(
    exec(cql(<span style="color: #008b00;">"updateOAuth"</span>)
      .executePrepared(updatePrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"token_id"</span>)))
      .exec(cql(<span style="color: #008b00;">"updateUser"</span>)
        .executePrepared(updatePrepared2)
        .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"ttl"</span>, <span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"token_id"</span>)))
  )
</pre>
</div>

<p>
Every group together with individual actions have names, so we can easily find information about any of them in the report.
</p>
</div>
</div>

<div id="outline-container-org1ea42bf" class="outline-4">
<h4 id="org1ea42bf"><span class="section-number-4">6.2.4</span> Setup/execute simulation</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
To make our test more flexible, we can pass the number of concurrent users &amp; test duration (in minutes) as system properties with names <code>concurrentSessionCount</code> &amp; <code>testDuration</code> correspondingly:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">testDuration</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">FiniteDuration</span>(java.lang.<span style="color: #008b8b;">Long</span>.getLong(<span style="color: #008b00;">"testDuration"</span>, <span style="color: #008b8b;">5</span>), <span style="color: #008b8b;">TimeUnit</span>.<span style="color: #008b8b;">MINUTES</span>)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">concurrentSessionCount</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">Int</span> <span style="color: #a020f0;">=</span> <span style="color: #008b8b;">Integer</span>.getInteger(<span style="color: #008b00;">"concurrentSessionCount"</span>, <span style="color: #008b8b;">100</span>)
</pre>
</div>

<p>
For our experiment we'll use different injection profiles to show difference on how results could look like:
</p>
<ul class="org-ul">
<li><p>
using <code>rampUsersPerSec</code> to emulate increase in number of concurrent users from 30% to 100% of target:
</p>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    rampUsersPerSec(concurrentSessionCount / <span style="color: #008b8b;">3</span>) to (concurrentSessionCount) during testDuration
  )
).protocols(cqlConfig)
</pre>
</div></li>

<li><p>
using <code>constantUsersPerSec</code> to create load with the same number of concurrent users:
</p>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    constantUsersPerSec(concurrentSessionCount) during testDuration
  )
).protocols(cqlConfig)
</pre>
</div></li>

<li><p>
using <code>constantUsersPerSec</code> to create load with the same number of concurrent users, but with separate <span class="underline">warm up</span> stage under 25% of load during 1/4 of test time:
</p>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    constantUsersPerSec(concurrentSessionCount / <span style="color: #008b8b;">4</span>) during (testDuration/<span style="color: #008b8b;">4</span>),
    nothingFor(<span style="color: #008b8b;">FiniteDuration</span>(<span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">TimeUnit</span>.<span style="color: #008b8b;">MINUTES</span>)),
    constantUsersPerSec(concurrentSessionCount) during testDuration
  )
).protocols(cqlConfig)
</pre>
</div></li>
</ul>

<p>
It's also easy to add assertion to check that we don't have the failed requests - just add the <code>assertion</code> into chain when setting up the simulation, and provide condition(s) to check:
</p>

<div class="org-src-container">
<pre class="src src-scala">setUp(
  loadData.inject(
    constantUsersPerSec(concurrentSessionCount) during testDuration
  )
).assertions(
  global.failedRequests.count.is(<span style="color: #008b8b;">0</span>)
).protocols(cqlConfig)

</pre>
</div>
</div>
</div>

<div id="outline-container-org81cdaad" class="outline-4">
<h4 id="org81cdaad"><span class="section-number-4">6.2.5</span> Run simulation</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
We can use following command to run the simulation, specifying necessary parameters (it's the same as was shown above):
</p>

<div class="org-src-container">
<pre class="src src-shell">java -cp &lt;path-to&gt;/gatling-charts-highcharts-bundle-2.3.0/conf:target/gatling-plugin-sim-0.0.1-jar-with-dependencies.jar <span style="color: #008b00;">\</span>
    -DcontactPoints=192.168.0.10 -DtestDuration=10 -DconcurrentSessionCount=5000 <span style="color: #008b00;">\</span>
    io.gatling.app.Gatling -s com.datastax.demos.gatling.GatlingLoadSim -rf results
</pre>
</div>

<p>
In this case we're running test for 10 minutes with maximal number of concurrent users equal to 5000.
</p>
</div>
</div>

<div id="outline-container-org87744f5" class="outline-4">
<h4 id="org87744f5"><span class="section-number-4">6.2.6</span> Check results</h4>
<div class="outline-text-4" id="text-6-2-6">
<p>
When using <code>rampUsersPerSec</code> we get following graph for response time &amp; number of requests per second:
</p>


<div class="figure">
<p><img src="./gatling-load-rampup.png" alt="gatling-load-rampup.png" />
</p>
</div>

<p>
As you can see, as the number of concurrent users started to increase, the 99th response time (and other percentiles as well) is increased from ~100ms to 350-500ms.
</p>

<p>
If we're putting the constant load of without pre-warm of the database, we get following graphs:
</p>


<div class="figure">
<p><img src="./gatling-load-constant.png" alt="gatling-load-constant.png" />
</p>
</div>


<p>
For constant load with pre-warm we've got following results - as you can see, even 50th percentile is quite high in this setup:
</p>


<div class="figure">
<p><img src="./gatling-load-constant-with-warmup.png" alt="gatling-load-constant-with-warmup.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga02f098" class="outline-3">
<h3 id="orga02f098"><span class="section-number-3">6.3</span> Simulation of mixed load</h3>
<div class="outline-text-3" id="text-6-3">
<p>
This simulation is slight modification of the previous example, and it's used to show how we can perform data selection.  It will insert data into one table, wait 1 second, select data, and then update <code>nonce</code> field. Source code is in the <a href="https://github.com/alexott/gatling-dse-examples/blob/master/plugin-sim/src/main/scala/com/datastax/demos/gatling/GatlingMixedSim.scala">GatlingMixedSim.scala</a>.
</p>

<p>
The most of code is taken from previous simulation, so I won't describe it in the much details.  The main changes are in the scenario's definition:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">selectPrepared</span> <span style="color: #a020f0;">=</span> dseSession.prepare(<span style="color: #008b00;">"select user, nonce from gatling.oauth_tokens where id = ?"</span>)

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">loadData</span><span style="color: #a020f0;">:</span> <span style="color: #0000ee;">ScenarioBuilder</span> <span style="color: #a020f0;">=</span> scenario(<span style="color: #008b00;">"insert-select-update"</span>)
  .feed(feeder)
  .group(<span style="color: #008b00;">"Insert"</span>)(
    exec(cql(<span style="color: #008b00;">"InsertOAuth"</span>)
      .executePrepared(insertPrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>, <span style="color: #008b00;">"nonce1"</span>, <span style="color: #008b00;">"user"</span>, <span style="color: #008b00;">"created"</span>, <span style="color: #008b00;">"expires"</span>, <span style="color: #008b00;">"attrs"</span>)))
  )
  .pause(<span style="color: #008b8b;">1</span>) <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">wait 1 second before selecting token...</span>
  .group(<span style="color: #008b00;">"Select"</span>)(
    exec(cql(<span style="color: #008b00;">"SelectOAuth"</span>)
      .executePrepared(selectPrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"token_id"</span>))
      <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">check that we received data from DSE</span>
      .check(rowCount.greaterThan(<span style="color: #008b8b;">0</span>))
      .check(resultSet.saveAs(<span style="color: #008b00;">"fetchedData"</span>))
      .check(columnValue(<span style="color: #008b00;">"user"</span>).is(session <span style="color: #a020f0;">=&gt;</span> session(<span style="color: #008b00;">"user"</span>).as[<span style="color: #008b8b;">String</span>]))
      .check(columnValue(<span style="color: #008b00;">"nonce"</span>).is(session <span style="color: #a020f0;">=&gt;</span> session(<span style="color: #008b00;">"nonce1"</span>).as[<span style="color: #008b8b;">Int</span>]))
  )
  .group(<span style="color: #008b00;">"Update"</span>)(
    exec(cql(<span style="color: #008b00;">"updateOAuth"</span>)
      .executePrepared(updatePrepared)
      .withParams(<span style="color: #008b8b;">List</span>(<span style="color: #008b00;">"nonce2"</span>, <span style="color: #008b00;">"token_id"</span>)))
  )
</pre>
</div>

<p>
As you can see, now we have an additional group with name <code>Select</code> that should perform CQL query to fetch value of fields <code>user</code> and <code>nonce</code> from database for token with given ID.  This part is look similar to previous examples except the new section - the chain of calls to the <code>check</code> function that performs following checks on executed query:
</p>
<ul class="org-ul">
<li>check that the number of returned rows is greater than zero;</li>
<li>save fetched data into the session as <code>fetchedData</code> field;</li>
<li>check that value of the <code>user</code> field in returned data matches the value of <code>user</code> field in the session;</li>
<li>the same is for the field <code>nonce</code>;</li>
</ul>

<p>
After we build this example, we can run it (don't forget to change the simulation name in the command line).  And we can see the results on our graphs:
</p>


<div class="figure">
<p><img src="./gatling-mixed-load-overview.png" alt="gatling-mixed-load-overview.png" />
</p>
</div>


<div class="figure">
<p><img src="./gatling-mixed-load-response-time.png" alt="gatling-mixed-load-response-time.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdb4f14c" class="outline-2">
<h2 id="orgdb4f14c"><span class="section-number-2">7</span> Additional information</h2>
<div class="outline-text-2" id="text-7">
<p>
This tutorial contains just enough information to start writing tests for DSE using Gatling.   Gatling's site has quite <a href="https://gatling.io/docs/current/">detailed documentation</a> on how you can use it.  The <a href="https://gatling.io/docs/current/cheat-sheet/">Gatling cheatsheet</a> page is also very useful resource when you just need to look to the syntax of particular function.
</p>

<p>
gatling-dse-plugin's <a href="https://github.com/datastax/gatling-dse-plugin/wiki">wiki pages</a> contain more information on how to use this plugin to test DSE Graph, some information about implementation, etc. 
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Alex Ott</p>
<p class="date">Created: 2018-08-18 Sat 10:04</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
